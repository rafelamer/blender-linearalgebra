<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>LinearAlgebra API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>LinearAlgebra</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Filename:   LinearAlgebra.py
# Author:     Rafel Amer (rafel.amer AT upc.edu)
# Copyright:  Rafel Amer 2020-2022
#
#             This file contains code from the file add_mesh_3d_function_surface.py
#             distributed with Blender
#
# Disclaimer: This code is presented &#34;as is&#34; and it has been written to learn
#             to use the python scripting language and the Blender sofware
#             use them in the studies of Linear Algebra and Geometry
#cos
# License:    This software is free software; you can redistribute it and/or
#             modify it under the terms of either:
#
#             1 the GNU Lesser General Public License as published by the Free
#               Software Foundation; either version 3 of the License, or (at your
#               option) any later version.
#
#             or
#
#             2 the GNU General Public License as published by the Free
#               Foundation; either version 2 of the License, or (at your option)
#               any later version.
#
#                 See https://www.gnu.org/licenses/
#########################################################################################
import math
import bpy
import bmesh
import random
from bpy_extras import object_utils
try:
        from sympy import *
except:
        print(&#34;Python sympy not available&#34;)
        pass
from mathutils import Vector, Matrix, Euler, Quaternion

def create_mesh_object(context,verts,edges,faces,name):
        mesh = bpy.data.meshes.new(name)
        mesh.from_pydata(verts, edges, faces)
        mesh.update()
        return object_utils.object_data_add(context, mesh, operator=None)
#
#
#
def createFaces(vertIdx1,vertIdx2,closed=False,flipped=False):
        faces = []
        if not vertIdx1 or not vertIdx2:
                return None
        if len(vertIdx1) &lt; 2 and len(vertIdx2) &lt; 2:
                return None

        fan = False
        if (len(vertIdx1) != len(vertIdx2)):
                if (len(vertIdx1) == 1 and len(vertIdx2) &gt; 1):
                        fan = True
                else:
                        return None

        total = len(vertIdx2)
        if closed:
                if flipped:
                        face = [vertIdx1[0],vertIdx2[0],vertIdx2[total - 1]]
                        if not fan:
                                face.append(vertIdx1[total - 1])
                        faces.append(face)
                else:
                        face = [vertIdx2[0], vertIdx1[0]]
                        if not fan:
                                face.append(vertIdx1[total - 1])
                        face.append(vertIdx2[total - 1])
                        faces.append(face)
        for num in range(total - 1):
                if flipped:
                        if fan:
                                face = [vertIdx2[num], vertIdx1[0], vertIdx2[num + 1]]
                        else:
                                face = [vertIdx2[num], vertIdx1[num],vertIdx1[num + 1], vertIdx2[num + 1]]
                        faces.append(face)
                else:
                        if fan:
                                face = [vertIdx1[0], vertIdx2[num], vertIdx2[num + 1]]
                        else:
                                face = [vertIdx1[num], vertIdx2[num],vertIdx2[num + 1], vertIdx1[num + 1]]
                        faces.append(face)
        return faces
#
#
#
def draw_parametric_surface(eq,range_u_min,range_u_max,range_u_step,range_v_min,range_v_max,range_v_step,name,wrap_u=False,wrap_v=False,close_v=False):
        verts = []
        faces = []
        if not callable(range_u_min) and not callable(range_u_max):
                uStep = (range_u_max - range_u_min) / range_u_step
        vStep = (range_v_max - range_v_min) / range_v_step
        uRange = range_u_step + 1
        vRange = range_v_step + 1

        if wrap_u:
                uRange = uRange - 1
        if wrap_v:
                vRange = vRange - 1

        for vN in range(vRange):
                v = range_v_min + (vN * vStep)
                if callable(range_u_min):
                        u_min = range_u_min(v)
                else:
                        u_min = range_u_min
                if callable(range_u_max):
                        u_max = range_u_max(v)
                else:
                        u_max = range_u_max
                uStep = (u_max - u_min) / range_u_step
                for uN in range(uRange):
                        u = u_min + (uN * uStep)
                        verts.append(eq(u,v))

        for vN in range(range_v_step):
                vNext = vN + 1
                if vNext &gt;= vRange:
                        vNext = 0
                for uN in range(range_u_step):
                        uNext = uN + 1
                        if uNext &gt;= uRange:
                                uNext = 0
                        faces.append([(vNext * uRange) + uNext,(vNext * uRange) + uN,(vN * uRange) + uN,(vN * uRange) + uNext])

        if close_v and wrap_u and (not wrap_v):
                for uN in range(1, range_u_step - 1):
                        faces.append([range_u_step - 1,range_u_step - 1 - uN,range_u_step - 2 - uN])
                        faces.append([range_v_step * uRange,range_v_step * uRange + uN,range_v_step * uRange + uN + 1])
        create_mesh_object(bpy.context,verts, [], faces, name)
#
#
#
class Color():
        &#34;&#34;&#34;
    Class that defines a color in RGB format
    &#34;&#34;&#34;
        def __init__(self,r,g,b,name):
                self.r = r
                self.g = g
                self.b = b
                self.name = name
#
#
#
class Colors():
        &#34;&#34;&#34;
        Class that defines a list of colors by name
        &#34;&#34;&#34;
        colorsbyname = {
                &#39;Black&#39; : Color(0,0,0,&#39;Black&#39;),
                &#39;GrayObscure&#39; : Color(0.2,0.2,0.2,&#39;GrayObscure&#39;),
                &#39;GrayDark&#39; : Color(0.4,0.4,0.4,&#39;GrayDark&#39;),
                &#39;GrayLight&#39; : Color(0.6,0.6,0.6,&#39;GrayLight&#39;),
                &#39;GrayPale&#39; : Color(0.8,0.8,0.8,&#39;GrayPale&#39;),
                &#39;White&#39; : Color(1,1,1,&#39;White&#39;),
                &#39;Red&#39; : Color(1,0,0,&#39;Red&#39;),
                &#39;RedDarkHard&#39; : Color(0.8,0,0,&#39;RedDarkHard&#39;),
                &#39;RedLightHard&#39; : Color(1,0.2,0.2,&#39;RedLightHard&#39;),
                &#39;RedDarkFaded&#39; : Color(0.6,0,0,&#39;RedDarkFaded&#39;),
                &#39;RedMediumFaded&#39; : Color(0.8,0.2,0.2,&#39;RedMediumFaded&#39;),
                &#39;RedLightFaded&#39; : Color(1,0.4,0.4,&#39;RedLightFaded&#39;),
                &#39;RedObscureDull&#39; : Color(0.4,0,0,&#39;RedObscureDull&#39;),
                &#39;RedDarkDull&#39; : Color(0.6,0.2,0.2,&#39;RedDarkDull&#39;),
                &#39;RedLightDull&#39; : Color(0.8,0.4,0.4,&#39;RedLightDull&#39;),
                &#39;RedPaleDull&#39; : Color(1,0.6,0.6,&#39;RedPaleDull&#39;),
                &#39;RedObscureWeak&#39; : Color(0.2,0,0,&#39;RedObscureWeak&#39;),
                &#39;RedDarkWeak&#39; : Color(0.4,0.2,0.2,&#39;RedDarkWeak&#39;),
                &#39;RedMediumWeak&#39; : Color(0.6,0.4,0.4,&#39;RedMediumWeak&#39;),
                &#39;RedLightWeak&#39; : Color(0.8,0.6,0.6,&#39;RedLightWeak&#39;),
                &#39;RedPaleWeak&#39; : Color(1,0.8,0.8,&#39;RedPaleWeak&#39;),
                &#39;Orange&#39; : Color(1,0.37,0.12,&#39;Orange&#39;),
                &#39;OrangeRedDark&#39; : Color(0.6,0.2,0,&#39;OrangeRedDark&#39;),
                &#39;OrangeRedMedium&#39; : Color(0.8,0.4,0.2,&#39;OrangeRedMedium&#39;),
                &#39;OrangeRedLight&#39; : Color(1,0.6,0.4,&#39;OrangeRedLight&#39;),
                &#39;OrangeOrangeRed&#39; : Color(1,0.4,0,&#39;OrangeOrangeRed&#39;),
                &#39;RedOrangeDark&#39; : Color(0.8,0.2,0,&#39;RedOrangeDark&#39;),
                &#39;RedOrangeLight&#39; : Color(1,0.4,0.2,&#39;RedOrangeLight&#39;),
                &#39;RedRedOrange&#39; : Color(1,0.2,0,&#39;RedRedOrange&#39;),
                &#39;OrangeDarkHard&#39; : Color(0.8,0.4,0,&#39;OrangeDarkHard&#39;),
                &#39;OrangeLightHard&#39; : Color(1,0.6,0.2,&#39;OrangeLightHard&#39;),
                &#39;OrangeObscureDull&#39; : Color(0.4,0.2,0,&#39;OrangeObscureDull&#39;),
                &#39;OrangeDarkDull&#39; : Color(0.6,0.4,0.2,&#39;OrangeDarkDull&#39;),
                &#39;OrangeLightDull&#39; : Color(0.8,0.6,0.4,&#39;OrangeLightDull&#39;),
                &#39;OrangePaleDull&#39; : Color(1,0.8,0.6,&#39;OrangePaleDull&#39;),
                &#39;OrangeYellowDark&#39; : Color(0.6,0.4,0,&#39;OrangeYellowDark&#39;),
                &#39;OrangeYellowMedium&#39; : Color(0.8,0.6,0.2,&#39;OrangeYellowMedium&#39;),
                &#39;OrangeYellowLight&#39; : Color(1,0.8,0.4,&#39;OrangeYellowLight&#39;),
                &#39;OrangeOrangeYellow&#39; : Color(1,0.6,0,&#39;OrangeOrangeYellow&#39;),
                &#39;YellowOrangeDark&#39; : Color(0.8,0.6,0,&#39;YellowOrangeDark&#39;),
                &#39;YellowOrangeLight&#39; : Color(1,0.8,0.2,&#39;YellowOrangeLight&#39;),
                &#39;YellowYellowOrange&#39; : Color(1,0.8,0,&#39;YellowYellowOrange&#39;),
                &#39;Yellow&#39; : Color(1,1,0,&#39;Yellow&#39;),
                &#39;YellowDarkHard&#39; : Color(0.8,0.8,0,&#39;YellowDarkHard&#39;),
                &#39;YellowLightHard&#39; : Color(1,1,0.2,&#39;YellowLightHard&#39;),
                &#39;YellowDarkFaded&#39; : Color(0.6,0.6,0,&#39;YellowDarkFaded&#39;),
                &#39;YellowMediumFaded&#39; : Color(0.8,0.8,0.2,&#39;YellowMediumFaded&#39;),
                &#39;YellowLightFaded&#39; : Color(1,1,0.4,&#39;YellowLightFaded&#39;),
                &#39;YellowObscureDull&#39; : Color(0.4,0.4,0,&#39;YellowObscureDull&#39;),
                &#39;YellowDarkDull&#39; : Color(0.6,0.6,0.2,&#39;YellowDarkDull&#39;),
                &#39;YellowLightDull&#39; : Color(0.8,0.8,0.4,&#39;YellowLightDull&#39;),
                &#39;YellowPaleDull&#39; : Color(1,1,0.6,&#39;YellowPaleDull&#39;),
                &#39;YellowObscureWeak&#39; : Color(0.2,0.2,0,&#39;YellowObscureWeak&#39;),
                &#39;YellowDarkWeak&#39; : Color(0.4,0.4,0.2,&#39;YellowDarkWeak&#39;),
                &#39;YellowMediumWeak&#39; : Color(0.6,0.6,0.4,&#39;YellowMediumWeak&#39;),
                &#39;YellowLightWeak&#39; : Color(0.8,0.8,0.6,&#39;YellowLightWeak&#39;),
                &#39;YellowPaleWeak&#39; : Color(1,1,0.8,&#39;YellowPaleWeak&#39;),
                &#39;SpringYellowDark&#39; : Color(0.4,0.6,0,&#39;SpringYellowDark&#39;),
                &#39;SpringYellowMedium&#39; : Color(0.6,0.8,0.2,&#39;SpringYellowMedium&#39;),
                &#39;SpringYellowLight&#39; : Color(0.8,1,0.4,&#39;SpringYellowLight&#39;),
                &#39;SpringSpringYellow&#39; : Color(0.6,1,0,&#39;SpringSpringYellow&#39;),
                &#39;YellowSpringDark&#39; : Color(0.6,0.8,0,&#39;YellowSpringDark&#39;),
                &#39;YellowSpringLight&#39; : Color(0.8,1,0.2,&#39;YellowSpringLight&#39;),
                &#39;YellowYellowSpring&#39; : Color(0.8,1,0,&#39;YellowYellowSpring&#39;),
                &#39;SpringDarkHard&#39; : Color(0.4,0.8,0,&#39;SpringDarkHard&#39;),
                &#39;SpringLightHard&#39; : Color(0.6,1,0.2,&#39;SpringLightHard&#39;),
                &#39;SpringObscureDull&#39; : Color(0.2,0.4,0,&#39;SpringObscureDull&#39;),
                &#39;SpringDarkDull&#39; : Color(0.4,0.6,0.2,&#39;SpringDarkDull&#39;),
                &#39;SpringLightDull&#39; : Color(0.6,0.8,0.4,&#39;SpringLightDull&#39;),
                &#39;SpringPaleDull&#39; : Color(0.8,1,0.6,&#39;SpringPaleDull&#39;),
                &#39;SpringGreenDark&#39; : Color(0.2,0.6,0,&#39;SpringGreenDark&#39;),
                &#39;SpringGreenMedium&#39; : Color(0.4,0.8,0.2,&#39;SpringGreenMedium&#39;),
                &#39;SpringGreenLight&#39; : Color(0.6,1,0.4,&#39;SpringGreenLight&#39;),
                &#39;SpringSpringGreen&#39; : Color(0.4,1,0,&#39;SpringSpringGreen&#39;),
                &#39;GreenSpringDark&#39; : Color(0.2,0.8,0,&#39;GreenSpringDark&#39;),
                &#39;GreenSpringLight&#39; : Color(0.4,1,0.2,&#39;GreenSpringLight&#39;),
                &#39;GreenGreenSpring&#39; : Color(0.2,1,0,&#39;GreenGreenSpring&#39;),
                &#39;Green&#39; : Color(0,1,0,&#39;Green&#39;),
                &#39;GreenDarkHard&#39; : Color(0,0.8,0,&#39;GreenDarkHard&#39;),
                &#39;GreenLightHard&#39; : Color(0.2,1,0.2,&#39;GreenLightHard&#39;),
                &#39;GreenDarkFaded&#39; : Color(0,0.6,0,&#39;GreenDarkFaded&#39;),
                &#39;GreenMediumFaded&#39; : Color(0.2,0.8,0.2,&#39;GreenMediumFaded&#39;),
                &#39;GreenLightFaded&#39; : Color(0.4,1,0.4,&#39;GreenLightFaded&#39;),
                &#39;GreenObscureDull&#39; : Color(0,0.4,0,&#39;GreenObscureDull&#39;),
                &#39;GreenDarkDull&#39; : Color(0.2,0.6,0.2,&#39;GreenDarkDull&#39;),
                &#39;GreenLightDull&#39; : Color(0.4,0.8,0.4,&#39;GreenLightDull&#39;),
                &#39;GreenPaleDull&#39; : Color(0.6,1,0.6,&#39;GreenPaleDull&#39;),
                &#39;GreenObscureWeak&#39; : Color(0,0.2,0,&#39;GreenObscureWeak&#39;),
                &#39;GreenDarkWeak&#39; : Color(0.2,0.4,0.2,&#39;GreenDarkWeak&#39;),
                &#39;GreenMediumWeak&#39; : Color(0.4,0.6,0.4,&#39;GreenMediumWeak&#39;),
                &#39;GreenLightWeak&#39; : Color(0.6,0.8,0.6,&#39;GreenLightWeak&#39;),
                &#39;GreenPaleWeak&#39; : Color(0.8,1,0.8,&#39;GreenPaleWeak&#39;),
                &#39;TealGreenDark&#39; : Color(0,0.6,0.2,&#39;TealGreenDark&#39;),
                &#39;TealGreenMedium&#39; : Color(0.2,0.8,0.4,&#39;TealGreenMedium&#39;),
                &#39;TealGreenLight&#39; : Color(0.4,1,0.6,&#39;TealGreenLight&#39;),
                &#39;TealTealGreen&#39; : Color(0,1,0.4,&#39;TealTealGreen&#39;),
                &#39;GreenTealDark&#39; : Color(0,0.8,0.2,&#39;GreenTealDark&#39;),
                &#39;GreenTealLight&#39; : Color(0.2,1,0.4,&#39;GreenTealLight&#39;),
                &#39;GreenGreenTeal&#39; : Color(0,1,0.2,&#39;GreenGreenTeal&#39;),
                &#39;TealDarkHard&#39; : Color(0,0.8,0.4,&#39;TealDarkHard&#39;),
                &#39;TealLightHard&#39; : Color(0.2,1,0.6,&#39;TealLightHard&#39;),
                &#39;TealObscureDull&#39; : Color(0,0.4,0.2,&#39;TealObscureDull&#39;),
                &#39;TealDarkDull&#39; : Color(0.2,0.6,0.4,&#39;TealDarkDull&#39;),
                &#39;TealLightDull&#39; : Color(0.4,0.8,0.6,&#39;TealLightDull&#39;),
                &#39;TealPaleDull&#39; : Color(0.6,1,0.8,&#39;TealPaleDull&#39;),
                &#39;TealCyanDark&#39; : Color(0,0.6,0.4,&#39;TealCyanDark&#39;),
                &#39;TealCyanMedium&#39; : Color(0.2,0.8,0.6,&#39;TealCyanMedium&#39;),
                &#39;TealCyanLight&#39; : Color(0.4,1,0.8,&#39;TealCyanLight&#39;),
                &#39;TealTealCyan&#39; : Color(0,1,0.6,&#39;TealTealCyan&#39;),
                &#39;CyanTealDark&#39; : Color(0,0.8,0.6,&#39;CyanTealDark&#39;),
                &#39;CyanTealLight&#39; : Color(0.2,1,0.8,&#39;CyanTealLight&#39;),
                &#39;CyanCyanTeal&#39; : Color(0,1,0.8,&#39;CyanCyanTeal&#39;),
                &#39;Cyan&#39; : Color(0,1,1,&#39;Cyan&#39;),
                &#39;CyanDarkHard&#39; : Color(0,0.8,0.8,&#39;CyanDarkHard&#39;),
                &#39;CyanLightHard&#39; : Color(0.2,1,1,&#39;CyanLightHard&#39;),
                &#39;CyanDarkFaded&#39; : Color(0,0.6,0.6,&#39;CyanDarkFaded&#39;),
                &#39;CyanMediumFaded&#39; : Color(0.2,0.8,0.8,&#39;CyanMediumFaded&#39;),
                &#39;CyanLightFaded&#39; : Color(0.4,1,1,&#39;CyanLightFaded&#39;),
                &#39;CyanObscureDull&#39; : Color(0,0.4,0.4,&#39;CyanObscureDull&#39;),
                &#39;CyanDarkDull&#39; : Color(0.2,0.6,0.6,&#39;CyanDarkDull&#39;),
                &#39;CyanLightDull&#39; : Color(0.4,0.8,0.8,&#39;CyanLightDull&#39;),
                &#39;CyanPaleDull&#39; : Color(0.6,1,1,&#39;CyanPaleDull&#39;),
                &#39;CyanObscureWeak&#39; : Color(0,0.2,0.2,&#39;CyanObscureWeak&#39;),
                &#39;CyanDarkWeak&#39; : Color(0.2,0.4,0.4,&#39;CyanDarkWeak&#39;),
                &#39;CyanMediumWeak&#39; : Color(0.4,0.6,0.6,&#39;CyanMediumWeak&#39;),
                &#39;CyanLightWeak&#39; : Color(0.6,0.8,0.8,&#39;CyanLightWeak&#39;),
                &#39;CyanPaleWeak&#39; : Color(0.8,1,1,&#39;CyanPaleWeak&#39;),
                &#39;AzureCyanDark&#39; : Color(0,0.4,0.6,&#39;AzureCyanDark&#39;),
                &#39;AzureCyanMedium&#39; : Color(0.2,0.6,0.8,&#39;AzureCyanMedium&#39;),
                &#39;AzureCyanLight&#39; : Color(0.4,0.8,1,&#39;AzureCyanLight&#39;),
                &#39;AzureAzureCyan&#39; : Color(0,0.6,1,&#39;AzureAzureCyan&#39;),
                &#39;CyanAzureDark&#39; : Color(0,0.6,0.8,&#39;CyanAzureDark&#39;),
                &#39;CyanAzureLight&#39; : Color(0.2,0.8,1,&#39;CyanAzureLight&#39;),
                &#39;CyanCyanAzure&#39; : Color(0,0.8,1,&#39;CyanCyanAzure&#39;),
                &#39;AzureDarkHard&#39; : Color(0,0.4,0.8,&#39;AzureDarkHard&#39;),
                &#39;AzureLightHard&#39; : Color(0.2,0.6,1,&#39;AzureLightHard&#39;),
                &#39;AzureObscureDull&#39; : Color(0,0.2,0.4,&#39;AzureObscureDull&#39;),
                &#39;AzureDarkDull&#39; : Color(0.2,0.4,0.6,&#39;AzureDarkDull&#39;),
                &#39;AzureLightDull&#39; : Color(0.4,0.6,0.8,&#39;AzureLightDull&#39;),
                &#39;AzurePaleDull&#39; : Color(0.6,0.8,1,&#39;AzurePaleDull&#39;),
                &#39;AzureBlueDark&#39; : Color(0,0.2,0.6,&#39;AzureBlueDark&#39;),
                &#39;AzureBlueMedium&#39; : Color(0.2,0.4,0.8,&#39;AzureBlueMedium&#39;),
                &#39;AzureBlueLight&#39; : Color(0.4,0.6,1,&#39;AzureBlueLight&#39;),
                &#39;AzureAzureBlue&#39; : Color(0,0.4,1,&#39;AzureAzureBlue&#39;),
                &#39;BlueAzureDark&#39; : Color(0,0.2,0.8,&#39;BlueAzureDark&#39;),
                &#39;BlueAzureLight&#39; : Color(0.2,0.4,1,&#39;BlueAzureLight&#39;),
                &#39;BlueBlueAzure&#39; : Color(0,0.2,1,&#39;BlueBlueAzure&#39;),
                &#39;Blue&#39; : Color(0,0,1,&#39;Blue&#39;),
                &#39;BlueDarkHard&#39; : Color(0,0,0.8,&#39;BlueDarkHard&#39;),
                &#39;BlueLightHard&#39; : Color(0.2,0.2,1,&#39;BlueLightHard&#39;),
                &#39;BlueDarkFaded&#39; : Color(0,0,0.6,&#39;BlueDarkFaded&#39;),
                &#39;BlueMediumFaded&#39; : Color(0.2,0.2,0.8,&#39;BlueMediumFaded&#39;),
                &#39;BlueLightFaded&#39; : Color(0.4,0.4,1,&#39;BlueLightFaded&#39;),
                &#39;BlueObscureDull&#39; : Color(0,0,0.4,&#39;BlueObscureDull&#39;),
                &#39;BlueDarkDull&#39; : Color(0.2,0.2,0.6,&#39;BlueDarkDull&#39;),
                &#39;BlueLightDull&#39; : Color(0.4,0.4,0.8,&#39;BlueLightDull&#39;),
                &#39;BluePaleDull&#39; : Color(0.6,0.6,1,&#39;BluePaleDull&#39;),
                &#39;BlueObscureWeak&#39; : Color(0,0,0.2,&#39;BlueObscureWeak&#39;),
                &#39;BlueDarkWeak&#39; : Color(0.2,0.2,0.4,&#39;BlueDarkWeak&#39;),
                &#39;BlueMediumWeak&#39; : Color(0.4,0.4,0.6,&#39;BlueMediumWeak&#39;),
                &#39;BlueLightWeak&#39; : Color(0.6,0.6,0.8,&#39;BlueLightWeak&#39;),
                &#39;BluePaleWeak&#39; : Color(0.8,0.8,1,&#39;BluePaleWeak&#39;),
                &#39;VioletBlueDark&#39; : Color(0.2,0,0.6,&#39;VioletBlueDark&#39;),
                &#39;VioletBlueMedium&#39; : Color(0.4,0.2,0.8,&#39;VioletBlueMedium&#39;),
                &#39;VioletBlueLight&#39; : Color(0.6,0.4,1,&#39;VioletBlueLight&#39;),
                &#39;VioletVioletBlue&#39; : Color(0.4,0,1,&#39;VioletVioletBlue&#39;),
                &#39;BlueVioletDark&#39; : Color(0.2,0,0.8,&#39;BlueVioletDark&#39;),
                &#39;BlueVioletLight&#39; : Color(0.4,0.2,1,&#39;BlueVioletLight&#39;),
                &#39;BlueBlueViolet&#39; : Color(0.2,0,1,&#39;BlueBlueViolet&#39;),
                &#39;VioletDarkHard&#39; : Color(0.4,0,0.8,&#39;VioletDarkHard&#39;),
                &#39;VioletLightHard&#39; : Color(0.6,0.2,1,&#39;VioletLightHard&#39;),
                &#39;VioletObscureDull&#39; : Color(0.2,0,0.4,&#39;VioletObscureDull&#39;),
                &#39;VioletDarkDull&#39; : Color(0.4,0.2,0.6,&#39;VioletDarkDull&#39;),
                &#39;VioletLightDull&#39; : Color(0.6,0.4,0.8,&#39;VioletLightDull&#39;),
                &#39;VioletPaleDull&#39; : Color(0.8,0.6,1,&#39;VioletPaleDull&#39;),
                &#39;VioletMagentaDark&#39; : Color(0.4,0,0.6,&#39;VioletMagentaDark&#39;),
                &#39;VioletMagentaMedium&#39; : Color(0.6,0.2,0.8,&#39;VioletMagentaMedium&#39;),
                &#39;VioletMagentaLight&#39; : Color(0.8,0.4,1,&#39;VioletMagentaLight&#39;),
                &#39;VioletVioletMagenta&#39; : Color(0.6,0,1,&#39;VioletVioletMagenta&#39;),
                &#39;MagentaVioletDark&#39; : Color(0.6,0,0.8,&#39;MagentaVioletDark&#39;),
                &#39;MagentaVioletLight&#39; : Color(0.8,0.2,1,&#39;MagentaVioletLight&#39;),
                &#39;MagentaMagentaViolet&#39; : Color(0.8,0,1,&#39;MagentaMagentaViolet&#39;),
                &#39;Magenta&#39; : Color(1,0,1,&#39;Magenta&#39;),
                &#39;MagentaDarkHard&#39; : Color(0.8,0,0.8,&#39;MagentaDarkHard&#39;),
                &#39;MagentaLightHard&#39; : Color(1,0.2,1,&#39;MagentaLightHard&#39;),
                &#39;MagentaDarkFaded&#39; : Color(0.6,0,0.6,&#39;MagentaDarkFaded&#39;),
                &#39;MagentaMediumFaded&#39; : Color(0.8,0.2,0.8,&#39;MagentaMediumFaded&#39;),
                &#39;MagentaLightFaded&#39; : Color(1,0.4,1,&#39;MagentaLightFaded&#39;),
                &#39;MagentaObscureDull&#39; : Color(0.4,0,0.4,&#39;MagentaObscureDull&#39;),
                &#39;MagentaDarkDull&#39; : Color(0.6,0.2,0.6,&#39;MagentaDarkDull&#39;),
                &#39;MagentaLightDull&#39; : Color(0.8,0.4,0.8,&#39;MagentaLightDull&#39;),
                &#39;MagentaPaleDull&#39; : Color(1,0.6,1,&#39;MagentaPaleDull&#39;),
                &#39;MagentaObscureWeak&#39; : Color(0.2,0,0.2,&#39;MagentaObscureWeak&#39;),
                &#39;MagentaDarkWeak&#39; : Color(0.4,0.2,0.4,&#39;MagentaDarkWeak&#39;),
                &#39;MagentaMediumWeak&#39; : Color(0.6,0.4,0.6,&#39;MagentaMediumWeak&#39;),
                &#39;MagentaLightWeak&#39; : Color(0.8,0.6,0.8,&#39;MagentaLightWeak&#39;),
                &#39;MagentaPaleWeak&#39; : Color(1,0.8,1,&#39;MagentaPaleWeak&#39;),
                &#39;PinkMagentaDark&#39; : Color(0.6,0,0.4,&#39;PinkMagentaDark&#39;),
                &#39;PinkMagentaMedium&#39; : Color(0.8,0.2,0.6,&#39;PinkMagentaMedium&#39;),
                &#39;PinkMagentaLight&#39; : Color(1,0.4,0.8,&#39;PinkMagentaLight&#39;),
                &#39;PinkPinkMagenta&#39; : Color(1,0,0.6,&#39;PinkPinkMagenta&#39;),
                &#39;MagentaPinkDark&#39; : Color(0.8,0,0.6,&#39;MagentaPinkDark&#39;),
                &#39;MagentaPinkLight&#39; : Color(1,0.2,0.8,&#39;MagentaPinkLight&#39;),
                &#39;MagentaMagentaPink&#39; : Color(1,0,0.8,&#39;MagentaMagentaPink&#39;),
                &#39;PinkDarkHard&#39; : Color(0.8,0,0.4,&#39;PinkDarkHard&#39;),
                &#39;PinkLightHard&#39; : Color(1,0.2,0.6,&#39;PinkLightHard&#39;),
                &#39;PinkObscureDull&#39; : Color(0.4,0,0.2,&#39;PinkObscureDull&#39;),
                &#39;PinkDarkDull&#39; : Color(0.6,0.2,0.4,&#39;PinkDarkDull&#39;),
                &#39;PinkLightDull&#39; : Color(0.8,0.4,0.6,&#39;PinkLightDull&#39;),
                &#39;PinkPaleDull&#39; : Color(1,0.6,0.8,&#39;PinkPaleDull&#39;),
                &#39;PinkRedDark&#39; : Color(0.6,0,0.2,&#39;PinkRedDark&#39;),
                &#39;PinkRedMedium&#39; : Color(0.8,0.2,0.4,&#39;PinkRedMedium&#39;),
                &#39;PinkRedLight&#39; : Color(1,0.4,0.6,&#39;PinkRedLight&#39;),
                &#39;PinkPinkRed&#39; : Color(1,0,0.4,&#39;PinkPinkRed&#39;),
                &#39;RedPinkDark&#39; : Color(0.8,0,0.2,&#39;RedPinkDark&#39;),
                &#39;RedPinkLight&#39; : Color(1,0.2,0.4,&#39;RedPinkLight&#39;),
                &#39;RedRedPink&#39; : Color(1,0,0.2,&#39;RedRedPink&#39;)
        }
        #
        #
        #
        @classmethod
        def color(self,name):
                &#34;&#34;&#34;
                Function that returns a color from his name
                Parameters:
                   name: name of the color
                &#34;&#34;&#34;
                try:
                        color = self.colorsbyname[name]
                except:
                        return self.colorsbyname[&#34;Black&#34;]
                return color
        #
        #
        #
        @classmethod
        def colors(self,names):
                &#34;&#34;&#34;
                Return a list of colors fron their names
                Parameters:
                   names: list of names
                &#34;&#34;&#34;
                return [self.colorsbyname[x] for x in names]
#
#
#
class Rotation():
        &#34;&#34;&#34;
    Class used for work with rotations. The stored value in the class is a quaternion
        &#34;&#34;&#34;
        def __init__(self,angle=None,vector=None,axis=None,quaternion=None,radians=False):
                &#34;&#34;&#34;
                Initializes the value for a rotation
                Parameters:
                   angle: angle of rotation

                   vector: axis of rotation

                   quaternion: The quaternion itself

                   radians: must be True if the angle is entered in radians and False if the
                            is entered in degrees.
                &#34;&#34;&#34;
                if vector is not None and axis is not None:
                        return
                if axis is not None:
                        if axis in (&#39;X&#39;,&#39;x&#39;):
                                vector = Vector([1,0,0])
                        elif axis in (&#39;Y&#39;,&#39;y&#39;):
                                vector = Vector([0,1,0])
                        elif axis in (&#39;Z&#39;,&#39;z&#39;):
                                vector = Vector([0,0,1])
                        else:
                                return

                if angle is not None:
                        if not radians:
                                angle = math.radians(angle)
                        if not isinstance(vector,Vector):
                                vector = Vector(vector)
                        self.quaternion = Quaternion(vector,angle)
                elif quaternion is not None:
                        self.quaternion = quaternion
                else:
                        self.quaternion = (1,0,0,0)
        #
        #
        #
        @classmethod
        def from_euler_angles(self,psi,theta,phi,axis=&#39;ZXZ&#39;,radians=False):
                &#34;&#34;&#34;
                Initializes a rotation from its Euler angles in the order ZXZ
                Parameters:
                   phi, theta, psi: Euler angles

                   axis: it must be &#39;XYZ&#39;, &#39;XZY&#39;, &#39;YXZ&#39;, &#39;YZX&#39;, &#39;ZXY&#39;, &#39;ZYX&#39;, &#39;XYX&#39;, &#39;XZX&#39;, &#39;YXY&#39;, &#39;YZY&#39;, &#39;ZXZ&#39; or &#39;ZYZ&#39;

                   radians: if radians, psi, theta and must be in radians
                &#34;&#34;&#34;
                if not radians:
                        phi = math.radians(phi)
                        theta = math.radians(theta)
                        psi = math.radians(psi)

                if axis is None:
                        return None
                if not isinstance(axis,str):
                        return None
                axis = axis.upper()
                if axis not in (&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,&#39;XYX&#39;,&#39;XZX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;):
                        return None

                r1 = Matrix.Rotation(psi,3,axis[0])
                r2 = Matrix.Rotation(theta,3,axis[1])
                r3 = Matrix.Rotation(phi,3,axis[2])
                m = r3 @ r2 @ r1
                q = m.to_quaternion()
                return self(quaternion=q)
        #
        #
        #
        def apply(self,v):
                &#34;&#34;&#34;
        Applies the rotation to an object v
                Parameters:
                   v: any object that can be transformed by a rotation
                &#34;&#34;&#34;
                return self.quaternion @ v
        #
        #
        #
        def to_axis_angle(self,radians=False):
                &#34;&#34;&#34;
                Returns the axis and angle of the rotation
                Parameters:
                   radians: if True, the angle returned is in radians, if not, is
                            returned in degrees
                &#34;&#34;&#34;
                v, alpha = self.quaternion.to_axis_angle()
                if radians:
                        return v, alpha
                return v, 180*alpha/math.pi
        #
        #
        #
        def to_euler_angles(self,axis=&#39;ZXZ&#39;,randomize=False,radians=False):
                &#34;&#34;&#34;
                Returns the Euler angles according to axis &#39;axis&#39;
                Parameters:
                   axis: it must be &#39;XYZ&#39;, &#39;XZY&#39;, &#39;YXZ&#39;, &#39;YZX&#39;, &#39;ZXY&#39;, &#39;ZYX&#39;, &#39;XYX&#39;, &#39;XZX&#39;, &#39;YXY&#39;, &#39;YZY&#39;, &#39;ZXZ&#39; or &#39;ZYZ&#39;

                   radians: if True, the angle returned is in radians, if not, is
                            returned in degrees
                &#34;&#34;&#34;
                def ACOS(x):
                        if x &gt; 1.0:
                                x = 1.0
                        if x &lt; -1.0:
                                x = -1.0
                        return math.acos(x)

                def ASIN(x):
                        if x &gt; 1.0:
                                x = 1.0
                        if x &lt; -1.0:
                                x = -1.0
                        return math.asin(x)

                axis = axis.upper()
                if axis not in (&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,&#39;XYX&#39;,&#39;XZX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;):
                        return None
                rndm = 0
                A = self.quaternion.to_matrix()
                if axis == &#39;ZXZ&#39;:
                        theta = ACOS(A[2][2])
                        if abs(A[2][2]) != 1:
                                psi = math.atan2(A[2][0],A[2][1])
                                phi = math.atan2(A[0][2],-A[1][2])
                        else:
                                rndm = A[2][2]
                                phi = 0
                                psi = math.atan2(A[1][0],A[0][0])
                if axis == &#39;XZX&#39;:
                        theta = ACOS(A[0][0])
                        if abs(A[0][0]) != 1:
                                psi = math.atan2(A[0][2],-A[0][1])
                                phi = math.atan2(A[2][0],A[1][0])
                        else:
                                rndm = A[0][0]
                                phi = 0
                                psi = math.atan2(-A[1][2],A[2][2])
                if axis == &#39;ZYZ&#39;:
                        theta = ACOS(A[2][2])
                        if abs(A[2][2]) != 1:
                                psi = math.atan2(A[2][1],-A[2][0])
                                phi = math.atan2(A[1][2],A[0][2])
                        else:
                                rndm = A[2][2]
                                phi = 0
                                psi = math.atan2(-A[0][1],A[1][1])
                if axis == &#39;YZY&#39;:
                        theta = ACOS(A[1][1])
                        if abs(A[1][1]) != 1:
                                psi = math.atan2(A[1][2],A[1][0])
                                phi = math.atan2(A[2][1],-A[0][1])
                        else:
                                rndm = A[1][1]
                                phi = 0
                                psi = math.atan2(A[0][2],A[2][2])
                if axis == &#39;XYX&#39;:
                        theta = ACOS(A[0][0])
                        if abs(A[0][0]) != 1:
                                psi = math.atan2(A[0][1],A[0][2])
                                phi = math.atan2(A[1][0],-A[2][0])
                        else:
                                rndm = A[0][0]
                                phi = 0
                                psi = math.atan2(A[2][1],A[1][1])
                if axis == &#39;YXY&#39;:
                        theta = ACOS(A[1][1])
                        if abs(A[1][1]) != 1:
                                psi = math.atan2(A[1][0],-A[1][2])
                                phi = math.atan2(A[0][1],A[2][1])
                        else:
                                rndm = A[1][1]
                                phi = 0
                                psi = math.atan2(-A[2][0],A[0][0])
                if axis == &#39;XYZ&#39;:
                        theta = ASIN(-A[2][0])
                        if abs(A[2][0]) != 1:
                                psi = math.atan2(A[2][1],A[2][2])
                                phi = math.atan2(A[1][0],A[0][0])
                        else:
                                rndm = A[2][0]
                                phi = 0
                                psi = math.atan2(-A[0][1],A[1][1])
                if axis == &#39;XZY&#39;:
                        theta = ASIN(A[1][0])
                        if abs(A[1][0]) != 1:
                                psi = math.atan2(-A[1][2],A[1][1])
                                phi = math.atan2(-A[2][0],A[0][0])
                        else:
                                rndm = A[1][0]
                                phi = 0
                                psi = math.atan2(A[0][2],A[2][2])
                if axis == &#39;YXZ&#39;:
                        theta = ASIN(A[2][1])
                        if abs(A[2][1]) != 1:
                                psi = math.atan2(-A[2][0],A[2][2])
                                phi = math.atan2(-A[0][1],A[1][1])
                        else:
                                rndm = A[2][1]
                                phi = 0
                                psi = math.atan2(A[1][0],A[0][0])
                if axis == &#39;YZX&#39;:
                        theta = ASIN(-A[0][1])
                        if abs(A[0][1]) != 1:
                                psi = math.atan2(A[0][2],A[0][0])
                                phi = math.atan2(A[2][1],A[1][1])
                        else:
                                rndm = A[0][1]
                                phi = 0
                                psi = math.atan2(-A[1][2],A[2][2])
                if axis == &#39;ZXY&#39;:
                        theta = ASIN(-A[1][2])
                        if abs(A[1][2]) != 1:
                                psi = math.atan2(A[1][0],A[1][1])
                                phi = math.atan2(A[0][2],A[2][2])
                        else:
                                rndm = A[1][2]
                                phi = 0
                                psi = math.atan2(-A[0][2],A[0][0])
                if axis == &#39;ZYX&#39;:
                        theta = ASIN(A[0][2])
                        if abs(A[0][2]) != 1:
                                psi = math.atan2(-A[0][1],A[0][0])
                                phi = math.atan2(-A[1][2],A[2][2])
                        else:
                                rndm = A[0][2]
                                phi = 0
                                psi = math.atan2(A[2][1],A[1][1])

                if psi &lt; 0:
                        psi += 2*math.pi
                if theta &lt; 0:
                        theta += 2*math.pi
                if phi &lt; 0:
                        phi += 2*math.pi

                if rndm != 0 and randomize:
                        phi = random.uniform(0.0,psi)
                        psi = rndm * (psi - phi)
                        if psi &lt; 0:
                                psi += 2*math.pi

                if not radians:
                        psi, theta, phi = 180.0/math.pi * psi, 180.0/math.pi * theta, 180.0/math.pi * phi
                        T = 359.9
                else:
                        T = 359.9 * math.pi / 180.0
                if psi &gt; T:
                        psi = 0.0
                if theta &gt; T:
                        theta = 0.0
                if phi &gt; T:
                        phi = 0.0
                return psi, theta, phi
#
#
#
class LinearAlgebra():
        &#34;&#34;&#34;
        Class used to define all the functions in this module to work with graphics in Blender
        &#34;&#34;&#34;
        def __init__(self):
                &#34;&#34;&#34;
        Initializes the values for scene, objects, meshes, collection, etc.
                &#34;&#34;&#34;
                self.scene = bpy.context.scene
                self.objects = bpy.data.objects
                self.meshes = bpy.data.meshes
                self.collection = bpy.context.collection
                self.ops = bpy.ops
                self.colors= Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                self.rotation = None
                self.origin = [0,0,0]
                self.base = [[1,0,0],[0,1,0],[0,0,1]]
                self.defaultcolor = None
                self.frame = 0
        #
        #
        #
        def base_cilinder(self):
                &#34;&#34;&#34;
                Draws a base cilinder with radius 1 and depth 1
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_cylinder_add(radius=1,depth=1,enter_editmode=False,location=(0, 0, 0))
                bpy.ops.transform.translate(value=(0, 0, 0.5), orient_type=&#39;GLOBAL&#39;,orient_matrix_type=&#39;GLOBAL&#39;,
                        constraint_axis=(False, False, True), mirror=True, use_proportional_edit=False,
                        proportional_edit_falloff=&#39;SMOOTH&#39;,proportional_size=1, use_proportional_connected=False, use_proportional_projected=False)
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                bpy.ops.object.shade_smooth()
                bpy.context.object.name = &#39;Arrow_stem&#39;
        #
        #
        #
        def base_cone(self):
                &#34;&#34;&#34;
                Draws a base cone with radius1=1.5, radius2=0, depth=2
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_cone_add(radius1=1.5, radius2=0, depth=2, enter_editmode=False, location=(0, 0, 0))
                bpy.ops.transform.translate(value=(0, 0, 1), orient_type=&#39;GLOBAL&#39;,orient_matrix_type=&#39;GLOBAL&#39;,
                        constraint_axis=(False, False, True), mirror=True, use_proportional_edit=False,
                        proportional_edit_falloff=&#39;SMOOTH&#39;, proportional_size=1, use_proportional_connected=False, use_proportional_projected=False)
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                bpy.ops.object.shade_smooth()
                bpy.context.object.name = &#39;Arrow_cone&#39;
        #
        #
        #
        def delete_base_cilinder(self):
                &#34;&#34;&#34;
                Removes the base cilinder
                &#34;&#34;&#34;
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.data.objects[&#39;Arrow_stem&#39;].select_set(True)
                bpy.ops.object.delete()
        #
        #
        #
        def delete_base_cone(self):
                &#34;&#34;&#34;
                Removes the base cone
                &#34;&#34;&#34;
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.data.objects[&#39;Arrow_cone&#39;].select_set(True)
                bpy.ops.object.delete()
        #
        #
        #
        def set_colors(self,names):
                &#34;&#34;&#34;
                Set self.colors to the list of colors with names &#39;names&#39;
                Parameters:
                   names: list of name colors
                &#34;&#34;&#34;
                self.colors = Colors.colors(names)
        #
        #
        #
        def reset_colors(self):
                &#34;&#34;&#34;
                Set self.colors to default colors
                &#34;&#34;&#34;
                self.colors= Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        #
        #
        #
        def set_default_color(self,name):
                &#34;&#34;&#34;
                Set self.defaultcolor to the color with name &#39;name&#39;
                Parameters:
                   name: name of a color
                &#34;&#34;&#34;
                self.defaultcolor = name
        #
        #
        #
        def reset_frames(self):
                &#34;&#34;&#34;
                Set self.frame to 0
                Parameters:
                   name: name of a color
                &#34;&#34;&#34;
                self.frame = 0
        #
        #
        #
        def reset(self):
                &#34;&#34;&#34;
                Resets origin, base, rotation, frames and colors
                &#34;&#34;&#34;
                self.reset_origin()
                self.reset_base()
                self.reset_rotation()
                self.reset_frames()
                self.reset_colors()
        #
        #
        #
        def set_rotation(self,angle=None,vector=None,quaternion=None):
                &#34;&#34;&#34;
                Sets self.rotation to the rotation defined by an angle and an axis or
                by a quaternion.
                Parameters:
                   angle: angle of rotation in degrees

                   vector: axis of rotation

                   quaternion: quaternion that defines a rotation

                The angle and vector takes precedence over the quaternion
                &#34;&#34;&#34;
                if angle is not None:
                        self.rotation = Rotation(angle,vector)
                elif quaternion is not None:
                        self.rotation = Rotation(quaternion=quaternion)
                else:
                        self.rotation = Rotation(0,[1,0,0])
        #
        #
        #
        def reset_rotation(self):
                &#34;&#34;&#34;
                Sets the rotation to identity, i.e., rotation of 0 degrees around the
                vector (1,0,0)
                &#34;&#34;&#34;
                self.set_rotation()
        #
        #
        #
        def set_origin(self,vector=[0,0,0]):
                &#34;&#34;&#34;
                Sets the origin of the reference coordinates used to display objects.
                Parameters:
                   vector: origin&#39;s position
                &#34;&#34;&#34;
                if isinstance(vector,Vector):
                        v1 = vector.copy()
                else:
                        v1 = Vector(vector)
                self.origin = v1
        #
        #
        #
        def reset_origin(self):
                &#34;&#34;&#34;
                Sets the origin to the point (0,0,0)
                &#34;&#34;&#34;
                self.origin = Vector([0,0,0])
        #
        #
        #
        def reset_base(self):
                &#34;&#34;&#34;
                Sets self.base to the canonical basis
                &#34;&#34;&#34;
                self.base = [[1,0,0],[0,1,0],[0,0,1]]
        #
        #
        #
        def set_base(self,base=[[1,0,0],[0,1,0],[0,0,1]],orthonormal=False):
                &#34;&#34;&#34;
                Sets the self.base, i.e., the basis of the reference coordinates used to display
                objects
                Parameters:
                   base: list of three vectors

                   orthonormal: if True, the Gram-Schmidt method is applied and the vectors
                   are normalized.
                &#34;&#34;&#34;
                if orthonormal:
                        u1 = base[0]
                        u2 = base[1]
                        if isinstance(u1,Vector):
                                v1 = u1
                        else:
                                v1 = Vector(u1)
                        if isinstance(u2,Vector):
                                v2 = u2
                        else:
                                v2 = Vector(u2)
                        v2 = v2 - v2.project(v1)
                        v1.normalize()
                        v2.normalize()
                        v3 = v1.cross(v2)
                        self.base=[v1,v2,v3]
                else:
                        self.base = base
        #
        #
        #
        def base_is_canonica(self):
                &#34;&#34;&#34;
                Returns True if sel.base is the canonical basis
                &#34;&#34;&#34;
                return Matrix(self.base).is_identity
        #
        #
        #
        def add_material(self,obj,material_name,r,g,b,opacity=1.0):
                &#34;&#34;&#34;
                Adds a material and color to an object
                Parameters:
                   obj: object

                   material_name: material&#39;s name

                   r, g, b: RGB color values

                   opacity: the opacity
                &#34;&#34;&#34;
                material = bpy.data.materials.get(material_name)
                if material is None:
                        material = bpy.data.materials.new(material_name)
                material.use_nodes = True
                principled_bsdf = material.node_tree.nodes[&#39;Principled BSDF&#39;]
                if principled_bsdf is not None:
                        #for i, o in enumerate(principled_bsdf.inputs):
                        #       print(i, o.name)
                        principled_bsdf.inputs[&#39;Base Color&#39;].default_value = (r, g, b, 0.5)
                        principled_bsdf.inputs[&#39;IOR&#39;].default_value = 0.0
                        principled_bsdf.inputs[&#39;Metallic&#39;].default_value = 1.0
                        if bpy.app.version[0] &lt; 4:
                                principled_bsdf.inputs[&#39;Specular&#39;].default_value = 1.0
                        else:
                                principled_bsdf.inputs[&#39;Specular IOR Level&#39;].default_value = 1.0
                        if bpy.app.version[0] &lt; 4:
                                principled_bsdf.inputs[&#39;Emission&#39;].default_value = (r, g, b, 0.5)
                        else:
                                principled_bsdf.inputs[&#39;Emission Color&#39;].default_value = (r, g, b, 0.5)
                        principled_bsdf.inputs[&#39;Emission Strength&#39;].default_value = 0.0
                        if opacity &lt; 1.0:
                                material.blend_method = &#39;BLEND&#39;
                                principled_bsdf.inputs[&#39;Alpha&#39;].default_value = opacity
                        else:
                                material.blend_method = &#39;OPAQUE&#39;
                                principled_bsdf.inputs[&#39;Alpha&#39;].default_value = 1.0
                obj.active_material = material
        #
        #
        #
        def add_ligth(self,location=[0,0,100],energy=3,direction=[0,0,-1]):
                &#34;&#34;&#34;
                Adds a ligth to the scene
                Parameters:
                   location: location point of the light

                   energy: energy of the ligth

                   direction: direction of the light
                &#34;&#34;&#34;
                l = bpy.data.lights.new(name=&#34;Light&#34;, type=&#39;SUN&#39;)
                l.energy = energy
                l.specular_factor = 4
                obj = self.objects.new(name=&#34;Light&#34;, object_data=l)
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.location = location
                n = Vector(direction)
                mat = Matrix(self.base)
                mat.transpose()
                n = mat @ n
                z = Vector([0,0,-1])
                quaternion = z.rotation_difference(n)
                obj.rotation_quaternion.rotate(quaternion)
                self.collection.objects.link(obj)
        #
        #
        #
        def add_ligths(self,energy=1):
                &#34;&#34;&#34;
                Adds diferent lights to the scene
                Parameters:
                   energy: energy of the lights
                &#34;&#34;&#34;
                self.add_ligth()
                self.add_ligth(location=[100,0,0],direction=[-1,0,0],energy=energy)
                self.add_ligth(location=[0,100,0],direction=[0,-1,0],energy=energy)
                self.add_ligth(location=[-100,0,0],direction=[1,0,0],energy=energy)
                self.add_ligth(location=[0,-100,0],direction=[0,1,0],energy=energy)
        #
        #
        #
        def components_in_base(self,vector=None):
                &#34;&#34;&#34;
                Returns the components of the vector &#39;vector&#39; in the basis determined by
                self.rotation and the basis self.base
                Parameters:
                   vector: components of the vector in the canonical basis
                &#34;&#34;&#34;
                if vector is None:
                        return Vector([0,0,0])
                if isinstance(vector,Vector):
                        u = vector
                else:
                        u = Vector(vector)
                if self.rotation is not None:
                        mat = self.rotation.quaternion.to_matrix()
                        mat.invert()
                        u = mat @ u
                mat = Matrix(self.base)
                mat.transpose()
                mat.invert()
                u = mat @ u
                return u
        #
        #
        #
        def coordinates_en_referencia(self,point=None):
                &#34;&#34;&#34;
                Returns the coordinates of the point &#39;point&#39; in the reference determined by
                self.origin, self.rotation and the basis self.base
                Parameters:
                   point: coordinates of the point in the canonical reference
                &#34;&#34;&#34;
                if point is None:
                        return Vector([0,0,0])
                if isinstance(point,Vector):
                        u = point
                else:
                        u = Vector(point)
                if self.rotation is not None:
                        mat = self.rotation.quaternion.to_matrix()
                        mat.invert()
                        u = mat @ u
                mat = Matrix(self.base)
                mat.transpose()
                mat.invert()
                u = mat @ (u - Vector(self.origin))
                return u
        #
        #
        #
        def set_cursor(self,origin=[0,0,0],direction=[1,0,0],axis=&#39;x&#39;):
                &#34;&#34;&#34;
                Sets the cursor position and direction
                Parameters:
                  origin: position of the cursor

                  direction: vector that indicates the direction of the axis &#39;axis&#39;

                  axis: &#39;x&#39;, &#39;y&#39; or &#39;z&#39;
                &#34;&#34;&#34;
                axis = axis.lower()
                if axis not in [&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]:
                        return
                eixos = {&#39;x&#39; : Vector([1,0,0]),
                                 &#39;y&#39; : Vector([0,1,0]),
                                 &#39;z&#39; : Vector([0,0,1])
                }
                if isinstance(direction,Vector):
                        d = direction
                else:
                        d = Vector(direction)
                x = eixos[axis]
                quaternion = x.rotation_difference(d)
                self.scene.cursor.location = origin
                self.scene.cursor.rotation_mode = &#39;QUATERNION&#39;
                self.scene.cursor.rotation_quaternion = quaternion
        #
        #
        #
        def set_cursor_rotation(self,origin=[0,0,0],rotation=Matrix.Identity(3)):
                &#34;&#34;&#34;
                Sets the rotation of the cursor
                Parameters:
                   origin: position of the cursor

                   rotation: matrix of a rotation
                &#34;&#34;&#34;
                m = rotation.copy()
                det = m.determinant()
                if abs(- det - 1.0) &lt; 0.1:
                        m[2] = - m[2]
                quaternion = m.to_quaternion()
                self.scene.cursor.location = origin
                self.scene.cursor.rotation_mode = &#39;QUATERNION&#39;
                self.scene.cursor.rotation_quaternion = quaternion.conjugated()
        #
        #
        #
        def draw_base_axis(self,scale=0.05,head_height=0.15,axis=0,name=&#34;Axis&#34;,positive=True,zaxis=True):
                &#34;&#34;&#34;
                Draws a reference axis given by self.origin, self.rotation and the basis self.base
                Parameters:
                   scale: scale of the cylinder

                   head_height: height of the head of the vector from self.base

                   axis: length of the coordinate axis. If the length is 0, only the basis vectors are drawn

                   name: name of the result object

                   positive: if True, draw the positive part of the axis

                   zaxis: if True, draw the z axis
                &#34;&#34;&#34;
                self.base_cilinder()
                self.base_cone()
                o = Vector([0,0,0])
                op = Vector(self.origin)
                color = 0

                if axis != 0 and axis &lt; 8:
                        scale /= 3

                base = self.base
                if not zaxis:
                        base = self.base[0:2]
                for vec in base:
                        #
                        # Draw the stem
                        #
                        v = Vector(vec)
                        t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                        obj = t.copy()
                        obj.name = &#34;Axis%d&#34; % (color + 1)
                        obj.data = obj.data.copy()
                        obj.location = o
                        obj.scale = (scale,scale,(v - o).length - 2 * head_height)
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if self.colors is not None and len(self.colors) &gt; color:
                                c = self.colors[color]
                                self.add_material(obj,c.name,c.r,c.g,c.b)
                        if self.rotation is not None:
                                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location = op
                        self.scene.collection.objects.link(obj)
                        #
                        # Draw the arrow
                        #
                        t = bpy.data.objects.get(&#34;Arrow_cone&#34;)
                        obj2 = t.copy()
                        obj2.name = &#34;Arrow&#34;
                        obj2.data = obj2.data.copy()
                        obj2.location =  v - 2 * head_height * v / v.length
                        obj2.scale = (scale + 0.05,scale + 0.05,head_height)
                        obj2.rotation_mode = &#39;QUATERNION&#39;
                        obj2.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if self.colors is not None and len(self.colors) &gt; color:
                                c = self.colors[color]
                                self.add_material(obj2,c.name,c.r,c.g,c.b)
                        if self.rotation is not None:
                                obj2.rotation_quaternion.rotate(self.rotation.quaternion)
                                obj2.location.rotate(self.rotation.quaternion)
                        obj2.location = op + obj2.location
                        self.scene.collection.objects.link(obj2)
                        #
                        # Draw the line
                        #
                        obj3 = None
                        if axis != 0:
                                v = axis * Vector(vec)
                                t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                                obj3 = t.copy()
                                obj3.name = &#34;Line&#34;
                                obj3.data = obj3.data.copy()
                                obj3.location = op - v
                                obj3.scale = (scale / 2,scale / 2,(2 * v).length)
                                obj3.rotation_mode = &#39;QUATERNION&#39;
                                obj3.rotation_quaternion = v.to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                                if self.colors is not None and len(self.colors) &gt; color:
                                        c = self.colors[color]
                                        self.add_material(obj3,c.name,c.r,c.g,c.b)
                                if self.rotation is not None:
                                        obj3.rotation_quaternion.rotate(self.rotation.quaternion)
                                if positive:
                                        obj3.location = op
                                else:
                                        if self.rotation is not None:
                                                v.rotate(self.rotation.quaternion)
                                        obj3.location = op - v
                                self.scene.collection.objects.link(obj3)
                        #
                        # Joint the three objects
                        #
                        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                        bpy.context.view_layer.objects.active = obj
                        obj.select_set(True)
                        obj2.select_set(True)
                        if obj3 is not None:
                                obj3.select_set(True)
                        bpy.ops.object.join()
                        color += 1
                #
                # Join all the axis
                #
                t1 = bpy.data.objects.get(&#34;Axis1&#34;)
                t1.name = name
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.context.view_layer.objects.active = t1
                t1.select_set(True)
                t2 = bpy.data.objects.get(&#34;Axis2&#34;)
                t2.select_set(True)
                if zaxis:
                        t3 = bpy.data.objects.get(&#34;Axis3&#34;)
                        t3.select_set(True)
                bpy.ops.object.join()
                self.delete_base_cilinder()
                self.delete_base_cone()
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return t1
        #
        #
        #
        def draw_vector(self,vector=None,canonica=False,color=&#34;Black&#34;,scale=0.05,arrow=True,head_height=0.15,axis=0,name=&#34;Vector&#34;,positive=True):
                &#34;&#34;&#34;
                Draw the vector with components &#39;vector&#39;
                Parameters:
                   vector: components of the vector

                   canonica: if True, the components are in the canonical basis, else they are in the basis self.base. Finally,
                      self.rotation is applied

                   color: color of the vector

                   scale: scale of the cylinder

                   arrow: if True draws the vector itself

                   head_height: height of the head of the vector

                   head_scale: scale of the head of the vector

                   axis: if not zero, draw also the line generated by the vector

                   positive: if axis is not zero and positive is True, draw only the positive part of the line
                      generated by the vector
                &#34;&#34;&#34;
                if vector is None:
                        return None
                if isinstance(vector,Vector):
                        vec = vector
                else:
                        vec = Vector(vector)
                if vec.length == 0:
                        return None
                self.base_cilinder()
                self.base_cone()
                o = Vector([0,0,0])
                op = Vector(self.origin)
                if color is not None:
                        color = Colors.color(color)
                v = vec
                if not canonica:
                        mat = Matrix(self.base)
                        mat.transpose()
                        v = mat @ vec

                if arrow:
                        t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                        obj = t.copy()
                        obj.name = name
                        obj.data = obj.data.copy()
                        obj.location = o
                        obj.scale = (scale,scale,(v - o).length - 2 * head_height)
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if color is not None:
                                self.add_material(obj,color.name,color.r,color.g,color.b)
                        if self.rotation is not None:
                                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location = op
                        self.scene.collection.objects.link(obj)

                        t = bpy.data.objects.get(&#34;Arrow_cone&#34;)
                        obj2 = t.copy()
                        obj2.data = obj2.data.copy()
                        obj2.name = &#34;Arrow&#34;
                        obj2.location =  v - 2 * head_height * v / v.length
                        obj2.scale = (1.05*scale,1.05*scale + 0.05,head_height)
                        obj2.rotation_mode = &#39;QUATERNION&#39;
                        obj2.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if color is not None:
                                self.add_material(obj2,color.name,color.r,color.g,color.b)
                        if self.rotation is not None:
                                obj2.rotation_quaternion.rotate(self.rotation.quaternion)
                                obj2.location.rotate(self.rotation.quaternion)
                        obj2.location = op + obj2.location
                        self.scene.collection.objects.link(obj2)

                obj3 = None
                if axis != 0:
                        v = axis * v / v.length
                        t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                        obj3 = t.copy()
                        if not arrow:
                                obj3.name = &#34;Line&#34;
                        else:
                                obj3.name = &#34;Generated&#34;
                        obj3.data = obj3.data.copy()
                        obj3.scale = (scale / 2,scale / 2,(2 * v).length)
                        obj3.rotation_mode = &#39;QUATERNION&#39;
                        obj3.rotation_quaternion = v.to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if color is not None:
                                self.add_material(obj3,color.name,color.r,color.g,color.b)
                        if self.rotation is not None:
                                obj3.rotation_quaternion.rotate(self.rotation.quaternion)
                        if positive:
                                obj3.location = op
                        else:
                                obj3.location = op - v
                        self.scene.collection.objects.link(obj3)

                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                if arrow:
                        bpy.context.view_layer.objects.active = obj
                elif axis != 0:
                        bpy.context.view_layer.objects.active = obj3
                if arrow:
                        obj.select_set(True)
                        obj2.select_set(True)
                if obj3 is not None:
                        obj3.select_set(True)
                if arrow:
                        bpy.ops.object.join()
                bpy.ops.object.shade_smooth()
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                self.delete_base_cilinder()
                self.delete_base_cone()
                bpy.context.view_layer.objects.active = None
                if arrow:
                        return obj
                if axis != 0:
                        return obj3
                return None
        #
        #
        #
        def comp_times_vector(self,u,v):
                &#34;&#34;&#34;
                Computes the vectorial product u x v
                Parameters:
                   u, v: two Vectors
                &#34;&#34;&#34;
                return Vector([u.x * v.x,u.y * v.y,u.z * v.z])
        #
        #
        #
        def draw_line(self,start=[1,1,1],end=[10,10,10],scale=0.05,name=&#34;Line&#34;,color=&#34;Black&#34;):
                &#34;&#34;&#34;
                Draws a line from the point start to the point end. The reference given by self.origin,
                self.rotation and the basis self.base is used
                Parameters:
                   start: starting point of the line

                   end: ending point of the line

                   scale: scale of the cylinder

                   name: name of the object

                   color: color of the vector
                &#34;&#34;&#34;
                if start is None or end is None:
                        return
                self.base_cilinder()
                o = Vector([0,0,0])
                op = Vector(self.origin)
                if isinstance(start,Vector):
                        u = start
                else:
                        u = Vector(start)
                if isinstance(end,Vector):
                        v = end
                else:
                        v = Vector(end)
                mat = Matrix(self.base)
                mat.transpose()
                u = mat @ u
                v = mat @ v
                l = (v - u).length
                t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                obj = t.copy()
                obj.name = name
                obj.location = u
                obj.scale = (scale / 2,scale / 2,l)
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.rotation_quaternion = (v - u).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                if color is not None:
                        c = Colors.color(color)
                        self.add_material(obj,c.name,c.r,c.g,c.b)
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                obj.location = obj.location + op
                self.scene.collection.objects.link(obj)
                bpy.ops.object.shade_flat()
                self.delete_base_cilinder()
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_components(self,vector=None,color=&#34;Cyan&#34;,name=&#34;Components&#34;,scale=0.0075):
                &#34;&#34;&#34;
                Draws the components of the the vector &#39;vector&#39; in the reference given by self.origin,
                self.rotation and the basis self.base
                Parameters:
                   vector: the vector

                   color: color of the lines of components

                   name: name of the object

                   scale: scale of the lines
                &#34;&#34;&#34;
                if vector is None:
                        return
                if isinstance(vector,Vector):
                        v = vector
                else:
                        v = Vector(vector)
                mat = Matrix(self.base)
                mat.transpose()
                list = [[0,0,0],[1,0,0],[1,1,0],[0,1,0],[0,0,1],[1,0,1],[1,1,1],[0,1,1]]
                lines = [[0,1],[1,2],[2,3],[0,3],[0,4],[1,5],[2,6],[3,7],[4,5],[5,6],[6,7],[4,7]]
                vecs = [self.comp_times_vector(v,Vector(x)) for x in list]
                count = 0
                for first, last in lines:
                        if count == 0:
                                this = name
                        else:
                                this = f&#34;Line{count}&#34;
                        count += 1
                        self.draw_line(start=vecs[first],end=vecs[last],scale=scale,name=this,color=color)
                t = bpy.data.objects.get(name)
                list = [t]
                for count in range(1,12):
                        obj = bpy.data.objects.get(f&#34;Line{count}&#34;)
                        if obj is not None:
                                list.append(obj)
                t = self.join(list)
                bpy.context.view_layer.objects.active = None
                return t
        #
        #
        #
        def draw_vectors(self,vectors=[],canonica=False,color=&#34;Black&#34;,scale=0.05,head_height=0.2,name=&#34;Vectors&#34;,axis=0):
                &#34;&#34;&#34;
                Draws a list of vectors.
                Parameters:
                   vectors: list of vectors

                   anonica: if True, the the vectors are expressed in the canonical basis.

                   color: color of the vectors

                   scale: scale of the cylinder

                   head_height: height of the head of the vector

                   axis: if not zero, draw also the line generated by every vector
                &#34;&#34;&#34;
                if len(vectors) == 0:
                        return
                count = 0
                for v in vectors:
                        if count == 0:
                                this = name
                        else:
                                this = f&#34;Vector{count}&#34;
                        count += 1
                        t = self.draw_vector(v,canonica,color=color,scale=scale,head_height=head_height,axis=axis,name=this)
                t = bpy.data.objects.get(name)
                list = [t]
                for count in range(1,len(vectors)+1):
                        obj = bpy.data.objects.get(f&#34;Vector{count}&#34;)
                        if obj is not None:
                                list.append(obj)
                t = self.join(list)
                return t
        #
        #
        #
        def draw_plane(self,normal=None,base=None,sizex=10,sizey=10,color=&#34;AzureBlueDark&#34;,name=&#39;Plane&#39;,opacity=1.0,thickness=0.01):
                &#34;&#34;&#34;
                Draws a plane with normal vector or base vectors. It passes through the point self.origin.
                Only normal or base can be not None
                Parameters:
                   normal: normal vector to the plane

                   base: list of two independent vectors

                   sizex: x-size of the plane

                   sizey: y-size of the plane

                   color: color of the plane

                   name: name of the plane

                   opacity: opacity of the plane

                   thickness: thickness of the plane
                &#34;&#34;&#34;
                if sizex == 0.0:
                        return
                bpy.ops.mesh.primitive_plane_add(size=sizex,enter_editmode=True,location=(0, 0, 0))
                bpy.context.object.name = name
                ##### bpy.ops.mesh.subdivide(number_cuts=6,quadcorner=&#39;INNERVERT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj = bpy.data.objects.get(name)
                if sizey is not None and sizey != 0.0:
                        t = sizey / sizex
                        obj.scale = [1,t,1]
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                if normal is not None and base is not None:
                        return
                if base is not None:
                        if len(base) != 2:
                                return
                        if isinstance(base[0],Vector):
                                v1 = base[0]
                        else:
                                v1 = Vector(base[0])
                        if isinstance(base[1],Vector):
                                v2 = base[1]
                        else:
                                v2 = Vector(base[1])

                        if self.base is None:
                                normal = v1.cross(v2)
                        else:
                                u1 = v1[0]*self.base[0] + v1[1]*self.base[1] + v1[2]*self.base[2]
                                u2 = v2[0]*self.base[0] + v2[1]*self.base[1] + v2[2]*self.base[2]
                                normal = u1.cross(u2)
                if normal is not None and normal != Vector([0,0,0]):
                        z = Vector([0,0,1])
                        quaternion = z.rotation_difference(normal)
                        obj.rotation_quaternion.rotate(quaternion)
                        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def simple_curve(self,f=None,tmin=0.0,tmax=1.0,steps=25,name=&#34;Simple curve&#34;,symmetry=None,draw=False):
                &#34;&#34;&#34;
                Return a curve defined by the parametrization f
                Parameters:
                   f: Parametrization of the curve

                   tmin: minimum value of the parameter

                   tmax: maximum value of the parameter

                   steps: number of steps

                   name: name of the curve

                   symmetry: None or a value in the list (&#39;XY&#39;,&#39;XZ&#39;,&#39;YZ&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;,&#39;O&#39;). Symmetry of the curve

                   draw: if True, the curve is drawn
                &#34;&#34;&#34;
                if f is None:
                        return None

                delta = (tmax - tmin)/steps
                t = tmin
                bm = bmesh.new()
                verts = []
                verts2 = []

                for k in range(steps + 1):
                        p = f(t)
                        q = None
                        verts.append(bm.verts.new(p))
                        if symmetry == &#39;XY&#39;:
                                q = (p[0],p[1],-p[2])
                        elif symmetry == &#39;XZ&#39;:
                                q = (p[0],-p[1],p[2])
                        elif symmetry == &#39;YZ&#39;:
                                q = (-p[0],p[1],p[2])
                        elif symmetry == &#39;X&#39;:
                                q = (p[0],-p[1],-p[2])
                        elif symmetry == &#39;Y&#39;:
                                q = (-p[0],p[1],-p[2])
                        elif symmetry == &#39;Z&#39;:
                                q = (-p[0],-p[1],p[2])
                        elif symmetry == &#39;O&#39;:
                                q = (-p[0],-p[1],-p[2])

                        if q is not None:
                                verts2.append(bm.verts.new(q))
                        t += delta
                        if t &gt; tmax:
                                t = tmax

                for i in range(len(verts) - 1):
                        bm.edges.new([verts[i], verts[i+1]])
                        if len(verts2) &gt; 0:
                                bm.edges.new([verts2[i], verts2[i+1]])

                me = bpy.data.meshes.new(&#39;placeholder_mesh&#39;)
                obj = bpy.data.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()

                if draw:
                        self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_elliptic_paraboloid(self,a=0.5,xmin=0.0,xmax=3.0,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;EllipticParaboloid&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws an elliptic paraboloid from the parabola z=a*t^2
                Parameters:
                   a: coefficient of the parabola

                   xmin: minimum value of x

                   xmax: maximum value of x

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                obj = self.simple_curve(f=lambda t:(t,0,a*t**2),tmin=xmin,tmax=xmax,steps=steps,name=name)
                modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                modifier.angle = 2 * math.pi
                modifier.steps = 128
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                self.scene.collection.objects.link(obj)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_one_sheet_hyperboloid(self,a=2.0,b=2.0,xmin=math.sqrt(2),xmax=5.0,steps=256,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperboloidOneSheet&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws a one sheet hyperboloid from the hyperbole z = \pm a*sqrt(x^2-b) in the XZ plane
                Parameters:
                   a, b: coefficients of the hyperbole

                   xmin: minimum value of x

                   xmax: maximum value of x

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                if xmin &lt; math.sqrt(b):
                        xmin = math.sqrt(b)
                delta = (xmax - xmin) / steps
                x = xmax
                bm = bmesh.new()
                verts = []

                for k in range(steps + 1):
                        if x &lt; math.sqrt(b):
                                z = 0.0
                        else:
                                z = - a * math.sqrt(x**2 - b)
                        verts.append(bm.verts.new((x,0,z)))
                        x -= delta
                x = math.sqrt(b)
                for k in range(steps):
                        x += delta
                        if x**2 &lt; b:
                                z = 0.0
                        else:
                                z = a * math.sqrt(x**2 - b)
                        verts.append(bm.verts.new((x,0,z)))

                for i in range(len(verts) - 1):
                        bm.edges.new([verts[i], verts[i+1]])

                me = self.meshes.new(&#39;placeholder_mesh&#39;)
                obj = self.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()
                modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                modifier.angle = 2 * math.pi
                modifier.steps = 128
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_two_sheets_hyperboloid(self,a=2.0,b=1.0,xmin=0.0,xmax=5.0,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperboloidTwoSheets&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws a two sheet hyperboloid from the hyperbole z = \pm a * math.sqrt(x**2+b) in the XZ plane
                Parameters:
                   a, b: coefficients of the hyperbole

                   xmin: minimum value of x

                   xmax: maximum value of x

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                delta = (xmax - xmin) / steps
                x = xmax
                bm = bmesh.new()
                verts = []
                count = 2 * steps + 2
                sign = 1
                for k in range(count):
                        if k == steps + 1:
                                sign = -1
                        z = sign * a * math.sqrt(x**2+b)
                        verts.append(bm.verts.new((x,0,z)))
                        if k == steps and xmin &gt; 0:
                                x = xmin
                        else:
                                x = x - sign * delta
                        if k == 0 or k == steps + 1:
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;placeholder_mesh&#39;)
                obj = self.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()

                modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                modifier.angle = 2 * math.pi
                modifier.steps = 128
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_cone(self,a=1.0,xmin=0.0,xmax=5.0,steps=50,scale=[1,1,1],half=False,color=&#34;AzureBlueDark&#34;,name=&#34;Cone&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws a cone from the line z = a*x in the XZ plane
                Parameters:
                   a: slope of the line

                   xmin: minimum value of x

                   xmax: maximum value of x

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   half: if True, draws half cone

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                delta = (xmax - xmin) / steps
                x = xmax
                bm = bmesh.new()
                verts = []
                count = 2 * steps + 2
                if xmin == 0.0:
                        count = 2 * steps + 1
                if half:
                        count = steps + 1
                for k in range(count):
                        z = a * x
                        verts.append(bm.verts.new((x,0,z)))
                        if k == steps and xmin &gt; 0:
                                x = - xmin
                        else:
                                x -= delta
                        if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;placeholder_mesh&#39;)
                obj = self.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()

                modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                modifier.angle = 2 * math.pi
                modifier.steps = 128
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_parabolic_cylinder(self,p=0.25,xmin=0.0,xmax=6.0,length=20,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;ParabolicCylinder&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws a parabolic cylinder from the parabola z=p*x^2 in the XZ plane
                Parameters:
                   p: coefficients of the parabola

                   xmin: minimum value of x

                   xmax: maximum value of x

                   length: length in the Y direction

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                delta = (xmax - xmin) / steps
                x = xmax
                bm = bmesh.new()
                verts = []
                count = 2 * steps + 2
                if xmin == 0.0:
                        count = 2 * steps + 1
                for k in range(count):
                        z = p * x**2
                        verts.append(bm.verts.new((x,0,z)))
                        if k == steps and xmin &gt; 0:
                                x = - xmin
                        else:
                                x -= delta
                        if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;ParabolicCylinderMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()

                bpy.context.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = obj
                bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
                bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
                bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
                bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0, length, 0),&#34;constraint_axis&#34;:(False, True, False),&#34;use_accurate&#34;:True})
                bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj.select_set(True)
                bpy.ops.transform.translate(value=(0, -length/2, 0),constraint_axis=(False, True, False))
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                obj.select_set(False)

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_hyperbolic_cylinder(self,a=1.0,b=4.0,xmin=2.0,xmax=6.0,length=20,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicCylinder&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws an hyperbolic cylinder from the hyperbole y = a * sqrt(x**2 - b) in the XY plane
                Parameters:
                   a, b: coefficients of the hyperbole

                   xmin: minimum value of x

                   xmax: maximum value of x

                   length: length in the Z direction

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                if xmin &lt; math.sqrt(b):
                        xmin = math.sqrt(b)
                delta = (xmax-xmin)/steps
                bm = bmesh.new()
                verts = []
                count = 2 * steps + 2
                if xmin == 0.0:
                        count = 2 * steps + 1
                for q, d in [[1,0],[-1,count]]:
                        x = xmax
                        sign = 1
                        for k in range(count):
                                if k == steps + 1:
                                        sign = -1
                                if x &lt; math.sqrt(b):
                                        x = math.sqrt(b)
                                y = sign * a * math.sqrt(x**2 - b)
                                verts.append(bm.verts.new((q * x,y,0)))
                                if k == steps and xmin &gt; math.sqrt(b):
                                        x = xmin
                                else:
                                        x = x - sign * delta
                                if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                                        continue
                                bm.edges.new([verts[d + k-1], verts[d + k]])

                me = self.meshes.new(&#39;HyperboliclinderMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()

                self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = obj
                bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
                bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
                bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
                bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0,0,length),&#34;constraint_axis&#34;:(False,False,True),&#34;use_accurate&#34;:True})
                bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj.select_set(True)
                bpy.ops.transform.translate(value=(0,0,-length/2),constraint_axis=(False,False,True))
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                obj.select_set(False)

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_elliptic_cylinder(self,a=8.0,b=5.0,amin=0.0,amax=2*math.pi,length=20,steps=200,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;EllipticCylinder&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws an eliptic cylinder from the ellipse
                  x = a*cos(t)
                  y = b*sin(t)
                in the XY plane
                Parameters:
                   a, b: coefficients of the ellipsw

                   amin: minimum value of the angle t

                   amax: maximum value of the angle t

                   length: length in the Z direction

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                if amin &lt; 0.0:
                        amin = 0.0
                if amax &gt; 2 * math.pi:
                        amax = 2 * math.pi
                delta = (amax-amin)/steps
                bm = bmesh.new()
                verts = []
                t = amin
                for k in range(steps + 1):
                        x = a * math.cos(t)
                        y = b * math.sin(t)
                        verts.append(bm.verts.new((x,y,0)))
                        t += delta
                        if k == 0:
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;EllipticCylinderMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()
                self.scene.collection.objects.link(obj)

                bpy.context.view_layer.objects.active = obj
                bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
                bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
                bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
                bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0,0,length),&#34;constraint_axis&#34;:(False,False,True),&#34;use_accurate&#34;:True})
                bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj.select_set(True)
                bpy.ops.transform.translate(value=(0,0,-length/2),constraint_axis=(False,False,True))
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                obj.select_set(False)

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_hyperbolic_paraboloid(self,a=0.2,b=0.4,xmax=10.0,ymax=10.0,steps=64,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicParaboloid&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws an hyperbolic paraboloid with equation z = a*x^2 - b*y^2
                Parameters:
                   a, b: coefficients of the parabolic hyperboloid

                   xmax: maximum  value of x

                   ymax: maxim value y

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                equ = lambda x,y: (x,y,a*x**2-b*y**2)
                obj = self.draw_surface(eq=equ,umin=-xmax,umax=xmax,usteps=steps,vmin=-ymax,vmax=ymax,vsteps=steps,thickness=thickness,opacity=opacity,pmax=0,name=&#34;Hyperbolic paraboloid&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),wrap_u=False,wrap_v=False,close_v=False)
                obj.scale = scale
                return obj
        #
        #
        #
        def draw_ellipsoid(self,radius=5.0,scale=[1.2,1.8,0.8],color=&#34;AzureBlueDark&#34;,name=&#34;Ellipsoid&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws en ellipsoid
                Parameters:
                   radius: radius of the sphere

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_uv_sphere_add(segments=128, ring_count=128, radius=radius, enter_editmode=False, location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                obj.select_set(False)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_plane_surface(self,origin=None,normal=None,base=None,sizex=10,sizey=10,vectors=False,scalelines=0.05,scalevector=0.01,
                                                color=&#34;AzureBlueDark&#34;,linecolor=&#34;BlueDarkDull&#34;,vectorcolor=&#34;Black&#34;,name=&#34;Plane&#34;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a plane with normal vector or base vectors. It passes through the point origin.
                Only normal or base can be not None
                Parameters:
                   origin: a point in the plane

                   normal: normal vector to the plane

                   base: list of two independent vectors

                   sizex: x-size of the plane

                   sizey: y-size of the plane

                   vectors: if True, draw the generators of the plane

                   scalelines: scale of the lines limiting the plane

                   scalevector: scale of the generators

                   color: color of the plane

                   linecolor: color of the lines limiting the plane

                   vectorcolor: color of the generators

                   name: name of the plane

                   opacity: opacity of the plane

                   thickness: thickness of the plane
                &#34;&#34;&#34;
                if normal is not None and base is not None:
                        return
                if normal is None and base is None:
                        return
                mat = Matrix(self.base)
                mat.transpose()
                if normal is not None:
                        if not isinstance(normal,Vector):
                                normal= Vector(normal)
                        normal = mat @ normal
                if base is not None:
                        if len(base) != 2:
                                return
                        if isinstance(base[0],Vector):
                                v1 = base[0]
                        else:
                                v1 = Vector(base[0])
                        if isinstance(base[1],Vector):
                                v2 = base[1]
                        else:
                                v2 = Vector(base[1])
                        v1 = mat @ v1
                        v2 = mat @ v2
                        normal = v1.cross(v2)

                if normal == Vector([0,0,0]):
                        return

                steps = 4
                delta = sizex / steps
                x = - sizex / 2
                bm = bmesh.new()
                verts = []
                for k in range(steps + 1):
                        verts.append(bm.verts.new((x,0,0)))
                        x += delta
                        if k == 0:
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;PlaneSurfaceMesh&#39;)
                obj = self.objects.new(&#39;PlaneSurface&#39;, me)
                bm.to_mesh(me)
                bm.free()

                bpy.context.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = obj
                bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
                bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
                bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
                bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0, sizey, 0),&#34;constraint_axis&#34;:(False, True, False),&#34;use_accurate&#34;:True})
                bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj.select_set(True)
                bpy.ops.transform.translate(value=(0, -sizey/2, 0),constraint_axis=(False, True, False))
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                obj.select_set(False)

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                if origin is not None:
                        if isinstance(origin,Vector):
                                op = op + origin
                        else:
                                op = op + Vector(origin)
                obj.location = o
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                lines = None
                vecs = None
                s = 0.0
                nodes = [[1,1,0],[-1,1,0],[-1,-1,0],[1,-1,0]]
                nodes = [self.comp_times_vector(Vector([sizex / 2,sizey / 2,0]),Vector(x)) for x in nodes]
                edges = [[0,1],[1,2],[2,3],[3,0]]

                if scalelines &gt; 0.0:
                        aux = self.origin
                        self.origin = Vector([0,0,0])
                        objects = []
                        aux2 = self.base
                        self.reset_base()
                        for edge in edges:
                                l = self.draw_line(start=nodes[edge[0]],end=nodes[edge[1]],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)
                        self.set_origin(aux)
                        self.set_base(aux2)

                if lines is not None:
                        obj = self.join([obj,lines])

                if vectors:
                        vecs = self.draw_vectors(nodes,True,color=vectorcolor,scale=scalevector,head_height=0.2,name=&#34;Vectors&#34;,axis=0)

                if vecs is not None:
                        obj = self.join([obj,vecs])
                obj.name = name

                if isinstance(normal,Vector):
                        n = normal
                else:
                        n = Vector(normal)
                z = Vector([0,0,1])
                quaternion = z.rotation_difference(n)
                tmp = obj.rotation_quaternion
                quaternion = tmp @ quaternion
                obj.rotation_quaternion = quaternion
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_point(self,radius=0.1,location=(0,0,0),name=&#34;Point&#34;,color=&#34;Black&#34;,opacity=1.0):
                &#34;&#34;&#34;
                Draws a point (in the reference self.origin, self.base)
                Parameters:
                   radius: radius of the point

                   location: location of the point

                   name: name of the point

                   color: color of the point

                   opacity: opacity of the point
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_uv_sphere_add(segments=16, ring_count=16, radius=radius, enter_editmode=False, location=location)
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                if not isinstance(location,Vector):
                        location = Vector(location)
                mat = Matrix(self.base)
                mat.transpose()
                location = mat @ location

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = 0.1
                modifier.offset = 0.0
                c = Colors.color(color)
                op = Vector(self.origin)
                obj.location = op + location
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                bpy.ops.object.shade_smooth()
                obj.select_set(False)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_cube(self,origin=None,scale=[1,1,1],scalelines=0.05,vectors=False,color=&#34;Blue&#34;,linecolor=&#34;Red&#34;,vectorcolor=&#34;Black&#34;,name=&#39;Parallelepiped&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a rectangular parallelepiped
                Parameters:
                   origin: center of the parallelepiped

                   scale: scale of the sides of the parallelepiped

                   scalelines: scale of the edges of the parallelepiped

                   vectors: if True, draws vectors from the origin to the vertices

                   color: color of the parallelepiped

                   linecolor: color of the edges

                   vectorcolor: color of the vectors

                   name: name of the parallelepiped

                   opacity: opacity of the parallelepiped

                   thickness: thickness of the parallelepiped
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_cube_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                if origin is not None:
                        if isinstance(origin,Vector):
                                op = op + origin
                        else:
                                op = op + Vector(origin)
                obj.location = o
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                vecs = None
                s = 0.0
                nodes = [[1+s,1+s,1+s],[-1-s,1+s,1+s],[-1-s,-1-s,1+s],[1+s,-1-s,1+s],
                                [1+s,1+s,-1-s],[-1-s,1+s,-1-s],[-1-s,-1-s,-1-s],[1+s,-1-s,-1-s]]
                nodes = [self.comp_times_vector(Vector(scale),Vector(x)) for x in nodes]
                edges =[[0,1],[1,2],[2,3],[3,0],[0,4],[1,5],[2,6],[3,7],[4,5],[5,6],[6,7],[7,4]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=op+nodes[edge[0]],end=op+nodes[edge[1]],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                if vectors:
                        vecs = self.draw_vectors(nodes,color=vectorcolor,scale=0.05,head_height=0.2,name=&#34;Vectors&#34;,axis=0)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.scale = scale

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                if lines is not None:
                        obj = self.join([obj,lines])

                if vecs is not None:
                        obj = self.join([obj,vecs])
                return obj
        #
        #
        #
        def draw_parallelepiped(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],u3=[0,0,1],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Parallelepiped&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a parallelepiped
                Parameters:
                   origin: base vertex of the parallelepiped

                   u1, u2, u3: vectors that gives the edges

                   scalelines: scale of the edges of the parallelepiped

                   color: color of the parallelepiped

                   linecolor: color of the edges

                   name: name of the parallelepiped

                   opacity: opacity of the parallelepiped

                   thickness: thickness of the parallelepiped
                &#34;&#34;&#34;
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                if not isinstance(u3,Vector):
                        u3 = Vector(u3)

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2
                u3 = mat @ u3

                bpy.ops.mesh.primitive_cube_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                verts = obj.data.vertices
                verts[0].co = op
                verts[1].co = op + u3
                verts[2].co = op + u2
                verts[3].co = op + u2 + u3
                verts[4].co = op + u1
                verts[5].co = op + u1 + u3
                verts[6].co = op + u1 + u2
                verts[7].co = op + u1 + u2 + u3

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                s = 0.0
                edges =[[0,1],[0,2],[0,4],[1,3],[1,5],[2,3],[2,6],[3,7],[4,5],[4,6],[5,7],[6,7]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj
        #
        #
        #
        def draw_tetrahedron(self,origin=[0,0,0],u1=[2,0,0],u2=[2*math.cos(math.pi/3),2*math.sin(math.pi/3),0],u3=[(2+2*math.cos(math.pi/3))/3,2*math.sin(math.pi/3)/3,2],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Tetrahedron&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a tetrahedron
                Parameters:
                   origin: base vertex of the tetrahedron

                   u1, u2, u3: vectors that gives the edges

                   scalelines: scale of the edges of the tetrahedron

                   color: color of the tetrahedron

                   linecolor: color of the edges

                   name: name of the tetrahedron

                   opacity: opacity of the tetrahedron

                   thickness: thickness of the tetrahedron
                &#34;&#34;&#34;
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                if not isinstance(u3,Vector):
                        u3 = Vector(u3)

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2
                u3 = mat @ u3

                bpy.ops.mesh.primitive_solid_add()
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                verts = obj.data.vertices
                verts[0].co = op + u3
                verts[1].co = op
                verts[2].co = op + u1
                verts[3].co = op + u2

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                s = 0.0
                edges =[[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj
        #
        #
        #
        def draw_pyramid(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],u3=[0.5,0.5,1],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Pyramid&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a pyramid
                Parameters:
                   origin: base vertex of the pyramid

                   u1, u2, u3: vectors that gives the edges

                   scalelines: scale of the edges of the pyramid

                   color: color of the pyramid

                   linecolor: color of the edges

                   name: name of the pyramid

                   opacity: opacity of the pyramid

                   thickness: thickness of the pyramid
                &#34;&#34;&#34;
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                if not isinstance(u3,Vector):
                        u3 = Vector(u3)

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2
                u3 = mat @ u3

                bpy.ops.mesh.primitive_cone_add(radius1=1, radius2=0, depth=2, enter_editmode=False, align=&#39;WORLD&#39;,vertices=4)
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                verts = obj.data.vertices
                verts[0].co = op
                verts[1].co = op + u1
                verts[2].co = op + u1 + u2
                verts[3].co = op + u2
                verts[4].co = op + u3

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                s = 0.0
                edges =[[0,1],[0,3],[0,4],[1,2],[1,4],[2,3],[2,4],[3,4]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj
        #
        #
        #
        def draw_parallelogram(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Parallelogram&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a parallelogram
                Parameters:
                   origin: base vertex of the parallelogram

                   u1, u2: vectors that gives the edges

                   scalelines: scale of the edges of the parallelogram

                   color: color of the parallelogram

                   linecolor: color of the edges

                   name: name of the parallelogram

                   opacity: opacity of the parallelogram

                   thickness: thickness of the parallelogram
                &#34;&#34;&#34;
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2

                bpy.ops.mesh.primitive_plane_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                verts = obj.data.vertices
                verts[0].co = op
                verts[1].co = op + u1
                verts[2].co = op + u2
                verts[3].co = op + u1 + u2

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                s = 0.0
                edges =[[0,1],[0,2],[1,3],[2,3]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj
        #
        #
        #
        def draw_polygon(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],points=[[0,0],[1,0],[0,1]],scalelines=0.075,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Polygon&#39;,opacity=1.0,thickness=0.0,vectors=None,scalevectors=0.01):
                &#34;&#34;&#34;
                Draws a polygon
                Parameters:
                   origin: base vertex of the polygon

                   u1, u2: base vectors for the polygon

                   points: list of coordinates of points. The coordinates are taken in the reference {origin; u1, u2}

                   scalelines: scale of the edges of the polygon

                   color: color of the polygon

                   linecolor: color of the edges

                   name: name of the polygon

                   opacity: opacity of the polygon

                   thickness: thickness of the polygon
                &#34;&#34;&#34;
                if len(points) &lt; 3:
                        return
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                for i in range(len(points)):
                        if not isinstance(points[i],Vector):
                                points[i] = Vector(points[i])

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2

                bpy.ops.curve.simple(Simple_Type=&#39;Polygon&#39;,Simple_sides=len(points),align=&#39;WORLD&#39;,location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)

                baricentre = Vector([0,0,0])
                verts = obj.data.splines[0].bezier_points
                for i in range(len(verts)):
                        verts[i].co = op + points[i][0] * u1 + points[i][1] * u2
                        baricentre += verts[i].co
                baricentre /= len(verts)

                for i in range(len(verts)):
                        verts[i].co -= baricentre
                obj.location = baricentre

                obj.select_set(True)
                bpy.ops.object.convert(target=&#39;MESH&#39;)

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                ps = [op + points[i][0] * u1 + points[i][1] * u2 for i in range(len(points))]
                lines = None
                if scalelines &gt; 0.0:
                        objects = []
                        for i in range(len(points)):
                                l = self.draw_line(start=ps[i],end=ps[(i + 1) % len(points)],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                if vectors is not None:
                        old = self.origin
                        self.set_origin(op)
                        ps = [points[i][0] * u1 + points[i][1] * u2 for i in range(len(points))]
                        vecs = self.draw_vectors(ps,color=vectors,scale=scalevectors)
                        self.set_origin(old)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])
                if vectors is not None:
                        obj = self.join([obj,vecs])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj
        #
        #
        #
        def draw_regular_polygon(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],vertexs=5,radius=1,scalelines=0.075,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;RegularPolygon&#39;,opacity=1.0,thickness=0.0,vectors=None):
                &#34;&#34;&#34;
                Draws a regular polygon
                Parameters:
                   origin: base vertex of the polygon

                   u1, u2: base vectors for the polygon

                   vertexs: number of vertices of the polygon

                   radius: radius of the polygon

                   scalelines: scale of the edges of the polygon

                   color: color of the polygon

                   linecolor: color of the edges

                   name: name of the polygon

                   opacity: opacity of the polygon

                   thickness: thickness of the polygon
                &#34;&#34;&#34;
                angle = 2*math.pi/vertexs
                points = [[radius*math.cos(i*angle),radius*math.sin(i*angle)] for i in range(vertexs)]
                return self.draw_polygon(origin=origin,u1=u1,u2=u2,points=points,scalelines=scalelines,color=color,linecolor=linecolor,name=name,opacity=opacity,thickness=thickness,vectors=vectors,scalevectors=radius/400)
        #
        #
        #
        def draw_triangle(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],points=[[0,0],[1,0],[0,1]],scalelines=0.075,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#34;Triangle&#34;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a triangle. It&#39;s a polygon with three vertices
                Parameters:
                   origin: base vertex of the triangle

                   u1, u2: base vectors for the triangle

                   points: list of coordinates of points. The coordinates are taken in the reference {origin; u1, u2}

                   scalelines: scale of the edges of the triangle

                   color: color of the triangle

                   linecolor: color of the edges

                   name: name of the triangle

                   opacity: opacity of the triangle

                   thickness: thickness of the triangle
                &#34;&#34;&#34;
                if len(points) != 3:
                        return
                self.draw_polygon(origin=origin,u1=u1,u2=u2,points=points,scalelines=scalelines,color=color,linecolor=linecolor,name=name,opacity=opacity,thickness=thickness)

        #
        #
        #
        def draw_points(self,points=[],name=&#39;Points&#39;,color=&#34;Blue&#34;,opacity=1):
                &#34;&#34;&#34;
                Draws a list of points
                Parameters:
                   points: list of points

                   name: name of the list of points

                   color: color of the points

                   opacity: opacity of the points
                &#34;&#34;&#34;
                bm = bmesh.new()
                verts = []
                for p in points:
                        verts.append(bm.verts.new(p))

                me = self.meshes.new(&#39;PointsMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()
                self.scene.collection.objects.link(obj)
                return obj
        #
        #
        #
        def draw_mesh(self,mesh=None,name=&#39;Mesh&#39;,color=&#34;Blue&#34;,opacity=1):
                &#34;&#34;&#34;
                Draws a mesh. This function is used by other functions
                Parameters:
                   mesh: the mesh to be drawn

                   name: name of the mesh

                   color: color of the mesh

                   opacity: opacity of the mesh
                &#34;&#34;&#34;
                bm = bmesh.new()
                verts = []
                for p in mesh.points:
                        verts.append(bm.verts.new(p))
                edges = [[0,1],[1,2],[2,3],[3,0]]
                for s in mesh.simplices:
                        for e in edges:
                                v = Vector(mesh.points[s[e[0]]]) - Vector(mesh.points[s[e[1]]])
                                edge = [verts[s[e[0]]],verts[s[e[1]]]]
                                try:
                                        bm.edges.new(edge)
                                except:
                                        pass
                me = self.meshes.new(&#39;PointsMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()
                self.scene.collection.objects.link(obj)
                return obj
        #
        #
        #
        def join(self,list):
                &#34;&#34;&#34;
                Joins a list of objects
                Parameters:
                   list: list of objects
                &#34;&#34;&#34;
                if len(list) &lt;= 1:
                        return
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.context.view_layer.objects.active = list[0]
                for obj in list:
                        obj.select_set(True)
                bpy.ops.object.join()
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                return list[0]
        #
        #
        #
        def vectors_to_quaternion(self,u1=Vector([1,0,0]),u2=Vector([0,1,0])):
                &#34;&#34;&#34;
                Returns the quaternion correspondint to the base {v1,v2,v3}
                u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
                       v1 = u1
                           v2 = u2 - u2.project(v1)
                           v1.normalize()
                           v2.normalize()
                           v3 = v1.cross(v2)
                &#34;&#34;&#34;
                if isinstance(u1,Vector):
                        v1 = u1
                else:
                        v1 = Vector(u1)
                if isinstance(u2,Vector):
                        v2 = u2
                else:
                        v2 = Vector(u2)
                v2 = v2 - v2.project(v1)
                v1.normalize()
                v2.normalize()
                v3 = v1.cross(v2)
                mat = Matrix([v1,v2,v3])
                mat.transpose()
                return mat.to_quaternion()
        #
        #
        #
        def ellipsoid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Ellipsoid&#34;,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an ellipsoid
                Parameters:
                   o: center of the ellipsoid

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
                       v1 = u1
                           v2 = u2 - u2.project(v1)
                           v1.normalize()
                           v2.normalize()
                           v3 = v1.cross(v2)

                   a2, b2, c2: squares of semi-axes of the ellipsoid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 + z&#39;^2/c^2 = 1

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the ellipsoid

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -pmax and pmax

                   thickness: thickness of the ellipsoid

                   opacity: opaccity of the ellipsoid
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                c = math.sqrt(c2)
                self.draw_ellipsoid(radius=1,scale=[a,b,c],color=color,name=name,thickness=thickness,opacity=opacity)
        #
        #
        #
        def sphere(self,o=[0,0,0],r2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Sphere&#34;,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws a sphere of center &#39;o&#39; and radius squared equal to &#39;r2&#39;
                Parameters:
                   o: center of the spherecmax=15

                   r2: radius of the sphere squared

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the sphere

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the sphere

                   opacity: opacity of the sphere
                &#34;&#34;&#34;
                u1 = Vector([1,0,0])
                u2 = Vector([0,1,0])
                return self.ellipsoid(o=o,u1=u1,u2=u2,a2=r2,b2=r2,c2=r2,principal=principal,canonica=canonica,color=color,name=name,cmax=cmax,pmax=pmax,thickness=thickness,opacity=opacity)
        #
        #
        #
        def one_sheet_hyperboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;OneSheetHyperboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an one sheet hyperboloid
                Parameters:
                   o: center of the hyperboloid

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = 1

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the hyperboloid

                   xmax: maximum value of the x coordinate

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the hyperboloid

                   opacity: opacity of the hyperboloid
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                c = math.sqrt(c2)
                if xmax is None:
                        xmax=5.0/a + 2
                xmax /= a
                self.draw_one_sheet_hyperboloid(a=1.0,b=1.0,xmin=1.0,xmax=xmax,scale=[a,b,c],color=color,name=name,thickness=thickness,opacity=opacity)
        #
        #
        #
        def two_sheets_hyperboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;TwoSheetParaboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws a two sheets hyperboloid
                Parameters:
                   o: center of the hyperboloid

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = -1

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the hyperboloid

                   xmax: maximum value of the x coordinate

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the hyperboloid

                   opacity: opacity of the hyperboloid
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                c = math.sqrt(c2)
                if xmax is None:
                        xmax = 5.0/a + 2
                xmax /= a
                self.draw_two_sheets_hyperboloid(a=1.0,b=1.0,xmin=0.0,xmax=xmax,color=color,scale=[a,b,c],name=name,thickness=thickness,opacity=opacity)
        #
        #
        #
        def cone(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,half=False,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Cone&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws a cone
                Parameters:
                   o: center of the cone

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   a2, b2, c2: squares of semi-axes of the cone. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = 0

                   half: if True draws half cone

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the cone

                   xmax: maximum value of the x coordinate

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -pmax and pmax

                   thickness: thickness of the cone

                   opacity: opacity of the cone
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                c = math.sqrt(c2)
                if xmax is None:
                        xmax = 10.0/a + 2
                xmax /= a
                self.draw_cone(a=1.0,xmin=0.0,xmax=xmax,steps=50,half=half,color=color,scale=[a,b,c],name=name,thickness=thickness,opacity=opacity)
        #
        #
        #
        def hyperbolic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicCylinder&#34;,xmax=None,zmax=20,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an hyperbolic cylinder
                Parameters:
                   o: center of the hyperbolic cylinder

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   a2, b2: squares of semi-axes of the hyperbolic cylinder. The equation is x&#39;^2/a^2 - y&#39;^2/b^2 = 1

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the hyperbolic cylinder

                   xmax: maximum value of the x coordinate

                   zmax: the hyperbolic cylinder is drawn between -zmax and zmax

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the hyperbolic cylinder

                   opacity: opacity of the hyperbolic cylinder
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                if xmax is None:
                        xmax = 5.0/a + 2
                xmax /= a
                obj = self.draw_hyperbolic_cylinder(a=1.0,b=1.0,xmin=1.0,xmax=xmax,length=zmax,steps=128,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)
        #
        #
        #
        def elliptic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;EllipticCylinder&#34;,zmax=20,cmax=15,pmax=15,thickness=0.02,opacity=1.0,change=False):
                &#34;&#34;&#34;
                Draws an elliptic cylinder
                Parameters:
                   o: center of the elliptic cylinder

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   a2, b2: squares of semi-axes of the elliptic cylinder. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 = 1

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the elliptic cylinder

                   zmax: the elliptic cylinder is drawn between -zmax and zmax

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the elliptic cylinder

                   opacity: opacity of the elliptic cylinder
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                self.draw_elliptic_cylinder(a=1.0,b=1.0,length=zmax,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)
                if not change:
                        self.set_origin()
                        self.set_base()
        #
        #
        #
        def elliptic_paraboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;EllipticParaboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an elliptic paraboloid
                Parameters:
                   o: vertex of the elliptic paraboloid

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   a2, b2: squares of semi-axes of the elliptic paraboloid. The equation is z = x&#39;^2/a^2 + y&#39;^2/b^2

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the elliptic paraboloid

                   xmax: maximum value of the coordinate x

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the elliptic paraboloid

                   opacity: opacity of the elliptic paraboloid
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                if xmax is None:
                        xmax = 10.0/a
                xmax /= a
                self.draw_elliptic_paraboloid(a=1.0,xmin=0.0,xmax=xmax,steps=50,scale=[a,b,1],color=color,name=name,opacity=opacity,thickness=thickness)
        #
        #
        #
        def hyperbolic_paraboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicParaboloid&#34;,xmax=None,ymax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an hyperbolic paraboloid
                Parameters:
                   o: vertex of the hyperbolic paraboloid

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   a2, b2: squares of semi-axes of the hyperbolic paraboloid. The equation is z = x&#39;^2/a^2 - y&#39;^2/b^2

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the elliptic paraboloid

                   xmax: maximum value of the coordinate x

                   ymax: maximum value of the coordinate y

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the hyperbolic paraboloid

                   opacity: opacity of the hyperbolic paraboloid
                &#34;&#34;&#34;
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                if xmax is None:
                        xmax = 10.0/a + 2
                if ymax is None:
                        ymax = 10.0/b + 1
                xmax /= a
                ymax /= b
                obj = self.draw_hyperbolic_paraboloid(a=1.0,b=1.0,xmax=xmax,ymax=ymax,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)

                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                obj.location = o
        #
        #
        #
        def parabolic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;ParabolicCylinder&#34;,xmax=None,ymax=30,cmax=20,pmax=20,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an hyperbolic paraboloid
                Parameters:
                   o: vertex of the hyperbolic paraboloid

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   a: coefficient of the intial parabola

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the elliptic paraboloid

                   xmax: maximum value of the coordinate x

                   ymax: maximum value of the coordinate y

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the hyperbolic paraboloid

                   opacity: opacity of the hyperbolic paraboloid
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                coef = 1.0
                if a &lt; 0:
                        coef = -1
                if xmax is None:
                        xmax = 5.0/a + 1.5
                xmax /= a
                self.draw_parabolic_cylinder(p=coef,xmin=0.0,xmax=xmax,length=ymax,color=color,name=name,scale=[a,1,1],thickness=thickness,opacity=opacity)
        #
        #
        #
        def draw_simple_curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.02,color=&#34;White&#34;,name=&#34;Curve&#34;):
                &#34;&#34;&#34;
                Draws a parametric curve
                Parameters:
                   fun: the parametric function

                   tmin: minimum value of the parameter

                   tmax: maximum value of the parameter

                   steps: number of steps

                   thickness: thickness of the curve

                   color: color of the curve

                   name: name of the curve
                &#34;&#34;&#34;
                if fun is None:
                        return None
                delta = (tmax - tmin) / steps
                t = tmin

                curve = bpy.data.curves.new(&#39;myCurve&#39;, type=&#39;CURVE&#39;)
                curve.dimensions = &#39;3D&#39;
                curve.resolution_u = 2

                line = curve.splines.new(&#39;POLY&#39;)
                line.points.add(steps)

                for i in range(steps+1):
                        p = fun(t)
                        p.append(1)
                        line.points[i].co = p
                        t += delta

                obj = bpy.data.objects.new(name, curve)
                curve.bevel_depth = thickness

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
                self.scene.collection.objects.link(obj)
                return obj
        #
        #
        #
        def draw_curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,axis=False,zaxis=True,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0])):
                &#34;&#34;&#34;
                Draws a curve in a reference R&#39; determined by the origin o and basis {v1, v2, v3} constructed from u1 and u2
                Parameters:
                   fun: the parametric function

                   tmin: minimum value of the parameter

                   tmax: maximum value of the parameter

                   steps: number of steps

                   thickness: thickness of the curve

                   name: name of the curve

                   color: color of the curve

                   axis: if True draws the axis of the reference R&#39;

                   zaxis: if True draws the z&#39; axis

                   o: origin of the reference R&#39;

                   u1, u2: vectors to construct the basis {v1, v2, v3}
                &#34;&#34;&#34;
                if fun is None:
                        return None
                qt = self.vectors_to_quaternion(u1,u2)
                delta = (tmax - tmin) / steps
                t = tmin
                bm = bmesh.new()
                verts = []

                pmax = 0
                for k in range(steps + 1):
                        p = fun(t)
                        m = max(map(abs,p))
                        if m &gt; pmax:
                                pmax = m
                        verts.append(bm.verts.new(p))
                        t += delta
                        if t &gt; tmax:
                                t = tmax

                for i in range(len(verts) - 1):
                        bm.edges.new([verts[i], verts[i+1]])

                me = self.meshes.new(&#39;placeholder_mesh&#39;)
                obj = self.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()

                modifier = obj.modifiers.new(type=&#39;SKIN&#39;,name = &#39;skin&#39;)
                for v in obj.data.skin_vertices[0].data:
                        v.radius = (thickness,thickness)

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
                self.set_origin(o)
                self.set_rotation(quaternion=qt)
                if self.rotation is not None:
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                if axis:
                        self.draw_base_axis(axis = pmax+3,positive=False,name=&#34;Referència escollida&#34;,zaxis=zaxis)
                self.scene.collection.objects.link(obj)
                bpy.ops.object.shade_smooth()
                obj.location = o
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,axis=False,zaxis=True,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),symmetry=None,change=False):
                &#34;&#34;&#34;
                Draws a curve in a reference R&#39; determined by the origin o and basis {v1, v2, v3} constructed from u1 and u2 and
                the symmetric curve or curves from the parameter &#39;symmetry&#39;
                Parameters:
                   fun: the parametric function

                   tmin: minimum value of the parameter

                   tmax: maximum value of the parameter

                   steps: number of steps

                   thickness: thickness of the curve

                   name: name of the curve

                   color: color of the curve

                   axis: if True draws the axis of the reference R&#39;

                   zaxis: if True draws the z&#39; axis

                   o: origin of the reference R&#39;

                   u1, u2: vectors to construct the basis {v1, v2, v3}

                   symmetry: list of values in (&#39;XY&#39;,&#39;XZ&#39;,&#39;YZ&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;,&#39;O&#39;). For every value S, draw the symmetric curve respect to S

                   change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                if fun is None:
                        return None
                obj = self.draw_curve(fun,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=name,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)

                if symmetry is None:
                        if change:
                                self.set_origin(o)
                                self.set_base([u1,u2],orthonormal=True)
                        return obj
                objs = [obj]
                if isinstance(symmetry,str):
                        symmetry = [symmetry]
                elif not isinstance(symmetry,list) and not isinstance(symmetry,tuple):
                        if change:
                                self.set_origin(o)
                                self.set_base([u1,u2],orthonormal=True)
                        return obj
                for s in symmetry:
                        namem = name + s
                        if s == &#39;XY&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (p[0],p[1],-p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;XZ&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (p[0],-p[1],p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;YZ&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (-p[0],p[1],p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;X&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (p[0],-p[1],-p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;Y&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (-p[0],p[1],-p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;Z&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (-p[0],-p[1],p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;O&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (-p[0],-p[1],-p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                if change:
                        self.set_origin(o)
                        self.set_base([u1,u2],orthonormal=True)
                return self.join(objs)
        #
        #
        #
        def draw_circle(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),axis=False,zaxis=False,radius=1,steps=25,thickness=0.01,name=&#34;Circle&#34;,color=&#34;White&#34;,change=False):
                &#34;&#34;&#34;
                Draws a circle of center &#39;center&#39; and radius &#39;radius&#39; in the plane determined by vectors u1 and u2
                Parameters:
                   center: center of the circle

                   u1, u2: vectors to construct the basis {v1, v2, v3}

                   axis: if True draws the axis of the reference R&#39;

                   zaxis: if True draws the z&#39; axis

                   radius: radius of the circle

                   steps: number of steps

                   thickness: thickness of the curve

                   name: name of the curve

                   color: color of the curve

                   change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                if change:
                        self.set_origin(center)
                        self.set_base([u1,u2],orthonormal=True)
                return self.draw_curve(lambda t: (radius*math.cos(t),radius*math.sin(t),0),tmin=0.0,tmax=2*math.pi,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
        #
        #
        #
        def draw_ellipse(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,b=1,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Ellipse&#34;,color=&#34;White&#34;,change=False):
                &#34;&#34;&#34;
                Draws an ellipse of center &#39;center&#39; and semi-axes a and b in the plane determined by vectors u1 and u2
                Parameters:
                   center: center of the ellipse

                   u1, u2: vectors to construct the basis {v1, v2, v3}

                   a, b: semi-axes of the ellipse

                   axis: if True draws the axis of the reference R&#39;

                   zaxis: if True draws the z&#39; axis

                   steps: number of steps

                   thickness: thickness of the curve

                   name: name of the curve

                   color: color of the curve

                   change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                if change:
                        self.set_origin(center)
                        self.set_base([u1,u2],orthonormal=True)
                return self.draw_curve(lambda t: (a*math.cos(t),b*math.sin(t),0),tmin=0.0,tmax=2*math.pi,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
        #
        #
        #
        def draw_parabola(self,vertex=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,xmax=3.0,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Parabola&#34;,color=&#34;White&#34;,change=False):
                &#34;&#34;&#34;
                Draws a parabola of vertex &#39;vertex&#39; of equation y&#39;=ax&#39;^2 in the reference {vertex; v1, v2, v3} determined by vectors u1 and u2
                Parameters:
                   vertex: vertex of the parabola

                   u1, u2: vectors to construct the basis {v1, v2, v3}

                   a: coefficient of the parabola

                   xmax: maximum value of x&#39;

                   axis: if True draws the axis of the reference R&#39;

                   zaxis: if True draws the z&#39; axis

                   steps: number of steps

                   thickness: thickness of the curve

                   name: name of the curve

                   color: color of the curve

                   change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                if change:
                        self.set_origin(vertex)
                        self.set_base([u1,u2],orthonormal=True)
                return self.draw_curve(lambda t: (t,a*t**2,0),tmin=-xmax,tmax=xmax,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=vertex,u1=u1,u2=u2)
        #
        #
        #
        def draw_hyperbole(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,b=1,ymax=3.0,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Hyperbole&#34;,color=&#34;White&#34;,change=False):
                &#34;&#34;&#34;
                Draws an hyperbole of center &#39;center&#39; and semi-axes a and b in the plane determined by vectors u1 and u2
                Parameters:
                   center: center of the hyperbole

                   u1, u2: vectors to construct the basis {v1, v2, v3}

                   a, b: semi-axes of the hyperbole

                   ymax: maximum value of the y&#39;

                   axis: if True draws the axis of the reference R&#39;

                   zaxis: if True draws the z&#39; axis

                   steps: number of steps

                   thickness: thickness of the curve

                   name: name of the curve

                   color: color of the curve

                   change: if True, set the reference self.origin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                c1 = self.draw_curve(lambda t: (a*math.sqrt(1+t**2/b**2),t,0),tmin=-ymax,tmax=ymax,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
                c2 = self.draw_curve(lambda t: (-a*math.sqrt(1+t**2/b**2),t,0),tmin=-ymax,tmax=ymax,axis=False,zaxis=False,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
                self.join([c1,c2])
                if change:
                        self.set_origin(center)
                        self.set_base([u1,u2],orthonormal=True)
                return c1
        #
        #
        #
        def draw_surface(self,eq=None,umin=-1,umax=1,usteps=64,vmin=-1,vmax=1,vsteps=64,thickness=0.02,opacity=1.0,pmax=10,name=&#34;Surface&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),wrap_u=False,wrap_v=False,close_v=False):
                &#34;&#34;&#34;
                Draws a parametric surface in the reference R&#39;
                Parameters:
                   eq: parametric equacion f(u,v)

                   umin: minimum value of u

                   umax: maximum value of u

                   usteps: steps in the u direction

                   vmin: minimum value of v

                   vmax: maximum value of v

                   vsteps: steps in the v direction

                   thickness: thickness of the surface

                   opacity: opacity of the surface

                   color: color of the surface

                   pmax: the principal axis are drawn between -cmax and cmax

                   name: name of the surface

                   color: color of the surface

                   axis: if True draw the axis of the reference {o, v1, v2, v3}

                   o: origin of the reference R&#39;

                   u1, u2: vectors to construct the basis {v1, v2, v3}

                   scale: scale coefficients

                   wrap_u: wrap the u coordinate

                   wrap_v: wrap the u coordinate

                   close_v: close the v coordinate
                &#34;&#34;&#34;
                if eq is None:
                        return

                q = self.vectors_to_quaternion(u1,u2)
                draw_parametric_surface(eq=eq,range_u_min=umin,range_u_max=umax,range_u_step=usteps,range_v_min=vmin,range_v_max=vmax,range_v_step=vsteps,name=name,wrap_u=wrap_u,wrap_v=wrap_v,close_v=close_v)

                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)
                obj.show_wire = False

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if self.rotation is not None:
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                if axis:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència escollida&#34;)

                bpy.ops.object.shade_smooth()
                obj.location = o
                obj.select_set(False)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_function(self,f=None,xmin=-3,xmax=3,xsteps=64,ymin=-3,ymax=3,ysteps=64,thickness=0.02,opacity=1.0,pmax=10,name=&#34;Function&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0])):
                &#34;&#34;&#34;
                Draws a function of two variables f(x,y) i the reference R&#39; = {o, v1, v2, v3}
                Parameters:
                   f: the function of two variables f(x,y)

                   xmin: minimum value of x

                   xmax: maximum value of x

                   xsteps: steps in the x direction

                   ymin: minimum value of y

                   ymax: maximum value of y

                   ysteps: steps in the x direction

                   thickness: thickness of the surface

                   opacity: opacity of the surface

                   pmax: the axis are drawn between -pmax and pmax

                   name: name of the surface

                   color: color of the surface

                   axis: if True the axis of the reference R&#39; are drawn

                   o: origin of the reference R&#39;

                   u1, u2: vectors to construct the basis {v1, v2, v3}
                &#34;&#34;&#34;
                if f is None:
                        return None
                return self.draw_surface(eq=lambda x,y:(x,y,f(x,y)),umin=xmin,umax=xmax,usteps=xsteps,vmin=ymin,vmax=ymax,vsteps=ysteps,thickness=thickness,opacity=opacity,pmax=pmax,name=name,color=color,axis=axis,o=o,u1=u1,u2=u2,wrap_u=False,wrap_v=False,close_v=False)
        #
        #
        #
        def draw_vector_field(self,f=None,xmin=-3,xmax=3,xsteps=8,ymin=-3,ymax=3,ysteps=8,zmin=-3,zmax=3,zsteps=8,name=&#34;Vector Field&#34;,color=&#34;Red&#34;,scale=0.02,head_height=0.05):
                &#34;&#34;&#34;
                Draws a vector field
                Parameters:
                   f: the vector field

                   xmin: minimum value of x

                   xmax: maximum value of x

                   xsteps: steps in the x direction

                   ymin: minimum value of y

                   ymax: maximum value of y

                   ysteps: steps in the y direction

                   zmin: minimum value of z

                   zmax: maximum value of z

                   zsteps: steps in the z direction

                   name: name of the vector field

                   color: color of the vector field

                   scale: scale of the vectors

                   head_height: head height of the vectors
                &#34;&#34;&#34;
                if f is None:
                        return None
                xstep = (xmax - xmin)/xsteps
                ystep = (ymax - ymin)/ysteps
                zstep = (zmax - zmin)/zsteps
                if xstep == 0 or ystep == 0 or zstep == 0:
                        return None
                vectors = []
                count = 1
                x = xmin
                while x &lt;= xmax:
                        y = ymin
                        while y &lt;= ymax:
                                z = zmin
                                while z &lt;= zmax:
                                        o = Vector([x,y,z])
                                        v = f(x,y,z)
                                        if not isinstance(v,Vector):
                                                v = Vector(v)
                                        self.set_origin(o)
                                        vec = self.draw_vector(v,color=color,name=f&#34;Vector{count}&#34;,scale=scale,head_height=head_height)
                                        if vec is not None:
                                                vectors.append(vec)
                                        z += zstep
                                        count += 1
                                y += ystep
                        x += xstep
                v = self.join(vectors)
                bpy.context.object.name = name
                return v
        #
        #
        #
        def revolution_surface(self,fun=None,tmin=0.0,tmax=1.0,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),pmax=0,steps=256,thickness=0.025,axis=&#39;Z&#39;,name=&#34;Revolution surface&#34;,color=&#34;AzureBlueDark&#34;):
                &#34;&#34;&#34;
                Draws a revolution surface from a curve in the reference R&#39;
                Parameters:
                   fun: parametric equacion of the curve

                   steps: number of steps

                   axis: axis of revolution. It must be &#39;X&#39;, &#39;Y&#39; or &#39;Z&#39;

                   o: origin of the reference R&#39;

                   u1, u2: vectors to construct the basis {v1, v2, v3}

                   pmax: the principal axis are drawn between -pmax and pmax

                   color: color of the surface
                &#34;&#34;&#34;
                if fun is None:
                        return None
                q = self.vectors_to_quaternion(u1,u2)
                obj = self.simple_curve(fun,tmin=tmin,tmax=tmax,steps=steps,name=name)
                m = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                m.levels = 4
                m.subdivision_type = &#39;SIMPLE&#39;
                m = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                m.thickness = thickness
                m.offset = 1.0
                m = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                m.angle = 2*math.pi
                m.steps = steps
                m.axis =  axis
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
                bpy.context.scene.collection.objects.link(obj)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if self.rotation is not None:
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                if pmax &gt; 0.0:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència R&#39;&#34;)
                bpy.ops.object.shade_smooth()
                obj.location = o
                obj.select_set(False)
                bpy.context.view_layer.objects.active = None
        #
        #
        #
        def animate_revolution_surface(self,fun=None,tmin=0.0,tmax=1.0,steps=256,curvethicknes=0.025,thickness=0.025,frames=3,angle=3,radians=False,axis=&#39;Z&#39;,symmetry=None,name=&#34;Revolution surface&#34;,color=&#34;AzureBlueDark&#34;,point=None):
                &#34;&#34;&#34;
                Draws and animates a revolution surface from a curve
                Parameters:
                   fun: parametric equacion of the curve

                   steps: number of steps to graw the curve

                   curvethicknes: thickness of the curve

                   frames: number of frames at each step of revolution

                   angle: step angle of the revolution

                   radians: if True, angle must be in radians

                   axis: axis of revolution. It must be &#39;X&#39;, &#39;Y&#39; or &#39;Z&#39;

                   symmetry: symmetry used to draw the curve

                   name: name of the surface

                   color: color of the surface

                   point: if not None draw three points and a cercle. Must be a float between tmax and tmin
                &#34;&#34;&#34;
                if radians:
                        angle *= 180/math.pi
                stepsr = int(360/angle) + 1
                angle = 360/stepsr
                if fun is None:
                        return None
                if axis == &#39;X&#39;:
                        r = Rotation(angle,Vector([1,0,0]))
                        d1 = Vector([0,1,0])
                        d2 = Vector([0,0,1])
                elif axis == &#39;Y&#39;:
                        r = Rotation(angle,Vector([0,1,0]))
                        d1 = Vector([0,0,1])
                        d2 = Vector([1,0,0])
                elif axis == &#39;Z&#39;:
                        r = Rotation(angle,Vector([0,0,1]))
                        d1 = Vector([1,0,0])
                        d2 = Vector([0,1,0])
                else:
                        return None

                if point is not None:
                        try:
                                tp = 1.0 * point
                        except:
                                pass
                        if not isinstance(tp,float):
                                return None
                        if tp &lt; tmin or tp &gt; tmax:
                                tp = random.uniform(tmin,tmax)
                        zp = Vector(fun(tp))
                        e = d1.cross(d2)
                        z0 = zp.project(e)

                p2 = self.curve(fun,tmin=tmin,tmax=tmax,steps=steps,thickness=curvethicknes,color=&#34;Red&#34;,symmetry=symmetry,name=&#34;Rotating curve&#34;)
                p1 = self.curve(fun,tmin=tmin,tmax=tmax,steps=steps,thickness=1.05*curvethicknes,color=&#34;Blue&#34;,symmetry=symmetry,name=&#34;Curve&#34;)
                obj = self.simple_curve(fun,tmin=tmin,tmax=tmax,steps=steps,name=&#34;Surface of revolution&#34;,symmetry=symmetry)
                if point is not None:
                        m1 = self.draw_point(radius=0.1,location=zp,name=&#34;Punt p0&#34;,color=&#34;Red&#34;)
                        m2 = self.draw_point(radius=0.1,location=zp,name=&#34;Punt p1&#34;,color=&#34;Black&#34;)
                        m3 = self.draw_point(radius=0.1,location=z0,name=&#34;Punt p2&#34;,color=&#34;Blue&#34;)
                        l1 = self.draw_line(start=z0,end=zp,scale=0.04,name=&#34;Línia 1&#34;,color=&#34;Black&#34;)
                        l2 = self.draw_line(start=z0,end=zp,scale=0.03,name=&#34;Línia 2&#34;,color=&#34;Red&#34;)
                        self.draw_circle(center=z0,u1=d1,u2=d2,radius=(zp-z0).length,steps=128,thickness=0.005,name=&#34;Circle&#34;,color=&#34;Cyan&#34;)

                m = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                m.levels = 4
                m.subdivision_type = &#39;SIMPLE&#39;
                m = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                m.thickness = thickness
                m.offset = 1.0
                m = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                m.angle = 0.0
                m.steps = steps
                m.axis =  axis
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
                bpy.context.scene.collection.objects.link(obj)

                bpy.context.scene.frame_set(self.frame)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                obj.keyframe_insert(data_path=&#39;modifiers[&#34;Screw&#34;].angle&#39;,index=-1)
                p2.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if point is not None:
                        l1.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        m2.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn = frames + self.frame
                for i in range(0,stepsr):
                        bpy.context.scene.frame_set(fn)
                        p2.rotation_quaternion.rotate(r.quaternion)
                        p2.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        obj.modifiers[&#34;Screw&#34;].angle = 2 * (i+1) * math.pi / stepsr
                        obj.modifiers[&#34;Screw&#34;].steps = i+1
                        obj.keyframe_insert(data_path=&#39;modifiers[&#34;Screw&#34;].angle&#39;,index=-1)
                        if point is not None:
                                l1.rotation_quaternion.rotate(r.quaternion)
                                l1.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                                m2.location.rotate(r.quaternion)
                                m2.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames
                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()
        #
        #
        #
        def rotate_object(self,obj=None,axis=&#39;Z&#39;,frames=1,origin=Vector([0,0,0]),localaxis=None,localangle=None,helicoidal=0.0,rounds=1,draw=True):
                &#34;&#34;&#34;
                Rotates an object around the axis
                Parameters:
                   obj: the object

                   axis: it must be &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39; or a Vector

                   local: if True the center of rotation is the location of the object
                &#34;&#34;&#34;
                if obj is None:
                        return None
                if not isinstance(origin,Vector):
                        origin = Vector(origin)
                if isinstance(axis,str):
                        axis = axis.strip().upper()
                if axis == &#39;X&#39;:
                        u = Vector([1,0,0])
                elif axis == &#39;Y&#39;:
                        u = Vector([0,1,0])
                elif axis == &#39;Z&#39;:
                        u = Vector([0,0,1])
                elif isinstance(axis,Vector):
                        u = axis
                else:
                        u = Vector(axis)

                line = None
                if localaxis is not None and localangle is not None:
                        old = self.origin
                        self.set_origin(obj.location)
                        l = obj.dimensions.length / 2
                        line = self.draw_vector(localaxis,axis=l,scale=0.1,arrow=False,positive=False,color=&#34;Orange&#34;,name=&#34;Eix rotació local&#34;)
                        line.select_set(True)
                        bpy.ops.object.origin_set(type=&#39;ORIGIN_CENTER_OF_MASS&#39;, center=&#39;MEDIAN&#39;)
                        line.select_set(False)
                        self.set_origin(old)
                        lr = Rotation(localangle,localaxis)
                if draw:
                        self.set_origin(origin)
                        self.draw_vector(u,axis=15/u.length,positive=False,color=&#34;White&#34;)
                        self.set_origin()
                r = Rotation(1/int(frames),u)
                axis, angle = r.to_axis_angle()
                t = helicoidal * axis
                bpy.context.scene.frame_set(self.frame)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn = self.frame + 1
                for i in range(int(frames) * int(rounds) * 360):
                        bpy.context.scene.frame_set(fn)
                        if line is None:
                                obj.rotation_quaternion.rotate(r.quaternion)
                        else:
                                obj.rotation_quaternion.rotate(lr.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        w = obj.location - origin
                        w.rotate(r.quaternion)
                        obj.location = origin + w + t
                        if line is not None:
                                line.location = origin + w + t
                                line.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += 1
                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()
        #
        #
        #
        def rotate_vector(self,vector=None,axis=&#39;Z&#39;):
                &#34;&#34;&#34;
                Rotates a vector around the axis
                Parameters:
                   vector: the vector

                   axis: it must be &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39; or a vector
                &#34;&#34;&#34;
                draw = False
                if vector is None:
                        return None
                if axis == &#39;X&#39;:
                        u = Vector([1,0,0])
                elif axis == &#39;Y&#39;:
                        u = Vector([0,1,0])
                elif axis == &#39;Z&#39;:
                        u = Vector([0,0,1])
                elif isinstance(axis,Vector):
                        u = axis
                else:
                        u = Vector(axis)

                self.draw_vector(vector,color=&#34;Black&#34;)
                obj = self.draw_vector(vector,color=&#34;Red&#34;)
                w1 = u.orthogonal().normalized()
                vec1 = vector.project(u)
                w3 = vec1.normalized()
                w2 = w3.cross(w1)
                a = vec1.length
                b = (vector-vec1).length
                p2 = b**2/a**2
                self.rotate_object(obj,u)
                self.cone(u1=w1,u2=w2,a2=p2,b2=p2,c2=1,half=True, principal=False,canonica=False,xmax=b,color=&#34;GrayLight&#34;,opacity=0.2)
        #
        #
        #
        def rotate_object_by_axis_angle(self,obj=None,axis=Vector([1,0,0]),angle=90,amax=15,frames=1,scaleaxis=0.075,local=False):
                &#34;&#34;&#34;
                Rotates an object around an angle &#39;angle&#39; around the axis
                Parameters:
                   obj: the object

                   axis: any non nul Vectors

                   angle: the angle of rotation in degrees

                   frames: increment of the frame set

                   scaleaxis: scale value for draw_base_axis

                   local: if True the center of rotation is the location of the object
                &#34;&#34;&#34;
                if obj is None:
                        return None
                if isinstance(axis,Vector):
                        u = axis
                else:
                        u = Vector(axis)
                if u.length == 0.0 or angle &lt;= 1:
                        return

                self.draw_base_axis(axis = amax,scale=scaleaxis,positive=False,name=&#34;Base canònica&#34;)
                self.draw_vector(u,scale=0.1,axis=amax,positive=False,color=&#34;Black&#34;,name=&#34;Eix rotació&#34;)

                num = int(angle)
                alfa = angle / num
                r = Rotation(alfa,u)
                bpy.context.scene.frame_set(self.frame)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if not local:
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn = frames + self.frame

                for i in range(num):
                        bpy.context.scene.frame_set(fn)
                        obj.rotation_quaternion.rotate(r.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if not local:
                                w = obj.location
                                w.rotate(r.quaternion)
                                obj.location = w
                                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames
                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()
        #
        #
        #
        def rotate_euler(self,obj=None,psi=0.0,theta=0.0,phi=0.0,frames=3,axis=&#39;ZXZ&#39;,amax=15,scaleaxis=0.075,reverse=False,local=False,radians=False,canonica=True,positive=False):
                &#34;&#34;&#34;
                Rotates an object by the Euler angles psi, theta and phi
                Parameters:
                   object: the object

                   psi, theta, phi: the Euler angles expressed in degrees

                   axis: it must be &#39;XYZ&#39;, &#39;XZY&#39;, &#39;YXZ&#39;, &#39;YZX&#39;, &#39;ZXY&#39;, &#39;ZYX&#39;, &#39;XYX&#39;, &#39;XZX&#39;, &#39;YXY&#39;, &#39;YZY&#39;, &#39;ZXZ&#39; or &#39;ZYZ&#39;

                   amax: axis valur for draw_base_axis

                   scaleaxis: scale value for draw_base_axis

                   local: if True the center of rotation is the location of the object

                   radians: if True, psi, theta and phi must be in radians

                   positive: if False and psi, theta or phi are greather than 180 degrees, they rae converted
                             to negative angles
                &#34;&#34;&#34;
                def vector_from_axis(axis):
                        if axis == &#39;X&#39;:
                                return Vector([1,0,0])
                        if axis == &#39;Y&#39;:
                                return Vector([0,1,0])
                        if axis == &#39;Z&#39;:
                                return Vector([0,0,1])
                        return None

                if obj is None or axis is None:
                        return None

                if not isinstance(axis,str):
                        return None

                axis = axis.upper()
                if axis not in (&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,&#39;XYX&#39;,&#39;XZX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;):
                        return None

                u1 = vector_from_axis(axis[0])
                u2 = vector_from_axis(axis[1])
                u3 = vector_from_axis(axis[2])

                if radians:
                        psi *= 180/math.pi
                        theta *= 180/math.pi
                        phi *= 180/math.pi
                if positive:
                        if psi &lt; 0.0:
                                psi += 360
                        if theta &lt; 0.0:
                                theta += 360
                        if phi &lt; 0.0:
                                phi += 360
                else:
                        if psi &gt; 180.0:
                                psi -= 360
                        if theta &gt; 180.0:
                                theta -= 360
                        if phi &gt; 180.0:
                                phi -= 360

                if reverse:
                        self.set_colors([&#34;OrangeRedDark&#34;,&#34;Yellow&#34;,&#34;Magenta&#34;])
                        axis = self.draw_base_axis(axis=amax,scale=scaleaxis,positive=False,name=&#34;Eixos transformats&#34;)
                        obj = self.join([obj,axis])
                        u1, u2, u3 = u3, u2, u1
                        psi, theta, phi = phi, theta, psi
                        s = Rotation(psi,u1)
                        u2 = s.apply(u2)
                        u3 = s.apply(u3)
                        s = Rotation(theta,u2)
                        u3 = s.apply(u3)
                elif canonica:
                        self.draw_base_axis(axis=amax,scale=scaleaxis,positive=False,name=&#34;Base canònica&#34;)

                bpy.context.scene.frame_set(self.frame)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if not local:
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn = frames + self.frame
                if psi &gt; 0:
                        num = int(psi)
                elif psi &lt; 0:
                        num = int(-psi)
                alfa = psi / num
                r = Rotation(alfa,u1)
                for i in range(num):
                        bpy.context.scene.frame_set(fn)
                        obj.rotation_quaternion.rotate(r.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if not local:
                                w = obj.location
                                w.rotate(r.quaternion)
                                obj.location = w
                                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames

                if theta &gt; 0:
                        num = int(theta)
                elif theta &lt; 0:
                        num = int(-theta)
                alfa = theta / num
                r = Rotation(alfa,u2)
                for i in range(num):
                        bpy.context.scene.frame_set(fn)
                        obj.rotation_quaternion.rotate(r.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if not local:
                                w = obj.location
                                w.rotate(r.quaternion)
                                obj.location = w
                                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames

                if phi &gt; 0:
                        num = int(phi)
                elif phi &lt; 0:
                        num = int(-phi)
                alfa = phi / num
                r = Rotation(alfa,u3)
                for i in range(num):
                        bpy.context.scene.frame_set(fn)
                        obj.rotation_quaternion.rotate(r.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if not local:
                                w = obj.location
                                w.rotate(r.quaternion)
                                obj.location = w
                                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames

                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()
        #
        #
        #
        def draw_frenet_curve(self,fun=None,var=None,tmin=0.0,tmax=1.0,radius=0.1,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,point=True,tangent=False,acceleration=False,normal=False,osculator=False,frenet=False,units=False,sizex=8,sizey=8,axis=10):
                &#34;&#34;&#34;
                Draws a curve and diferents elements related to the curve
                Parameters:
                   fun: the parametric function

                   var = parameter variable of the function fun

                   tmin: minimum value of the parameter

                   tmax: maximum value of the parameter

                   radius: radius of the point

                   steps: number of steps

                   frames: increment of the frame set

                   thickness: thickness of the curve

                   name: name of the curve

                   color: color of the curve

                   point: if True draw a point along the curve

                   tangent: if True draw the tangent vector along the curve

                   acceleration: if True draw the acceleration vector along the curve

                   normal: if True draw the normal vector along the curve

                   osculator: if True draw the osculating plane along the curve

                   frenet: if True draw the Frenet trihedron along the curve

                   units: if True normalize the tangent and normal vectors

                   sizex, sizey: sizes of the osculating plane

                   axis: length of the coordinate axis
                &#34;&#34;&#34;
                if fun is None:
                        return None

                self.draw_base_axis(axis=axis,positive=False)

                def _fun_(x):
                        return [u.subs(var,x) for u in fun]

                def frenet_quaternion(tangent,normal):
                        v1 = tangent.normalized()
                        v2 = normal.normalized()
                        v3 = v1.cross(v2)
                        return Matrix([v1,v2,v3]).transposed().to_quaternion()

                frames = 1
                curve = self.draw_curve(_fun_,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,color=color,axis=False)
                if not point and not tangent and not osculator and not frenet:
                        return curve

                T = [diff(u,var) for u in fun]
                Tnorm = sqrt(sum([u**2 for u in T]))
                A = [diff(u,var) for u in T]
                p0 = Vector([u.subs(var,tmin) for u in fun])
                v0 = Vector([N(u.subs(var,tmin)) for u in T])
                a0 = Vector([N(u.subs(var,tmin)) for u in A])
                n0 = a0 - a0.project(v0)
                q0 = frenet_quaternion(v0,n0)
                f0 = [Vector([1,0,0]),Vector([0,1,0]),Vector([0,0,1])]

                if units:
                        v0.normalize()
                        n0.normalize()
                bpy.context.scene.frame_set(self.frame)

                if point:
                        p = self.draw_point(radius=radius,location=p0,name=&#34;Punt&#34;,color=&#34;Black&#34;)
                        p.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                self.set_origin(p0)
                if tangent:
                        l = v0.length
                        if not units:
                                vp = 5*v0.normalized()
                        else:
                                vp = v0
                        if not units:
                                v = self.draw_vector(vp,color=&#34;Red&#34;,scale=0.035,head_height=0.3)
                                v.scale.z *= l / 5.0
                        else:
                                v = self.draw_vector(vp,color=&#34;Red&#34;,scale=0.035,head_height=0.2)
                        v.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        v.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        v.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if acceleration:
                        l = a0.length
                        ap = 5*a0.normalized()
                        a = self.draw_vector(ap,color=&#34;Green&#34;,scale=0.035,head_height=0.2)
                        a.scale.z *= l / 5.0
                        a.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        a.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        a.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if normal:
                        l = n0.length
                        if not units:
                                np = 5*n0.normalized()
                        else:
                                np = n0
                        if not units:
                                n = self.draw_vector(np,color=&#34;Red&#34;,scale=0.035,head_height=0.2)
                                n.scale.z *= l / 5.0
                        else:
                                n = self.draw_vector(np,color=&#34;Red&#34;,scale=0.035,head_height=0.1)
                        n.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        n.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        n.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if osculator:
                        o = self.draw_plane_surface(base=[[1,0,0],[0,1,0]],color=&#34;GreenPaleDull&#34;,linecolor=&#34;GreenDarkDull&#34;,sizex=sizex,sizey=sizey,opacity=0.25)
                        o.rotation_quaternion = q0
                        o.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        o.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if frenet:
                        f = self.draw_vectors(f0,color=&#34;Red&#34;,scale=0.035,head_height=0.1)
                        f.rotation_quaternion = q0
                        f.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        f.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                self.set_origin()

                fn = frames + self.frame
                for i in range(steps):
                        bpy.context.scene.frame_set(fn)
                        x = tmin + (tmax - tmin)*i/steps
                        pos = Vector([u.subs(var,x) for u in fun])
                        v1 = Vector([N(u.subs(var,x)) for u in T])
                        a1 = Vector([N(u.subs(var,x)) for u in A])
                        n1 = a1 - a1.project(v1)
                        q1 = frenet_quaternion(v1,n1)
                        if point:
                                p.location = pos
                                p.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        if tangent:
                                if not units:
                                        r = v1.length / v0.length
                                        v.scale.z *= r
                                v.location = pos
                                v.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                v.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                                q = v0.rotation_difference(v1)
                                v.rotation_quaternion.rotate(q)
                                v.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if acceleration:
                                r = a1.length / a0.length
                                a.scale.z *= r
                                a.location = pos
                                a.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                a.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                                q = a0.rotation_difference(a1)
                                a.rotation_quaternion.rotate(q)
                                a.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if normal:
                                if not units:
                                        r = n1.length / n0.length
                                        n.scale.z *= r
                                n.location = pos
                                n.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                n.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                                q = n0.rotation_difference(n1)
                                n.rotation_quaternion.rotate(q)
                                n.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if osculator:
                                o.location = pos
                                o.rotation_quaternion = q1
                                o.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                o.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if frenet:
                                f.location = pos
                                f.rotation_quaternion = q1
                                f.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                f.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        v0 = v1.copy()
                        a0 = a1.copy()
                        n0 = n1.copy()
                        fn += frames
                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()
        #
        # Examples of use
        #
        def clear(self):
                &#34;&#34;&#34;
                Clears and removes all the elements
                &#34;&#34;&#34;
                self.reset()
                for obj in bpy.data.objects:
                        bpy.data.objects.remove(obj)
        #
        # Base canònica
        #
        def base_canonica(self,origin=Vector([0,0,0]),length=15,scale=0.04,zaxis=True,name=&#34;Base canònica&#34;):
                &#34;&#34;&#34;
                Draws the canonical base
                Parameters:
                   origin: point where to represent the base

                   length: length of the axis

                   scale: scale of the cylinder

                   zaxis: if False the z axis is not drawn

                   name: name of the object
                &#34;&#34;&#34;
                if not isinstance(origin,Vector):
                        origin = Vector(origin)
                self.set_origin(origin)
                self.draw_base_axis(axis=length,positive=False,scale=scale,zaxis=zaxis,name=name)
        #
        # Vector i base canònica
        #
        def vector_base_canonica(self,vector=Vector([-4,7,6]),length=12,name=&#34;Vector&#34;,components=True):
                &#34;&#34;&#34;
                Draws a vector expressed in the canonical base
                Parameters:
                   vector: the vector to draw

                   length: length of the axis

                   name: name of the vector

                   components: if True draws lines representing the components
                &#34;&#34;&#34;
                self.base_canonica(length=length)
                if not isinstance(vector,Vector):
                        vector = Vector(vector)
                self.draw_vector(vector,name=name)
                if components:
                        self.draw_components(vector,name=&#34;Components en base canònica&#34;)
        #
        # Base no canònica
        #
        def base_no_canonica(self,origin=Vector([0,0,0]),u1=Vector([1,-1,0]),u2=1/2*Vector([1,-1,-1]),u3=Vector([-1,0,1]),length=12,scale=0.04,name=&#34;Base B&#39;&#34;):
                &#34;&#34;&#34;
                Draws the base {u1,u2,u3} with origin in the point origin and sets the default
                origin and default base to them
                Parameters:
                        origin: origin of the vector and the base

                        u1, u2, u3: vectors of the base

                        length: length of the axis

                        scale: scale of the base

                        name: name of the base
                &#34;&#34;&#34;
                if not isinstance(origin,Vector):
                        origin = Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                if not isinstance(u3,Vector):
                        u3 = Vector(u3)
                self.set_origin(origin)
                self.set_base([u1,u2,u3])
                self.draw_base_axis(axis=length,positive=False,scale=scale,name=name)
        #
        # Vector en base no canònica
        #
        def vector_base_no_canonica(self,vector=Vector([5,6,-5]),origin=Vector([0,0,0]),u1=1/3*Vector([-1,-2,2]),u2=1/3*Vector([2,1,2]),u3=1/3*Vector([-2,2,1]),length=12,scale=0.04,name=&#34;Base B&#39;&#34;):
                &#34;&#34;&#34;
                Draws a vector expressed in the base {u1,u2,u3} with origin in the point origin and sets the default
                origin and default base to them
                Parameters:
                        vector: vector to draw

                        origin: origin of the vector and the base

                        u1, u2, u3: vectors of the base

                        length: length of the axis

                        scale: scale of the base

                        name: name of the base
                &#34;&#34;&#34;
                self.base_no_canonica(origin=origin,u1=u1,u2=u2,u3=u3,length=length,scale=scale,name=name)
                if not isinstance(vector,Vector):
                        vector = Vector(vector)
                self.draw_vector(vector,scale=0.06,head_height=0.25)
                self.draw_components(vector,scale=0.015,name=&#34;Components en base B&#39;&#34;)
        #
        # Canvi de base
        #
        def canvi_base(self,vector=Vector([8,-6,7]),u1=1/3*Vector([-1,-2,2]),u2=1/3*Vector([2,1,2]),u3=1/3*Vector([-2,2,1]),length=12):
                &#34;&#34;&#34;
                Draw the components of a vectors in the canonical base and in the base {u1,u2,u3}. Sets the default
                origin and default base to them
                Parameters:
                        vector: vector to draw

                        u1, u2, u3: vectors of the base

                        length: length of the axis
                &#34;&#34;&#34;
                self.vector_base_canonica(vector=vector,length=length)
                self.set_colors([&#34;Magenta&#34;,&#34;Yellow&#34;,&#34;Cyan&#34;])
                self.base_no_canonica(u1=u1,u2=u2,u3=u3,length=length)
                v = self.components_in_base(vector)
                self.draw_components(v,color=&#34;White&#34;,name=&#34;Components en la base B&#39;&#34;)
        #
        # Pla vectorial
        #
        def pla_vectorial(self,v1=Vector([3,2,1]),v2=Vector([1,-2,0.5]),canonica=False,length=15,color=&#34;Cyan&#34;,sizex=25,sizey=20,opacity=0.8):
                &#34;&#34;&#34;
                Draws the plane generated by two vectors
                Parameters:
                        v1, v2: generators of the plane

                        canonica: if True, draws the x, y and z axis

                        length: length of the axis x, y and z

                        color: color of the plane

                        sizex, sizey: size of the plane

                        opacicity: opacity of the plane
                &#34;&#34;&#34;
                if canonica:
                        self.base_canonica(length=length)
                self.draw_vectors([v1,v2],color=&#34;Blue&#34;)
                self.draw_plane_surface(base=[v1,v2],color=color,sizex=sizex,sizey=sizey,opacity=opacity)
        #
        # Pla afí
        #
        def pla_afi(self,punt=Vector([0,0,0]),v1=Vector([3,2,1]),v2=Vector([1,-2,0.5]),canonica=False,name=&#34;Pla afí&#34;,length=15,color=&#34;Cyan&#34;,sizex=25,sizey=20,opacity=0.8,elements=True):
                &#34;&#34;&#34;
                Draws the affine plane generated by two vectors passing through a point
                Parameters:
                        punt: point of the plane

                        v1, v2: generators of the plane

                        canonica: if True, draws the x, y and z axis

                        name: name of the affine plane

                        length: length of the axis x, y and z

                        color: color of the plane

                        sizex, sizey: size of the plane

                        opacicity: opacity of the plane
                &#34;&#34;&#34;
                if canonica:
                        self.base_canonica(length=length)
                self.draw_plane_surface(origin=punt,base=[v1,v2],color=color,sizex=sizex,sizey=sizey,name=name,opacity=opacity)
                if elements:
                        self.set_origin(punt)
                        self.draw_point(color=&#34;Blue&#34;)
                        self.draw_vectors([v1,v2],color=&#34;Blue&#34;)
                        self.set_origin()
        #
        # Projecció ortogonal i simètric sobre un pla vectorial
        #
        def projeccio_ortogonal_simetric_pla_vectorial(self,vector=Vector([7,-1,12]),v1=Vector([3,-1,1]),v2=Vector([1,0.5,0.5]),canonica=True):
                &#34;&#34;&#34;
                Draws the otoghonal projection and the symmetric of a vector with respecte a plane
                Parameters:
                        vector: the initial vector

                        v1, v2: generators of the plane

                        canonica: if True, draws the x, y and z axis
                &#34;&#34;&#34;
                if not isinstance(vector,Vector):
                        vector = Vector(vector)
                if not isinstance(v1,Vector):
                        v1 = Vector(v1)
                if not isinstance(v2,Vector):
                        v2 = Vector(v2)
                self.draw_vector(vector)
                w = v1.cross(v2)
                vp = vector - vector.project(w)
                self.draw_vector(vp,color=&#34;Red&#34;)
                self.pla_vectorial(v1,v2,sizex=3*vp.length,sizey=2.6*vp.length,canonica=canonica)
                self.set_origin(vp)
                self.draw_vector(vector.project(w),scale=0.025,color=&#34;White&#34;)
                self.set_origin()
                self.set_base([v1,v2,w])
                vb = self.components_in_base(vector)
                self.set_base()
                p1 = vb.x * v1
                p2 = vb.y * v2
                self.draw_line(start=[0,0,0],end=p1,scale=0.04,color=&#34;Blue&#34;)
                self.draw_line(start=[0,0,0],end=p2,scale=0.04,color=&#34;Blue&#34;)
                self.draw_line(start=vp,end=p1,scale=0.04,color=&#34;Blue&#34;)
                self.draw_line(start=vp,end=p2,scale=0.04,color=&#34;Blue&#34;)
                self.draw_vector(2 * vp - vector,color=&#34;Green&#34;)
                self.draw_line(start=2 * vp - vector,end=vp,scale=0.04,color=&#34;White&#34;)
        #
        # Projecció ortogonal i simètric d&#39;un punt sobre un pla afí
        #
        def projeccio_ortogonal_simetric_pla_afi(self,punt=Vector([6,-5,8]),p0=Vector([3,-2,-3]),v1=Vector([3,-1,1]),v2=Vector([1,0.5,0.5]),radi=0.15,sizex=35,sizey=30,canonica=True):
                &#34;&#34;&#34;
                Draws the orthogonal projection and the symmetric of a point with respect an affine plane
                Parameters:
                        punt: the initial point

                        p0: point of the affine plane

                        v1, v2: generators of the plane

                        radi: radius of the points

                        sizex, sizey: sizes of the affine plane

                        canonica: if True, draws the x, y and z axis
                &#34;&#34;&#34;
                if not isinstance(punt,Vector):
                        punt = Vector(punt)
                if not isinstance(p0,Vector):
                        p0 = Vector(p0)
                if not isinstance(v1,Vector):
                        v1 = Vector(v1)
                if not isinstance(v2,Vector):
                        v2 = Vector(v2)
                self.draw_point(location=punt,color=&#34;Black&#34;,radius=radi)
                w = v1.cross(v2)
                self.pla_afi(punt=p0,v1=v1,v2=v2,sizex=sizex,sizey=sizey,canonica=canonica)
                u = punt - p0
                up = punt - u.project(w)
                self.draw_point(location=up,color=&#34;Red&#34;,radius=radi)
                us = punt - 2*u.project(w)
                self.draw_point(location=us,color=&#34;Green&#34;,radius=radi)
                u = punt - up
                self.draw_line(start=up-1.5*u,end=up+1.5*u,scale=0.04,color=&#34;White&#34;)
        #
        # Projecció ortogonal i simètric d&#39;un punt sobre una recta afí
        #
        def projeccio_ortogonal_simetric_recta_afi(self,punt=Vector([6,-5,8]),p0=Vector([3,-2,-3]),v1=Vector([3,-1,1]),scale=0.1,radi=0.15,canonica=True):
                &#34;&#34;&#34;
                Draws the orthogonal projection and the symmetric of a point with respect an affine line
                Parameters:
                        punt: the initial point

                        p0: point of the affine line

                        v1: generator of the line

                        radi: radius of the points

                        canonica: if True, draws the x, y and z axis
                &#34;&#34;&#34;
                self.draw_point(location=p0,color=&#34;Blue&#34;,radius=radius,name=&#34;Punt de la recta&#34;)
                self.set_origin(p0)
                self.draw_vector(vector=v1,canonica=canonica,scale=scale,head_height=0.15,axis=20,name=&#34;Recta afí&#34;,color=&#34;Blue&#34;,positive=False)
                self.set_origin()
                self.draw_point(location=punt,color=&#34;Black&#34;,radius=radi,name=&#34;Punt inicial&#34;)
                u = punt - p0
                p1 = p0 + u.project(v1)
                size = 4 * (p1-p0).length
                if size &lt; 20:
                        size = 20
                self.draw_point(location=p1,color=&#34;Red&#34;,radius=radi,name=&#34;Projecció ortogonal&#34;)
                self.draw_plane_surface(origin=p1,normal=v1,name=&#34;Pla perpendicular a la recta&#34;,sizex=size,sizey=size)
                self.draw_point(location=2*p1-punt,color=&#34;Green&#34;,radius=radi,name=&#34;Simètric&#34;)
                self.draw_line(start=punt,end=2*p1-punt,scale=0.04,color=&#34;White&#34;)
        #
        # Projecció ortogonal i simètric sobre una recta vectorial
        #
        def projeccio_ortogonal_simetric_recta_vectorial(self,vector=Vector([7,-1,12]),v1=Vector([3,-1,1]),canonica=True):
                &#34;&#34;&#34;
                Draws the otoghonal projection and the symmetric of a vector with respecte a line
                Parameters:
                        vector: the initial vector

                        v1: generator of the line

                        canonica: if True, draws the x, y and z axis
                &#34;&#34;&#34;
                if not isinstance(vector,Vector):
                        vector = Vector(vector)
                if not isinstance(v1,Vector):
                        v1 = Vector(v1)
                if canonica:
                        self.base_canonica()
                self.draw_vector(v1,axis=20,positive=False,color=&#34;Blue&#34;,scale=0.066)
                self.draw_vector(vector)
                vp = vector.project(v1)
                self.draw_vector(vp,color=&#34;Red&#34;)
                self.set_origin(vp)
                self.draw_vector(vector - vp,scale=0.025,color=&#34;White&#34;)
                self.set_origin()
                self.draw_vector(2 * vp - vector,color=&#34;Green&#34;)
                self.draw_line(start=2 * vp - vector,end=vp,scale=0.04,color=&#34;White&#34;)
        #
        # Referència canònica
        #
        def referencia_canonica(self,origin=Vector([0,0,0]),length=15,scale=0.04,zaxis=True,name=&#34;Referència canònica&#34;):
                &#34;&#34;&#34;
                Draws the canonical reference
                Parameters:
                   origin: point where to represent the base

                   length: length of the axis

                   scale: scale of the cylinder

                   zaxis: if False the z axis is not drawn

                   name: name of the object
                &#34;&#34;&#34;
                if not isinstance(origin,Vector):
                        origin = Vector(origin)
                self.set_origin(origin)
                self.draw_base_axis(axis=length,positive=False,scale=scale,zaxis=zaxis,name=name)
        #
        # Punt en referència canònica
        #
        def punt_referencia_canonica(self,punt=Vector([-4,7,6]),radius=0.1,length=12,name=&#34;Punt p&#34;,coordenades=True):
                &#34;&#34;&#34;
                Draws a point expressed in the canonical reference
                Parameters:
                   punt: the point to draw

                   length: length of the axis

                   name: name of the point

                   components: if True draws lines representing the coordinates
                &#34;&#34;&#34;
                self.base_canonica(length=length)
                if not isinstance(punt,Vector):
                        punt = Vector(punt)
                self.draw_point(location=punt,color=&#34;Black&#34;,radius=radius,name=name)
                if coordenades:
                        self.draw_components(punt,name=&#34;Coordenades en referència canònica&#34;)
        #
        # Referència no canònica
        #
        def referencia_no_canonica(self,origin=Vector([0,0,0]),u1=Vector([1,-1,0]),u2=1/2*Vector([-1,2,1]),u3=Vector([-1,0,1]),length=12,scale=0.04,name=&#34;Referència R&#39;&#34;):
                &#34;&#34;&#34;
                Draws the reference {o;u1,u2,u3} with origin in the point origin and sets the default
                origin and default base to them
                Parameters:
                        origin: origin of the reference

                        u1, u2, u3: vectors of the base

                        length: length of the axis

                        scale: scale of the axis

                        name: name of the reference
                &#34;&#34;&#34;
                if not isinstance(origin,Vector):
                        origin = Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                if not isinstance(u3,Vector):
                        u3 = Vector(u3)
                self.set_origin(origin)
                self.set_base([u1,u2,u3])
                self.draw_base_axis(axis=length,positive=False,scale=scale,name=name)
        #
        # Punt en referencia no canònica
        #
        def punt_referencia_no_canonica(self,punt=Vector([5,6,-5]),origin=Vector([-2,3,3]),u1=1/3*Vector([-1,-2,2]),u2=1/3*Vector([2,1,2]),u3=1/3*Vector([-2,2,1]),length=12,scale=0.04,radius=0.1,name=&#34;Punt p&#34;):
                &#34;&#34;&#34;
                Draws a point expressed in the reference {o,u1,u2,u3} with origin in the point origin and sets the default
                origin and default base to them
                Parameters:
                        punt: point to draw

                        origin: origin of the reference

                        u1, u2, u3: vectors of the base

                        length: length of the axis

                        scale: scale of the axis

                        name: name of the reference
                &#34;&#34;&#34;
                self.referencia_no_canonica(origin=origin,u1=u1,u2=u2,u3=u3,length=length,scale=scale,name=&#34;Referència R&#39;&#34;)
                if not isinstance(punt,Vector):
                        punt = Vector(punt)
                self.draw_point(location=punt,color=&#34;Black&#34;,radius=radius,name=name)
                self.draw_components(punt,scale=0.015,name=&#34;Coordenades en referència R&#39;&#34;)
        #
        # Canvi de coordenades
        #
        def canvi_coordenades(self,punt=Vector([8,-6,7]),origin=Vector([-2,3,3]),u1=1/3*Vector([-1,-2,2]),u2=1/3*Vector([2,1,2]),u3=1/3*Vector([-2,2,1]),length=12,radius=0.1):
                &#34;&#34;&#34;
                Draw the coordinates of a point in the canonical reference and in the reference {o;u1,u2,u3}. Sets the default
                origin and default base to them
                Parameters:
                        punt: point to draw

                        origin: origin of the reference

                        u1, u2, u3: vectors of the base

                        length: length of the axis
                &#34;&#34;&#34;
                self.punt_referencia_canonica(punt=punt,length=length,radius=radius)
                self.set_colors([&#34;Magenta&#34;,&#34;Yellow&#34;,&#34;Cyan&#34;])
                self.referencia_no_canonica(origin=origin,u1=u1,u2=u2,u3=u3,length=length)
                p = self.coordinates_en_referencia(punt)
                self.draw_components(p,color=&#34;White&#34;,name=&#34;Coordenades en la referència R&#39;&#34;)
        #
        # El·lipse
        #
        def ellipse(self,center=Vector([0,0,0]),a=8,b=5,canonica=True):
                &#34;&#34;&#34;
                Draws the ellipse of equation (x-x0)^2/a^2 + (y-y0)^2/b^2 == 1
                Parameters:
                        centre: center of the ellipse

                        a, b: semiaxis of the ellipse

                        canonica: if True, draws the x and y axis
                &#34;&#34;&#34;
                if len(center) == 2:
                        center = (center[0],center[1],0)
                if not isinstance(center,Vector):
                        center = Vector(center)
                if a &gt;= b:
                        c = sqrt(a**2 - b**2)
                        f1 = Vector([c,0,0])
                        f2 = Vector([-c,0,0])
                else:
                        c = sqrt(b**2 - a**2)
                        f1 = Vector([0,c,0])
                        f2 = Vector([0,-c,0])
                if canonica:
                        self.referencia_canonica(zaxis=False)
                self.draw_ellipse(center=center,a=a,b=b,thickness=0.02,steps=128,axis=False)
                self.draw_point(radius=0.167,location=(0,0,0),name=&#34;Centre&#34;,color=&#34;White&#34;)
                self.draw_point(radius=0.167,location=f1,name=&#34;F1&#34;,color=&#34;Black&#34;)
                self.draw_point(radius=0.167,location=f2,name=&#34;F2&#34;,color=&#34;Black&#34;)
                self.set_origin()
        #
        # Hipèrbola
        #
        def hiperbola(self,center=Vector([0,0,0]),a=8,b=5,negatiu=False,canonica=True):
                &#34;&#34;&#34;
                Draws the hyperbole of equation (x-x0)^2/a^2 - (y-y0)^2/b^2 == 1 (or -1)
                Parameters:
                        centre: center of the hyperbole

                        a, b: semiaxis of the hyperbole

                        canonica: if True, draws the x and y axis

                        negatiu: if True, draws the hyperbole (x-x0)^2/a^2 - (y-y0)^2/b^2 == -1
                &#34;&#34;&#34;
                if len(center) == 2:
                        center = (center[0],center[1],0)
                if not isinstance(center,Vector):
                        center = Vector(center)
                u1 = Vector([a,b,0])
                u2 = Vector([a,-b,0])
                c = sqrt(a**2 + b**2)
                f1 = [c,0,0]
                f2 = [-c,0,0]
                if canonica:
                        self.referencia_canonica(zaxis=False)
                v1 = Vector([1,0,0])
                v2 = Vector([0,1,0])
                if negatiu:
                        self.set_base(base=[[0,1,0],[-1,0,0],[0,0,1]])
                        v1 = Vector([0,1,0])
                        v2 = Vector([-1,0,0])
                        u1 = Vector([b,a,0])
                        u2 = Vector([b,-a,0])
                self.draw_hyperbole(center=center,u1=v1,u2=v2,a=a,b=b,ymax=14,thickness=0.02,steps=128,axis=False)
                self.draw_point(radius=0.167,location=(0,0,0),name=&#34;Centre&#34;,color=&#34;White&#34;)
                self.draw_point(radius=0.167,location=f1,name=&#34;F1&#34;,color=&#34;Black&#34;)
                self.draw_point(radius=0.167,location=f2,name=&#34;F2&#34;,color=&#34;Black&#34;)
                self.draw_line(start=-5*u1,end=5*u1,color=&#34;Blue&#34;,scale=0.03,name=&#34;Asímptota 1&#34;)
                self.draw_line(start=-5*u2,end=5*u2,color=&#34;Blue&#34;,scale=0.03,name=&#34;Asímptota 2&#34;)
                self.set_origin()
                self.set_base()
        #
        # Paràbola
        #
        def parabola(self,vertex=Vector([0,0,0]),p=5,xmax=15,eixos=&#39;XY&#39;,canonica=True):
                &#34;&#34;&#34;
                Draws the parabola of equation y - y0 = (x-x0)^2/(2*p) or x - x0 = (y-y0)^2/(2*p)
                Parameters:
                        vertex: vertex of the parabola

                        p: parameter of the parabola

                        pmax: maximum value of the independent variable

                        eixos: &#39;XY&#39;, draws y - y0 = (x-x0)^2/(2*p)
                                   &#39;YX&#39;, draws x - x0 = (y-y0)^2/(2*p)

                        canonica: if True, draws the x and y axis
                &#34;&#34;&#34;
                if len(vertex) == 2:
                        vertex = (vertex[0],vertex[1],0)
                if not isinstance(vertex,Vector):
                        vertex = Vector(vertex)
                f = [0,p/2,0]
                if canonica:
                        self.referencia_canonica(zaxis=False)
                u1 = Vector([1,0,0])
                u2 = Vector([0,1,0])
                if eixos == &#39;YX&#39; or eixos == &#39;yx&#39;:
                        self.set_base(base=[[0,1,0],[1,0,0],[0,0,-1]])
                        u1 = Vector([0,1,0])
                        u2 = Vector([1,0,0])
                self.draw_parabola(vertex=vertex,a=1/(2*p),u1=u1,u2=u2,xmax=xmax,thickness=0.02,steps=128,axis=False)
                self.reset_rotation()
                self.draw_point(radius=0.167,location=f,name=&#34;Focus&#34;,color=&#34;Black&#34;)
                self.draw_point(radius=0.167,location=(0,0,0),name=&#34;Vèrtex&#34;,color=&#34;White&#34;)
                self.draw_line(start=[-xmax-3,-p/2,0],end=[xmax+3,-p/2,0],color=&#34;Blue&#34;,scale=0.04,name=&#34;Recta directriu&#34;)
                self.set_origin()
                self.set_base()
        #
        # El·lipsoide de revolucio
        #
        def ellipsoide_revolucio(self,a=12,b=8,direccio=&#39;Z&#39;,punt=None):
                &#34;&#34;&#34;
                Draws an animation showing an ellipsoid of revolution
                        a, b: semiaxis of the initial ellipse

                        direccio: &#39;X&#39;, the initial ellipse is in the plane XZ and rotates around the X axis
                                          &#39;Y&#39;, the initial ellipse is in the plane YZ and rotates around the Y axis
                                          &#39;Z&#39;, the initial ellipse is in the plane ZX and rotates around the Z axis

                        punt: if it&#39;s a value between 0 and pi, the animation shows a rotating point
                &#34;&#34;&#34;
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        F = lambda t: (a*cos(t),0,b*sin(t))
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        F = lambda t: (0,a*cos(t),b*sin(t))
                else:
                        F = lambda t: (b*sin(t),0,a*cos(t))
                self.base_canonica()
                self.animate_revolution_surface(F,tmin=0,tmax=pi,steps=128,axis=direccio,point=punt)
        #
        # Hiperboloide d&#39;una fulla de revolució
        #
        def hiperboloide_una_fulla_revolucio(self,a=3,b=2,pmax=8,direccio=&#39;Z&#39;,punt=None):
                &#34;&#34;&#34;
                Draws an animation showing an one sheet hyperboloid of revolution
                        a, b: semiaxis of the initial hyperbole

                        pmax: maximum value of the independent variable

                        direccio: &#39;X&#39;, the initial hyperbole is in the plane XZ and rotates around the X axis
                                  &#39;Y&#39;, the initial hyperbole is in the plane YX and rotates around the Y axis
                                      &#39;Z&#39;, the initial hyperbole is in the plane ZX and rotates around the Z axis

                        punt: if it&#39;s a value between 0 and pi, the animation shows a rotating point
                &#34;&#34;&#34;
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        F = lambda t: (t,0,a*math.sqrt(1+t**2/b**2))
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        F = lambda t: (a*math.sqrt(1+t**2/b**2),t,0)
                else:
                        F = lambda t: (a*math.sqrt(1+t**2/b**2),0,t)
                self.base_canonica()
                self.animate_revolution_surface(F,tmin=-pmax,tmax=pmax,steps=128,axis=direccio,point=punt)
        #
        # Hiperboloide de dues fulles de revolució
        #
        def hiperboloide_dues_fulles_revolucio(self,a=3,b=2,pmax=8,direccio=&#39;Z&#39;,punt=None):
                &#34;&#34;&#34;
                Draws an animation showing a two sheet hyperboloid of revolution
                        a, b: semiaxis of the initial hyperbole

                        pmax: maximum value of the independent variable

                        direccio: &#39;X&#39;, the initial hyperbole is in the plane YX and rotates around the X axis
                                  &#39;Y&#39;, the initial hyperbole is in the plane ZY and rotates around the Y axis
                                      &#39;Z&#39;, the initial hyperbole is in the plane XZ and rotates around the Z axis

                        punt: if it&#39;s a value between 0 and pi, the animation shows a rotating point
                &#34;&#34;&#34;
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        s = &#39;Z&#39;
                        F = lambda t: (a*math.sqrt(1+t**2/b**2),t,0)
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        F = lambda t: (0,a*math.sqrt(1+t**2/b**2),t)
                        s = &#39;Z&#39;
                else:
                        F = lambda t: (t,0,a*math.sqrt(1+t**2/b**2))
                        s = &#39;X&#39;
                self.base_canonica()
                self.animate_revolution_surface(F,tmin=-pmax,tmax=pmax,steps=128,axis=direccio,symmetry=s,point=punt)
        #
        # Con de revolució
        #
        def con_revolucio(self,a=1.5,pmax=8,direccio=&#39;Z&#39;,punt=None):
                &#34;&#34;&#34;
                Draws an animation showing a cone of revolution
                        a: slope of the initial straight line

                        pmax: maximum value of the independent variable

                        direccio: &#39;X&#39;, the initial line is in the plane YX and rotates around the X axis
                                  &#39;Y&#39;, the initial line is in the plane ZY and rotates around the Y axis
                                      &#39;Z&#39;, the initial line is in the plane XZ and rotates around the Z axis

                        punt: if it&#39;s a value between -pmax and pmax, the animation shows a rotating point
                &#34;&#34;&#34;
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        F = lambda t: (a*t,t,0)
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        F = lambda t: (0,a*t,t)
                else:
                        F = lambda t: (t,0,a*t)
                self.base_canonica()
                self.animate_revolution_surface(F,tmin=-pmax,tmax=pmax,steps=128,axis=direccio,point=punt)
        #
        # Paraboloide el·líptic de revolució
        #
        def paraboloide_elliptic_revolucio(self,a=0.5,pmax=5,direccio=&#39;Z&#39;,punt=None):
                &#34;&#34;&#34;
                Draws an animation showing an elliptic paraboloid of revolution
                        a: The constant of the initial parabola

                        pmax: maximum value of the independent variable

                        direccio: &#39;X&#39;, the initial parabola is in the plane YX and rotates around the X axis
                                  &#39;Y&#39;, the initial parabola is in the plane ZY and rotates around the Y axis
                                      &#39;Z&#39;, the initial parabola is in the plane XZ and rotates around the Z axis

                        punt: if it&#39;s a value between -pmax and pmax, the animation shows a rotating point
                &#34;&#34;&#34;
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        F = lambda t: (a*t**2,t,0)
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        F = lambda t: (0,a*t**2,t)
                else:
                        F = lambda t: (t,0,a*t**2)
                self.base_canonica()
                self.animate_revolution_surface(F,tmin=0,tmax=pmax,steps=128,axis=direccio,point=punt)
        #
        # Paraboloide hiperbòlic
        #
        def paraboloide_hiperbolic_simple(self,a=3,b=4,xmax=12,ymax=12):
                &#34;&#34;&#34;
                Draws the hyperbolic paraboloid of equation z = x^2/a^2 - y^2/b^2
                Parameters:
                        a, b: constants the defines he hyperbolic paraboloid

                        xmax, ymax: maximun values of the x and y coordinates
                &#34;&#34;&#34;
                self.hyperbolic_paraboloid(a2=a**2,b2=b**2,xmax=xmax,ymax=ymax,canonica=True,principal=False)
        #
        # Cilindre el·líptic
        #
        def cilindre_elliptic_simple(self,a=10,b=6,direccio=&#39;Z&#39;,pmax=26):
                &#34;&#34;&#34;
                Draws an elliptic cylinder with direction X, Y or Z
                Parameters:
                        a, b: semiaxis of the ellipse

                        direction: direction of translation of the ellipse

                        pmax = height of the cylindrer
                &#34;&#34;&#34;
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        u1 = Vector([0,0,1])
                        u2 = Vector([0,1,0])
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        u1 = Vector([1,0,0])
                        u2 = Vector([0,0,1])
                else:
                        u1 = Vector([1,0,0])
                        u2 = Vector([0,1,0])
                self.elliptic_cylinder(a2=a**2,b2=b**2,u1=u1,u2=u2,zmax=pmax,canonica=True,principal=False)
                self.draw_ellipse(a=a,b=b,u1=u1,u2=u2,thickness=0.02,steps=128,axis=False)
                self.reset()
        #
        # Cilindre hiperbòlic
        #
        def cilindre_hiperbolic_simple(self,a=4,b=3,direccio=&#39;Z&#39;,pmax=12,hmax=26):
                &#34;&#34;&#34;
                Draws an hyperbolic cylinder with direction X, Y or Z
                Parameters:
                        a, b: semiaxis of the hyperbole

                        direction: direction of translation of the hyperbole

                        pmax = maximum value of the independent variable

                        hmax = height of the cylindrer
                &#34;&#34;&#34;
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        u1 = Vector([0,0,1])
                        u2 = Vector([0,1,0])
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        u1 = Vector([1,0,0])
                        u2 = Vector([0,0,1])
                else:
                        u1 = Vector([1,0,0])
                        u2 = Vector([0,1,0])
                self.hyperbolic_cylinder(a2=a**2,b2=b**2,u1=u1,u2=u2,xmax=pmax,zmax=hmax,canonica=True,principal=False)
                self.draw_hyperbole(a=a,b=b,u1=u1,u2=u2,thickness=0.02,ymax=b*math.sqrt(-1+(pmax/a)**2),steps=128,axis=False)
                self.reset()
        #
        # Cilindre parabòlic
        #
        def cilindre_parabolic_simple(self,a=3,direccio=&#39;Z&#39;,pmax=10,hmax=26):
                &#34;&#34;&#34;
                Draws a parabolic cylinder with direction X, Y or Z
                Parameters:
                        a: the initial parabola has equation of type z=\pm x^2/a^2

                        direction: direction of translation of the hyperbole

                        pmax = maximum value of the independent variable

                        hmax = height of the cylindrer
                &#34;&#34;&#34;
                if a == 0:
                        return
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        u1 = Vector([0,0,1])
                        u2 = Vector([0,-1,0])
                        v1 = Vector([0,0,1])
                        v2 = Vector([1,0,0])
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        u1 = Vector([1,0,0])
                        u2 = Vector([0,0,-1])
                        v1 = Vector([1,0,0])
                        v2 = Vector([0,1,0])
                else:
                        u1 = Vector([1,0,0])
                        u2 = Vector([0,1,0])
                        v1 = Vector([1,0,0])
                        v2 = Vector([0,0,1])
                s = 1
                if a &lt; 0:
                        s = -1
                self.parabolic_cylinder(a=a,u1=u1,u2=u2,xmax=pmax,canonica=True,principal=False)
                self.draw_parabola(a=s/a**2,u1=v1,u2=v2,thickness=0.02,xmax=pmax,steps=128,axis=False)
                self.reset()
        #
        # Esfera
        #
        def esfera(self,centre=Vector([0,0,0]),radi=10,cmax=20):
                &#34;&#34;&#34;
                Draws a sphere
                Parametre:
                        centre: center of the sphere

                        radi: radius of the sphere

                        cmax: maximum values of the x, y and z coordinates
                &#34;&#34;&#34;
                self.sphere(o=centre,r2=radi**2,canonica=True,principal=False,cmax=cmax)
        #
        # Tor
        #
        def tor(self,centre=Vector([8,0,3]),radi=3,punt=None):
                &#34;&#34;&#34;
                Draws a torus of revolution from a circumference
                Parameters:
                        centre: center of the circumference

                        radi: radius of the circumference

                        cmax: maximum values of the x, y and z coordinates

                        punt: if it&#39;s a float value, draws a moving poing
                &#34;&#34;&#34;
                self.base_canonica(length=cmax)
                if len(centre) == 2:
                        centre = (centre[0],0,centre[1])
                if not isinstance(centre,Vector):
                        centre = Vector(centre)
                def F(t):
                        return (centre + Vector([radi*math.cos(t),0,radi*math.sin(t)]))
                self.animate_revolution_surface(F,tmin=0,tmax=2*pi,steps=128,axis=&#39;Z&#39;,point=punt)
        #
        # Revolució d&#39;una paràbola que no és un paraboloide
        #
        def superficie_revolucio_parabola(self,a=0.2,vertex=Vector([0,0,0]),pmax=8,pla=&#39;XZ&#39;,punt=None):
                &#34;&#34;&#34;
                Draws an animation of a revolution surface from a paràbola
                Parameters:
                        a: the paràbola is of the form y = a*x^2

                        vertex: vertex of the parabola

                        pmax: maximum value of the independent variable

                        pla: a value from the list (&#39;XY&#39;,&#39;YX&#39;,&#39;XZ&#39;,&#39;ZX&#39;,&#39;YZ&#39;,&#39;ZY&#39;) representing
                             the variables for the equation
                                 &#39;XY&#39; y = a*x^2 and rotaqtion around the X axis
                                 &#39;YX&#39; x = a*y^2 and rotaqtion around the Y axis
                                 &#39;XZ&#39; z = a*x^2 and rotaqtion around the X axis
                                 &#39;ZX&#39; x = a*x^2 and rotaqtion around the Z axis
                                 &#39;YZ&#39; z = a*y^2 and rotaqtion around the Y axis
                                 &#39;ZY&#39; y = a*z^2 and rotaqtion around the Z axis

                        punt: punt: if it&#39;s a float value, draws a moving poing
                &#34;&#34;&#34;
                self.base_canonica()
                if not isinstance(vertex,Vector):
                        vertex = Vector(vertex)
                def F(t):
                        if pla.upper() == &#39;XZ&#39;:
                                return (vertex + Vector([t,0,a*t**2]))
                        if pla.upper() == &#39;XY&#39;:
                                return (vertex + Vector([t,a*t**2,0]))
                        if pla.upper() == &#39;ZX&#39;:
                                return (vertex + Vector([a*t**2,0,t]))
                        if pla.upper() == &#39;ZY&#39;:
                                return (vertex + Vector([0,a*t**2,t]))
                        if pla.upper() == &#39;YZ&#39;:
                                return (vertex + Vector([0,t,a*t**2]))
                        if pla.upper() == &#39;YX&#39;:
                                return (vertex + Vector([a*t**2,t,0]))
                self.animate_revolution_surface(F,tmin=-pmax,tmax=pmax,steps=128,axis=pla[0],point=punt)
        #
        # Rotació d&#39;un ortoedre
        #
        def rotacio_ortoedre(self,centre=Vector([0,0,0]),costats=Vector([8,5,4]),eix=&#39;Z&#39;,opacity=1):
                &#34;&#34;&#34;
                Draws an animation of an orthohedron rotating around a vectorial line
                Parameters:
                        centre: center of the orthohedron

                        costats: half sides of the orthohedron

                        eix: axis of rotation

                        opacity: opacity of the orthohedron
                &#34;&#34;&#34;
                self.base_canonica()
                if not isinstance(centre,Vector):
                        centre = Vector(centre)
                if not isinstance(costats,Vector):
                        costats = Vector(costats)
                ortoedre = self.draw_cube(origin=centre,scale=costats,color=&#34;AzureBlueDark&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Ortoedre&#34;)
                self.rotate_object(ortoedre,axis=eix,draw=False)
        #
        # Rotació d&#39;un vector
        #
        def rotacio_vector(self,vector=Vector([6,8,5]),eix=Vector([1,1,1])):
                &#34;&#34;&#34;
                Draws an animation of a vector rotating around a vectorial line
                Parameters:
                        vector: vector to rotate

                        eix: axis of rotation, given by a vector or by X, Y or Z
                &#34;&#34;&#34;
                self.base_canonica(length=vector.length + 2)
                self.rotate_vector(vector,eix)
        #
        # Rotació d&#39;un ortoedre a partir dels angles d&#39;Euler
        #
        def rotacio_ortoedre_angles_euler(self,centre=Vector([0,0,0]),costats=Vector([8,5,4]),psi=90,theta=60,phi=45,radians=False,opacity=1,eixos=&#39;zxz&#39;):
                &#34;&#34;&#34;
                Draws an animation of an orthohedron rotating given the Euler&#39;s angles
                Parameters:
                        centre: center of the orthohedron

                        costats: half sides of the orthohedron

                        psi, theta, phi: Euler&#39;s angles

                        radians: if True the Euler&#39;s angles must in radians. If False in degrees

                        opacity: opacity of the orthohedron

                        eixos: axis of the three rotations
                &#34;&#34;&#34;
                if not isinstance(centre,Vector):
                        centre = Vector(centre)
                if not isinstance(costats,Vector):
                        costats = Vector(costats)
                ortoedre = self.draw_cube(origin=centre,scale=costats,color=&#34;AzureBlueDark&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Ortoedre&#34;)
                self.rotate_euler(ortoedre,psi,theta,phi,radians=radians,axis=eixos)
        #
        # Rotació d&#39;un ortoedre al voltant d&#39;un eix i angles d&#39;Euler
        #
        def rotacio_ortoedre_voltant_vector(self,centre=Vector([0,0,0]),costats=Vector([8,5,4]),angle=80,radians=False,vector=Vector([1,-2,1]),opacity=0.7,euler=None,reverse=False):
                &#34;&#34;&#34;
                Draws an animation of a vector rotating around a vectorial line
                Parameters:
                        centre: center of the orthohedron

                        costats: half sides of the orthohedron

                        angle: angle of rotation

                        radians: if True the Euler&#39;s angles must in radians. If False in degrees

                        vector: generator of the vectorial line

                        opacity: opacity of the orthohedron

                        euler: None or the value of the three Euler&#39;s axis

                        reverse: if True, shows the rotation with Euler&#39;s angles in reverse order
                &#34;&#34;&#34;
                if not isinstance(centre,Vector):
                        centre = Vector(centre)
                if not isinstance(costats,Vector):
                        costats = Vector(costats)
                if not isinstance(vector,Vector):
                        vector = Vector(vector)
                ortoedre = self.draw_cube(origin=centre,scale=costats,color=&#34;AzureBlueDark&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Primer ortoedre&#34;)
                if euler is not None:
                        ortoedre2 = self.draw_cube(origin=centre,scale=costats,color=&#34;Green&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Segon ortoedre&#34;)
                self.rotate_object_by_axis_angle(obj=ortoedre,axis=vector,angle=angle,frames=3)
                if euler is not None:
                        R = Rotation(angle=angle,vector=vector)
                        psi, theta, phi = R.to_euler_angles(axis=euler)
                        self.rotate_euler(ortoedre2,psi=psi,theta=theta,phi=phi,axis=euler,canonica=False,reverse=reverse)
        #
        # Rotació afí i moviment helicoidal
        #
        def moviment_helicoidal_ortoedre(self,centre=Vector([0,0,0]),costats=Vector([3,4,2]),opacity=1,origen=Vector([4,3,0]),eix=&#39;Z&#39;,translacio=0.0):
                &#34;&#34;&#34;
                Draws an animation of the helical motion of an orthohedron around an affine line
                Parameters:
                        centre: center of the orthohedron

                        costats: half sides of the orthohedron

                        origen: point of the affine line

                        eix: axis of rotation

                        opacity: opacity of the orthohedron

                        translation: translation of the helical motion (distance by frame)
                                     if translation = 0.0, it&#39;s a rotation motion
                &#34;&#34;&#34;
                self.base_canonica()
                if not isinstance(centre,Vector):
                        centre = Vector(centre)
                if not isinstance(costats,Vector):
                        costats = Vector(costats)
                if not isinstance(origen,Vector):
                        origen = Vector(origen)
                ortoedre = self.draw_cube(origin=centre,scale=costats,color=&#34;AzureBlueDark&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Ortoedre&#34;)
                self.rotate_object(ortoedre,axis=eix,origin=origen,helicoidal=translacio)
        #
        # Gir en el pla d&#39;un poligon
        #
        def gir_poligon(self,centre=Vector([0,0,0]),costats=6,origen=Vector([0,0,0]),radi=8):
                &#34;&#34;&#34;
                Draws an animation of the rotation around a point of a polygon in the plane XY
                Parameters:
                        centre: center of the polygon

                        costats: sides of the polygon

                        origen: center of the rotation

                        radi: radius of the polygon
                &#34;&#34;&#34;
                if len(centre) == 2:
                        centre = [centre[0],centre[1],0]
                if len(origen) == 2:
                        origen = [origen[0],origen[1],0]
                if not isinstance(centre,Vector):
                        centre = Vector(centre)
                if not isinstance(origen,Vector):
                        origen = Vector(origen)
                self.base_canonica(zaxis=False)
                self.draw_point(radius=0.167,location=origen,name=&#34;Centre del gir&#34;,color=&#34;White&#34;)
                poligon = self.draw_regular_polygon(origin=centre,vertexs=costats,radius=radi,name=&#34;Polígon regular&#34;)
                self.rotate_object(poligon,axis=&#39;Z&#39;,origin=origen,draw=False)
        #
        # Quàdriques
        #
        ellipsoide = ellipsoid
        hiperboloide_dues_fulles = two_sheets_hyperboloid
        hiperboloide_una_fulla = one_sheet_hyperboloid
        con = cone
        paraboloide_elliptic = elliptic_paraboloid
        paraboloide_hiperbolic = hyperbolic_paraboloid
        cilindre_elliptic = elliptic_cylinder
        cilindre_hiperbolic = hyperbolic_cylinder
        cilindre_parabolic = parabolic_cylinder
        #
        # Esfera i cilindre el·liptic
        #
        def esfera_cilindre_elliptic(self,radi=10,x0=5,a=5,b=5):
                &#34;&#34;&#34;
                Draws an sphere centered at (0,0,0), an elliptic cylinder and their intersection
                Parameters:
                        radi: radius of the sphere

                        x0: (x0,0,0) is the center of the ellipse in the plain XY

                        a, b: semiaxis of this ellipse
                &#34;&#34;&#34;
                if radi &lt;= 0:
                        return
                def F(t):
                        x = x0 + a*math.cos(t)
                        y = b*math.sin(t)
                        z = radi**2 - x**2 - y**2
                        if z &lt; 0:
                                z  = 0
                        z = math.sqrt(z)
                        return (x,y,z)
                self.sphere(r2=radi**2,canonica=True,color=&#34;GrayLight&#34;,thickness=0.0001,pmax=3*radi+3,name=&#34;Esfera&#34;)
                self.elliptic_cylinder(o=[x0,0,0],a2=a**2,b2=b**2,principal=False,canonica=False,zmax=3*radi,thickness=0.01,name=&#34;Cilindre&#34;)
                x, y = symbols(&#39;x y&#39;,real=True)
                sol = solve([x**2 + y**2 - radi**2, (x-x0)**2/a**2 + y**2/b**2 - 1],[x,y],dict=True)
                #
                # 1. solve retorna una única solució
                # La solució és el punt (x0+a,0) o (x0-a,0,0)
                #
                if len(sol) == 1:
                        #
                        # L&#39;altre vèrtex està dins o fora de la circumferència x^2 + y^2 = radi^2
                        #
                        if (sol[0][x] == radi and abs(x0 - a) &lt; radi) or (sol[0][x] == - radi and abs(x0 + a) &lt; radi):
                                self.curve(F,tmin=0,tmax=2*pi,steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
                        else:
                                self.draw_point(radius=0.2,location=(sol[0][x],sol[0][y],0),name=&#34;Punt intersecció&#34;,color=&#34;Black&#34;,opacity=1.0)
                #
                # 2. solve retorna dues solucions
                #
                if len(sol) == 2:
                        try:
                                sol[0][x]
                                sol[0][y]
                                sol[1][x]
                                sol[1][y]
                                circ = False
                        except:
                                circ = True
                        if circ:
                                #
                                # El cilindre és de revolució i les circumferències al pla XY coincideixen
                                #
                                self.draw_circle(radius=radi,steps=64,thickness=0.05,name=&#34;Circumferència&#34;,color=&#34;Black&#34;)
                        else:
                                #
                                # Tenim dues solucions diferents, que han de ser (radi,0) i (-radi,0)
                                #
                                if abs(b) &lt; radi:
                                        theta = [math.atan2(sol[i][y]/b,(sol[i][x] - x0)/a) for i in range(2)]
                                        theta.sort()
                                        if x0 &gt; 0:
                                                self.curve(F,tmin=theta[1],tmax=2*pi-theta[1],steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
                                        else:
                                                self.curve(F,tmin=theta[0],tmax=theta[1],steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
                                else:
                                        self.draw_point(radius=0.2,location=(sol[0][x],sol[0][y],0),name=&#34;Punt intersecció 1&#34;,color=&#34;Black&#34;,opacity=1.0)
                                        self.draw_point(radius=0.2,location=(sol[1][x],sol[1][y],0),name=&#34;Punt intersecció 2&#34;,color=&#34;Black&#34;,opacity=1.0)
                #
                # 2. solve retorna tres solucions
                #
                if len(sol) == 3:
                        theta = [math.atan2(sol[i][y]/b,(sol[i][x] - x0)/a) for i in range(3)]
                        theta.sort()
                        if theta[1] == 0.0:
                                self.curve(F,tmin=theta[0],tmax=theta[2],steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
                        if theta[2] == math.pi:
                                self.curve(F,tmin=theta[1],tmax=theta[0]+2*math.pi,steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
                #
                # 2. solve retorna quatre solucions
                #
                if len(sol) == 4:
                        theta = [math.atan2(sol[i][y]/b,(sol[i][x] - x0)/a) for i in range(4)]
                        theta.sort()
                        self.curve(F,tmin=theta[2],tmax=theta[3],steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=(&#39;XY&#39;,&#39;XZ&#39;,&#39;X&#39;),name=&#34;Corba intersecció&#34;)
        #
        # Con i cilindre el·liptic
        #
        def con_cilindre_elliptic(self,a2=1,b2=1,c2=1,x0=5,a=8,b=5,zmax=15):
                &#34;&#34;&#34;
                Draws a cone with vertex at (0,0,0) and equation x^2/a2 + y^2/b2 - z^2/c2 == 0,
                an elliptic cylinder and their intersection
                Parameters:
                        a2, b2, c2: coefficients of the equation of the cone

                        x0: (x0,0,0) is the center of the ellipse in the plain XY

                        a, b: semiaxis of this ellipse

                        zmax: maximum value of the z coordinate
                &#34;&#34;&#34;
                a2, b2, c2 = abs(a2), abs(b2), abs(c2)
                if a2*b2*c2 == 0:
                        return
                xmax = zmax*math.sqrt(a2/c2)
                def F(t):
                        x = x0 + a*math.cos(t)
                        y = b*math.sin(t)
                        z = math.sqrt(c2*(x**2/a2 + y**2/b2))
                        return (x,y,z)
                self.cone(a2=a2,b2=b2,c2=c2,principal=False,canonica=True,color=&#34;GrayLight&#34;,thickness=0.0001,name=&#34;Con&#34;,xmax=xmax,cmax=xmax+5,opacity=1.0)
                self.elliptic_cylinder(o=[x0,0,0],a2=a**2,b2=b**2,principal=False,canonica=False,zmax=2*(zmax+3),thickness=0.01,name=&#34;Cilindre&#34;)
                self.curve(F,tmin=0,tmax=2*pi,steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="LinearAlgebra.createFaces"><code class="name flex">
<span>def <span class="ident">createFaces</span></span>(<span>vertIdx1, vertIdx2, closed=False, flipped=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createFaces(vertIdx1,vertIdx2,closed=False,flipped=False):
        faces = []
        if not vertIdx1 or not vertIdx2:
                return None
        if len(vertIdx1) &lt; 2 and len(vertIdx2) &lt; 2:
                return None

        fan = False
        if (len(vertIdx1) != len(vertIdx2)):
                if (len(vertIdx1) == 1 and len(vertIdx2) &gt; 1):
                        fan = True
                else:
                        return None

        total = len(vertIdx2)
        if closed:
                if flipped:
                        face = [vertIdx1[0],vertIdx2[0],vertIdx2[total - 1]]
                        if not fan:
                                face.append(vertIdx1[total - 1])
                        faces.append(face)
                else:
                        face = [vertIdx2[0], vertIdx1[0]]
                        if not fan:
                                face.append(vertIdx1[total - 1])
                        face.append(vertIdx2[total - 1])
                        faces.append(face)
        for num in range(total - 1):
                if flipped:
                        if fan:
                                face = [vertIdx2[num], vertIdx1[0], vertIdx2[num + 1]]
                        else:
                                face = [vertIdx2[num], vertIdx1[num],vertIdx1[num + 1], vertIdx2[num + 1]]
                        faces.append(face)
                else:
                        if fan:
                                face = [vertIdx1[0], vertIdx2[num], vertIdx2[num + 1]]
                        else:
                                face = [vertIdx1[num], vertIdx2[num],vertIdx2[num + 1], vertIdx1[num + 1]]
                        faces.append(face)
        return faces</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.create_mesh_object"><code class="name flex">
<span>def <span class="ident">create_mesh_object</span></span>(<span>context, verts, edges, faces, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_mesh_object(context,verts,edges,faces,name):
        mesh = bpy.data.meshes.new(name)
        mesh.from_pydata(verts, edges, faces)
        mesh.update()
        return object_utils.object_data_add(context, mesh, operator=None)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.draw_parametric_surface"><code class="name flex">
<span>def <span class="ident">draw_parametric_surface</span></span>(<span>eq, range_u_min, range_u_max, range_u_step, range_v_min, range_v_max, range_v_step, name, wrap_u=False, wrap_v=False, close_v=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_parametric_surface(eq,range_u_min,range_u_max,range_u_step,range_v_min,range_v_max,range_v_step,name,wrap_u=False,wrap_v=False,close_v=False):
        verts = []
        faces = []
        if not callable(range_u_min) and not callable(range_u_max):
                uStep = (range_u_max - range_u_min) / range_u_step
        vStep = (range_v_max - range_v_min) / range_v_step
        uRange = range_u_step + 1
        vRange = range_v_step + 1

        if wrap_u:
                uRange = uRange - 1
        if wrap_v:
                vRange = vRange - 1

        for vN in range(vRange):
                v = range_v_min + (vN * vStep)
                if callable(range_u_min):
                        u_min = range_u_min(v)
                else:
                        u_min = range_u_min
                if callable(range_u_max):
                        u_max = range_u_max(v)
                else:
                        u_max = range_u_max
                uStep = (u_max - u_min) / range_u_step
                for uN in range(uRange):
                        u = u_min + (uN * uStep)
                        verts.append(eq(u,v))

        for vN in range(range_v_step):
                vNext = vN + 1
                if vNext &gt;= vRange:
                        vNext = 0
                for uN in range(range_u_step):
                        uNext = uN + 1
                        if uNext &gt;= uRange:
                                uNext = 0
                        faces.append([(vNext * uRange) + uNext,(vNext * uRange) + uN,(vN * uRange) + uN,(vN * uRange) + uNext])

        if close_v and wrap_u and (not wrap_v):
                for uN in range(1, range_u_step - 1):
                        faces.append([range_u_step - 1,range_u_step - 1 - uN,range_u_step - 2 - uN])
                        faces.append([range_v_step * uRange,range_v_step * uRange + uN,range_v_step * uRange + uN + 1])
        create_mesh_object(bpy.context,verts, [], faces, name)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="LinearAlgebra.Color"><code class="flex name class">
<span>class <span class="ident">Color</span></span>
<span>(</span><span>r, g, b, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Class that defines a color in RGB format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Color():
        &#34;&#34;&#34;
    Class that defines a color in RGB format
    &#34;&#34;&#34;
        def __init__(self,r,g,b,name):
                self.r = r
                self.g = g
                self.b = b
                self.name = name</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.Colors"><code class="flex name class">
<span>class <span class="ident">Colors</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class that defines a list of colors by name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Colors():
        &#34;&#34;&#34;
        Class that defines a list of colors by name
        &#34;&#34;&#34;
        colorsbyname = {
                &#39;Black&#39; : Color(0,0,0,&#39;Black&#39;),
                &#39;GrayObscure&#39; : Color(0.2,0.2,0.2,&#39;GrayObscure&#39;),
                &#39;GrayDark&#39; : Color(0.4,0.4,0.4,&#39;GrayDark&#39;),
                &#39;GrayLight&#39; : Color(0.6,0.6,0.6,&#39;GrayLight&#39;),
                &#39;GrayPale&#39; : Color(0.8,0.8,0.8,&#39;GrayPale&#39;),
                &#39;White&#39; : Color(1,1,1,&#39;White&#39;),
                &#39;Red&#39; : Color(1,0,0,&#39;Red&#39;),
                &#39;RedDarkHard&#39; : Color(0.8,0,0,&#39;RedDarkHard&#39;),
                &#39;RedLightHard&#39; : Color(1,0.2,0.2,&#39;RedLightHard&#39;),
                &#39;RedDarkFaded&#39; : Color(0.6,0,0,&#39;RedDarkFaded&#39;),
                &#39;RedMediumFaded&#39; : Color(0.8,0.2,0.2,&#39;RedMediumFaded&#39;),
                &#39;RedLightFaded&#39; : Color(1,0.4,0.4,&#39;RedLightFaded&#39;),
                &#39;RedObscureDull&#39; : Color(0.4,0,0,&#39;RedObscureDull&#39;),
                &#39;RedDarkDull&#39; : Color(0.6,0.2,0.2,&#39;RedDarkDull&#39;),
                &#39;RedLightDull&#39; : Color(0.8,0.4,0.4,&#39;RedLightDull&#39;),
                &#39;RedPaleDull&#39; : Color(1,0.6,0.6,&#39;RedPaleDull&#39;),
                &#39;RedObscureWeak&#39; : Color(0.2,0,0,&#39;RedObscureWeak&#39;),
                &#39;RedDarkWeak&#39; : Color(0.4,0.2,0.2,&#39;RedDarkWeak&#39;),
                &#39;RedMediumWeak&#39; : Color(0.6,0.4,0.4,&#39;RedMediumWeak&#39;),
                &#39;RedLightWeak&#39; : Color(0.8,0.6,0.6,&#39;RedLightWeak&#39;),
                &#39;RedPaleWeak&#39; : Color(1,0.8,0.8,&#39;RedPaleWeak&#39;),
                &#39;Orange&#39; : Color(1,0.37,0.12,&#39;Orange&#39;),
                &#39;OrangeRedDark&#39; : Color(0.6,0.2,0,&#39;OrangeRedDark&#39;),
                &#39;OrangeRedMedium&#39; : Color(0.8,0.4,0.2,&#39;OrangeRedMedium&#39;),
                &#39;OrangeRedLight&#39; : Color(1,0.6,0.4,&#39;OrangeRedLight&#39;),
                &#39;OrangeOrangeRed&#39; : Color(1,0.4,0,&#39;OrangeOrangeRed&#39;),
                &#39;RedOrangeDark&#39; : Color(0.8,0.2,0,&#39;RedOrangeDark&#39;),
                &#39;RedOrangeLight&#39; : Color(1,0.4,0.2,&#39;RedOrangeLight&#39;),
                &#39;RedRedOrange&#39; : Color(1,0.2,0,&#39;RedRedOrange&#39;),
                &#39;OrangeDarkHard&#39; : Color(0.8,0.4,0,&#39;OrangeDarkHard&#39;),
                &#39;OrangeLightHard&#39; : Color(1,0.6,0.2,&#39;OrangeLightHard&#39;),
                &#39;OrangeObscureDull&#39; : Color(0.4,0.2,0,&#39;OrangeObscureDull&#39;),
                &#39;OrangeDarkDull&#39; : Color(0.6,0.4,0.2,&#39;OrangeDarkDull&#39;),
                &#39;OrangeLightDull&#39; : Color(0.8,0.6,0.4,&#39;OrangeLightDull&#39;),
                &#39;OrangePaleDull&#39; : Color(1,0.8,0.6,&#39;OrangePaleDull&#39;),
                &#39;OrangeYellowDark&#39; : Color(0.6,0.4,0,&#39;OrangeYellowDark&#39;),
                &#39;OrangeYellowMedium&#39; : Color(0.8,0.6,0.2,&#39;OrangeYellowMedium&#39;),
                &#39;OrangeYellowLight&#39; : Color(1,0.8,0.4,&#39;OrangeYellowLight&#39;),
                &#39;OrangeOrangeYellow&#39; : Color(1,0.6,0,&#39;OrangeOrangeYellow&#39;),
                &#39;YellowOrangeDark&#39; : Color(0.8,0.6,0,&#39;YellowOrangeDark&#39;),
                &#39;YellowOrangeLight&#39; : Color(1,0.8,0.2,&#39;YellowOrangeLight&#39;),
                &#39;YellowYellowOrange&#39; : Color(1,0.8,0,&#39;YellowYellowOrange&#39;),
                &#39;Yellow&#39; : Color(1,1,0,&#39;Yellow&#39;),
                &#39;YellowDarkHard&#39; : Color(0.8,0.8,0,&#39;YellowDarkHard&#39;),
                &#39;YellowLightHard&#39; : Color(1,1,0.2,&#39;YellowLightHard&#39;),
                &#39;YellowDarkFaded&#39; : Color(0.6,0.6,0,&#39;YellowDarkFaded&#39;),
                &#39;YellowMediumFaded&#39; : Color(0.8,0.8,0.2,&#39;YellowMediumFaded&#39;),
                &#39;YellowLightFaded&#39; : Color(1,1,0.4,&#39;YellowLightFaded&#39;),
                &#39;YellowObscureDull&#39; : Color(0.4,0.4,0,&#39;YellowObscureDull&#39;),
                &#39;YellowDarkDull&#39; : Color(0.6,0.6,0.2,&#39;YellowDarkDull&#39;),
                &#39;YellowLightDull&#39; : Color(0.8,0.8,0.4,&#39;YellowLightDull&#39;),
                &#39;YellowPaleDull&#39; : Color(1,1,0.6,&#39;YellowPaleDull&#39;),
                &#39;YellowObscureWeak&#39; : Color(0.2,0.2,0,&#39;YellowObscureWeak&#39;),
                &#39;YellowDarkWeak&#39; : Color(0.4,0.4,0.2,&#39;YellowDarkWeak&#39;),
                &#39;YellowMediumWeak&#39; : Color(0.6,0.6,0.4,&#39;YellowMediumWeak&#39;),
                &#39;YellowLightWeak&#39; : Color(0.8,0.8,0.6,&#39;YellowLightWeak&#39;),
                &#39;YellowPaleWeak&#39; : Color(1,1,0.8,&#39;YellowPaleWeak&#39;),
                &#39;SpringYellowDark&#39; : Color(0.4,0.6,0,&#39;SpringYellowDark&#39;),
                &#39;SpringYellowMedium&#39; : Color(0.6,0.8,0.2,&#39;SpringYellowMedium&#39;),
                &#39;SpringYellowLight&#39; : Color(0.8,1,0.4,&#39;SpringYellowLight&#39;),
                &#39;SpringSpringYellow&#39; : Color(0.6,1,0,&#39;SpringSpringYellow&#39;),
                &#39;YellowSpringDark&#39; : Color(0.6,0.8,0,&#39;YellowSpringDark&#39;),
                &#39;YellowSpringLight&#39; : Color(0.8,1,0.2,&#39;YellowSpringLight&#39;),
                &#39;YellowYellowSpring&#39; : Color(0.8,1,0,&#39;YellowYellowSpring&#39;),
                &#39;SpringDarkHard&#39; : Color(0.4,0.8,0,&#39;SpringDarkHard&#39;),
                &#39;SpringLightHard&#39; : Color(0.6,1,0.2,&#39;SpringLightHard&#39;),
                &#39;SpringObscureDull&#39; : Color(0.2,0.4,0,&#39;SpringObscureDull&#39;),
                &#39;SpringDarkDull&#39; : Color(0.4,0.6,0.2,&#39;SpringDarkDull&#39;),
                &#39;SpringLightDull&#39; : Color(0.6,0.8,0.4,&#39;SpringLightDull&#39;),
                &#39;SpringPaleDull&#39; : Color(0.8,1,0.6,&#39;SpringPaleDull&#39;),
                &#39;SpringGreenDark&#39; : Color(0.2,0.6,0,&#39;SpringGreenDark&#39;),
                &#39;SpringGreenMedium&#39; : Color(0.4,0.8,0.2,&#39;SpringGreenMedium&#39;),
                &#39;SpringGreenLight&#39; : Color(0.6,1,0.4,&#39;SpringGreenLight&#39;),
                &#39;SpringSpringGreen&#39; : Color(0.4,1,0,&#39;SpringSpringGreen&#39;),
                &#39;GreenSpringDark&#39; : Color(0.2,0.8,0,&#39;GreenSpringDark&#39;),
                &#39;GreenSpringLight&#39; : Color(0.4,1,0.2,&#39;GreenSpringLight&#39;),
                &#39;GreenGreenSpring&#39; : Color(0.2,1,0,&#39;GreenGreenSpring&#39;),
                &#39;Green&#39; : Color(0,1,0,&#39;Green&#39;),
                &#39;GreenDarkHard&#39; : Color(0,0.8,0,&#39;GreenDarkHard&#39;),
                &#39;GreenLightHard&#39; : Color(0.2,1,0.2,&#39;GreenLightHard&#39;),
                &#39;GreenDarkFaded&#39; : Color(0,0.6,0,&#39;GreenDarkFaded&#39;),
                &#39;GreenMediumFaded&#39; : Color(0.2,0.8,0.2,&#39;GreenMediumFaded&#39;),
                &#39;GreenLightFaded&#39; : Color(0.4,1,0.4,&#39;GreenLightFaded&#39;),
                &#39;GreenObscureDull&#39; : Color(0,0.4,0,&#39;GreenObscureDull&#39;),
                &#39;GreenDarkDull&#39; : Color(0.2,0.6,0.2,&#39;GreenDarkDull&#39;),
                &#39;GreenLightDull&#39; : Color(0.4,0.8,0.4,&#39;GreenLightDull&#39;),
                &#39;GreenPaleDull&#39; : Color(0.6,1,0.6,&#39;GreenPaleDull&#39;),
                &#39;GreenObscureWeak&#39; : Color(0,0.2,0,&#39;GreenObscureWeak&#39;),
                &#39;GreenDarkWeak&#39; : Color(0.2,0.4,0.2,&#39;GreenDarkWeak&#39;),
                &#39;GreenMediumWeak&#39; : Color(0.4,0.6,0.4,&#39;GreenMediumWeak&#39;),
                &#39;GreenLightWeak&#39; : Color(0.6,0.8,0.6,&#39;GreenLightWeak&#39;),
                &#39;GreenPaleWeak&#39; : Color(0.8,1,0.8,&#39;GreenPaleWeak&#39;),
                &#39;TealGreenDark&#39; : Color(0,0.6,0.2,&#39;TealGreenDark&#39;),
                &#39;TealGreenMedium&#39; : Color(0.2,0.8,0.4,&#39;TealGreenMedium&#39;),
                &#39;TealGreenLight&#39; : Color(0.4,1,0.6,&#39;TealGreenLight&#39;),
                &#39;TealTealGreen&#39; : Color(0,1,0.4,&#39;TealTealGreen&#39;),
                &#39;GreenTealDark&#39; : Color(0,0.8,0.2,&#39;GreenTealDark&#39;),
                &#39;GreenTealLight&#39; : Color(0.2,1,0.4,&#39;GreenTealLight&#39;),
                &#39;GreenGreenTeal&#39; : Color(0,1,0.2,&#39;GreenGreenTeal&#39;),
                &#39;TealDarkHard&#39; : Color(0,0.8,0.4,&#39;TealDarkHard&#39;),
                &#39;TealLightHard&#39; : Color(0.2,1,0.6,&#39;TealLightHard&#39;),
                &#39;TealObscureDull&#39; : Color(0,0.4,0.2,&#39;TealObscureDull&#39;),
                &#39;TealDarkDull&#39; : Color(0.2,0.6,0.4,&#39;TealDarkDull&#39;),
                &#39;TealLightDull&#39; : Color(0.4,0.8,0.6,&#39;TealLightDull&#39;),
                &#39;TealPaleDull&#39; : Color(0.6,1,0.8,&#39;TealPaleDull&#39;),
                &#39;TealCyanDark&#39; : Color(0,0.6,0.4,&#39;TealCyanDark&#39;),
                &#39;TealCyanMedium&#39; : Color(0.2,0.8,0.6,&#39;TealCyanMedium&#39;),
                &#39;TealCyanLight&#39; : Color(0.4,1,0.8,&#39;TealCyanLight&#39;),
                &#39;TealTealCyan&#39; : Color(0,1,0.6,&#39;TealTealCyan&#39;),
                &#39;CyanTealDark&#39; : Color(0,0.8,0.6,&#39;CyanTealDark&#39;),
                &#39;CyanTealLight&#39; : Color(0.2,1,0.8,&#39;CyanTealLight&#39;),
                &#39;CyanCyanTeal&#39; : Color(0,1,0.8,&#39;CyanCyanTeal&#39;),
                &#39;Cyan&#39; : Color(0,1,1,&#39;Cyan&#39;),
                &#39;CyanDarkHard&#39; : Color(0,0.8,0.8,&#39;CyanDarkHard&#39;),
                &#39;CyanLightHard&#39; : Color(0.2,1,1,&#39;CyanLightHard&#39;),
                &#39;CyanDarkFaded&#39; : Color(0,0.6,0.6,&#39;CyanDarkFaded&#39;),
                &#39;CyanMediumFaded&#39; : Color(0.2,0.8,0.8,&#39;CyanMediumFaded&#39;),
                &#39;CyanLightFaded&#39; : Color(0.4,1,1,&#39;CyanLightFaded&#39;),
                &#39;CyanObscureDull&#39; : Color(0,0.4,0.4,&#39;CyanObscureDull&#39;),
                &#39;CyanDarkDull&#39; : Color(0.2,0.6,0.6,&#39;CyanDarkDull&#39;),
                &#39;CyanLightDull&#39; : Color(0.4,0.8,0.8,&#39;CyanLightDull&#39;),
                &#39;CyanPaleDull&#39; : Color(0.6,1,1,&#39;CyanPaleDull&#39;),
                &#39;CyanObscureWeak&#39; : Color(0,0.2,0.2,&#39;CyanObscureWeak&#39;),
                &#39;CyanDarkWeak&#39; : Color(0.2,0.4,0.4,&#39;CyanDarkWeak&#39;),
                &#39;CyanMediumWeak&#39; : Color(0.4,0.6,0.6,&#39;CyanMediumWeak&#39;),
                &#39;CyanLightWeak&#39; : Color(0.6,0.8,0.8,&#39;CyanLightWeak&#39;),
                &#39;CyanPaleWeak&#39; : Color(0.8,1,1,&#39;CyanPaleWeak&#39;),
                &#39;AzureCyanDark&#39; : Color(0,0.4,0.6,&#39;AzureCyanDark&#39;),
                &#39;AzureCyanMedium&#39; : Color(0.2,0.6,0.8,&#39;AzureCyanMedium&#39;),
                &#39;AzureCyanLight&#39; : Color(0.4,0.8,1,&#39;AzureCyanLight&#39;),
                &#39;AzureAzureCyan&#39; : Color(0,0.6,1,&#39;AzureAzureCyan&#39;),
                &#39;CyanAzureDark&#39; : Color(0,0.6,0.8,&#39;CyanAzureDark&#39;),
                &#39;CyanAzureLight&#39; : Color(0.2,0.8,1,&#39;CyanAzureLight&#39;),
                &#39;CyanCyanAzure&#39; : Color(0,0.8,1,&#39;CyanCyanAzure&#39;),
                &#39;AzureDarkHard&#39; : Color(0,0.4,0.8,&#39;AzureDarkHard&#39;),
                &#39;AzureLightHard&#39; : Color(0.2,0.6,1,&#39;AzureLightHard&#39;),
                &#39;AzureObscureDull&#39; : Color(0,0.2,0.4,&#39;AzureObscureDull&#39;),
                &#39;AzureDarkDull&#39; : Color(0.2,0.4,0.6,&#39;AzureDarkDull&#39;),
                &#39;AzureLightDull&#39; : Color(0.4,0.6,0.8,&#39;AzureLightDull&#39;),
                &#39;AzurePaleDull&#39; : Color(0.6,0.8,1,&#39;AzurePaleDull&#39;),
                &#39;AzureBlueDark&#39; : Color(0,0.2,0.6,&#39;AzureBlueDark&#39;),
                &#39;AzureBlueMedium&#39; : Color(0.2,0.4,0.8,&#39;AzureBlueMedium&#39;),
                &#39;AzureBlueLight&#39; : Color(0.4,0.6,1,&#39;AzureBlueLight&#39;),
                &#39;AzureAzureBlue&#39; : Color(0,0.4,1,&#39;AzureAzureBlue&#39;),
                &#39;BlueAzureDark&#39; : Color(0,0.2,0.8,&#39;BlueAzureDark&#39;),
                &#39;BlueAzureLight&#39; : Color(0.2,0.4,1,&#39;BlueAzureLight&#39;),
                &#39;BlueBlueAzure&#39; : Color(0,0.2,1,&#39;BlueBlueAzure&#39;),
                &#39;Blue&#39; : Color(0,0,1,&#39;Blue&#39;),
                &#39;BlueDarkHard&#39; : Color(0,0,0.8,&#39;BlueDarkHard&#39;),
                &#39;BlueLightHard&#39; : Color(0.2,0.2,1,&#39;BlueLightHard&#39;),
                &#39;BlueDarkFaded&#39; : Color(0,0,0.6,&#39;BlueDarkFaded&#39;),
                &#39;BlueMediumFaded&#39; : Color(0.2,0.2,0.8,&#39;BlueMediumFaded&#39;),
                &#39;BlueLightFaded&#39; : Color(0.4,0.4,1,&#39;BlueLightFaded&#39;),
                &#39;BlueObscureDull&#39; : Color(0,0,0.4,&#39;BlueObscureDull&#39;),
                &#39;BlueDarkDull&#39; : Color(0.2,0.2,0.6,&#39;BlueDarkDull&#39;),
                &#39;BlueLightDull&#39; : Color(0.4,0.4,0.8,&#39;BlueLightDull&#39;),
                &#39;BluePaleDull&#39; : Color(0.6,0.6,1,&#39;BluePaleDull&#39;),
                &#39;BlueObscureWeak&#39; : Color(0,0,0.2,&#39;BlueObscureWeak&#39;),
                &#39;BlueDarkWeak&#39; : Color(0.2,0.2,0.4,&#39;BlueDarkWeak&#39;),
                &#39;BlueMediumWeak&#39; : Color(0.4,0.4,0.6,&#39;BlueMediumWeak&#39;),
                &#39;BlueLightWeak&#39; : Color(0.6,0.6,0.8,&#39;BlueLightWeak&#39;),
                &#39;BluePaleWeak&#39; : Color(0.8,0.8,1,&#39;BluePaleWeak&#39;),
                &#39;VioletBlueDark&#39; : Color(0.2,0,0.6,&#39;VioletBlueDark&#39;),
                &#39;VioletBlueMedium&#39; : Color(0.4,0.2,0.8,&#39;VioletBlueMedium&#39;),
                &#39;VioletBlueLight&#39; : Color(0.6,0.4,1,&#39;VioletBlueLight&#39;),
                &#39;VioletVioletBlue&#39; : Color(0.4,0,1,&#39;VioletVioletBlue&#39;),
                &#39;BlueVioletDark&#39; : Color(0.2,0,0.8,&#39;BlueVioletDark&#39;),
                &#39;BlueVioletLight&#39; : Color(0.4,0.2,1,&#39;BlueVioletLight&#39;),
                &#39;BlueBlueViolet&#39; : Color(0.2,0,1,&#39;BlueBlueViolet&#39;),
                &#39;VioletDarkHard&#39; : Color(0.4,0,0.8,&#39;VioletDarkHard&#39;),
                &#39;VioletLightHard&#39; : Color(0.6,0.2,1,&#39;VioletLightHard&#39;),
                &#39;VioletObscureDull&#39; : Color(0.2,0,0.4,&#39;VioletObscureDull&#39;),
                &#39;VioletDarkDull&#39; : Color(0.4,0.2,0.6,&#39;VioletDarkDull&#39;),
                &#39;VioletLightDull&#39; : Color(0.6,0.4,0.8,&#39;VioletLightDull&#39;),
                &#39;VioletPaleDull&#39; : Color(0.8,0.6,1,&#39;VioletPaleDull&#39;),
                &#39;VioletMagentaDark&#39; : Color(0.4,0,0.6,&#39;VioletMagentaDark&#39;),
                &#39;VioletMagentaMedium&#39; : Color(0.6,0.2,0.8,&#39;VioletMagentaMedium&#39;),
                &#39;VioletMagentaLight&#39; : Color(0.8,0.4,1,&#39;VioletMagentaLight&#39;),
                &#39;VioletVioletMagenta&#39; : Color(0.6,0,1,&#39;VioletVioletMagenta&#39;),
                &#39;MagentaVioletDark&#39; : Color(0.6,0,0.8,&#39;MagentaVioletDark&#39;),
                &#39;MagentaVioletLight&#39; : Color(0.8,0.2,1,&#39;MagentaVioletLight&#39;),
                &#39;MagentaMagentaViolet&#39; : Color(0.8,0,1,&#39;MagentaMagentaViolet&#39;),
                &#39;Magenta&#39; : Color(1,0,1,&#39;Magenta&#39;),
                &#39;MagentaDarkHard&#39; : Color(0.8,0,0.8,&#39;MagentaDarkHard&#39;),
                &#39;MagentaLightHard&#39; : Color(1,0.2,1,&#39;MagentaLightHard&#39;),
                &#39;MagentaDarkFaded&#39; : Color(0.6,0,0.6,&#39;MagentaDarkFaded&#39;),
                &#39;MagentaMediumFaded&#39; : Color(0.8,0.2,0.8,&#39;MagentaMediumFaded&#39;),
                &#39;MagentaLightFaded&#39; : Color(1,0.4,1,&#39;MagentaLightFaded&#39;),
                &#39;MagentaObscureDull&#39; : Color(0.4,0,0.4,&#39;MagentaObscureDull&#39;),
                &#39;MagentaDarkDull&#39; : Color(0.6,0.2,0.6,&#39;MagentaDarkDull&#39;),
                &#39;MagentaLightDull&#39; : Color(0.8,0.4,0.8,&#39;MagentaLightDull&#39;),
                &#39;MagentaPaleDull&#39; : Color(1,0.6,1,&#39;MagentaPaleDull&#39;),
                &#39;MagentaObscureWeak&#39; : Color(0.2,0,0.2,&#39;MagentaObscureWeak&#39;),
                &#39;MagentaDarkWeak&#39; : Color(0.4,0.2,0.4,&#39;MagentaDarkWeak&#39;),
                &#39;MagentaMediumWeak&#39; : Color(0.6,0.4,0.6,&#39;MagentaMediumWeak&#39;),
                &#39;MagentaLightWeak&#39; : Color(0.8,0.6,0.8,&#39;MagentaLightWeak&#39;),
                &#39;MagentaPaleWeak&#39; : Color(1,0.8,1,&#39;MagentaPaleWeak&#39;),
                &#39;PinkMagentaDark&#39; : Color(0.6,0,0.4,&#39;PinkMagentaDark&#39;),
                &#39;PinkMagentaMedium&#39; : Color(0.8,0.2,0.6,&#39;PinkMagentaMedium&#39;),
                &#39;PinkMagentaLight&#39; : Color(1,0.4,0.8,&#39;PinkMagentaLight&#39;),
                &#39;PinkPinkMagenta&#39; : Color(1,0,0.6,&#39;PinkPinkMagenta&#39;),
                &#39;MagentaPinkDark&#39; : Color(0.8,0,0.6,&#39;MagentaPinkDark&#39;),
                &#39;MagentaPinkLight&#39; : Color(1,0.2,0.8,&#39;MagentaPinkLight&#39;),
                &#39;MagentaMagentaPink&#39; : Color(1,0,0.8,&#39;MagentaMagentaPink&#39;),
                &#39;PinkDarkHard&#39; : Color(0.8,0,0.4,&#39;PinkDarkHard&#39;),
                &#39;PinkLightHard&#39; : Color(1,0.2,0.6,&#39;PinkLightHard&#39;),
                &#39;PinkObscureDull&#39; : Color(0.4,0,0.2,&#39;PinkObscureDull&#39;),
                &#39;PinkDarkDull&#39; : Color(0.6,0.2,0.4,&#39;PinkDarkDull&#39;),
                &#39;PinkLightDull&#39; : Color(0.8,0.4,0.6,&#39;PinkLightDull&#39;),
                &#39;PinkPaleDull&#39; : Color(1,0.6,0.8,&#39;PinkPaleDull&#39;),
                &#39;PinkRedDark&#39; : Color(0.6,0,0.2,&#39;PinkRedDark&#39;),
                &#39;PinkRedMedium&#39; : Color(0.8,0.2,0.4,&#39;PinkRedMedium&#39;),
                &#39;PinkRedLight&#39; : Color(1,0.4,0.6,&#39;PinkRedLight&#39;),
                &#39;PinkPinkRed&#39; : Color(1,0,0.4,&#39;PinkPinkRed&#39;),
                &#39;RedPinkDark&#39; : Color(0.8,0,0.2,&#39;RedPinkDark&#39;),
                &#39;RedPinkLight&#39; : Color(1,0.2,0.4,&#39;RedPinkLight&#39;),
                &#39;RedRedPink&#39; : Color(1,0,0.2,&#39;RedRedPink&#39;)
        }
        #
        #
        #
        @classmethod
        def color(self,name):
                &#34;&#34;&#34;
                Function that returns a color from his name
                Parameters:
                   name: name of the color
                &#34;&#34;&#34;
                try:
                        color = self.colorsbyname[name]
                except:
                        return self.colorsbyname[&#34;Black&#34;]
                return color
        #
        #
        #
        @classmethod
        def colors(self,names):
                &#34;&#34;&#34;
                Return a list of colors fron their names
                Parameters:
                   names: list of names
                &#34;&#34;&#34;
                return [self.colorsbyname[x] for x in names]</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="LinearAlgebra.Colors.colorsbyname"><code class="name">var <span class="ident">colorsbyname</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="LinearAlgebra.Colors.color"><code class="name flex">
<span>def <span class="ident">color</span></span>(<span>name)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that returns a color from his name</p>
<h2 id="parameters">Parameters</h2>
<p>name: name of the color</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def color(self,name):
        &#34;&#34;&#34;
        Function that returns a color from his name
        Parameters:
           name: name of the color
        &#34;&#34;&#34;
        try:
                color = self.colorsbyname[name]
        except:
                return self.colorsbyname[&#34;Black&#34;]
        return color</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.Colors.colors"><code class="name flex">
<span>def <span class="ident">colors</span></span>(<span>names)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of colors fron their names</p>
<h2 id="parameters">Parameters</h2>
<p>names: list of names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def colors(self,names):
        &#34;&#34;&#34;
        Return a list of colors fron their names
        Parameters:
           names: list of names
        &#34;&#34;&#34;
        return [self.colorsbyname[x] for x in names]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="LinearAlgebra.LinearAlgebra"><code class="flex name class">
<span>class <span class="ident">LinearAlgebra</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class used to define all the functions in this module to work with graphics in Blender</p>
<p>Initializes the values for scene, objects, meshes, collection, etc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LinearAlgebra():
        &#34;&#34;&#34;
        Class used to define all the functions in this module to work with graphics in Blender
        &#34;&#34;&#34;
        def __init__(self):
                &#34;&#34;&#34;
        Initializes the values for scene, objects, meshes, collection, etc.
                &#34;&#34;&#34;
                self.scene = bpy.context.scene
                self.objects = bpy.data.objects
                self.meshes = bpy.data.meshes
                self.collection = bpy.context.collection
                self.ops = bpy.ops
                self.colors= Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                self.rotation = None
                self.origin = [0,0,0]
                self.base = [[1,0,0],[0,1,0],[0,0,1]]
                self.defaultcolor = None
                self.frame = 0
        #
        #
        #
        def base_cilinder(self):
                &#34;&#34;&#34;
                Draws a base cilinder with radius 1 and depth 1
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_cylinder_add(radius=1,depth=1,enter_editmode=False,location=(0, 0, 0))
                bpy.ops.transform.translate(value=(0, 0, 0.5), orient_type=&#39;GLOBAL&#39;,orient_matrix_type=&#39;GLOBAL&#39;,
                        constraint_axis=(False, False, True), mirror=True, use_proportional_edit=False,
                        proportional_edit_falloff=&#39;SMOOTH&#39;,proportional_size=1, use_proportional_connected=False, use_proportional_projected=False)
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                bpy.ops.object.shade_smooth()
                bpy.context.object.name = &#39;Arrow_stem&#39;
        #
        #
        #
        def base_cone(self):
                &#34;&#34;&#34;
                Draws a base cone with radius1=1.5, radius2=0, depth=2
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_cone_add(radius1=1.5, radius2=0, depth=2, enter_editmode=False, location=(0, 0, 0))
                bpy.ops.transform.translate(value=(0, 0, 1), orient_type=&#39;GLOBAL&#39;,orient_matrix_type=&#39;GLOBAL&#39;,
                        constraint_axis=(False, False, True), mirror=True, use_proportional_edit=False,
                        proportional_edit_falloff=&#39;SMOOTH&#39;, proportional_size=1, use_proportional_connected=False, use_proportional_projected=False)
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                bpy.ops.object.shade_smooth()
                bpy.context.object.name = &#39;Arrow_cone&#39;
        #
        #
        #
        def delete_base_cilinder(self):
                &#34;&#34;&#34;
                Removes the base cilinder
                &#34;&#34;&#34;
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.data.objects[&#39;Arrow_stem&#39;].select_set(True)
                bpy.ops.object.delete()
        #
        #
        #
        def delete_base_cone(self):
                &#34;&#34;&#34;
                Removes the base cone
                &#34;&#34;&#34;
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.data.objects[&#39;Arrow_cone&#39;].select_set(True)
                bpy.ops.object.delete()
        #
        #
        #
        def set_colors(self,names):
                &#34;&#34;&#34;
                Set self.colors to the list of colors with names &#39;names&#39;
                Parameters:
                   names: list of name colors
                &#34;&#34;&#34;
                self.colors = Colors.colors(names)
        #
        #
        #
        def reset_colors(self):
                &#34;&#34;&#34;
                Set self.colors to default colors
                &#34;&#34;&#34;
                self.colors= Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        #
        #
        #
        def set_default_color(self,name):
                &#34;&#34;&#34;
                Set self.defaultcolor to the color with name &#39;name&#39;
                Parameters:
                   name: name of a color
                &#34;&#34;&#34;
                self.defaultcolor = name
        #
        #
        #
        def reset_frames(self):
                &#34;&#34;&#34;
                Set self.frame to 0
                Parameters:
                   name: name of a color
                &#34;&#34;&#34;
                self.frame = 0
        #
        #
        #
        def reset(self):
                &#34;&#34;&#34;
                Resets origin, base, rotation, frames and colors
                &#34;&#34;&#34;
                self.reset_origin()
                self.reset_base()
                self.reset_rotation()
                self.reset_frames()
                self.reset_colors()
        #
        #
        #
        def set_rotation(self,angle=None,vector=None,quaternion=None):
                &#34;&#34;&#34;
                Sets self.rotation to the rotation defined by an angle and an axis or
                by a quaternion.
                Parameters:
                   angle: angle of rotation in degrees

                   vector: axis of rotation

                   quaternion: quaternion that defines a rotation

                The angle and vector takes precedence over the quaternion
                &#34;&#34;&#34;
                if angle is not None:
                        self.rotation = Rotation(angle,vector)
                elif quaternion is not None:
                        self.rotation = Rotation(quaternion=quaternion)
                else:
                        self.rotation = Rotation(0,[1,0,0])
        #
        #
        #
        def reset_rotation(self):
                &#34;&#34;&#34;
                Sets the rotation to identity, i.e., rotation of 0 degrees around the
                vector (1,0,0)
                &#34;&#34;&#34;
                self.set_rotation()
        #
        #
        #
        def set_origin(self,vector=[0,0,0]):
                &#34;&#34;&#34;
                Sets the origin of the reference coordinates used to display objects.
                Parameters:
                   vector: origin&#39;s position
                &#34;&#34;&#34;
                if isinstance(vector,Vector):
                        v1 = vector.copy()
                else:
                        v1 = Vector(vector)
                self.origin = v1
        #
        #
        #
        def reset_origin(self):
                &#34;&#34;&#34;
                Sets the origin to the point (0,0,0)
                &#34;&#34;&#34;
                self.origin = Vector([0,0,0])
        #
        #
        #
        def reset_base(self):
                &#34;&#34;&#34;
                Sets self.base to the canonical basis
                &#34;&#34;&#34;
                self.base = [[1,0,0],[0,1,0],[0,0,1]]
        #
        #
        #
        def set_base(self,base=[[1,0,0],[0,1,0],[0,0,1]],orthonormal=False):
                &#34;&#34;&#34;
                Sets the self.base, i.e., the basis of the reference coordinates used to display
                objects
                Parameters:
                   base: list of three vectors

                   orthonormal: if True, the Gram-Schmidt method is applied and the vectors
                   are normalized.
                &#34;&#34;&#34;
                if orthonormal:
                        u1 = base[0]
                        u2 = base[1]
                        if isinstance(u1,Vector):
                                v1 = u1
                        else:
                                v1 = Vector(u1)
                        if isinstance(u2,Vector):
                                v2 = u2
                        else:
                                v2 = Vector(u2)
                        v2 = v2 - v2.project(v1)
                        v1.normalize()
                        v2.normalize()
                        v3 = v1.cross(v2)
                        self.base=[v1,v2,v3]
                else:
                        self.base = base
        #
        #
        #
        def base_is_canonica(self):
                &#34;&#34;&#34;
                Returns True if sel.base is the canonical basis
                &#34;&#34;&#34;
                return Matrix(self.base).is_identity
        #
        #
        #
        def add_material(self,obj,material_name,r,g,b,opacity=1.0):
                &#34;&#34;&#34;
                Adds a material and color to an object
                Parameters:
                   obj: object

                   material_name: material&#39;s name

                   r, g, b: RGB color values

                   opacity: the opacity
                &#34;&#34;&#34;
                material = bpy.data.materials.get(material_name)
                if material is None:
                        material = bpy.data.materials.new(material_name)
                material.use_nodes = True
                principled_bsdf = material.node_tree.nodes[&#39;Principled BSDF&#39;]
                if principled_bsdf is not None:
                        #for i, o in enumerate(principled_bsdf.inputs):
                        #       print(i, o.name)
                        principled_bsdf.inputs[&#39;Base Color&#39;].default_value = (r, g, b, 0.5)
                        principled_bsdf.inputs[&#39;IOR&#39;].default_value = 0.0
                        principled_bsdf.inputs[&#39;Metallic&#39;].default_value = 1.0
                        if bpy.app.version[0] &lt; 4:
                                principled_bsdf.inputs[&#39;Specular&#39;].default_value = 1.0
                        else:
                                principled_bsdf.inputs[&#39;Specular IOR Level&#39;].default_value = 1.0
                        if bpy.app.version[0] &lt; 4:
                                principled_bsdf.inputs[&#39;Emission&#39;].default_value = (r, g, b, 0.5)
                        else:
                                principled_bsdf.inputs[&#39;Emission Color&#39;].default_value = (r, g, b, 0.5)
                        principled_bsdf.inputs[&#39;Emission Strength&#39;].default_value = 0.0
                        if opacity &lt; 1.0:
                                material.blend_method = &#39;BLEND&#39;
                                principled_bsdf.inputs[&#39;Alpha&#39;].default_value = opacity
                        else:
                                material.blend_method = &#39;OPAQUE&#39;
                                principled_bsdf.inputs[&#39;Alpha&#39;].default_value = 1.0
                obj.active_material = material
        #
        #
        #
        def add_ligth(self,location=[0,0,100],energy=3,direction=[0,0,-1]):
                &#34;&#34;&#34;
                Adds a ligth to the scene
                Parameters:
                   location: location point of the light

                   energy: energy of the ligth

                   direction: direction of the light
                &#34;&#34;&#34;
                l = bpy.data.lights.new(name=&#34;Light&#34;, type=&#39;SUN&#39;)
                l.energy = energy
                l.specular_factor = 4
                obj = self.objects.new(name=&#34;Light&#34;, object_data=l)
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.location = location
                n = Vector(direction)
                mat = Matrix(self.base)
                mat.transpose()
                n = mat @ n
                z = Vector([0,0,-1])
                quaternion = z.rotation_difference(n)
                obj.rotation_quaternion.rotate(quaternion)
                self.collection.objects.link(obj)
        #
        #
        #
        def add_ligths(self,energy=1):
                &#34;&#34;&#34;
                Adds diferent lights to the scene
                Parameters:
                   energy: energy of the lights
                &#34;&#34;&#34;
                self.add_ligth()
                self.add_ligth(location=[100,0,0],direction=[-1,0,0],energy=energy)
                self.add_ligth(location=[0,100,0],direction=[0,-1,0],energy=energy)
                self.add_ligth(location=[-100,0,0],direction=[1,0,0],energy=energy)
                self.add_ligth(location=[0,-100,0],direction=[0,1,0],energy=energy)
        #
        #
        #
        def components_in_base(self,vector=None):
                &#34;&#34;&#34;
                Returns the components of the vector &#39;vector&#39; in the basis determined by
                self.rotation and the basis self.base
                Parameters:
                   vector: components of the vector in the canonical basis
                &#34;&#34;&#34;
                if vector is None:
                        return Vector([0,0,0])
                if isinstance(vector,Vector):
                        u = vector
                else:
                        u = Vector(vector)
                if self.rotation is not None:
                        mat = self.rotation.quaternion.to_matrix()
                        mat.invert()
                        u = mat @ u
                mat = Matrix(self.base)
                mat.transpose()
                mat.invert()
                u = mat @ u
                return u
        #
        #
        #
        def coordinates_en_referencia(self,point=None):
                &#34;&#34;&#34;
                Returns the coordinates of the point &#39;point&#39; in the reference determined by
                self.origin, self.rotation and the basis self.base
                Parameters:
                   point: coordinates of the point in the canonical reference
                &#34;&#34;&#34;
                if point is None:
                        return Vector([0,0,0])
                if isinstance(point,Vector):
                        u = point
                else:
                        u = Vector(point)
                if self.rotation is not None:
                        mat = self.rotation.quaternion.to_matrix()
                        mat.invert()
                        u = mat @ u
                mat = Matrix(self.base)
                mat.transpose()
                mat.invert()
                u = mat @ (u - Vector(self.origin))
                return u
        #
        #
        #
        def set_cursor(self,origin=[0,0,0],direction=[1,0,0],axis=&#39;x&#39;):
                &#34;&#34;&#34;
                Sets the cursor position and direction
                Parameters:
                  origin: position of the cursor

                  direction: vector that indicates the direction of the axis &#39;axis&#39;

                  axis: &#39;x&#39;, &#39;y&#39; or &#39;z&#39;
                &#34;&#34;&#34;
                axis = axis.lower()
                if axis not in [&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]:
                        return
                eixos = {&#39;x&#39; : Vector([1,0,0]),
                                 &#39;y&#39; : Vector([0,1,0]),
                                 &#39;z&#39; : Vector([0,0,1])
                }
                if isinstance(direction,Vector):
                        d = direction
                else:
                        d = Vector(direction)
                x = eixos[axis]
                quaternion = x.rotation_difference(d)
                self.scene.cursor.location = origin
                self.scene.cursor.rotation_mode = &#39;QUATERNION&#39;
                self.scene.cursor.rotation_quaternion = quaternion
        #
        #
        #
        def set_cursor_rotation(self,origin=[0,0,0],rotation=Matrix.Identity(3)):
                &#34;&#34;&#34;
                Sets the rotation of the cursor
                Parameters:
                   origin: position of the cursor

                   rotation: matrix of a rotation
                &#34;&#34;&#34;
                m = rotation.copy()
                det = m.determinant()
                if abs(- det - 1.0) &lt; 0.1:
                        m[2] = - m[2]
                quaternion = m.to_quaternion()
                self.scene.cursor.location = origin
                self.scene.cursor.rotation_mode = &#39;QUATERNION&#39;
                self.scene.cursor.rotation_quaternion = quaternion.conjugated()
        #
        #
        #
        def draw_base_axis(self,scale=0.05,head_height=0.15,axis=0,name=&#34;Axis&#34;,positive=True,zaxis=True):
                &#34;&#34;&#34;
                Draws a reference axis given by self.origin, self.rotation and the basis self.base
                Parameters:
                   scale: scale of the cylinder

                   head_height: height of the head of the vector from self.base

                   axis: length of the coordinate axis. If the length is 0, only the basis vectors are drawn

                   name: name of the result object

                   positive: if True, draw the positive part of the axis

                   zaxis: if True, draw the z axis
                &#34;&#34;&#34;
                self.base_cilinder()
                self.base_cone()
                o = Vector([0,0,0])
                op = Vector(self.origin)
                color = 0

                if axis != 0 and axis &lt; 8:
                        scale /= 3

                base = self.base
                if not zaxis:
                        base = self.base[0:2]
                for vec in base:
                        #
                        # Draw the stem
                        #
                        v = Vector(vec)
                        t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                        obj = t.copy()
                        obj.name = &#34;Axis%d&#34; % (color + 1)
                        obj.data = obj.data.copy()
                        obj.location = o
                        obj.scale = (scale,scale,(v - o).length - 2 * head_height)
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if self.colors is not None and len(self.colors) &gt; color:
                                c = self.colors[color]
                                self.add_material(obj,c.name,c.r,c.g,c.b)
                        if self.rotation is not None:
                                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location = op
                        self.scene.collection.objects.link(obj)
                        #
                        # Draw the arrow
                        #
                        t = bpy.data.objects.get(&#34;Arrow_cone&#34;)
                        obj2 = t.copy()
                        obj2.name = &#34;Arrow&#34;
                        obj2.data = obj2.data.copy()
                        obj2.location =  v - 2 * head_height * v / v.length
                        obj2.scale = (scale + 0.05,scale + 0.05,head_height)
                        obj2.rotation_mode = &#39;QUATERNION&#39;
                        obj2.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if self.colors is not None and len(self.colors) &gt; color:
                                c = self.colors[color]
                                self.add_material(obj2,c.name,c.r,c.g,c.b)
                        if self.rotation is not None:
                                obj2.rotation_quaternion.rotate(self.rotation.quaternion)
                                obj2.location.rotate(self.rotation.quaternion)
                        obj2.location = op + obj2.location
                        self.scene.collection.objects.link(obj2)
                        #
                        # Draw the line
                        #
                        obj3 = None
                        if axis != 0:
                                v = axis * Vector(vec)
                                t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                                obj3 = t.copy()
                                obj3.name = &#34;Line&#34;
                                obj3.data = obj3.data.copy()
                                obj3.location = op - v
                                obj3.scale = (scale / 2,scale / 2,(2 * v).length)
                                obj3.rotation_mode = &#39;QUATERNION&#39;
                                obj3.rotation_quaternion = v.to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                                if self.colors is not None and len(self.colors) &gt; color:
                                        c = self.colors[color]
                                        self.add_material(obj3,c.name,c.r,c.g,c.b)
                                if self.rotation is not None:
                                        obj3.rotation_quaternion.rotate(self.rotation.quaternion)
                                if positive:
                                        obj3.location = op
                                else:
                                        if self.rotation is not None:
                                                v.rotate(self.rotation.quaternion)
                                        obj3.location = op - v
                                self.scene.collection.objects.link(obj3)
                        #
                        # Joint the three objects
                        #
                        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                        bpy.context.view_layer.objects.active = obj
                        obj.select_set(True)
                        obj2.select_set(True)
                        if obj3 is not None:
                                obj3.select_set(True)
                        bpy.ops.object.join()
                        color += 1
                #
                # Join all the axis
                #
                t1 = bpy.data.objects.get(&#34;Axis1&#34;)
                t1.name = name
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.context.view_layer.objects.active = t1
                t1.select_set(True)
                t2 = bpy.data.objects.get(&#34;Axis2&#34;)
                t2.select_set(True)
                if zaxis:
                        t3 = bpy.data.objects.get(&#34;Axis3&#34;)
                        t3.select_set(True)
                bpy.ops.object.join()
                self.delete_base_cilinder()
                self.delete_base_cone()
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return t1
        #
        #
        #
        def draw_vector(self,vector=None,canonica=False,color=&#34;Black&#34;,scale=0.05,arrow=True,head_height=0.15,axis=0,name=&#34;Vector&#34;,positive=True):
                &#34;&#34;&#34;
                Draw the vector with components &#39;vector&#39;
                Parameters:
                   vector: components of the vector

                   canonica: if True, the components are in the canonical basis, else they are in the basis self.base. Finally,
                      self.rotation is applied

                   color: color of the vector

                   scale: scale of the cylinder

                   arrow: if True draws the vector itself

                   head_height: height of the head of the vector

                   head_scale: scale of the head of the vector

                   axis: if not zero, draw also the line generated by the vector

                   positive: if axis is not zero and positive is True, draw only the positive part of the line
                      generated by the vector
                &#34;&#34;&#34;
                if vector is None:
                        return None
                if isinstance(vector,Vector):
                        vec = vector
                else:
                        vec = Vector(vector)
                if vec.length == 0:
                        return None
                self.base_cilinder()
                self.base_cone()
                o = Vector([0,0,0])
                op = Vector(self.origin)
                if color is not None:
                        color = Colors.color(color)
                v = vec
                if not canonica:
                        mat = Matrix(self.base)
                        mat.transpose()
                        v = mat @ vec

                if arrow:
                        t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                        obj = t.copy()
                        obj.name = name
                        obj.data = obj.data.copy()
                        obj.location = o
                        obj.scale = (scale,scale,(v - o).length - 2 * head_height)
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if color is not None:
                                self.add_material(obj,color.name,color.r,color.g,color.b)
                        if self.rotation is not None:
                                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location = op
                        self.scene.collection.objects.link(obj)

                        t = bpy.data.objects.get(&#34;Arrow_cone&#34;)
                        obj2 = t.copy()
                        obj2.data = obj2.data.copy()
                        obj2.name = &#34;Arrow&#34;
                        obj2.location =  v - 2 * head_height * v / v.length
                        obj2.scale = (1.05*scale,1.05*scale + 0.05,head_height)
                        obj2.rotation_mode = &#39;QUATERNION&#39;
                        obj2.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if color is not None:
                                self.add_material(obj2,color.name,color.r,color.g,color.b)
                        if self.rotation is not None:
                                obj2.rotation_quaternion.rotate(self.rotation.quaternion)
                                obj2.location.rotate(self.rotation.quaternion)
                        obj2.location = op + obj2.location
                        self.scene.collection.objects.link(obj2)

                obj3 = None
                if axis != 0:
                        v = axis * v / v.length
                        t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                        obj3 = t.copy()
                        if not arrow:
                                obj3.name = &#34;Line&#34;
                        else:
                                obj3.name = &#34;Generated&#34;
                        obj3.data = obj3.data.copy()
                        obj3.scale = (scale / 2,scale / 2,(2 * v).length)
                        obj3.rotation_mode = &#39;QUATERNION&#39;
                        obj3.rotation_quaternion = v.to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if color is not None:
                                self.add_material(obj3,color.name,color.r,color.g,color.b)
                        if self.rotation is not None:
                                obj3.rotation_quaternion.rotate(self.rotation.quaternion)
                        if positive:
                                obj3.location = op
                        else:
                                obj3.location = op - v
                        self.scene.collection.objects.link(obj3)

                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                if arrow:
                        bpy.context.view_layer.objects.active = obj
                elif axis != 0:
                        bpy.context.view_layer.objects.active = obj3
                if arrow:
                        obj.select_set(True)
                        obj2.select_set(True)
                if obj3 is not None:
                        obj3.select_set(True)
                if arrow:
                        bpy.ops.object.join()
                bpy.ops.object.shade_smooth()
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                self.delete_base_cilinder()
                self.delete_base_cone()
                bpy.context.view_layer.objects.active = None
                if arrow:
                        return obj
                if axis != 0:
                        return obj3
                return None
        #
        #
        #
        def comp_times_vector(self,u,v):
                &#34;&#34;&#34;
                Computes the vectorial product u x v
                Parameters:
                   u, v: two Vectors
                &#34;&#34;&#34;
                return Vector([u.x * v.x,u.y * v.y,u.z * v.z])
        #
        #
        #
        def draw_line(self,start=[1,1,1],end=[10,10,10],scale=0.05,name=&#34;Line&#34;,color=&#34;Black&#34;):
                &#34;&#34;&#34;
                Draws a line from the point start to the point end. The reference given by self.origin,
                self.rotation and the basis self.base is used
                Parameters:
                   start: starting point of the line

                   end: ending point of the line

                   scale: scale of the cylinder

                   name: name of the object

                   color: color of the vector
                &#34;&#34;&#34;
                if start is None or end is None:
                        return
                self.base_cilinder()
                o = Vector([0,0,0])
                op = Vector(self.origin)
                if isinstance(start,Vector):
                        u = start
                else:
                        u = Vector(start)
                if isinstance(end,Vector):
                        v = end
                else:
                        v = Vector(end)
                mat = Matrix(self.base)
                mat.transpose()
                u = mat @ u
                v = mat @ v
                l = (v - u).length
                t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                obj = t.copy()
                obj.name = name
                obj.location = u
                obj.scale = (scale / 2,scale / 2,l)
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.rotation_quaternion = (v - u).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                if color is not None:
                        c = Colors.color(color)
                        self.add_material(obj,c.name,c.r,c.g,c.b)
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                obj.location = obj.location + op
                self.scene.collection.objects.link(obj)
                bpy.ops.object.shade_flat()
                self.delete_base_cilinder()
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_components(self,vector=None,color=&#34;Cyan&#34;,name=&#34;Components&#34;,scale=0.0075):
                &#34;&#34;&#34;
                Draws the components of the the vector &#39;vector&#39; in the reference given by self.origin,
                self.rotation and the basis self.base
                Parameters:
                   vector: the vector

                   color: color of the lines of components

                   name: name of the object

                   scale: scale of the lines
                &#34;&#34;&#34;
                if vector is None:
                        return
                if isinstance(vector,Vector):
                        v = vector
                else:
                        v = Vector(vector)
                mat = Matrix(self.base)
                mat.transpose()
                list = [[0,0,0],[1,0,0],[1,1,0],[0,1,0],[0,0,1],[1,0,1],[1,1,1],[0,1,1]]
                lines = [[0,1],[1,2],[2,3],[0,3],[0,4],[1,5],[2,6],[3,7],[4,5],[5,6],[6,7],[4,7]]
                vecs = [self.comp_times_vector(v,Vector(x)) for x in list]
                count = 0
                for first, last in lines:
                        if count == 0:
                                this = name
                        else:
                                this = f&#34;Line{count}&#34;
                        count += 1
                        self.draw_line(start=vecs[first],end=vecs[last],scale=scale,name=this,color=color)
                t = bpy.data.objects.get(name)
                list = [t]
                for count in range(1,12):
                        obj = bpy.data.objects.get(f&#34;Line{count}&#34;)
                        if obj is not None:
                                list.append(obj)
                t = self.join(list)
                bpy.context.view_layer.objects.active = None
                return t
        #
        #
        #
        def draw_vectors(self,vectors=[],canonica=False,color=&#34;Black&#34;,scale=0.05,head_height=0.2,name=&#34;Vectors&#34;,axis=0):
                &#34;&#34;&#34;
                Draws a list of vectors.
                Parameters:
                   vectors: list of vectors

                   anonica: if True, the the vectors are expressed in the canonical basis.

                   color: color of the vectors

                   scale: scale of the cylinder

                   head_height: height of the head of the vector

                   axis: if not zero, draw also the line generated by every vector
                &#34;&#34;&#34;
                if len(vectors) == 0:
                        return
                count = 0
                for v in vectors:
                        if count == 0:
                                this = name
                        else:
                                this = f&#34;Vector{count}&#34;
                        count += 1
                        t = self.draw_vector(v,canonica,color=color,scale=scale,head_height=head_height,axis=axis,name=this)
                t = bpy.data.objects.get(name)
                list = [t]
                for count in range(1,len(vectors)+1):
                        obj = bpy.data.objects.get(f&#34;Vector{count}&#34;)
                        if obj is not None:
                                list.append(obj)
                t = self.join(list)
                return t
        #
        #
        #
        def draw_plane(self,normal=None,base=None,sizex=10,sizey=10,color=&#34;AzureBlueDark&#34;,name=&#39;Plane&#39;,opacity=1.0,thickness=0.01):
                &#34;&#34;&#34;
                Draws a plane with normal vector or base vectors. It passes through the point self.origin.
                Only normal or base can be not None
                Parameters:
                   normal: normal vector to the plane

                   base: list of two independent vectors

                   sizex: x-size of the plane

                   sizey: y-size of the plane

                   color: color of the plane

                   name: name of the plane

                   opacity: opacity of the plane

                   thickness: thickness of the plane
                &#34;&#34;&#34;
                if sizex == 0.0:
                        return
                bpy.ops.mesh.primitive_plane_add(size=sizex,enter_editmode=True,location=(0, 0, 0))
                bpy.context.object.name = name
                ##### bpy.ops.mesh.subdivide(number_cuts=6,quadcorner=&#39;INNERVERT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj = bpy.data.objects.get(name)
                if sizey is not None and sizey != 0.0:
                        t = sizey / sizex
                        obj.scale = [1,t,1]
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                if normal is not None and base is not None:
                        return
                if base is not None:
                        if len(base) != 2:
                                return
                        if isinstance(base[0],Vector):
                                v1 = base[0]
                        else:
                                v1 = Vector(base[0])
                        if isinstance(base[1],Vector):
                                v2 = base[1]
                        else:
                                v2 = Vector(base[1])

                        if self.base is None:
                                normal = v1.cross(v2)
                        else:
                                u1 = v1[0]*self.base[0] + v1[1]*self.base[1] + v1[2]*self.base[2]
                                u2 = v2[0]*self.base[0] + v2[1]*self.base[1] + v2[2]*self.base[2]
                                normal = u1.cross(u2)
                if normal is not None and normal != Vector([0,0,0]):
                        z = Vector([0,0,1])
                        quaternion = z.rotation_difference(normal)
                        obj.rotation_quaternion.rotate(quaternion)
                        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def simple_curve(self,f=None,tmin=0.0,tmax=1.0,steps=25,name=&#34;Simple curve&#34;,symmetry=None,draw=False):
                &#34;&#34;&#34;
                Return a curve defined by the parametrization f
                Parameters:
                   f: Parametrization of the curve

                   tmin: minimum value of the parameter

                   tmax: maximum value of the parameter

                   steps: number of steps

                   name: name of the curve

                   symmetry: None or a value in the list (&#39;XY&#39;,&#39;XZ&#39;,&#39;YZ&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;,&#39;O&#39;). Symmetry of the curve

                   draw: if True, the curve is drawn
                &#34;&#34;&#34;
                if f is None:
                        return None

                delta = (tmax - tmin)/steps
                t = tmin
                bm = bmesh.new()
                verts = []
                verts2 = []

                for k in range(steps + 1):
                        p = f(t)
                        q = None
                        verts.append(bm.verts.new(p))
                        if symmetry == &#39;XY&#39;:
                                q = (p[0],p[1],-p[2])
                        elif symmetry == &#39;XZ&#39;:
                                q = (p[0],-p[1],p[2])
                        elif symmetry == &#39;YZ&#39;:
                                q = (-p[0],p[1],p[2])
                        elif symmetry == &#39;X&#39;:
                                q = (p[0],-p[1],-p[2])
                        elif symmetry == &#39;Y&#39;:
                                q = (-p[0],p[1],-p[2])
                        elif symmetry == &#39;Z&#39;:
                                q = (-p[0],-p[1],p[2])
                        elif symmetry == &#39;O&#39;:
                                q = (-p[0],-p[1],-p[2])

                        if q is not None:
                                verts2.append(bm.verts.new(q))
                        t += delta
                        if t &gt; tmax:
                                t = tmax

                for i in range(len(verts) - 1):
                        bm.edges.new([verts[i], verts[i+1]])
                        if len(verts2) &gt; 0:
                                bm.edges.new([verts2[i], verts2[i+1]])

                me = bpy.data.meshes.new(&#39;placeholder_mesh&#39;)
                obj = bpy.data.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()

                if draw:
                        self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_elliptic_paraboloid(self,a=0.5,xmin=0.0,xmax=3.0,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;EllipticParaboloid&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws an elliptic paraboloid from the parabola z=a*t^2
                Parameters:
                   a: coefficient of the parabola

                   xmin: minimum value of x

                   xmax: maximum value of x

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                obj = self.simple_curve(f=lambda t:(t,0,a*t**2),tmin=xmin,tmax=xmax,steps=steps,name=name)
                modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                modifier.angle = 2 * math.pi
                modifier.steps = 128
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                self.scene.collection.objects.link(obj)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_one_sheet_hyperboloid(self,a=2.0,b=2.0,xmin=math.sqrt(2),xmax=5.0,steps=256,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperboloidOneSheet&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws a one sheet hyperboloid from the hyperbole z = \pm a*sqrt(x^2-b) in the XZ plane
                Parameters:
                   a, b: coefficients of the hyperbole

                   xmin: minimum value of x

                   xmax: maximum value of x

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                if xmin &lt; math.sqrt(b):
                        xmin = math.sqrt(b)
                delta = (xmax - xmin) / steps
                x = xmax
                bm = bmesh.new()
                verts = []

                for k in range(steps + 1):
                        if x &lt; math.sqrt(b):
                                z = 0.0
                        else:
                                z = - a * math.sqrt(x**2 - b)
                        verts.append(bm.verts.new((x,0,z)))
                        x -= delta
                x = math.sqrt(b)
                for k in range(steps):
                        x += delta
                        if x**2 &lt; b:
                                z = 0.0
                        else:
                                z = a * math.sqrt(x**2 - b)
                        verts.append(bm.verts.new((x,0,z)))

                for i in range(len(verts) - 1):
                        bm.edges.new([verts[i], verts[i+1]])

                me = self.meshes.new(&#39;placeholder_mesh&#39;)
                obj = self.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()
                modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                modifier.angle = 2 * math.pi
                modifier.steps = 128
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_two_sheets_hyperboloid(self,a=2.0,b=1.0,xmin=0.0,xmax=5.0,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperboloidTwoSheets&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws a two sheet hyperboloid from the hyperbole z = \pm a * math.sqrt(x**2+b) in the XZ plane
                Parameters:
                   a, b: coefficients of the hyperbole

                   xmin: minimum value of x

                   xmax: maximum value of x

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                delta = (xmax - xmin) / steps
                x = xmax
                bm = bmesh.new()
                verts = []
                count = 2 * steps + 2
                sign = 1
                for k in range(count):
                        if k == steps + 1:
                                sign = -1
                        z = sign * a * math.sqrt(x**2+b)
                        verts.append(bm.verts.new((x,0,z)))
                        if k == steps and xmin &gt; 0:
                                x = xmin
                        else:
                                x = x - sign * delta
                        if k == 0 or k == steps + 1:
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;placeholder_mesh&#39;)
                obj = self.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()

                modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                modifier.angle = 2 * math.pi
                modifier.steps = 128
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_cone(self,a=1.0,xmin=0.0,xmax=5.0,steps=50,scale=[1,1,1],half=False,color=&#34;AzureBlueDark&#34;,name=&#34;Cone&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws a cone from the line z = a*x in the XZ plane
                Parameters:
                   a: slope of the line

                   xmin: minimum value of x

                   xmax: maximum value of x

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   half: if True, draws half cone

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                delta = (xmax - xmin) / steps
                x = xmax
                bm = bmesh.new()
                verts = []
                count = 2 * steps + 2
                if xmin == 0.0:
                        count = 2 * steps + 1
                if half:
                        count = steps + 1
                for k in range(count):
                        z = a * x
                        verts.append(bm.verts.new((x,0,z)))
                        if k == steps and xmin &gt; 0:
                                x = - xmin
                        else:
                                x -= delta
                        if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;placeholder_mesh&#39;)
                obj = self.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()

                modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                modifier.angle = 2 * math.pi
                modifier.steps = 128
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_parabolic_cylinder(self,p=0.25,xmin=0.0,xmax=6.0,length=20,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;ParabolicCylinder&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws a parabolic cylinder from the parabola z=p*x^2 in the XZ plane
                Parameters:
                   p: coefficients of the parabola

                   xmin: minimum value of x

                   xmax: maximum value of x

                   length: length in the Y direction

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                delta = (xmax - xmin) / steps
                x = xmax
                bm = bmesh.new()
                verts = []
                count = 2 * steps + 2
                if xmin == 0.0:
                        count = 2 * steps + 1
                for k in range(count):
                        z = p * x**2
                        verts.append(bm.verts.new((x,0,z)))
                        if k == steps and xmin &gt; 0:
                                x = - xmin
                        else:
                                x -= delta
                        if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;ParabolicCylinderMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()

                bpy.context.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = obj
                bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
                bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
                bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
                bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0, length, 0),&#34;constraint_axis&#34;:(False, True, False),&#34;use_accurate&#34;:True})
                bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj.select_set(True)
                bpy.ops.transform.translate(value=(0, -length/2, 0),constraint_axis=(False, True, False))
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                obj.select_set(False)

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_hyperbolic_cylinder(self,a=1.0,b=4.0,xmin=2.0,xmax=6.0,length=20,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicCylinder&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws an hyperbolic cylinder from the hyperbole y = a * sqrt(x**2 - b) in the XY plane
                Parameters:
                   a, b: coefficients of the hyperbole

                   xmin: minimum value of x

                   xmax: maximum value of x

                   length: length in the Z direction

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                if xmin &lt; math.sqrt(b):
                        xmin = math.sqrt(b)
                delta = (xmax-xmin)/steps
                bm = bmesh.new()
                verts = []
                count = 2 * steps + 2
                if xmin == 0.0:
                        count = 2 * steps + 1
                for q, d in [[1,0],[-1,count]]:
                        x = xmax
                        sign = 1
                        for k in range(count):
                                if k == steps + 1:
                                        sign = -1
                                if x &lt; math.sqrt(b):
                                        x = math.sqrt(b)
                                y = sign * a * math.sqrt(x**2 - b)
                                verts.append(bm.verts.new((q * x,y,0)))
                                if k == steps and xmin &gt; math.sqrt(b):
                                        x = xmin
                                else:
                                        x = x - sign * delta
                                if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                                        continue
                                bm.edges.new([verts[d + k-1], verts[d + k]])

                me = self.meshes.new(&#39;HyperboliclinderMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()

                self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = obj
                bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
                bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
                bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
                bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0,0,length),&#34;constraint_axis&#34;:(False,False,True),&#34;use_accurate&#34;:True})
                bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj.select_set(True)
                bpy.ops.transform.translate(value=(0,0,-length/2),constraint_axis=(False,False,True))
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                obj.select_set(False)

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_elliptic_cylinder(self,a=8.0,b=5.0,amin=0.0,amax=2*math.pi,length=20,steps=200,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;EllipticCylinder&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws an eliptic cylinder from the ellipse
                  x = a*cos(t)
                  y = b*sin(t)
                in the XY plane
                Parameters:
                   a, b: coefficients of the ellipsw

                   amin: minimum value of the angle t

                   amax: maximum value of the angle t

                   length: length in the Z direction

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                if amin &lt; 0.0:
                        amin = 0.0
                if amax &gt; 2 * math.pi:
                        amax = 2 * math.pi
                delta = (amax-amin)/steps
                bm = bmesh.new()
                verts = []
                t = amin
                for k in range(steps + 1):
                        x = a * math.cos(t)
                        y = b * math.sin(t)
                        verts.append(bm.verts.new((x,y,0)))
                        t += delta
                        if k == 0:
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;EllipticCylinderMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()
                self.scene.collection.objects.link(obj)

                bpy.context.view_layer.objects.active = obj
                bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
                bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
                bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
                bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0,0,length),&#34;constraint_axis&#34;:(False,False,True),&#34;use_accurate&#34;:True})
                bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj.select_set(True)
                bpy.ops.transform.translate(value=(0,0,-length/2),constraint_axis=(False,False,True))
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                obj.select_set(False)

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_hyperbolic_paraboloid(self,a=0.2,b=0.4,xmax=10.0,ymax=10.0,steps=64,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicParaboloid&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws an hyperbolic paraboloid with equation z = a*x^2 - b*y^2
                Parameters:
                   a, b: coefficients of the parabolic hyperboloid

                   xmax: maximum  value of x

                   ymax: maxim value y

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                equ = lambda x,y: (x,y,a*x**2-b*y**2)
                obj = self.draw_surface(eq=equ,umin=-xmax,umax=xmax,usteps=steps,vmin=-ymax,vmax=ymax,vsteps=steps,thickness=thickness,opacity=opacity,pmax=0,name=&#34;Hyperbolic paraboloid&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),wrap_u=False,wrap_v=False,close_v=False)
                obj.scale = scale
                return obj
        #
        #
        #
        def draw_ellipsoid(self,radius=5.0,scale=[1.2,1.8,0.8],color=&#34;AzureBlueDark&#34;,name=&#34;Ellipsoid&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws en ellipsoid
                Parameters:
                   radius: radius of the sphere

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_uv_sphere_add(segments=128, ring_count=128, radius=radius, enter_editmode=False, location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                obj.select_set(False)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_plane_surface(self,origin=None,normal=None,base=None,sizex=10,sizey=10,vectors=False,scalelines=0.05,scalevector=0.01,
                                                color=&#34;AzureBlueDark&#34;,linecolor=&#34;BlueDarkDull&#34;,vectorcolor=&#34;Black&#34;,name=&#34;Plane&#34;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a plane with normal vector or base vectors. It passes through the point origin.
                Only normal or base can be not None
                Parameters:
                   origin: a point in the plane

                   normal: normal vector to the plane

                   base: list of two independent vectors

                   sizex: x-size of the plane

                   sizey: y-size of the plane

                   vectors: if True, draw the generators of the plane

                   scalelines: scale of the lines limiting the plane

                   scalevector: scale of the generators

                   color: color of the plane

                   linecolor: color of the lines limiting the plane

                   vectorcolor: color of the generators

                   name: name of the plane

                   opacity: opacity of the plane

                   thickness: thickness of the plane
                &#34;&#34;&#34;
                if normal is not None and base is not None:
                        return
                if normal is None and base is None:
                        return
                mat = Matrix(self.base)
                mat.transpose()
                if normal is not None:
                        if not isinstance(normal,Vector):
                                normal= Vector(normal)
                        normal = mat @ normal
                if base is not None:
                        if len(base) != 2:
                                return
                        if isinstance(base[0],Vector):
                                v1 = base[0]
                        else:
                                v1 = Vector(base[0])
                        if isinstance(base[1],Vector):
                                v2 = base[1]
                        else:
                                v2 = Vector(base[1])
                        v1 = mat @ v1
                        v2 = mat @ v2
                        normal = v1.cross(v2)

                if normal == Vector([0,0,0]):
                        return

                steps = 4
                delta = sizex / steps
                x = - sizex / 2
                bm = bmesh.new()
                verts = []
                for k in range(steps + 1):
                        verts.append(bm.verts.new((x,0,0)))
                        x += delta
                        if k == 0:
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;PlaneSurfaceMesh&#39;)
                obj = self.objects.new(&#39;PlaneSurface&#39;, me)
                bm.to_mesh(me)
                bm.free()

                bpy.context.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = obj
                bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
                bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
                bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
                bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0, sizey, 0),&#34;constraint_axis&#34;:(False, True, False),&#34;use_accurate&#34;:True})
                bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj.select_set(True)
                bpy.ops.transform.translate(value=(0, -sizey/2, 0),constraint_axis=(False, True, False))
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                obj.select_set(False)

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                if origin is not None:
                        if isinstance(origin,Vector):
                                op = op + origin
                        else:
                                op = op + Vector(origin)
                obj.location = o
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                lines = None
                vecs = None
                s = 0.0
                nodes = [[1,1,0],[-1,1,0],[-1,-1,0],[1,-1,0]]
                nodes = [self.comp_times_vector(Vector([sizex / 2,sizey / 2,0]),Vector(x)) for x in nodes]
                edges = [[0,1],[1,2],[2,3],[3,0]]

                if scalelines &gt; 0.0:
                        aux = self.origin
                        self.origin = Vector([0,0,0])
                        objects = []
                        aux2 = self.base
                        self.reset_base()
                        for edge in edges:
                                l = self.draw_line(start=nodes[edge[0]],end=nodes[edge[1]],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)
                        self.set_origin(aux)
                        self.set_base(aux2)

                if lines is not None:
                        obj = self.join([obj,lines])

                if vectors:
                        vecs = self.draw_vectors(nodes,True,color=vectorcolor,scale=scalevector,head_height=0.2,name=&#34;Vectors&#34;,axis=0)

                if vecs is not None:
                        obj = self.join([obj,vecs])
                obj.name = name

                if isinstance(normal,Vector):
                        n = normal
                else:
                        n = Vector(normal)
                z = Vector([0,0,1])
                quaternion = z.rotation_difference(n)
                tmp = obj.rotation_quaternion
                quaternion = tmp @ quaternion
                obj.rotation_quaternion = quaternion
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_point(self,radius=0.1,location=(0,0,0),name=&#34;Point&#34;,color=&#34;Black&#34;,opacity=1.0):
                &#34;&#34;&#34;
                Draws a point (in the reference self.origin, self.base)
                Parameters:
                   radius: radius of the point

                   location: location of the point

                   name: name of the point

                   color: color of the point

                   opacity: opacity of the point
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_uv_sphere_add(segments=16, ring_count=16, radius=radius, enter_editmode=False, location=location)
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                if not isinstance(location,Vector):
                        location = Vector(location)
                mat = Matrix(self.base)
                mat.transpose()
                location = mat @ location

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = 0.1
                modifier.offset = 0.0
                c = Colors.color(color)
                op = Vector(self.origin)
                obj.location = op + location
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                bpy.ops.object.shade_smooth()
                obj.select_set(False)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_cube(self,origin=None,scale=[1,1,1],scalelines=0.05,vectors=False,color=&#34;Blue&#34;,linecolor=&#34;Red&#34;,vectorcolor=&#34;Black&#34;,name=&#39;Parallelepiped&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a rectangular parallelepiped
                Parameters:
                   origin: center of the parallelepiped

                   scale: scale of the sides of the parallelepiped

                   scalelines: scale of the edges of the parallelepiped

                   vectors: if True, draws vectors from the origin to the vertices

                   color: color of the parallelepiped

                   linecolor: color of the edges

                   vectorcolor: color of the vectors

                   name: name of the parallelepiped

                   opacity: opacity of the parallelepiped

                   thickness: thickness of the parallelepiped
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_cube_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                if origin is not None:
                        if isinstance(origin,Vector):
                                op = op + origin
                        else:
                                op = op + Vector(origin)
                obj.location = o
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                vecs = None
                s = 0.0
                nodes = [[1+s,1+s,1+s],[-1-s,1+s,1+s],[-1-s,-1-s,1+s],[1+s,-1-s,1+s],
                                [1+s,1+s,-1-s],[-1-s,1+s,-1-s],[-1-s,-1-s,-1-s],[1+s,-1-s,-1-s]]
                nodes = [self.comp_times_vector(Vector(scale),Vector(x)) for x in nodes]
                edges =[[0,1],[1,2],[2,3],[3,0],[0,4],[1,5],[2,6],[3,7],[4,5],[5,6],[6,7],[7,4]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=op+nodes[edge[0]],end=op+nodes[edge[1]],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                if vectors:
                        vecs = self.draw_vectors(nodes,color=vectorcolor,scale=0.05,head_height=0.2,name=&#34;Vectors&#34;,axis=0)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.scale = scale

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                if lines is not None:
                        obj = self.join([obj,lines])

                if vecs is not None:
                        obj = self.join([obj,vecs])
                return obj
        #
        #
        #
        def draw_parallelepiped(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],u3=[0,0,1],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Parallelepiped&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a parallelepiped
                Parameters:
                   origin: base vertex of the parallelepiped

                   u1, u2, u3: vectors that gives the edges

                   scalelines: scale of the edges of the parallelepiped

                   color: color of the parallelepiped

                   linecolor: color of the edges

                   name: name of the parallelepiped

                   opacity: opacity of the parallelepiped

                   thickness: thickness of the parallelepiped
                &#34;&#34;&#34;
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                if not isinstance(u3,Vector):
                        u3 = Vector(u3)

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2
                u3 = mat @ u3

                bpy.ops.mesh.primitive_cube_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                verts = obj.data.vertices
                verts[0].co = op
                verts[1].co = op + u3
                verts[2].co = op + u2
                verts[3].co = op + u2 + u3
                verts[4].co = op + u1
                verts[5].co = op + u1 + u3
                verts[6].co = op + u1 + u2
                verts[7].co = op + u1 + u2 + u3

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                s = 0.0
                edges =[[0,1],[0,2],[0,4],[1,3],[1,5],[2,3],[2,6],[3,7],[4,5],[4,6],[5,7],[6,7]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj
        #
        #
        #
        def draw_tetrahedron(self,origin=[0,0,0],u1=[2,0,0],u2=[2*math.cos(math.pi/3),2*math.sin(math.pi/3),0],u3=[(2+2*math.cos(math.pi/3))/3,2*math.sin(math.pi/3)/3,2],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Tetrahedron&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a tetrahedron
                Parameters:
                   origin: base vertex of the tetrahedron

                   u1, u2, u3: vectors that gives the edges

                   scalelines: scale of the edges of the tetrahedron

                   color: color of the tetrahedron

                   linecolor: color of the edges

                   name: name of the tetrahedron

                   opacity: opacity of the tetrahedron

                   thickness: thickness of the tetrahedron
                &#34;&#34;&#34;
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                if not isinstance(u3,Vector):
                        u3 = Vector(u3)

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2
                u3 = mat @ u3

                bpy.ops.mesh.primitive_solid_add()
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                verts = obj.data.vertices
                verts[0].co = op + u3
                verts[1].co = op
                verts[2].co = op + u1
                verts[3].co = op + u2

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                s = 0.0
                edges =[[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj
        #
        #
        #
        def draw_pyramid(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],u3=[0.5,0.5,1],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Pyramid&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a pyramid
                Parameters:
                   origin: base vertex of the pyramid

                   u1, u2, u3: vectors that gives the edges

                   scalelines: scale of the edges of the pyramid

                   color: color of the pyramid

                   linecolor: color of the edges

                   name: name of the pyramid

                   opacity: opacity of the pyramid

                   thickness: thickness of the pyramid
                &#34;&#34;&#34;
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                if not isinstance(u3,Vector):
                        u3 = Vector(u3)

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2
                u3 = mat @ u3

                bpy.ops.mesh.primitive_cone_add(radius1=1, radius2=0, depth=2, enter_editmode=False, align=&#39;WORLD&#39;,vertices=4)
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                verts = obj.data.vertices
                verts[0].co = op
                verts[1].co = op + u1
                verts[2].co = op + u1 + u2
                verts[3].co = op + u2
                verts[4].co = op + u3

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                s = 0.0
                edges =[[0,1],[0,3],[0,4],[1,2],[1,4],[2,3],[2,4],[3,4]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj
        #
        #
        #
        def draw_parallelogram(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Parallelogram&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a parallelogram
                Parameters:
                   origin: base vertex of the parallelogram

                   u1, u2: vectors that gives the edges

                   scalelines: scale of the edges of the parallelogram

                   color: color of the parallelogram

                   linecolor: color of the edges

                   name: name of the parallelogram

                   opacity: opacity of the parallelogram

                   thickness: thickness of the parallelogram
                &#34;&#34;&#34;
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2

                bpy.ops.mesh.primitive_plane_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                verts = obj.data.vertices
                verts[0].co = op
                verts[1].co = op + u1
                verts[2].co = op + u2
                verts[3].co = op + u1 + u2

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                s = 0.0
                edges =[[0,1],[0,2],[1,3],[2,3]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj
        #
        #
        #
        def draw_polygon(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],points=[[0,0],[1,0],[0,1]],scalelines=0.075,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Polygon&#39;,opacity=1.0,thickness=0.0,vectors=None,scalevectors=0.01):
                &#34;&#34;&#34;
                Draws a polygon
                Parameters:
                   origin: base vertex of the polygon

                   u1, u2: base vectors for the polygon

                   points: list of coordinates of points. The coordinates are taken in the reference {origin; u1, u2}

                   scalelines: scale of the edges of the polygon

                   color: color of the polygon

                   linecolor: color of the edges

                   name: name of the polygon

                   opacity: opacity of the polygon

                   thickness: thickness of the polygon
                &#34;&#34;&#34;
                if len(points) &lt; 3:
                        return
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                for i in range(len(points)):
                        if not isinstance(points[i],Vector):
                                points[i] = Vector(points[i])

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2

                bpy.ops.curve.simple(Simple_Type=&#39;Polygon&#39;,Simple_sides=len(points),align=&#39;WORLD&#39;,location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)

                baricentre = Vector([0,0,0])
                verts = obj.data.splines[0].bezier_points
                for i in range(len(verts)):
                        verts[i].co = op + points[i][0] * u1 + points[i][1] * u2
                        baricentre += verts[i].co
                baricentre /= len(verts)

                for i in range(len(verts)):
                        verts[i].co -= baricentre
                obj.location = baricentre

                obj.select_set(True)
                bpy.ops.object.convert(target=&#39;MESH&#39;)

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                ps = [op + points[i][0] * u1 + points[i][1] * u2 for i in range(len(points))]
                lines = None
                if scalelines &gt; 0.0:
                        objects = []
                        for i in range(len(points)):
                                l = self.draw_line(start=ps[i],end=ps[(i + 1) % len(points)],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                if vectors is not None:
                        old = self.origin
                        self.set_origin(op)
                        ps = [points[i][0] * u1 + points[i][1] * u2 for i in range(len(points))]
                        vecs = self.draw_vectors(ps,color=vectors,scale=scalevectors)
                        self.set_origin(old)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])
                if vectors is not None:
                        obj = self.join([obj,vecs])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj
        #
        #
        #
        def draw_regular_polygon(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],vertexs=5,radius=1,scalelines=0.075,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;RegularPolygon&#39;,opacity=1.0,thickness=0.0,vectors=None):
                &#34;&#34;&#34;
                Draws a regular polygon
                Parameters:
                   origin: base vertex of the polygon

                   u1, u2: base vectors for the polygon

                   vertexs: number of vertices of the polygon

                   radius: radius of the polygon

                   scalelines: scale of the edges of the polygon

                   color: color of the polygon

                   linecolor: color of the edges

                   name: name of the polygon

                   opacity: opacity of the polygon

                   thickness: thickness of the polygon
                &#34;&#34;&#34;
                angle = 2*math.pi/vertexs
                points = [[radius*math.cos(i*angle),radius*math.sin(i*angle)] for i in range(vertexs)]
                return self.draw_polygon(origin=origin,u1=u1,u2=u2,points=points,scalelines=scalelines,color=color,linecolor=linecolor,name=name,opacity=opacity,thickness=thickness,vectors=vectors,scalevectors=radius/400)
        #
        #
        #
        def draw_triangle(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],points=[[0,0],[1,0],[0,1]],scalelines=0.075,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#34;Triangle&#34;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a triangle. It&#39;s a polygon with three vertices
                Parameters:
                   origin: base vertex of the triangle

                   u1, u2: base vectors for the triangle

                   points: list of coordinates of points. The coordinates are taken in the reference {origin; u1, u2}

                   scalelines: scale of the edges of the triangle

                   color: color of the triangle

                   linecolor: color of the edges

                   name: name of the triangle

                   opacity: opacity of the triangle

                   thickness: thickness of the triangle
                &#34;&#34;&#34;
                if len(points) != 3:
                        return
                self.draw_polygon(origin=origin,u1=u1,u2=u2,points=points,scalelines=scalelines,color=color,linecolor=linecolor,name=name,opacity=opacity,thickness=thickness)

        #
        #
        #
        def draw_points(self,points=[],name=&#39;Points&#39;,color=&#34;Blue&#34;,opacity=1):
                &#34;&#34;&#34;
                Draws a list of points
                Parameters:
                   points: list of points

                   name: name of the list of points

                   color: color of the points

                   opacity: opacity of the points
                &#34;&#34;&#34;
                bm = bmesh.new()
                verts = []
                for p in points:
                        verts.append(bm.verts.new(p))

                me = self.meshes.new(&#39;PointsMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()
                self.scene.collection.objects.link(obj)
                return obj
        #
        #
        #
        def draw_mesh(self,mesh=None,name=&#39;Mesh&#39;,color=&#34;Blue&#34;,opacity=1):
                &#34;&#34;&#34;
                Draws a mesh. This function is used by other functions
                Parameters:
                   mesh: the mesh to be drawn

                   name: name of the mesh

                   color: color of the mesh

                   opacity: opacity of the mesh
                &#34;&#34;&#34;
                bm = bmesh.new()
                verts = []
                for p in mesh.points:
                        verts.append(bm.verts.new(p))
                edges = [[0,1],[1,2],[2,3],[3,0]]
                for s in mesh.simplices:
                        for e in edges:
                                v = Vector(mesh.points[s[e[0]]]) - Vector(mesh.points[s[e[1]]])
                                edge = [verts[s[e[0]]],verts[s[e[1]]]]
                                try:
                                        bm.edges.new(edge)
                                except:
                                        pass
                me = self.meshes.new(&#39;PointsMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()
                self.scene.collection.objects.link(obj)
                return obj
        #
        #
        #
        def join(self,list):
                &#34;&#34;&#34;
                Joins a list of objects
                Parameters:
                   list: list of objects
                &#34;&#34;&#34;
                if len(list) &lt;= 1:
                        return
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.context.view_layer.objects.active = list[0]
                for obj in list:
                        obj.select_set(True)
                bpy.ops.object.join()
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                return list[0]
        #
        #
        #
        def vectors_to_quaternion(self,u1=Vector([1,0,0]),u2=Vector([0,1,0])):
                &#34;&#34;&#34;
                Returns the quaternion correspondint to the base {v1,v2,v3}
                u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
                       v1 = u1
                           v2 = u2 - u2.project(v1)
                           v1.normalize()
                           v2.normalize()
                           v3 = v1.cross(v2)
                &#34;&#34;&#34;
                if isinstance(u1,Vector):
                        v1 = u1
                else:
                        v1 = Vector(u1)
                if isinstance(u2,Vector):
                        v2 = u2
                else:
                        v2 = Vector(u2)
                v2 = v2 - v2.project(v1)
                v1.normalize()
                v2.normalize()
                v3 = v1.cross(v2)
                mat = Matrix([v1,v2,v3])
                mat.transpose()
                return mat.to_quaternion()
        #
        #
        #
        def ellipsoid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Ellipsoid&#34;,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an ellipsoid
                Parameters:
                   o: center of the ellipsoid

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
                       v1 = u1
                           v2 = u2 - u2.project(v1)
                           v1.normalize()
                           v2.normalize()
                           v3 = v1.cross(v2)

                   a2, b2, c2: squares of semi-axes of the ellipsoid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 + z&#39;^2/c^2 = 1

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the ellipsoid

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -pmax and pmax

                   thickness: thickness of the ellipsoid

                   opacity: opaccity of the ellipsoid
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                c = math.sqrt(c2)
                self.draw_ellipsoid(radius=1,scale=[a,b,c],color=color,name=name,thickness=thickness,opacity=opacity)
        #
        #
        #
        def sphere(self,o=[0,0,0],r2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Sphere&#34;,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws a sphere of center &#39;o&#39; and radius squared equal to &#39;r2&#39;
                Parameters:
                   o: center of the spherecmax=15

                   r2: radius of the sphere squared

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the sphere

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the sphere

                   opacity: opacity of the sphere
                &#34;&#34;&#34;
                u1 = Vector([1,0,0])
                u2 = Vector([0,1,0])
                return self.ellipsoid(o=o,u1=u1,u2=u2,a2=r2,b2=r2,c2=r2,principal=principal,canonica=canonica,color=color,name=name,cmax=cmax,pmax=pmax,thickness=thickness,opacity=opacity)
        #
        #
        #
        def one_sheet_hyperboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;OneSheetHyperboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an one sheet hyperboloid
                Parameters:
                   o: center of the hyperboloid

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = 1

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the hyperboloid

                   xmax: maximum value of the x coordinate

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the hyperboloid

                   opacity: opacity of the hyperboloid
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                c = math.sqrt(c2)
                if xmax is None:
                        xmax=5.0/a + 2
                xmax /= a
                self.draw_one_sheet_hyperboloid(a=1.0,b=1.0,xmin=1.0,xmax=xmax,scale=[a,b,c],color=color,name=name,thickness=thickness,opacity=opacity)
        #
        #
        #
        def two_sheets_hyperboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;TwoSheetParaboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws a two sheets hyperboloid
                Parameters:
                   o: center of the hyperboloid

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = -1

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the hyperboloid

                   xmax: maximum value of the x coordinate

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the hyperboloid

                   opacity: opacity of the hyperboloid
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                c = math.sqrt(c2)
                if xmax is None:
                        xmax = 5.0/a + 2
                xmax /= a
                self.draw_two_sheets_hyperboloid(a=1.0,b=1.0,xmin=0.0,xmax=xmax,color=color,scale=[a,b,c],name=name,thickness=thickness,opacity=opacity)
        #
        #
        #
        def cone(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,half=False,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Cone&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws a cone
                Parameters:
                   o: center of the cone

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   a2, b2, c2: squares of semi-axes of the cone. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = 0

                   half: if True draws half cone

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the cone

                   xmax: maximum value of the x coordinate

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -pmax and pmax

                   thickness: thickness of the cone

                   opacity: opacity of the cone
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                c = math.sqrt(c2)
                if xmax is None:
                        xmax = 10.0/a + 2
                xmax /= a
                self.draw_cone(a=1.0,xmin=0.0,xmax=xmax,steps=50,half=half,color=color,scale=[a,b,c],name=name,thickness=thickness,opacity=opacity)
        #
        #
        #
        def hyperbolic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicCylinder&#34;,xmax=None,zmax=20,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an hyperbolic cylinder
                Parameters:
                   o: center of the hyperbolic cylinder

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   a2, b2: squares of semi-axes of the hyperbolic cylinder. The equation is x&#39;^2/a^2 - y&#39;^2/b^2 = 1

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the hyperbolic cylinder

                   xmax: maximum value of the x coordinate

                   zmax: the hyperbolic cylinder is drawn between -zmax and zmax

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the hyperbolic cylinder

                   opacity: opacity of the hyperbolic cylinder
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                if xmax is None:
                        xmax = 5.0/a + 2
                xmax /= a
                obj = self.draw_hyperbolic_cylinder(a=1.0,b=1.0,xmin=1.0,xmax=xmax,length=zmax,steps=128,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)
        #
        #
        #
        def elliptic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;EllipticCylinder&#34;,zmax=20,cmax=15,pmax=15,thickness=0.02,opacity=1.0,change=False):
                &#34;&#34;&#34;
                Draws an elliptic cylinder
                Parameters:
                   o: center of the elliptic cylinder

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   a2, b2: squares of semi-axes of the elliptic cylinder. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 = 1

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the elliptic cylinder

                   zmax: the elliptic cylinder is drawn between -zmax and zmax

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the elliptic cylinder

                   opacity: opacity of the elliptic cylinder
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                self.draw_elliptic_cylinder(a=1.0,b=1.0,length=zmax,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)
                if not change:
                        self.set_origin()
                        self.set_base()
        #
        #
        #
        def elliptic_paraboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;EllipticParaboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an elliptic paraboloid
                Parameters:
                   o: vertex of the elliptic paraboloid

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   a2, b2: squares of semi-axes of the elliptic paraboloid. The equation is z = x&#39;^2/a^2 + y&#39;^2/b^2

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the elliptic paraboloid

                   xmax: maximum value of the coordinate x

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the elliptic paraboloid

                   opacity: opacity of the elliptic paraboloid
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                if xmax is None:
                        xmax = 10.0/a
                xmax /= a
                self.draw_elliptic_paraboloid(a=1.0,xmin=0.0,xmax=xmax,steps=50,scale=[a,b,1],color=color,name=name,opacity=opacity,thickness=thickness)
        #
        #
        #
        def hyperbolic_paraboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicParaboloid&#34;,xmax=None,ymax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an hyperbolic paraboloid
                Parameters:
                   o: vertex of the hyperbolic paraboloid

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   a2, b2: squares of semi-axes of the hyperbolic paraboloid. The equation is z = x&#39;^2/a^2 - y&#39;^2/b^2

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the elliptic paraboloid

                   xmax: maximum value of the coordinate x

                   ymax: maximum value of the coordinate y

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the hyperbolic paraboloid

                   opacity: opacity of the hyperbolic paraboloid
                &#34;&#34;&#34;
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                if xmax is None:
                        xmax = 10.0/a + 2
                if ymax is None:
                        ymax = 10.0/b + 1
                xmax /= a
                ymax /= b
                obj = self.draw_hyperbolic_paraboloid(a=1.0,b=1.0,xmax=xmax,ymax=ymax,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)

                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                obj.location = o
        #
        #
        #
        def parabolic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;ParabolicCylinder&#34;,xmax=None,ymax=30,cmax=20,pmax=20,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an hyperbolic paraboloid
                Parameters:
                   o: vertex of the hyperbolic paraboloid

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   a: coefficient of the intial parabola

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the elliptic paraboloid

                   xmax: maximum value of the coordinate x

                   ymax: maximum value of the coordinate y

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the hyperbolic paraboloid

                   opacity: opacity of the hyperbolic paraboloid
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                coef = 1.0
                if a &lt; 0:
                        coef = -1
                if xmax is None:
                        xmax = 5.0/a + 1.5
                xmax /= a
                self.draw_parabolic_cylinder(p=coef,xmin=0.0,xmax=xmax,length=ymax,color=color,name=name,scale=[a,1,1],thickness=thickness,opacity=opacity)
        #
        #
        #
        def draw_simple_curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.02,color=&#34;White&#34;,name=&#34;Curve&#34;):
                &#34;&#34;&#34;
                Draws a parametric curve
                Parameters:
                   fun: the parametric function

                   tmin: minimum value of the parameter

                   tmax: maximum value of the parameter

                   steps: number of steps

                   thickness: thickness of the curve

                   color: color of the curve

                   name: name of the curve
                &#34;&#34;&#34;
                if fun is None:
                        return None
                delta = (tmax - tmin) / steps
                t = tmin

                curve = bpy.data.curves.new(&#39;myCurve&#39;, type=&#39;CURVE&#39;)
                curve.dimensions = &#39;3D&#39;
                curve.resolution_u = 2

                line = curve.splines.new(&#39;POLY&#39;)
                line.points.add(steps)

                for i in range(steps+1):
                        p = fun(t)
                        p.append(1)
                        line.points[i].co = p
                        t += delta

                obj = bpy.data.objects.new(name, curve)
                curve.bevel_depth = thickness

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
                self.scene.collection.objects.link(obj)
                return obj
        #
        #
        #
        def draw_curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,axis=False,zaxis=True,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0])):
                &#34;&#34;&#34;
                Draws a curve in a reference R&#39; determined by the origin o and basis {v1, v2, v3} constructed from u1 and u2
                Parameters:
                   fun: the parametric function

                   tmin: minimum value of the parameter

                   tmax: maximum value of the parameter

                   steps: number of steps

                   thickness: thickness of the curve

                   name: name of the curve

                   color: color of the curve

                   axis: if True draws the axis of the reference R&#39;

                   zaxis: if True draws the z&#39; axis

                   o: origin of the reference R&#39;

                   u1, u2: vectors to construct the basis {v1, v2, v3}
                &#34;&#34;&#34;
                if fun is None:
                        return None
                qt = self.vectors_to_quaternion(u1,u2)
                delta = (tmax - tmin) / steps
                t = tmin
                bm = bmesh.new()
                verts = []

                pmax = 0
                for k in range(steps + 1):
                        p = fun(t)
                        m = max(map(abs,p))
                        if m &gt; pmax:
                                pmax = m
                        verts.append(bm.verts.new(p))
                        t += delta
                        if t &gt; tmax:
                                t = tmax

                for i in range(len(verts) - 1):
                        bm.edges.new([verts[i], verts[i+1]])

                me = self.meshes.new(&#39;placeholder_mesh&#39;)
                obj = self.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()

                modifier = obj.modifiers.new(type=&#39;SKIN&#39;,name = &#39;skin&#39;)
                for v in obj.data.skin_vertices[0].data:
                        v.radius = (thickness,thickness)

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
                self.set_origin(o)
                self.set_rotation(quaternion=qt)
                if self.rotation is not None:
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                if axis:
                        self.draw_base_axis(axis = pmax+3,positive=False,name=&#34;Referència escollida&#34;,zaxis=zaxis)
                self.scene.collection.objects.link(obj)
                bpy.ops.object.shade_smooth()
                obj.location = o
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,axis=False,zaxis=True,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),symmetry=None,change=False):
                &#34;&#34;&#34;
                Draws a curve in a reference R&#39; determined by the origin o and basis {v1, v2, v3} constructed from u1 and u2 and
                the symmetric curve or curves from the parameter &#39;symmetry&#39;
                Parameters:
                   fun: the parametric function

                   tmin: minimum value of the parameter

                   tmax: maximum value of the parameter

                   steps: number of steps

                   thickness: thickness of the curve

                   name: name of the curve

                   color: color of the curve

                   axis: if True draws the axis of the reference R&#39;

                   zaxis: if True draws the z&#39; axis

                   o: origin of the reference R&#39;

                   u1, u2: vectors to construct the basis {v1, v2, v3}

                   symmetry: list of values in (&#39;XY&#39;,&#39;XZ&#39;,&#39;YZ&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;,&#39;O&#39;). For every value S, draw the symmetric curve respect to S

                   change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                if fun is None:
                        return None
                obj = self.draw_curve(fun,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=name,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)

                if symmetry is None:
                        if change:
                                self.set_origin(o)
                                self.set_base([u1,u2],orthonormal=True)
                        return obj
                objs = [obj]
                if isinstance(symmetry,str):
                        symmetry = [symmetry]
                elif not isinstance(symmetry,list) and not isinstance(symmetry,tuple):
                        if change:
                                self.set_origin(o)
                                self.set_base([u1,u2],orthonormal=True)
                        return obj
                for s in symmetry:
                        namem = name + s
                        if s == &#39;XY&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (p[0],p[1],-p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;XZ&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (p[0],-p[1],p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;YZ&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (-p[0],p[1],p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;X&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (p[0],-p[1],-p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;Y&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (-p[0],p[1],-p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;Z&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (-p[0],-p[1],p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;O&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (-p[0],-p[1],-p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                if change:
                        self.set_origin(o)
                        self.set_base([u1,u2],orthonormal=True)
                return self.join(objs)
        #
        #
        #
        def draw_circle(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),axis=False,zaxis=False,radius=1,steps=25,thickness=0.01,name=&#34;Circle&#34;,color=&#34;White&#34;,change=False):
                &#34;&#34;&#34;
                Draws a circle of center &#39;center&#39; and radius &#39;radius&#39; in the plane determined by vectors u1 and u2
                Parameters:
                   center: center of the circle

                   u1, u2: vectors to construct the basis {v1, v2, v3}

                   axis: if True draws the axis of the reference R&#39;

                   zaxis: if True draws the z&#39; axis

                   radius: radius of the circle

                   steps: number of steps

                   thickness: thickness of the curve

                   name: name of the curve

                   color: color of the curve

                   change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                if change:
                        self.set_origin(center)
                        self.set_base([u1,u2],orthonormal=True)
                return self.draw_curve(lambda t: (radius*math.cos(t),radius*math.sin(t),0),tmin=0.0,tmax=2*math.pi,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
        #
        #
        #
        def draw_ellipse(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,b=1,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Ellipse&#34;,color=&#34;White&#34;,change=False):
                &#34;&#34;&#34;
                Draws an ellipse of center &#39;center&#39; and semi-axes a and b in the plane determined by vectors u1 and u2
                Parameters:
                   center: center of the ellipse

                   u1, u2: vectors to construct the basis {v1, v2, v3}

                   a, b: semi-axes of the ellipse

                   axis: if True draws the axis of the reference R&#39;

                   zaxis: if True draws the z&#39; axis

                   steps: number of steps

                   thickness: thickness of the curve

                   name: name of the curve

                   color: color of the curve

                   change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                if change:
                        self.set_origin(center)
                        self.set_base([u1,u2],orthonormal=True)
                return self.draw_curve(lambda t: (a*math.cos(t),b*math.sin(t),0),tmin=0.0,tmax=2*math.pi,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
        #
        #
        #
        def draw_parabola(self,vertex=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,xmax=3.0,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Parabola&#34;,color=&#34;White&#34;,change=False):
                &#34;&#34;&#34;
                Draws a parabola of vertex &#39;vertex&#39; of equation y&#39;=ax&#39;^2 in the reference {vertex; v1, v2, v3} determined by vectors u1 and u2
                Parameters:
                   vertex: vertex of the parabola

                   u1, u2: vectors to construct the basis {v1, v2, v3}

                   a: coefficient of the parabola

                   xmax: maximum value of x&#39;

                   axis: if True draws the axis of the reference R&#39;

                   zaxis: if True draws the z&#39; axis

                   steps: number of steps

                   thickness: thickness of the curve

                   name: name of the curve

                   color: color of the curve

                   change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                if change:
                        self.set_origin(vertex)
                        self.set_base([u1,u2],orthonormal=True)
                return self.draw_curve(lambda t: (t,a*t**2,0),tmin=-xmax,tmax=xmax,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=vertex,u1=u1,u2=u2)
        #
        #
        #
        def draw_hyperbole(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,b=1,ymax=3.0,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Hyperbole&#34;,color=&#34;White&#34;,change=False):
                &#34;&#34;&#34;
                Draws an hyperbole of center &#39;center&#39; and semi-axes a and b in the plane determined by vectors u1 and u2
                Parameters:
                   center: center of the hyperbole

                   u1, u2: vectors to construct the basis {v1, v2, v3}

                   a, b: semi-axes of the hyperbole

                   ymax: maximum value of the y&#39;

                   axis: if True draws the axis of the reference R&#39;

                   zaxis: if True draws the z&#39; axis

                   steps: number of steps

                   thickness: thickness of the curve

                   name: name of the curve

                   color: color of the curve

                   change: if True, set the reference self.origin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                c1 = self.draw_curve(lambda t: (a*math.sqrt(1+t**2/b**2),t,0),tmin=-ymax,tmax=ymax,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
                c2 = self.draw_curve(lambda t: (-a*math.sqrt(1+t**2/b**2),t,0),tmin=-ymax,tmax=ymax,axis=False,zaxis=False,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
                self.join([c1,c2])
                if change:
                        self.set_origin(center)
                        self.set_base([u1,u2],orthonormal=True)
                return c1
        #
        #
        #
        def draw_surface(self,eq=None,umin=-1,umax=1,usteps=64,vmin=-1,vmax=1,vsteps=64,thickness=0.02,opacity=1.0,pmax=10,name=&#34;Surface&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),wrap_u=False,wrap_v=False,close_v=False):
                &#34;&#34;&#34;
                Draws a parametric surface in the reference R&#39;
                Parameters:
                   eq: parametric equacion f(u,v)

                   umin: minimum value of u

                   umax: maximum value of u

                   usteps: steps in the u direction

                   vmin: minimum value of v

                   vmax: maximum value of v

                   vsteps: steps in the v direction

                   thickness: thickness of the surface

                   opacity: opacity of the surface

                   color: color of the surface

                   pmax: the principal axis are drawn between -cmax and cmax

                   name: name of the surface

                   color: color of the surface

                   axis: if True draw the axis of the reference {o, v1, v2, v3}

                   o: origin of the reference R&#39;

                   u1, u2: vectors to construct the basis {v1, v2, v3}

                   scale: scale coefficients

                   wrap_u: wrap the u coordinate

                   wrap_v: wrap the u coordinate

                   close_v: close the v coordinate
                &#34;&#34;&#34;
                if eq is None:
                        return

                q = self.vectors_to_quaternion(u1,u2)
                draw_parametric_surface(eq=eq,range_u_min=umin,range_u_max=umax,range_u_step=usteps,range_v_min=vmin,range_v_max=vmax,range_v_step=vsteps,name=name,wrap_u=wrap_u,wrap_v=wrap_v,close_v=close_v)

                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)
                obj.show_wire = False

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if self.rotation is not None:
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                if axis:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència escollida&#34;)

                bpy.ops.object.shade_smooth()
                obj.location = o
                obj.select_set(False)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_function(self,f=None,xmin=-3,xmax=3,xsteps=64,ymin=-3,ymax=3,ysteps=64,thickness=0.02,opacity=1.0,pmax=10,name=&#34;Function&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0])):
                &#34;&#34;&#34;
                Draws a function of two variables f(x,y) i the reference R&#39; = {o, v1, v2, v3}
                Parameters:
                   f: the function of two variables f(x,y)

                   xmin: minimum value of x

                   xmax: maximum value of x

                   xsteps: steps in the x direction

                   ymin: minimum value of y

                   ymax: maximum value of y

                   ysteps: steps in the x direction

                   thickness: thickness of the surface

                   opacity: opacity of the surface

                   pmax: the axis are drawn between -pmax and pmax

                   name: name of the surface

                   color: color of the surface

                   axis: if True the axis of the reference R&#39; are drawn

                   o: origin of the reference R&#39;

                   u1, u2: vectors to construct the basis {v1, v2, v3}
                &#34;&#34;&#34;
                if f is None:
                        return None
                return self.draw_surface(eq=lambda x,y:(x,y,f(x,y)),umin=xmin,umax=xmax,usteps=xsteps,vmin=ymin,vmax=ymax,vsteps=ysteps,thickness=thickness,opacity=opacity,pmax=pmax,name=name,color=color,axis=axis,o=o,u1=u1,u2=u2,wrap_u=False,wrap_v=False,close_v=False)
        #
        #
        #
        def draw_vector_field(self,f=None,xmin=-3,xmax=3,xsteps=8,ymin=-3,ymax=3,ysteps=8,zmin=-3,zmax=3,zsteps=8,name=&#34;Vector Field&#34;,color=&#34;Red&#34;,scale=0.02,head_height=0.05):
                &#34;&#34;&#34;
                Draws a vector field
                Parameters:
                   f: the vector field

                   xmin: minimum value of x

                   xmax: maximum value of x

                   xsteps: steps in the x direction

                   ymin: minimum value of y

                   ymax: maximum value of y

                   ysteps: steps in the y direction

                   zmin: minimum value of z

                   zmax: maximum value of z

                   zsteps: steps in the z direction

                   name: name of the vector field

                   color: color of the vector field

                   scale: scale of the vectors

                   head_height: head height of the vectors
                &#34;&#34;&#34;
                if f is None:
                        return None
                xstep = (xmax - xmin)/xsteps
                ystep = (ymax - ymin)/ysteps
                zstep = (zmax - zmin)/zsteps
                if xstep == 0 or ystep == 0 or zstep == 0:
                        return None
                vectors = []
                count = 1
                x = xmin
                while x &lt;= xmax:
                        y = ymin
                        while y &lt;= ymax:
                                z = zmin
                                while z &lt;= zmax:
                                        o = Vector([x,y,z])
                                        v = f(x,y,z)
                                        if not isinstance(v,Vector):
                                                v = Vector(v)
                                        self.set_origin(o)
                                        vec = self.draw_vector(v,color=color,name=f&#34;Vector{count}&#34;,scale=scale,head_height=head_height)
                                        if vec is not None:
                                                vectors.append(vec)
                                        z += zstep
                                        count += 1
                                y += ystep
                        x += xstep
                v = self.join(vectors)
                bpy.context.object.name = name
                return v
        #
        #
        #
        def revolution_surface(self,fun=None,tmin=0.0,tmax=1.0,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),pmax=0,steps=256,thickness=0.025,axis=&#39;Z&#39;,name=&#34;Revolution surface&#34;,color=&#34;AzureBlueDark&#34;):
                &#34;&#34;&#34;
                Draws a revolution surface from a curve in the reference R&#39;
                Parameters:
                   fun: parametric equacion of the curve

                   steps: number of steps

                   axis: axis of revolution. It must be &#39;X&#39;, &#39;Y&#39; or &#39;Z&#39;

                   o: origin of the reference R&#39;

                   u1, u2: vectors to construct the basis {v1, v2, v3}

                   pmax: the principal axis are drawn between -pmax and pmax

                   color: color of the surface
                &#34;&#34;&#34;
                if fun is None:
                        return None
                q = self.vectors_to_quaternion(u1,u2)
                obj = self.simple_curve(fun,tmin=tmin,tmax=tmax,steps=steps,name=name)
                m = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                m.levels = 4
                m.subdivision_type = &#39;SIMPLE&#39;
                m = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                m.thickness = thickness
                m.offset = 1.0
                m = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                m.angle = 2*math.pi
                m.steps = steps
                m.axis =  axis
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
                bpy.context.scene.collection.objects.link(obj)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if self.rotation is not None:
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                if pmax &gt; 0.0:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència R&#39;&#34;)
                bpy.ops.object.shade_smooth()
                obj.location = o
                obj.select_set(False)
                bpy.context.view_layer.objects.active = None
        #
        #
        #
        def animate_revolution_surface(self,fun=None,tmin=0.0,tmax=1.0,steps=256,curvethicknes=0.025,thickness=0.025,frames=3,angle=3,radians=False,axis=&#39;Z&#39;,symmetry=None,name=&#34;Revolution surface&#34;,color=&#34;AzureBlueDark&#34;,point=None):
                &#34;&#34;&#34;
                Draws and animates a revolution surface from a curve
                Parameters:
                   fun: parametric equacion of the curve

                   steps: number of steps to graw the curve

                   curvethicknes: thickness of the curve

                   frames: number of frames at each step of revolution

                   angle: step angle of the revolution

                   radians: if True, angle must be in radians

                   axis: axis of revolution. It must be &#39;X&#39;, &#39;Y&#39; or &#39;Z&#39;

                   symmetry: symmetry used to draw the curve

                   name: name of the surface

                   color: color of the surface

                   point: if not None draw three points and a cercle. Must be a float between tmax and tmin
                &#34;&#34;&#34;
                if radians:
                        angle *= 180/math.pi
                stepsr = int(360/angle) + 1
                angle = 360/stepsr
                if fun is None:
                        return None
                if axis == &#39;X&#39;:
                        r = Rotation(angle,Vector([1,0,0]))
                        d1 = Vector([0,1,0])
                        d2 = Vector([0,0,1])
                elif axis == &#39;Y&#39;:
                        r = Rotation(angle,Vector([0,1,0]))
                        d1 = Vector([0,0,1])
                        d2 = Vector([1,0,0])
                elif axis == &#39;Z&#39;:
                        r = Rotation(angle,Vector([0,0,1]))
                        d1 = Vector([1,0,0])
                        d2 = Vector([0,1,0])
                else:
                        return None

                if point is not None:
                        try:
                                tp = 1.0 * point
                        except:
                                pass
                        if not isinstance(tp,float):
                                return None
                        if tp &lt; tmin or tp &gt; tmax:
                                tp = random.uniform(tmin,tmax)
                        zp = Vector(fun(tp))
                        e = d1.cross(d2)
                        z0 = zp.project(e)

                p2 = self.curve(fun,tmin=tmin,tmax=tmax,steps=steps,thickness=curvethicknes,color=&#34;Red&#34;,symmetry=symmetry,name=&#34;Rotating curve&#34;)
                p1 = self.curve(fun,tmin=tmin,tmax=tmax,steps=steps,thickness=1.05*curvethicknes,color=&#34;Blue&#34;,symmetry=symmetry,name=&#34;Curve&#34;)
                obj = self.simple_curve(fun,tmin=tmin,tmax=tmax,steps=steps,name=&#34;Surface of revolution&#34;,symmetry=symmetry)
                if point is not None:
                        m1 = self.draw_point(radius=0.1,location=zp,name=&#34;Punt p0&#34;,color=&#34;Red&#34;)
                        m2 = self.draw_point(radius=0.1,location=zp,name=&#34;Punt p1&#34;,color=&#34;Black&#34;)
                        m3 = self.draw_point(radius=0.1,location=z0,name=&#34;Punt p2&#34;,color=&#34;Blue&#34;)
                        l1 = self.draw_line(start=z0,end=zp,scale=0.04,name=&#34;Línia 1&#34;,color=&#34;Black&#34;)
                        l2 = self.draw_line(start=z0,end=zp,scale=0.03,name=&#34;Línia 2&#34;,color=&#34;Red&#34;)
                        self.draw_circle(center=z0,u1=d1,u2=d2,radius=(zp-z0).length,steps=128,thickness=0.005,name=&#34;Circle&#34;,color=&#34;Cyan&#34;)

                m = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                m.levels = 4
                m.subdivision_type = &#39;SIMPLE&#39;
                m = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                m.thickness = thickness
                m.offset = 1.0
                m = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                m.angle = 0.0
                m.steps = steps
                m.axis =  axis
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
                bpy.context.scene.collection.objects.link(obj)

                bpy.context.scene.frame_set(self.frame)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                obj.keyframe_insert(data_path=&#39;modifiers[&#34;Screw&#34;].angle&#39;,index=-1)
                p2.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if point is not None:
                        l1.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        m2.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn = frames + self.frame
                for i in range(0,stepsr):
                        bpy.context.scene.frame_set(fn)
                        p2.rotation_quaternion.rotate(r.quaternion)
                        p2.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        obj.modifiers[&#34;Screw&#34;].angle = 2 * (i+1) * math.pi / stepsr
                        obj.modifiers[&#34;Screw&#34;].steps = i+1
                        obj.keyframe_insert(data_path=&#39;modifiers[&#34;Screw&#34;].angle&#39;,index=-1)
                        if point is not None:
                                l1.rotation_quaternion.rotate(r.quaternion)
                                l1.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                                m2.location.rotate(r.quaternion)
                                m2.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames
                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()
        #
        #
        #
        def rotate_object(self,obj=None,axis=&#39;Z&#39;,frames=1,origin=Vector([0,0,0]),localaxis=None,localangle=None,helicoidal=0.0,rounds=1,draw=True):
                &#34;&#34;&#34;
                Rotates an object around the axis
                Parameters:
                   obj: the object

                   axis: it must be &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39; or a Vector

                   local: if True the center of rotation is the location of the object
                &#34;&#34;&#34;
                if obj is None:
                        return None
                if not isinstance(origin,Vector):
                        origin = Vector(origin)
                if isinstance(axis,str):
                        axis = axis.strip().upper()
                if axis == &#39;X&#39;:
                        u = Vector([1,0,0])
                elif axis == &#39;Y&#39;:
                        u = Vector([0,1,0])
                elif axis == &#39;Z&#39;:
                        u = Vector([0,0,1])
                elif isinstance(axis,Vector):
                        u = axis
                else:
                        u = Vector(axis)

                line = None
                if localaxis is not None and localangle is not None:
                        old = self.origin
                        self.set_origin(obj.location)
                        l = obj.dimensions.length / 2
                        line = self.draw_vector(localaxis,axis=l,scale=0.1,arrow=False,positive=False,color=&#34;Orange&#34;,name=&#34;Eix rotació local&#34;)
                        line.select_set(True)
                        bpy.ops.object.origin_set(type=&#39;ORIGIN_CENTER_OF_MASS&#39;, center=&#39;MEDIAN&#39;)
                        line.select_set(False)
                        self.set_origin(old)
                        lr = Rotation(localangle,localaxis)
                if draw:
                        self.set_origin(origin)
                        self.draw_vector(u,axis=15/u.length,positive=False,color=&#34;White&#34;)
                        self.set_origin()
                r = Rotation(1/int(frames),u)
                axis, angle = r.to_axis_angle()
                t = helicoidal * axis
                bpy.context.scene.frame_set(self.frame)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn = self.frame + 1
                for i in range(int(frames) * int(rounds) * 360):
                        bpy.context.scene.frame_set(fn)
                        if line is None:
                                obj.rotation_quaternion.rotate(r.quaternion)
                        else:
                                obj.rotation_quaternion.rotate(lr.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        w = obj.location - origin
                        w.rotate(r.quaternion)
                        obj.location = origin + w + t
                        if line is not None:
                                line.location = origin + w + t
                                line.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += 1
                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()
        #
        #
        #
        def rotate_vector(self,vector=None,axis=&#39;Z&#39;):
                &#34;&#34;&#34;
                Rotates a vector around the axis
                Parameters:
                   vector: the vector

                   axis: it must be &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39; or a vector
                &#34;&#34;&#34;
                draw = False
                if vector is None:
                        return None
                if axis == &#39;X&#39;:
                        u = Vector([1,0,0])
                elif axis == &#39;Y&#39;:
                        u = Vector([0,1,0])
                elif axis == &#39;Z&#39;:
                        u = Vector([0,0,1])
                elif isinstance(axis,Vector):
                        u = axis
                else:
                        u = Vector(axis)

                self.draw_vector(vector,color=&#34;Black&#34;)
                obj = self.draw_vector(vector,color=&#34;Red&#34;)
                w1 = u.orthogonal().normalized()
                vec1 = vector.project(u)
                w3 = vec1.normalized()
                w2 = w3.cross(w1)
                a = vec1.length
                b = (vector-vec1).length
                p2 = b**2/a**2
                self.rotate_object(obj,u)
                self.cone(u1=w1,u2=w2,a2=p2,b2=p2,c2=1,half=True, principal=False,canonica=False,xmax=b,color=&#34;GrayLight&#34;,opacity=0.2)
        #
        #
        #
        def rotate_object_by_axis_angle(self,obj=None,axis=Vector([1,0,0]),angle=90,amax=15,frames=1,scaleaxis=0.075,local=False):
                &#34;&#34;&#34;
                Rotates an object around an angle &#39;angle&#39; around the axis
                Parameters:
                   obj: the object

                   axis: any non nul Vectors

                   angle: the angle of rotation in degrees

                   frames: increment of the frame set

                   scaleaxis: scale value for draw_base_axis

                   local: if True the center of rotation is the location of the object
                &#34;&#34;&#34;
                if obj is None:
                        return None
                if isinstance(axis,Vector):
                        u = axis
                else:
                        u = Vector(axis)
                if u.length == 0.0 or angle &lt;= 1:
                        return

                self.draw_base_axis(axis = amax,scale=scaleaxis,positive=False,name=&#34;Base canònica&#34;)
                self.draw_vector(u,scale=0.1,axis=amax,positive=False,color=&#34;Black&#34;,name=&#34;Eix rotació&#34;)

                num = int(angle)
                alfa = angle / num
                r = Rotation(alfa,u)
                bpy.context.scene.frame_set(self.frame)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if not local:
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn = frames + self.frame

                for i in range(num):
                        bpy.context.scene.frame_set(fn)
                        obj.rotation_quaternion.rotate(r.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if not local:
                                w = obj.location
                                w.rotate(r.quaternion)
                                obj.location = w
                                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames
                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()
        #
        #
        #
        def rotate_euler(self,obj=None,psi=0.0,theta=0.0,phi=0.0,frames=3,axis=&#39;ZXZ&#39;,amax=15,scaleaxis=0.075,reverse=False,local=False,radians=False,canonica=True,positive=False):
                &#34;&#34;&#34;
                Rotates an object by the Euler angles psi, theta and phi
                Parameters:
                   object: the object

                   psi, theta, phi: the Euler angles expressed in degrees

                   axis: it must be &#39;XYZ&#39;, &#39;XZY&#39;, &#39;YXZ&#39;, &#39;YZX&#39;, &#39;ZXY&#39;, &#39;ZYX&#39;, &#39;XYX&#39;, &#39;XZX&#39;, &#39;YXY&#39;, &#39;YZY&#39;, &#39;ZXZ&#39; or &#39;ZYZ&#39;

                   amax: axis valur for draw_base_axis

                   scaleaxis: scale value for draw_base_axis

                   local: if True the center of rotation is the location of the object

                   radians: if True, psi, theta and phi must be in radians

                   positive: if False and psi, theta or phi are greather than 180 degrees, they rae converted
                             to negative angles
                &#34;&#34;&#34;
                def vector_from_axis(axis):
                        if axis == &#39;X&#39;:
                                return Vector([1,0,0])
                        if axis == &#39;Y&#39;:
                                return Vector([0,1,0])
                        if axis == &#39;Z&#39;:
                                return Vector([0,0,1])
                        return None

                if obj is None or axis is None:
                        return None

                if not isinstance(axis,str):
                        return None

                axis = axis.upper()
                if axis not in (&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,&#39;XYX&#39;,&#39;XZX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;):
                        return None

                u1 = vector_from_axis(axis[0])
                u2 = vector_from_axis(axis[1])
                u3 = vector_from_axis(axis[2])

                if radians:
                        psi *= 180/math.pi
                        theta *= 180/math.pi
                        phi *= 180/math.pi
                if positive:
                        if psi &lt; 0.0:
                                psi += 360
                        if theta &lt; 0.0:
                                theta += 360
                        if phi &lt; 0.0:
                                phi += 360
                else:
                        if psi &gt; 180.0:
                                psi -= 360
                        if theta &gt; 180.0:
                                theta -= 360
                        if phi &gt; 180.0:
                                phi -= 360

                if reverse:
                        self.set_colors([&#34;OrangeRedDark&#34;,&#34;Yellow&#34;,&#34;Magenta&#34;])
                        axis = self.draw_base_axis(axis=amax,scale=scaleaxis,positive=False,name=&#34;Eixos transformats&#34;)
                        obj = self.join([obj,axis])
                        u1, u2, u3 = u3, u2, u1
                        psi, theta, phi = phi, theta, psi
                        s = Rotation(psi,u1)
                        u2 = s.apply(u2)
                        u3 = s.apply(u3)
                        s = Rotation(theta,u2)
                        u3 = s.apply(u3)
                elif canonica:
                        self.draw_base_axis(axis=amax,scale=scaleaxis,positive=False,name=&#34;Base canònica&#34;)

                bpy.context.scene.frame_set(self.frame)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if not local:
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn = frames + self.frame
                if psi &gt; 0:
                        num = int(psi)
                elif psi &lt; 0:
                        num = int(-psi)
                alfa = psi / num
                r = Rotation(alfa,u1)
                for i in range(num):
                        bpy.context.scene.frame_set(fn)
                        obj.rotation_quaternion.rotate(r.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if not local:
                                w = obj.location
                                w.rotate(r.quaternion)
                                obj.location = w
                                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames

                if theta &gt; 0:
                        num = int(theta)
                elif theta &lt; 0:
                        num = int(-theta)
                alfa = theta / num
                r = Rotation(alfa,u2)
                for i in range(num):
                        bpy.context.scene.frame_set(fn)
                        obj.rotation_quaternion.rotate(r.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if not local:
                                w = obj.location
                                w.rotate(r.quaternion)
                                obj.location = w
                                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames

                if phi &gt; 0:
                        num = int(phi)
                elif phi &lt; 0:
                        num = int(-phi)
                alfa = phi / num
                r = Rotation(alfa,u3)
                for i in range(num):
                        bpy.context.scene.frame_set(fn)
                        obj.rotation_quaternion.rotate(r.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if not local:
                                w = obj.location
                                w.rotate(r.quaternion)
                                obj.location = w
                                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames

                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()
        #
        #
        #
        def draw_frenet_curve(self,fun=None,var=None,tmin=0.0,tmax=1.0,radius=0.1,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,point=True,tangent=False,acceleration=False,normal=False,osculator=False,frenet=False,units=False,sizex=8,sizey=8,axis=10):
                &#34;&#34;&#34;
                Draws a curve and diferents elements related to the curve
                Parameters:
                   fun: the parametric function

                   var = parameter variable of the function fun

                   tmin: minimum value of the parameter

                   tmax: maximum value of the parameter

                   radius: radius of the point

                   steps: number of steps

                   frames: increment of the frame set

                   thickness: thickness of the curve

                   name: name of the curve

                   color: color of the curve

                   point: if True draw a point along the curve

                   tangent: if True draw the tangent vector along the curve

                   acceleration: if True draw the acceleration vector along the curve

                   normal: if True draw the normal vector along the curve

                   osculator: if True draw the osculating plane along the curve

                   frenet: if True draw the Frenet trihedron along the curve

                   units: if True normalize the tangent and normal vectors

                   sizex, sizey: sizes of the osculating plane

                   axis: length of the coordinate axis
                &#34;&#34;&#34;
                if fun is None:
                        return None

                self.draw_base_axis(axis=axis,positive=False)

                def _fun_(x):
                        return [u.subs(var,x) for u in fun]

                def frenet_quaternion(tangent,normal):
                        v1 = tangent.normalized()
                        v2 = normal.normalized()
                        v3 = v1.cross(v2)
                        return Matrix([v1,v2,v3]).transposed().to_quaternion()

                frames = 1
                curve = self.draw_curve(_fun_,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,color=color,axis=False)
                if not point and not tangent and not osculator and not frenet:
                        return curve

                T = [diff(u,var) for u in fun]
                Tnorm = sqrt(sum([u**2 for u in T]))
                A = [diff(u,var) for u in T]
                p0 = Vector([u.subs(var,tmin) for u in fun])
                v0 = Vector([N(u.subs(var,tmin)) for u in T])
                a0 = Vector([N(u.subs(var,tmin)) for u in A])
                n0 = a0 - a0.project(v0)
                q0 = frenet_quaternion(v0,n0)
                f0 = [Vector([1,0,0]),Vector([0,1,0]),Vector([0,0,1])]

                if units:
                        v0.normalize()
                        n0.normalize()
                bpy.context.scene.frame_set(self.frame)

                if point:
                        p = self.draw_point(radius=radius,location=p0,name=&#34;Punt&#34;,color=&#34;Black&#34;)
                        p.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                self.set_origin(p0)
                if tangent:
                        l = v0.length
                        if not units:
                                vp = 5*v0.normalized()
                        else:
                                vp = v0
                        if not units:
                                v = self.draw_vector(vp,color=&#34;Red&#34;,scale=0.035,head_height=0.3)
                                v.scale.z *= l / 5.0
                        else:
                                v = self.draw_vector(vp,color=&#34;Red&#34;,scale=0.035,head_height=0.2)
                        v.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        v.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        v.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if acceleration:
                        l = a0.length
                        ap = 5*a0.normalized()
                        a = self.draw_vector(ap,color=&#34;Green&#34;,scale=0.035,head_height=0.2)
                        a.scale.z *= l / 5.0
                        a.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        a.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        a.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if normal:
                        l = n0.length
                        if not units:
                                np = 5*n0.normalized()
                        else:
                                np = n0
                        if not units:
                                n = self.draw_vector(np,color=&#34;Red&#34;,scale=0.035,head_height=0.2)
                                n.scale.z *= l / 5.0
                        else:
                                n = self.draw_vector(np,color=&#34;Red&#34;,scale=0.035,head_height=0.1)
                        n.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        n.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        n.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if osculator:
                        o = self.draw_plane_surface(base=[[1,0,0],[0,1,0]],color=&#34;GreenPaleDull&#34;,linecolor=&#34;GreenDarkDull&#34;,sizex=sizex,sizey=sizey,opacity=0.25)
                        o.rotation_quaternion = q0
                        o.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        o.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if frenet:
                        f = self.draw_vectors(f0,color=&#34;Red&#34;,scale=0.035,head_height=0.1)
                        f.rotation_quaternion = q0
                        f.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        f.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                self.set_origin()

                fn = frames + self.frame
                for i in range(steps):
                        bpy.context.scene.frame_set(fn)
                        x = tmin + (tmax - tmin)*i/steps
                        pos = Vector([u.subs(var,x) for u in fun])
                        v1 = Vector([N(u.subs(var,x)) for u in T])
                        a1 = Vector([N(u.subs(var,x)) for u in A])
                        n1 = a1 - a1.project(v1)
                        q1 = frenet_quaternion(v1,n1)
                        if point:
                                p.location = pos
                                p.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        if tangent:
                                if not units:
                                        r = v1.length / v0.length
                                        v.scale.z *= r
                                v.location = pos
                                v.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                v.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                                q = v0.rotation_difference(v1)
                                v.rotation_quaternion.rotate(q)
                                v.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if acceleration:
                                r = a1.length / a0.length
                                a.scale.z *= r
                                a.location = pos
                                a.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                a.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                                q = a0.rotation_difference(a1)
                                a.rotation_quaternion.rotate(q)
                                a.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if normal:
                                if not units:
                                        r = n1.length / n0.length
                                        n.scale.z *= r
                                n.location = pos
                                n.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                n.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                                q = n0.rotation_difference(n1)
                                n.rotation_quaternion.rotate(q)
                                n.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if osculator:
                                o.location = pos
                                o.rotation_quaternion = q1
                                o.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                o.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if frenet:
                                f.location = pos
                                f.rotation_quaternion = q1
                                f.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                f.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        v0 = v1.copy()
                        a0 = a1.copy()
                        n0 = n1.copy()
                        fn += frames
                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()
        #
        # Examples of use
        #
        def clear(self):
                &#34;&#34;&#34;
                Clears and removes all the elements
                &#34;&#34;&#34;
                self.reset()
                for obj in bpy.data.objects:
                        bpy.data.objects.remove(obj)
        #
        # Base canònica
        #
        def base_canonica(self,origin=Vector([0,0,0]),length=15,scale=0.04,zaxis=True,name=&#34;Base canònica&#34;):
                &#34;&#34;&#34;
                Draws the canonical base
                Parameters:
                   origin: point where to represent the base

                   length: length of the axis

                   scale: scale of the cylinder

                   zaxis: if False the z axis is not drawn

                   name: name of the object
                &#34;&#34;&#34;
                if not isinstance(origin,Vector):
                        origin = Vector(origin)
                self.set_origin(origin)
                self.draw_base_axis(axis=length,positive=False,scale=scale,zaxis=zaxis,name=name)
        #
        # Vector i base canònica
        #
        def vector_base_canonica(self,vector=Vector([-4,7,6]),length=12,name=&#34;Vector&#34;,components=True):
                &#34;&#34;&#34;
                Draws a vector expressed in the canonical base
                Parameters:
                   vector: the vector to draw

                   length: length of the axis

                   name: name of the vector

                   components: if True draws lines representing the components
                &#34;&#34;&#34;
                self.base_canonica(length=length)
                if not isinstance(vector,Vector):
                        vector = Vector(vector)
                self.draw_vector(vector,name=name)
                if components:
                        self.draw_components(vector,name=&#34;Components en base canònica&#34;)
        #
        # Base no canònica
        #
        def base_no_canonica(self,origin=Vector([0,0,0]),u1=Vector([1,-1,0]),u2=1/2*Vector([1,-1,-1]),u3=Vector([-1,0,1]),length=12,scale=0.04,name=&#34;Base B&#39;&#34;):
                &#34;&#34;&#34;
                Draws the base {u1,u2,u3} with origin in the point origin and sets the default
                origin and default base to them
                Parameters:
                        origin: origin of the vector and the base

                        u1, u2, u3: vectors of the base

                        length: length of the axis

                        scale: scale of the base

                        name: name of the base
                &#34;&#34;&#34;
                if not isinstance(origin,Vector):
                        origin = Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                if not isinstance(u3,Vector):
                        u3 = Vector(u3)
                self.set_origin(origin)
                self.set_base([u1,u2,u3])
                self.draw_base_axis(axis=length,positive=False,scale=scale,name=name)
        #
        # Vector en base no canònica
        #
        def vector_base_no_canonica(self,vector=Vector([5,6,-5]),origin=Vector([0,0,0]),u1=1/3*Vector([-1,-2,2]),u2=1/3*Vector([2,1,2]),u3=1/3*Vector([-2,2,1]),length=12,scale=0.04,name=&#34;Base B&#39;&#34;):
                &#34;&#34;&#34;
                Draws a vector expressed in the base {u1,u2,u3} with origin in the point origin and sets the default
                origin and default base to them
                Parameters:
                        vector: vector to draw

                        origin: origin of the vector and the base

                        u1, u2, u3: vectors of the base

                        length: length of the axis

                        scale: scale of the base

                        name: name of the base
                &#34;&#34;&#34;
                self.base_no_canonica(origin=origin,u1=u1,u2=u2,u3=u3,length=length,scale=scale,name=name)
                if not isinstance(vector,Vector):
                        vector = Vector(vector)
                self.draw_vector(vector,scale=0.06,head_height=0.25)
                self.draw_components(vector,scale=0.015,name=&#34;Components en base B&#39;&#34;)
        #
        # Canvi de base
        #
        def canvi_base(self,vector=Vector([8,-6,7]),u1=1/3*Vector([-1,-2,2]),u2=1/3*Vector([2,1,2]),u3=1/3*Vector([-2,2,1]),length=12):
                &#34;&#34;&#34;
                Draw the components of a vectors in the canonical base and in the base {u1,u2,u3}. Sets the default
                origin and default base to them
                Parameters:
                        vector: vector to draw

                        u1, u2, u3: vectors of the base

                        length: length of the axis
                &#34;&#34;&#34;
                self.vector_base_canonica(vector=vector,length=length)
                self.set_colors([&#34;Magenta&#34;,&#34;Yellow&#34;,&#34;Cyan&#34;])
                self.base_no_canonica(u1=u1,u2=u2,u3=u3,length=length)
                v = self.components_in_base(vector)
                self.draw_components(v,color=&#34;White&#34;,name=&#34;Components en la base B&#39;&#34;)
        #
        # Pla vectorial
        #
        def pla_vectorial(self,v1=Vector([3,2,1]),v2=Vector([1,-2,0.5]),canonica=False,length=15,color=&#34;Cyan&#34;,sizex=25,sizey=20,opacity=0.8):
                &#34;&#34;&#34;
                Draws the plane generated by two vectors
                Parameters:
                        v1, v2: generators of the plane

                        canonica: if True, draws the x, y and z axis

                        length: length of the axis x, y and z

                        color: color of the plane

                        sizex, sizey: size of the plane

                        opacicity: opacity of the plane
                &#34;&#34;&#34;
                if canonica:
                        self.base_canonica(length=length)
                self.draw_vectors([v1,v2],color=&#34;Blue&#34;)
                self.draw_plane_surface(base=[v1,v2],color=color,sizex=sizex,sizey=sizey,opacity=opacity)
        #
        # Pla afí
        #
        def pla_afi(self,punt=Vector([0,0,0]),v1=Vector([3,2,1]),v2=Vector([1,-2,0.5]),canonica=False,name=&#34;Pla afí&#34;,length=15,color=&#34;Cyan&#34;,sizex=25,sizey=20,opacity=0.8,elements=True):
                &#34;&#34;&#34;
                Draws the affine plane generated by two vectors passing through a point
                Parameters:
                        punt: point of the plane

                        v1, v2: generators of the plane

                        canonica: if True, draws the x, y and z axis

                        name: name of the affine plane

                        length: length of the axis x, y and z

                        color: color of the plane

                        sizex, sizey: size of the plane

                        opacicity: opacity of the plane
                &#34;&#34;&#34;
                if canonica:
                        self.base_canonica(length=length)
                self.draw_plane_surface(origin=punt,base=[v1,v2],color=color,sizex=sizex,sizey=sizey,name=name,opacity=opacity)
                if elements:
                        self.set_origin(punt)
                        self.draw_point(color=&#34;Blue&#34;)
                        self.draw_vectors([v1,v2],color=&#34;Blue&#34;)
                        self.set_origin()
        #
        # Projecció ortogonal i simètric sobre un pla vectorial
        #
        def projeccio_ortogonal_simetric_pla_vectorial(self,vector=Vector([7,-1,12]),v1=Vector([3,-1,1]),v2=Vector([1,0.5,0.5]),canonica=True):
                &#34;&#34;&#34;
                Draws the otoghonal projection and the symmetric of a vector with respecte a plane
                Parameters:
                        vector: the initial vector

                        v1, v2: generators of the plane

                        canonica: if True, draws the x, y and z axis
                &#34;&#34;&#34;
                if not isinstance(vector,Vector):
                        vector = Vector(vector)
                if not isinstance(v1,Vector):
                        v1 = Vector(v1)
                if not isinstance(v2,Vector):
                        v2 = Vector(v2)
                self.draw_vector(vector)
                w = v1.cross(v2)
                vp = vector - vector.project(w)
                self.draw_vector(vp,color=&#34;Red&#34;)
                self.pla_vectorial(v1,v2,sizex=3*vp.length,sizey=2.6*vp.length,canonica=canonica)
                self.set_origin(vp)
                self.draw_vector(vector.project(w),scale=0.025,color=&#34;White&#34;)
                self.set_origin()
                self.set_base([v1,v2,w])
                vb = self.components_in_base(vector)
                self.set_base()
                p1 = vb.x * v1
                p2 = vb.y * v2
                self.draw_line(start=[0,0,0],end=p1,scale=0.04,color=&#34;Blue&#34;)
                self.draw_line(start=[0,0,0],end=p2,scale=0.04,color=&#34;Blue&#34;)
                self.draw_line(start=vp,end=p1,scale=0.04,color=&#34;Blue&#34;)
                self.draw_line(start=vp,end=p2,scale=0.04,color=&#34;Blue&#34;)
                self.draw_vector(2 * vp - vector,color=&#34;Green&#34;)
                self.draw_line(start=2 * vp - vector,end=vp,scale=0.04,color=&#34;White&#34;)
        #
        # Projecció ortogonal i simètric d&#39;un punt sobre un pla afí
        #
        def projeccio_ortogonal_simetric_pla_afi(self,punt=Vector([6,-5,8]),p0=Vector([3,-2,-3]),v1=Vector([3,-1,1]),v2=Vector([1,0.5,0.5]),radi=0.15,sizex=35,sizey=30,canonica=True):
                &#34;&#34;&#34;
                Draws the orthogonal projection and the symmetric of a point with respect an affine plane
                Parameters:
                        punt: the initial point

                        p0: point of the affine plane

                        v1, v2: generators of the plane

                        radi: radius of the points

                        sizex, sizey: sizes of the affine plane

                        canonica: if True, draws the x, y and z axis
                &#34;&#34;&#34;
                if not isinstance(punt,Vector):
                        punt = Vector(punt)
                if not isinstance(p0,Vector):
                        p0 = Vector(p0)
                if not isinstance(v1,Vector):
                        v1 = Vector(v1)
                if not isinstance(v2,Vector):
                        v2 = Vector(v2)
                self.draw_point(location=punt,color=&#34;Black&#34;,radius=radi)
                w = v1.cross(v2)
                self.pla_afi(punt=p0,v1=v1,v2=v2,sizex=sizex,sizey=sizey,canonica=canonica)
                u = punt - p0
                up = punt - u.project(w)
                self.draw_point(location=up,color=&#34;Red&#34;,radius=radi)
                us = punt - 2*u.project(w)
                self.draw_point(location=us,color=&#34;Green&#34;,radius=radi)
                u = punt - up
                self.draw_line(start=up-1.5*u,end=up+1.5*u,scale=0.04,color=&#34;White&#34;)
        #
        # Projecció ortogonal i simètric d&#39;un punt sobre una recta afí
        #
        def projeccio_ortogonal_simetric_recta_afi(self,punt=Vector([6,-5,8]),p0=Vector([3,-2,-3]),v1=Vector([3,-1,1]),scale=0.1,radi=0.15,canonica=True):
                &#34;&#34;&#34;
                Draws the orthogonal projection and the symmetric of a point with respect an affine line
                Parameters:
                        punt: the initial point

                        p0: point of the affine line

                        v1: generator of the line

                        radi: radius of the points

                        canonica: if True, draws the x, y and z axis
                &#34;&#34;&#34;
                self.draw_point(location=p0,color=&#34;Blue&#34;,radius=radius,name=&#34;Punt de la recta&#34;)
                self.set_origin(p0)
                self.draw_vector(vector=v1,canonica=canonica,scale=scale,head_height=0.15,axis=20,name=&#34;Recta afí&#34;,color=&#34;Blue&#34;,positive=False)
                self.set_origin()
                self.draw_point(location=punt,color=&#34;Black&#34;,radius=radi,name=&#34;Punt inicial&#34;)
                u = punt - p0
                p1 = p0 + u.project(v1)
                size = 4 * (p1-p0).length
                if size &lt; 20:
                        size = 20
                self.draw_point(location=p1,color=&#34;Red&#34;,radius=radi,name=&#34;Projecció ortogonal&#34;)
                self.draw_plane_surface(origin=p1,normal=v1,name=&#34;Pla perpendicular a la recta&#34;,sizex=size,sizey=size)
                self.draw_point(location=2*p1-punt,color=&#34;Green&#34;,radius=radi,name=&#34;Simètric&#34;)
                self.draw_line(start=punt,end=2*p1-punt,scale=0.04,color=&#34;White&#34;)
        #
        # Projecció ortogonal i simètric sobre una recta vectorial
        #
        def projeccio_ortogonal_simetric_recta_vectorial(self,vector=Vector([7,-1,12]),v1=Vector([3,-1,1]),canonica=True):
                &#34;&#34;&#34;
                Draws the otoghonal projection and the symmetric of a vector with respecte a line
                Parameters:
                        vector: the initial vector

                        v1: generator of the line

                        canonica: if True, draws the x, y and z axis
                &#34;&#34;&#34;
                if not isinstance(vector,Vector):
                        vector = Vector(vector)
                if not isinstance(v1,Vector):
                        v1 = Vector(v1)
                if canonica:
                        self.base_canonica()
                self.draw_vector(v1,axis=20,positive=False,color=&#34;Blue&#34;,scale=0.066)
                self.draw_vector(vector)
                vp = vector.project(v1)
                self.draw_vector(vp,color=&#34;Red&#34;)
                self.set_origin(vp)
                self.draw_vector(vector - vp,scale=0.025,color=&#34;White&#34;)
                self.set_origin()
                self.draw_vector(2 * vp - vector,color=&#34;Green&#34;)
                self.draw_line(start=2 * vp - vector,end=vp,scale=0.04,color=&#34;White&#34;)
        #
        # Referència canònica
        #
        def referencia_canonica(self,origin=Vector([0,0,0]),length=15,scale=0.04,zaxis=True,name=&#34;Referència canònica&#34;):
                &#34;&#34;&#34;
                Draws the canonical reference
                Parameters:
                   origin: point where to represent the base

                   length: length of the axis

                   scale: scale of the cylinder

                   zaxis: if False the z axis is not drawn

                   name: name of the object
                &#34;&#34;&#34;
                if not isinstance(origin,Vector):
                        origin = Vector(origin)
                self.set_origin(origin)
                self.draw_base_axis(axis=length,positive=False,scale=scale,zaxis=zaxis,name=name)
        #
        # Punt en referència canònica
        #
        def punt_referencia_canonica(self,punt=Vector([-4,7,6]),radius=0.1,length=12,name=&#34;Punt p&#34;,coordenades=True):
                &#34;&#34;&#34;
                Draws a point expressed in the canonical reference
                Parameters:
                   punt: the point to draw

                   length: length of the axis

                   name: name of the point

                   components: if True draws lines representing the coordinates
                &#34;&#34;&#34;
                self.base_canonica(length=length)
                if not isinstance(punt,Vector):
                        punt = Vector(punt)
                self.draw_point(location=punt,color=&#34;Black&#34;,radius=radius,name=name)
                if coordenades:
                        self.draw_components(punt,name=&#34;Coordenades en referència canònica&#34;)
        #
        # Referència no canònica
        #
        def referencia_no_canonica(self,origin=Vector([0,0,0]),u1=Vector([1,-1,0]),u2=1/2*Vector([-1,2,1]),u3=Vector([-1,0,1]),length=12,scale=0.04,name=&#34;Referència R&#39;&#34;):
                &#34;&#34;&#34;
                Draws the reference {o;u1,u2,u3} with origin in the point origin and sets the default
                origin and default base to them
                Parameters:
                        origin: origin of the reference

                        u1, u2, u3: vectors of the base

                        length: length of the axis

                        scale: scale of the axis

                        name: name of the reference
                &#34;&#34;&#34;
                if not isinstance(origin,Vector):
                        origin = Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                if not isinstance(u3,Vector):
                        u3 = Vector(u3)
                self.set_origin(origin)
                self.set_base([u1,u2,u3])
                self.draw_base_axis(axis=length,positive=False,scale=scale,name=name)
        #
        # Punt en referencia no canònica
        #
        def punt_referencia_no_canonica(self,punt=Vector([5,6,-5]),origin=Vector([-2,3,3]),u1=1/3*Vector([-1,-2,2]),u2=1/3*Vector([2,1,2]),u3=1/3*Vector([-2,2,1]),length=12,scale=0.04,radius=0.1,name=&#34;Punt p&#34;):
                &#34;&#34;&#34;
                Draws a point expressed in the reference {o,u1,u2,u3} with origin in the point origin and sets the default
                origin and default base to them
                Parameters:
                        punt: point to draw

                        origin: origin of the reference

                        u1, u2, u3: vectors of the base

                        length: length of the axis

                        scale: scale of the axis

                        name: name of the reference
                &#34;&#34;&#34;
                self.referencia_no_canonica(origin=origin,u1=u1,u2=u2,u3=u3,length=length,scale=scale,name=&#34;Referència R&#39;&#34;)
                if not isinstance(punt,Vector):
                        punt = Vector(punt)
                self.draw_point(location=punt,color=&#34;Black&#34;,radius=radius,name=name)
                self.draw_components(punt,scale=0.015,name=&#34;Coordenades en referència R&#39;&#34;)
        #
        # Canvi de coordenades
        #
        def canvi_coordenades(self,punt=Vector([8,-6,7]),origin=Vector([-2,3,3]),u1=1/3*Vector([-1,-2,2]),u2=1/3*Vector([2,1,2]),u3=1/3*Vector([-2,2,1]),length=12,radius=0.1):
                &#34;&#34;&#34;
                Draw the coordinates of a point in the canonical reference and in the reference {o;u1,u2,u3}. Sets the default
                origin and default base to them
                Parameters:
                        punt: point to draw

                        origin: origin of the reference

                        u1, u2, u3: vectors of the base

                        length: length of the axis
                &#34;&#34;&#34;
                self.punt_referencia_canonica(punt=punt,length=length,radius=radius)
                self.set_colors([&#34;Magenta&#34;,&#34;Yellow&#34;,&#34;Cyan&#34;])
                self.referencia_no_canonica(origin=origin,u1=u1,u2=u2,u3=u3,length=length)
                p = self.coordinates_en_referencia(punt)
                self.draw_components(p,color=&#34;White&#34;,name=&#34;Coordenades en la referència R&#39;&#34;)
        #
        # El·lipse
        #
        def ellipse(self,center=Vector([0,0,0]),a=8,b=5,canonica=True):
                &#34;&#34;&#34;
                Draws the ellipse of equation (x-x0)^2/a^2 + (y-y0)^2/b^2 == 1
                Parameters:
                        centre: center of the ellipse

                        a, b: semiaxis of the ellipse

                        canonica: if True, draws the x and y axis
                &#34;&#34;&#34;
                if len(center) == 2:
                        center = (center[0],center[1],0)
                if not isinstance(center,Vector):
                        center = Vector(center)
                if a &gt;= b:
                        c = sqrt(a**2 - b**2)
                        f1 = Vector([c,0,0])
                        f2 = Vector([-c,0,0])
                else:
                        c = sqrt(b**2 - a**2)
                        f1 = Vector([0,c,0])
                        f2 = Vector([0,-c,0])
                if canonica:
                        self.referencia_canonica(zaxis=False)
                self.draw_ellipse(center=center,a=a,b=b,thickness=0.02,steps=128,axis=False)
                self.draw_point(radius=0.167,location=(0,0,0),name=&#34;Centre&#34;,color=&#34;White&#34;)
                self.draw_point(radius=0.167,location=f1,name=&#34;F1&#34;,color=&#34;Black&#34;)
                self.draw_point(radius=0.167,location=f2,name=&#34;F2&#34;,color=&#34;Black&#34;)
                self.set_origin()
        #
        # Hipèrbola
        #
        def hiperbola(self,center=Vector([0,0,0]),a=8,b=5,negatiu=False,canonica=True):
                &#34;&#34;&#34;
                Draws the hyperbole of equation (x-x0)^2/a^2 - (y-y0)^2/b^2 == 1 (or -1)
                Parameters:
                        centre: center of the hyperbole

                        a, b: semiaxis of the hyperbole

                        canonica: if True, draws the x and y axis

                        negatiu: if True, draws the hyperbole (x-x0)^2/a^2 - (y-y0)^2/b^2 == -1
                &#34;&#34;&#34;
                if len(center) == 2:
                        center = (center[0],center[1],0)
                if not isinstance(center,Vector):
                        center = Vector(center)
                u1 = Vector([a,b,0])
                u2 = Vector([a,-b,0])
                c = sqrt(a**2 + b**2)
                f1 = [c,0,0]
                f2 = [-c,0,0]
                if canonica:
                        self.referencia_canonica(zaxis=False)
                v1 = Vector([1,0,0])
                v2 = Vector([0,1,0])
                if negatiu:
                        self.set_base(base=[[0,1,0],[-1,0,0],[0,0,1]])
                        v1 = Vector([0,1,0])
                        v2 = Vector([-1,0,0])
                        u1 = Vector([b,a,0])
                        u2 = Vector([b,-a,0])
                self.draw_hyperbole(center=center,u1=v1,u2=v2,a=a,b=b,ymax=14,thickness=0.02,steps=128,axis=False)
                self.draw_point(radius=0.167,location=(0,0,0),name=&#34;Centre&#34;,color=&#34;White&#34;)
                self.draw_point(radius=0.167,location=f1,name=&#34;F1&#34;,color=&#34;Black&#34;)
                self.draw_point(radius=0.167,location=f2,name=&#34;F2&#34;,color=&#34;Black&#34;)
                self.draw_line(start=-5*u1,end=5*u1,color=&#34;Blue&#34;,scale=0.03,name=&#34;Asímptota 1&#34;)
                self.draw_line(start=-5*u2,end=5*u2,color=&#34;Blue&#34;,scale=0.03,name=&#34;Asímptota 2&#34;)
                self.set_origin()
                self.set_base()
        #
        # Paràbola
        #
        def parabola(self,vertex=Vector([0,0,0]),p=5,xmax=15,eixos=&#39;XY&#39;,canonica=True):
                &#34;&#34;&#34;
                Draws the parabola of equation y - y0 = (x-x0)^2/(2*p) or x - x0 = (y-y0)^2/(2*p)
                Parameters:
                        vertex: vertex of the parabola

                        p: parameter of the parabola

                        pmax: maximum value of the independent variable

                        eixos: &#39;XY&#39;, draws y - y0 = (x-x0)^2/(2*p)
                                   &#39;YX&#39;, draws x - x0 = (y-y0)^2/(2*p)

                        canonica: if True, draws the x and y axis
                &#34;&#34;&#34;
                if len(vertex) == 2:
                        vertex = (vertex[0],vertex[1],0)
                if not isinstance(vertex,Vector):
                        vertex = Vector(vertex)
                f = [0,p/2,0]
                if canonica:
                        self.referencia_canonica(zaxis=False)
                u1 = Vector([1,0,0])
                u2 = Vector([0,1,0])
                if eixos == &#39;YX&#39; or eixos == &#39;yx&#39;:
                        self.set_base(base=[[0,1,0],[1,0,0],[0,0,-1]])
                        u1 = Vector([0,1,0])
                        u2 = Vector([1,0,0])
                self.draw_parabola(vertex=vertex,a=1/(2*p),u1=u1,u2=u2,xmax=xmax,thickness=0.02,steps=128,axis=False)
                self.reset_rotation()
                self.draw_point(radius=0.167,location=f,name=&#34;Focus&#34;,color=&#34;Black&#34;)
                self.draw_point(radius=0.167,location=(0,0,0),name=&#34;Vèrtex&#34;,color=&#34;White&#34;)
                self.draw_line(start=[-xmax-3,-p/2,0],end=[xmax+3,-p/2,0],color=&#34;Blue&#34;,scale=0.04,name=&#34;Recta directriu&#34;)
                self.set_origin()
                self.set_base()
        #
        # El·lipsoide de revolucio
        #
        def ellipsoide_revolucio(self,a=12,b=8,direccio=&#39;Z&#39;,punt=None):
                &#34;&#34;&#34;
                Draws an animation showing an ellipsoid of revolution
                        a, b: semiaxis of the initial ellipse

                        direccio: &#39;X&#39;, the initial ellipse is in the plane XZ and rotates around the X axis
                                          &#39;Y&#39;, the initial ellipse is in the plane YZ and rotates around the Y axis
                                          &#39;Z&#39;, the initial ellipse is in the plane ZX and rotates around the Z axis

                        punt: if it&#39;s a value between 0 and pi, the animation shows a rotating point
                &#34;&#34;&#34;
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        F = lambda t: (a*cos(t),0,b*sin(t))
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        F = lambda t: (0,a*cos(t),b*sin(t))
                else:
                        F = lambda t: (b*sin(t),0,a*cos(t))
                self.base_canonica()
                self.animate_revolution_surface(F,tmin=0,tmax=pi,steps=128,axis=direccio,point=punt)
        #
        # Hiperboloide d&#39;una fulla de revolució
        #
        def hiperboloide_una_fulla_revolucio(self,a=3,b=2,pmax=8,direccio=&#39;Z&#39;,punt=None):
                &#34;&#34;&#34;
                Draws an animation showing an one sheet hyperboloid of revolution
                        a, b: semiaxis of the initial hyperbole

                        pmax: maximum value of the independent variable

                        direccio: &#39;X&#39;, the initial hyperbole is in the plane XZ and rotates around the X axis
                                  &#39;Y&#39;, the initial hyperbole is in the plane YX and rotates around the Y axis
                                      &#39;Z&#39;, the initial hyperbole is in the plane ZX and rotates around the Z axis

                        punt: if it&#39;s a value between 0 and pi, the animation shows a rotating point
                &#34;&#34;&#34;
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        F = lambda t: (t,0,a*math.sqrt(1+t**2/b**2))
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        F = lambda t: (a*math.sqrt(1+t**2/b**2),t,0)
                else:
                        F = lambda t: (a*math.sqrt(1+t**2/b**2),0,t)
                self.base_canonica()
                self.animate_revolution_surface(F,tmin=-pmax,tmax=pmax,steps=128,axis=direccio,point=punt)
        #
        # Hiperboloide de dues fulles de revolució
        #
        def hiperboloide_dues_fulles_revolucio(self,a=3,b=2,pmax=8,direccio=&#39;Z&#39;,punt=None):
                &#34;&#34;&#34;
                Draws an animation showing a two sheet hyperboloid of revolution
                        a, b: semiaxis of the initial hyperbole

                        pmax: maximum value of the independent variable

                        direccio: &#39;X&#39;, the initial hyperbole is in the plane YX and rotates around the X axis
                                  &#39;Y&#39;, the initial hyperbole is in the plane ZY and rotates around the Y axis
                                      &#39;Z&#39;, the initial hyperbole is in the plane XZ and rotates around the Z axis

                        punt: if it&#39;s a value between 0 and pi, the animation shows a rotating point
                &#34;&#34;&#34;
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        s = &#39;Z&#39;
                        F = lambda t: (a*math.sqrt(1+t**2/b**2),t,0)
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        F = lambda t: (0,a*math.sqrt(1+t**2/b**2),t)
                        s = &#39;Z&#39;
                else:
                        F = lambda t: (t,0,a*math.sqrt(1+t**2/b**2))
                        s = &#39;X&#39;
                self.base_canonica()
                self.animate_revolution_surface(F,tmin=-pmax,tmax=pmax,steps=128,axis=direccio,symmetry=s,point=punt)
        #
        # Con de revolució
        #
        def con_revolucio(self,a=1.5,pmax=8,direccio=&#39;Z&#39;,punt=None):
                &#34;&#34;&#34;
                Draws an animation showing a cone of revolution
                        a: slope of the initial straight line

                        pmax: maximum value of the independent variable

                        direccio: &#39;X&#39;, the initial line is in the plane YX and rotates around the X axis
                                  &#39;Y&#39;, the initial line is in the plane ZY and rotates around the Y axis
                                      &#39;Z&#39;, the initial line is in the plane XZ and rotates around the Z axis

                        punt: if it&#39;s a value between -pmax and pmax, the animation shows a rotating point
                &#34;&#34;&#34;
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        F = lambda t: (a*t,t,0)
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        F = lambda t: (0,a*t,t)
                else:
                        F = lambda t: (t,0,a*t)
                self.base_canonica()
                self.animate_revolution_surface(F,tmin=-pmax,tmax=pmax,steps=128,axis=direccio,point=punt)
        #
        # Paraboloide el·líptic de revolució
        #
        def paraboloide_elliptic_revolucio(self,a=0.5,pmax=5,direccio=&#39;Z&#39;,punt=None):
                &#34;&#34;&#34;
                Draws an animation showing an elliptic paraboloid of revolution
                        a: The constant of the initial parabola

                        pmax: maximum value of the independent variable

                        direccio: &#39;X&#39;, the initial parabola is in the plane YX and rotates around the X axis
                                  &#39;Y&#39;, the initial parabola is in the plane ZY and rotates around the Y axis
                                      &#39;Z&#39;, the initial parabola is in the plane XZ and rotates around the Z axis

                        punt: if it&#39;s a value between -pmax and pmax, the animation shows a rotating point
                &#34;&#34;&#34;
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        F = lambda t: (a*t**2,t,0)
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        F = lambda t: (0,a*t**2,t)
                else:
                        F = lambda t: (t,0,a*t**2)
                self.base_canonica()
                self.animate_revolution_surface(F,tmin=0,tmax=pmax,steps=128,axis=direccio,point=punt)
        #
        # Paraboloide hiperbòlic
        #
        def paraboloide_hiperbolic_simple(self,a=3,b=4,xmax=12,ymax=12):
                &#34;&#34;&#34;
                Draws the hyperbolic paraboloid of equation z = x^2/a^2 - y^2/b^2
                Parameters:
                        a, b: constants the defines he hyperbolic paraboloid

                        xmax, ymax: maximun values of the x and y coordinates
                &#34;&#34;&#34;
                self.hyperbolic_paraboloid(a2=a**2,b2=b**2,xmax=xmax,ymax=ymax,canonica=True,principal=False)
        #
        # Cilindre el·líptic
        #
        def cilindre_elliptic_simple(self,a=10,b=6,direccio=&#39;Z&#39;,pmax=26):
                &#34;&#34;&#34;
                Draws an elliptic cylinder with direction X, Y or Z
                Parameters:
                        a, b: semiaxis of the ellipse

                        direction: direction of translation of the ellipse

                        pmax = height of the cylindrer
                &#34;&#34;&#34;
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        u1 = Vector([0,0,1])
                        u2 = Vector([0,1,0])
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        u1 = Vector([1,0,0])
                        u2 = Vector([0,0,1])
                else:
                        u1 = Vector([1,0,0])
                        u2 = Vector([0,1,0])
                self.elliptic_cylinder(a2=a**2,b2=b**2,u1=u1,u2=u2,zmax=pmax,canonica=True,principal=False)
                self.draw_ellipse(a=a,b=b,u1=u1,u2=u2,thickness=0.02,steps=128,axis=False)
                self.reset()
        #
        # Cilindre hiperbòlic
        #
        def cilindre_hiperbolic_simple(self,a=4,b=3,direccio=&#39;Z&#39;,pmax=12,hmax=26):
                &#34;&#34;&#34;
                Draws an hyperbolic cylinder with direction X, Y or Z
                Parameters:
                        a, b: semiaxis of the hyperbole

                        direction: direction of translation of the hyperbole

                        pmax = maximum value of the independent variable

                        hmax = height of the cylindrer
                &#34;&#34;&#34;
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        u1 = Vector([0,0,1])
                        u2 = Vector([0,1,0])
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        u1 = Vector([1,0,0])
                        u2 = Vector([0,0,1])
                else:
                        u1 = Vector([1,0,0])
                        u2 = Vector([0,1,0])
                self.hyperbolic_cylinder(a2=a**2,b2=b**2,u1=u1,u2=u2,xmax=pmax,zmax=hmax,canonica=True,principal=False)
                self.draw_hyperbole(a=a,b=b,u1=u1,u2=u2,thickness=0.02,ymax=b*math.sqrt(-1+(pmax/a)**2),steps=128,axis=False)
                self.reset()
        #
        # Cilindre parabòlic
        #
        def cilindre_parabolic_simple(self,a=3,direccio=&#39;Z&#39;,pmax=10,hmax=26):
                &#34;&#34;&#34;
                Draws a parabolic cylinder with direction X, Y or Z
                Parameters:
                        a: the initial parabola has equation of type z=\pm x^2/a^2

                        direction: direction of translation of the hyperbole

                        pmax = maximum value of the independent variable

                        hmax = height of the cylindrer
                &#34;&#34;&#34;
                if a == 0:
                        return
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        u1 = Vector([0,0,1])
                        u2 = Vector([0,-1,0])
                        v1 = Vector([0,0,1])
                        v2 = Vector([1,0,0])
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        u1 = Vector([1,0,0])
                        u2 = Vector([0,0,-1])
                        v1 = Vector([1,0,0])
                        v2 = Vector([0,1,0])
                else:
                        u1 = Vector([1,0,0])
                        u2 = Vector([0,1,0])
                        v1 = Vector([1,0,0])
                        v2 = Vector([0,0,1])
                s = 1
                if a &lt; 0:
                        s = -1
                self.parabolic_cylinder(a=a,u1=u1,u2=u2,xmax=pmax,canonica=True,principal=False)
                self.draw_parabola(a=s/a**2,u1=v1,u2=v2,thickness=0.02,xmax=pmax,steps=128,axis=False)
                self.reset()
        #
        # Esfera
        #
        def esfera(self,centre=Vector([0,0,0]),radi=10,cmax=20):
                &#34;&#34;&#34;
                Draws a sphere
                Parametre:
                        centre: center of the sphere

                        radi: radius of the sphere

                        cmax: maximum values of the x, y and z coordinates
                &#34;&#34;&#34;
                self.sphere(o=centre,r2=radi**2,canonica=True,principal=False,cmax=cmax)
        #
        # Tor
        #
        def tor(self,centre=Vector([8,0,3]),radi=3,punt=None):
                &#34;&#34;&#34;
                Draws a torus of revolution from a circumference
                Parameters:
                        centre: center of the circumference

                        radi: radius of the circumference

                        cmax: maximum values of the x, y and z coordinates

                        punt: if it&#39;s a float value, draws a moving poing
                &#34;&#34;&#34;
                self.base_canonica(length=cmax)
                if len(centre) == 2:
                        centre = (centre[0],0,centre[1])
                if not isinstance(centre,Vector):
                        centre = Vector(centre)
                def F(t):
                        return (centre + Vector([radi*math.cos(t),0,radi*math.sin(t)]))
                self.animate_revolution_surface(F,tmin=0,tmax=2*pi,steps=128,axis=&#39;Z&#39;,point=punt)
        #
        # Revolució d&#39;una paràbola que no és un paraboloide
        #
        def superficie_revolucio_parabola(self,a=0.2,vertex=Vector([0,0,0]),pmax=8,pla=&#39;XZ&#39;,punt=None):
                &#34;&#34;&#34;
                Draws an animation of a revolution surface from a paràbola
                Parameters:
                        a: the paràbola is of the form y = a*x^2

                        vertex: vertex of the parabola

                        pmax: maximum value of the independent variable

                        pla: a value from the list (&#39;XY&#39;,&#39;YX&#39;,&#39;XZ&#39;,&#39;ZX&#39;,&#39;YZ&#39;,&#39;ZY&#39;) representing
                             the variables for the equation
                                 &#39;XY&#39; y = a*x^2 and rotaqtion around the X axis
                                 &#39;YX&#39; x = a*y^2 and rotaqtion around the Y axis
                                 &#39;XZ&#39; z = a*x^2 and rotaqtion around the X axis
                                 &#39;ZX&#39; x = a*x^2 and rotaqtion around the Z axis
                                 &#39;YZ&#39; z = a*y^2 and rotaqtion around the Y axis
                                 &#39;ZY&#39; y = a*z^2 and rotaqtion around the Z axis

                        punt: punt: if it&#39;s a float value, draws a moving poing
                &#34;&#34;&#34;
                self.base_canonica()
                if not isinstance(vertex,Vector):
                        vertex = Vector(vertex)
                def F(t):
                        if pla.upper() == &#39;XZ&#39;:
                                return (vertex + Vector([t,0,a*t**2]))
                        if pla.upper() == &#39;XY&#39;:
                                return (vertex + Vector([t,a*t**2,0]))
                        if pla.upper() == &#39;ZX&#39;:
                                return (vertex + Vector([a*t**2,0,t]))
                        if pla.upper() == &#39;ZY&#39;:
                                return (vertex + Vector([0,a*t**2,t]))
                        if pla.upper() == &#39;YZ&#39;:
                                return (vertex + Vector([0,t,a*t**2]))
                        if pla.upper() == &#39;YX&#39;:
                                return (vertex + Vector([a*t**2,t,0]))
                self.animate_revolution_surface(F,tmin=-pmax,tmax=pmax,steps=128,axis=pla[0],point=punt)
        #
        # Rotació d&#39;un ortoedre
        #
        def rotacio_ortoedre(self,centre=Vector([0,0,0]),costats=Vector([8,5,4]),eix=&#39;Z&#39;,opacity=1):
                &#34;&#34;&#34;
                Draws an animation of an orthohedron rotating around a vectorial line
                Parameters:
                        centre: center of the orthohedron

                        costats: half sides of the orthohedron

                        eix: axis of rotation

                        opacity: opacity of the orthohedron
                &#34;&#34;&#34;
                self.base_canonica()
                if not isinstance(centre,Vector):
                        centre = Vector(centre)
                if not isinstance(costats,Vector):
                        costats = Vector(costats)
                ortoedre = self.draw_cube(origin=centre,scale=costats,color=&#34;AzureBlueDark&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Ortoedre&#34;)
                self.rotate_object(ortoedre,axis=eix,draw=False)
        #
        # Rotació d&#39;un vector
        #
        def rotacio_vector(self,vector=Vector([6,8,5]),eix=Vector([1,1,1])):
                &#34;&#34;&#34;
                Draws an animation of a vector rotating around a vectorial line
                Parameters:
                        vector: vector to rotate

                        eix: axis of rotation, given by a vector or by X, Y or Z
                &#34;&#34;&#34;
                self.base_canonica(length=vector.length + 2)
                self.rotate_vector(vector,eix)
        #
        # Rotació d&#39;un ortoedre a partir dels angles d&#39;Euler
        #
        def rotacio_ortoedre_angles_euler(self,centre=Vector([0,0,0]),costats=Vector([8,5,4]),psi=90,theta=60,phi=45,radians=False,opacity=1,eixos=&#39;zxz&#39;):
                &#34;&#34;&#34;
                Draws an animation of an orthohedron rotating given the Euler&#39;s angles
                Parameters:
                        centre: center of the orthohedron

                        costats: half sides of the orthohedron

                        psi, theta, phi: Euler&#39;s angles

                        radians: if True the Euler&#39;s angles must in radians. If False in degrees

                        opacity: opacity of the orthohedron

                        eixos: axis of the three rotations
                &#34;&#34;&#34;
                if not isinstance(centre,Vector):
                        centre = Vector(centre)
                if not isinstance(costats,Vector):
                        costats = Vector(costats)
                ortoedre = self.draw_cube(origin=centre,scale=costats,color=&#34;AzureBlueDark&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Ortoedre&#34;)
                self.rotate_euler(ortoedre,psi,theta,phi,radians=radians,axis=eixos)
        #
        # Rotació d&#39;un ortoedre al voltant d&#39;un eix i angles d&#39;Euler
        #
        def rotacio_ortoedre_voltant_vector(self,centre=Vector([0,0,0]),costats=Vector([8,5,4]),angle=80,radians=False,vector=Vector([1,-2,1]),opacity=0.7,euler=None,reverse=False):
                &#34;&#34;&#34;
                Draws an animation of a vector rotating around a vectorial line
                Parameters:
                        centre: center of the orthohedron

                        costats: half sides of the orthohedron

                        angle: angle of rotation

                        radians: if True the Euler&#39;s angles must in radians. If False in degrees

                        vector: generator of the vectorial line

                        opacity: opacity of the orthohedron

                        euler: None or the value of the three Euler&#39;s axis

                        reverse: if True, shows the rotation with Euler&#39;s angles in reverse order
                &#34;&#34;&#34;
                if not isinstance(centre,Vector):
                        centre = Vector(centre)
                if not isinstance(costats,Vector):
                        costats = Vector(costats)
                if not isinstance(vector,Vector):
                        vector = Vector(vector)
                ortoedre = self.draw_cube(origin=centre,scale=costats,color=&#34;AzureBlueDark&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Primer ortoedre&#34;)
                if euler is not None:
                        ortoedre2 = self.draw_cube(origin=centre,scale=costats,color=&#34;Green&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Segon ortoedre&#34;)
                self.rotate_object_by_axis_angle(obj=ortoedre,axis=vector,angle=angle,frames=3)
                if euler is not None:
                        R = Rotation(angle=angle,vector=vector)
                        psi, theta, phi = R.to_euler_angles(axis=euler)
                        self.rotate_euler(ortoedre2,psi=psi,theta=theta,phi=phi,axis=euler,canonica=False,reverse=reverse)
        #
        # Rotació afí i moviment helicoidal
        #
        def moviment_helicoidal_ortoedre(self,centre=Vector([0,0,0]),costats=Vector([3,4,2]),opacity=1,origen=Vector([4,3,0]),eix=&#39;Z&#39;,translacio=0.0):
                &#34;&#34;&#34;
                Draws an animation of the helical motion of an orthohedron around an affine line
                Parameters:
                        centre: center of the orthohedron

                        costats: half sides of the orthohedron

                        origen: point of the affine line

                        eix: axis of rotation

                        opacity: opacity of the orthohedron

                        translation: translation of the helical motion (distance by frame)
                                     if translation = 0.0, it&#39;s a rotation motion
                &#34;&#34;&#34;
                self.base_canonica()
                if not isinstance(centre,Vector):
                        centre = Vector(centre)
                if not isinstance(costats,Vector):
                        costats = Vector(costats)
                if not isinstance(origen,Vector):
                        origen = Vector(origen)
                ortoedre = self.draw_cube(origin=centre,scale=costats,color=&#34;AzureBlueDark&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Ortoedre&#34;)
                self.rotate_object(ortoedre,axis=eix,origin=origen,helicoidal=translacio)
        #
        # Gir en el pla d&#39;un poligon
        #
        def gir_poligon(self,centre=Vector([0,0,0]),costats=6,origen=Vector([0,0,0]),radi=8):
                &#34;&#34;&#34;
                Draws an animation of the rotation around a point of a polygon in the plane XY
                Parameters:
                        centre: center of the polygon

                        costats: sides of the polygon

                        origen: center of the rotation

                        radi: radius of the polygon
                &#34;&#34;&#34;
                if len(centre) == 2:
                        centre = [centre[0],centre[1],0]
                if len(origen) == 2:
                        origen = [origen[0],origen[1],0]
                if not isinstance(centre,Vector):
                        centre = Vector(centre)
                if not isinstance(origen,Vector):
                        origen = Vector(origen)
                self.base_canonica(zaxis=False)
                self.draw_point(radius=0.167,location=origen,name=&#34;Centre del gir&#34;,color=&#34;White&#34;)
                poligon = self.draw_regular_polygon(origin=centre,vertexs=costats,radius=radi,name=&#34;Polígon regular&#34;)
                self.rotate_object(poligon,axis=&#39;Z&#39;,origin=origen,draw=False)
        #
        # Quàdriques
        #
        ellipsoide = ellipsoid
        hiperboloide_dues_fulles = two_sheets_hyperboloid
        hiperboloide_una_fulla = one_sheet_hyperboloid
        con = cone
        paraboloide_elliptic = elliptic_paraboloid
        paraboloide_hiperbolic = hyperbolic_paraboloid
        cilindre_elliptic = elliptic_cylinder
        cilindre_hiperbolic = hyperbolic_cylinder
        cilindre_parabolic = parabolic_cylinder
        #
        # Esfera i cilindre el·liptic
        #
        def esfera_cilindre_elliptic(self,radi=10,x0=5,a=5,b=5):
                &#34;&#34;&#34;
                Draws an sphere centered at (0,0,0), an elliptic cylinder and their intersection
                Parameters:
                        radi: radius of the sphere

                        x0: (x0,0,0) is the center of the ellipse in the plain XY

                        a, b: semiaxis of this ellipse
                &#34;&#34;&#34;
                if radi &lt;= 0:
                        return
                def F(t):
                        x = x0 + a*math.cos(t)
                        y = b*math.sin(t)
                        z = radi**2 - x**2 - y**2
                        if z &lt; 0:
                                z  = 0
                        z = math.sqrt(z)
                        return (x,y,z)
                self.sphere(r2=radi**2,canonica=True,color=&#34;GrayLight&#34;,thickness=0.0001,pmax=3*radi+3,name=&#34;Esfera&#34;)
                self.elliptic_cylinder(o=[x0,0,0],a2=a**2,b2=b**2,principal=False,canonica=False,zmax=3*radi,thickness=0.01,name=&#34;Cilindre&#34;)
                x, y = symbols(&#39;x y&#39;,real=True)
                sol = solve([x**2 + y**2 - radi**2, (x-x0)**2/a**2 + y**2/b**2 - 1],[x,y],dict=True)
                #
                # 1. solve retorna una única solució
                # La solució és el punt (x0+a,0) o (x0-a,0,0)
                #
                if len(sol) == 1:
                        #
                        # L&#39;altre vèrtex està dins o fora de la circumferència x^2 + y^2 = radi^2
                        #
                        if (sol[0][x] == radi and abs(x0 - a) &lt; radi) or (sol[0][x] == - radi and abs(x0 + a) &lt; radi):
                                self.curve(F,tmin=0,tmax=2*pi,steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
                        else:
                                self.draw_point(radius=0.2,location=(sol[0][x],sol[0][y],0),name=&#34;Punt intersecció&#34;,color=&#34;Black&#34;,opacity=1.0)
                #
                # 2. solve retorna dues solucions
                #
                if len(sol) == 2:
                        try:
                                sol[0][x]
                                sol[0][y]
                                sol[1][x]
                                sol[1][y]
                                circ = False
                        except:
                                circ = True
                        if circ:
                                #
                                # El cilindre és de revolució i les circumferències al pla XY coincideixen
                                #
                                self.draw_circle(radius=radi,steps=64,thickness=0.05,name=&#34;Circumferència&#34;,color=&#34;Black&#34;)
                        else:
                                #
                                # Tenim dues solucions diferents, que han de ser (radi,0) i (-radi,0)
                                #
                                if abs(b) &lt; radi:
                                        theta = [math.atan2(sol[i][y]/b,(sol[i][x] - x0)/a) for i in range(2)]
                                        theta.sort()
                                        if x0 &gt; 0:
                                                self.curve(F,tmin=theta[1],tmax=2*pi-theta[1],steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
                                        else:
                                                self.curve(F,tmin=theta[0],tmax=theta[1],steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
                                else:
                                        self.draw_point(radius=0.2,location=(sol[0][x],sol[0][y],0),name=&#34;Punt intersecció 1&#34;,color=&#34;Black&#34;,opacity=1.0)
                                        self.draw_point(radius=0.2,location=(sol[1][x],sol[1][y],0),name=&#34;Punt intersecció 2&#34;,color=&#34;Black&#34;,opacity=1.0)
                #
                # 2. solve retorna tres solucions
                #
                if len(sol) == 3:
                        theta = [math.atan2(sol[i][y]/b,(sol[i][x] - x0)/a) for i in range(3)]
                        theta.sort()
                        if theta[1] == 0.0:
                                self.curve(F,tmin=theta[0],tmax=theta[2],steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
                        if theta[2] == math.pi:
                                self.curve(F,tmin=theta[1],tmax=theta[0]+2*math.pi,steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
                #
                # 2. solve retorna quatre solucions
                #
                if len(sol) == 4:
                        theta = [math.atan2(sol[i][y]/b,(sol[i][x] - x0)/a) for i in range(4)]
                        theta.sort()
                        self.curve(F,tmin=theta[2],tmax=theta[3],steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=(&#39;XY&#39;,&#39;XZ&#39;,&#39;X&#39;),name=&#34;Corba intersecció&#34;)
        #
        # Con i cilindre el·liptic
        #
        def con_cilindre_elliptic(self,a2=1,b2=1,c2=1,x0=5,a=8,b=5,zmax=15):
                &#34;&#34;&#34;
                Draws a cone with vertex at (0,0,0) and equation x^2/a2 + y^2/b2 - z^2/c2 == 0,
                an elliptic cylinder and their intersection
                Parameters:
                        a2, b2, c2: coefficients of the equation of the cone

                        x0: (x0,0,0) is the center of the ellipse in the plain XY

                        a, b: semiaxis of this ellipse

                        zmax: maximum value of the z coordinate
                &#34;&#34;&#34;
                a2, b2, c2 = abs(a2), abs(b2), abs(c2)
                if a2*b2*c2 == 0:
                        return
                xmax = zmax*math.sqrt(a2/c2)
                def F(t):
                        x = x0 + a*math.cos(t)
                        y = b*math.sin(t)
                        z = math.sqrt(c2*(x**2/a2 + y**2/b2))
                        return (x,y,z)
                self.cone(a2=a2,b2=b2,c2=c2,principal=False,canonica=True,color=&#34;GrayLight&#34;,thickness=0.0001,name=&#34;Con&#34;,xmax=xmax,cmax=xmax+5,opacity=1.0)
                self.elliptic_cylinder(o=[x0,0,0],a2=a**2,b2=b**2,principal=False,canonica=False,zmax=2*(zmax+3),thickness=0.01,name=&#34;Cilindre&#34;)
                self.curve(F,tmin=0,tmax=2*pi,steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="LinearAlgebra.LinearAlgebra.add_ligth"><code class="name flex">
<span>def <span class="ident">add_ligth</span></span>(<span>self, location=[0, 0, 100], energy=3, direction=[0, 0, -1])</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a ligth to the scene</p>
<h2 id="parameters">Parameters</h2>
<p>location: location point of the light</p>
<p>energy: energy of the ligth</p>
<p>direction: direction of the light</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_ligth(self,location=[0,0,100],energy=3,direction=[0,0,-1]):
        &#34;&#34;&#34;
        Adds a ligth to the scene
        Parameters:
           location: location point of the light

           energy: energy of the ligth

           direction: direction of the light
        &#34;&#34;&#34;
        l = bpy.data.lights.new(name=&#34;Light&#34;, type=&#39;SUN&#39;)
        l.energy = energy
        l.specular_factor = 4
        obj = self.objects.new(name=&#34;Light&#34;, object_data=l)
        obj.rotation_mode = &#39;QUATERNION&#39;
        obj.location = location
        n = Vector(direction)
        mat = Matrix(self.base)
        mat.transpose()
        n = mat @ n
        z = Vector([0,0,-1])
        quaternion = z.rotation_difference(n)
        obj.rotation_quaternion.rotate(quaternion)
        self.collection.objects.link(obj)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.add_ligths"><code class="name flex">
<span>def <span class="ident">add_ligths</span></span>(<span>self, energy=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds diferent lights to the scene</p>
<h2 id="parameters">Parameters</h2>
<p>energy: energy of the lights</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_ligths(self,energy=1):
        &#34;&#34;&#34;
        Adds diferent lights to the scene
        Parameters:
           energy: energy of the lights
        &#34;&#34;&#34;
        self.add_ligth()
        self.add_ligth(location=[100,0,0],direction=[-1,0,0],energy=energy)
        self.add_ligth(location=[0,100,0],direction=[0,-1,0],energy=energy)
        self.add_ligth(location=[-100,0,0],direction=[1,0,0],energy=energy)
        self.add_ligth(location=[0,-100,0],direction=[0,1,0],energy=energy)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.add_material"><code class="name flex">
<span>def <span class="ident">add_material</span></span>(<span>self, obj, material_name, r, g, b, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a material and color to an object</p>
<h2 id="parameters">Parameters</h2>
<p>obj: object</p>
<p>material_name: material's name</p>
<p>r, g, b: RGB color values</p>
<p>opacity: the opacity</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_material(self,obj,material_name,r,g,b,opacity=1.0):
        &#34;&#34;&#34;
        Adds a material and color to an object
        Parameters:
           obj: object

           material_name: material&#39;s name

           r, g, b: RGB color values

           opacity: the opacity
        &#34;&#34;&#34;
        material = bpy.data.materials.get(material_name)
        if material is None:
                material = bpy.data.materials.new(material_name)
        material.use_nodes = True
        principled_bsdf = material.node_tree.nodes[&#39;Principled BSDF&#39;]
        if principled_bsdf is not None:
                #for i, o in enumerate(principled_bsdf.inputs):
                #       print(i, o.name)
                principled_bsdf.inputs[&#39;Base Color&#39;].default_value = (r, g, b, 0.5)
                principled_bsdf.inputs[&#39;IOR&#39;].default_value = 0.0
                principled_bsdf.inputs[&#39;Metallic&#39;].default_value = 1.0
                if bpy.app.version[0] &lt; 4:
                        principled_bsdf.inputs[&#39;Specular&#39;].default_value = 1.0
                else:
                        principled_bsdf.inputs[&#39;Specular IOR Level&#39;].default_value = 1.0
                if bpy.app.version[0] &lt; 4:
                        principled_bsdf.inputs[&#39;Emission&#39;].default_value = (r, g, b, 0.5)
                else:
                        principled_bsdf.inputs[&#39;Emission Color&#39;].default_value = (r, g, b, 0.5)
                principled_bsdf.inputs[&#39;Emission Strength&#39;].default_value = 0.0
                if opacity &lt; 1.0:
                        material.blend_method = &#39;BLEND&#39;
                        principled_bsdf.inputs[&#39;Alpha&#39;].default_value = opacity
                else:
                        material.blend_method = &#39;OPAQUE&#39;
                        principled_bsdf.inputs[&#39;Alpha&#39;].default_value = 1.0
        obj.active_material = material</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.animate_revolution_surface"><code class="name flex">
<span>def <span class="ident">animate_revolution_surface</span></span>(<span>self, fun=None, tmin=0.0, tmax=1.0, steps=256, curvethicknes=0.025, thickness=0.025, frames=3, angle=3, radians=False, axis='Z', symmetry=None, name='Revolution surface', color='AzureBlueDark', point=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws and animates a revolution surface from a curve</p>
<h2 id="parameters">Parameters</h2>
<p>fun: parametric equacion of the curve</p>
<p>steps: number of steps to graw the curve</p>
<p>curvethicknes: thickness of the curve</p>
<p>frames: number of frames at each step of revolution</p>
<p>angle: step angle of the revolution</p>
<p>radians: if True, angle must be in radians</p>
<p>axis: axis of revolution. It must be 'X', 'Y' or 'Z'</p>
<p>symmetry: symmetry used to draw the curve</p>
<p>name: name of the surface</p>
<p>color: color of the surface</p>
<p>point: if not None draw three points and a cercle. Must be a float between tmax and tmin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def animate_revolution_surface(self,fun=None,tmin=0.0,tmax=1.0,steps=256,curvethicknes=0.025,thickness=0.025,frames=3,angle=3,radians=False,axis=&#39;Z&#39;,symmetry=None,name=&#34;Revolution surface&#34;,color=&#34;AzureBlueDark&#34;,point=None):
        &#34;&#34;&#34;
        Draws and animates a revolution surface from a curve
        Parameters:
           fun: parametric equacion of the curve

           steps: number of steps to graw the curve

           curvethicknes: thickness of the curve

           frames: number of frames at each step of revolution

           angle: step angle of the revolution

           radians: if True, angle must be in radians

           axis: axis of revolution. It must be &#39;X&#39;, &#39;Y&#39; or &#39;Z&#39;

           symmetry: symmetry used to draw the curve

           name: name of the surface

           color: color of the surface

           point: if not None draw three points and a cercle. Must be a float between tmax and tmin
        &#34;&#34;&#34;
        if radians:
                angle *= 180/math.pi
        stepsr = int(360/angle) + 1
        angle = 360/stepsr
        if fun is None:
                return None
        if axis == &#39;X&#39;:
                r = Rotation(angle,Vector([1,0,0]))
                d1 = Vector([0,1,0])
                d2 = Vector([0,0,1])
        elif axis == &#39;Y&#39;:
                r = Rotation(angle,Vector([0,1,0]))
                d1 = Vector([0,0,1])
                d2 = Vector([1,0,0])
        elif axis == &#39;Z&#39;:
                r = Rotation(angle,Vector([0,0,1]))
                d1 = Vector([1,0,0])
                d2 = Vector([0,1,0])
        else:
                return None

        if point is not None:
                try:
                        tp = 1.0 * point
                except:
                        pass
                if not isinstance(tp,float):
                        return None
                if tp &lt; tmin or tp &gt; tmax:
                        tp = random.uniform(tmin,tmax)
                zp = Vector(fun(tp))
                e = d1.cross(d2)
                z0 = zp.project(e)

        p2 = self.curve(fun,tmin=tmin,tmax=tmax,steps=steps,thickness=curvethicknes,color=&#34;Red&#34;,symmetry=symmetry,name=&#34;Rotating curve&#34;)
        p1 = self.curve(fun,tmin=tmin,tmax=tmax,steps=steps,thickness=1.05*curvethicknes,color=&#34;Blue&#34;,symmetry=symmetry,name=&#34;Curve&#34;)
        obj = self.simple_curve(fun,tmin=tmin,tmax=tmax,steps=steps,name=&#34;Surface of revolution&#34;,symmetry=symmetry)
        if point is not None:
                m1 = self.draw_point(radius=0.1,location=zp,name=&#34;Punt p0&#34;,color=&#34;Red&#34;)
                m2 = self.draw_point(radius=0.1,location=zp,name=&#34;Punt p1&#34;,color=&#34;Black&#34;)
                m3 = self.draw_point(radius=0.1,location=z0,name=&#34;Punt p2&#34;,color=&#34;Blue&#34;)
                l1 = self.draw_line(start=z0,end=zp,scale=0.04,name=&#34;Línia 1&#34;,color=&#34;Black&#34;)
                l2 = self.draw_line(start=z0,end=zp,scale=0.03,name=&#34;Línia 2&#34;,color=&#34;Red&#34;)
                self.draw_circle(center=z0,u1=d1,u2=d2,radius=(zp-z0).length,steps=128,thickness=0.005,name=&#34;Circle&#34;,color=&#34;Cyan&#34;)

        m = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        m.levels = 4
        m.subdivision_type = &#39;SIMPLE&#39;
        m = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
        m.thickness = thickness
        m.offset = 1.0
        m = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
        m.angle = 0.0
        m.steps = steps
        m.axis =  axis
        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
        bpy.context.scene.collection.objects.link(obj)

        bpy.context.scene.frame_set(self.frame)
        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        obj.keyframe_insert(data_path=&#39;modifiers[&#34;Screw&#34;].angle&#39;,index=-1)
        p2.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        if point is not None:
                l1.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                m2.keyframe_insert(data_path=&#34;location&#34;,index=-1)
        fn = frames + self.frame
        for i in range(0,stepsr):
                bpy.context.scene.frame_set(fn)
                p2.rotation_quaternion.rotate(r.quaternion)
                p2.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                obj.modifiers[&#34;Screw&#34;].angle = 2 * (i+1) * math.pi / stepsr
                obj.modifiers[&#34;Screw&#34;].steps = i+1
                obj.keyframe_insert(data_path=&#39;modifiers[&#34;Screw&#34;].angle&#39;,index=-1)
                if point is not None:
                        l1.rotation_quaternion.rotate(r.quaternion)
                        l1.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        m2.location.rotate(r.quaternion)
                        m2.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn += frames
        self.frame = fn - frames
        bpy.context.scene.frame_end = self.frame
        bpy.context.scene.frame_set(0)
        bpy.context.view_layer.update()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.base_canonica"><code class="name flex">
<span>def <span class="ident">base_canonica</span></span>(<span>self, origin=Vector((0.0, 0.0, 0.0)), length=15, scale=0.04, zaxis=True, name='Base canònica')</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the canonical base</p>
<h2 id="parameters">Parameters</h2>
<p>origin: point where to represent the base</p>
<p>length: length of the axis</p>
<p>scale: scale of the cylinder</p>
<p>zaxis: if False the z axis is not drawn</p>
<p>name: name of the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_canonica(self,origin=Vector([0,0,0]),length=15,scale=0.04,zaxis=True,name=&#34;Base canònica&#34;):
        &#34;&#34;&#34;
        Draws the canonical base
        Parameters:
           origin: point where to represent the base

           length: length of the axis

           scale: scale of the cylinder

           zaxis: if False the z axis is not drawn

           name: name of the object
        &#34;&#34;&#34;
        if not isinstance(origin,Vector):
                origin = Vector(origin)
        self.set_origin(origin)
        self.draw_base_axis(axis=length,positive=False,scale=scale,zaxis=zaxis,name=name)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.base_cilinder"><code class="name flex">
<span>def <span class="ident">base_cilinder</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a base cilinder with radius 1 and depth 1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_cilinder(self):
        &#34;&#34;&#34;
        Draws a base cilinder with radius 1 and depth 1
        &#34;&#34;&#34;
        bpy.ops.mesh.primitive_cylinder_add(radius=1,depth=1,enter_editmode=False,location=(0, 0, 0))
        bpy.ops.transform.translate(value=(0, 0, 0.5), orient_type=&#39;GLOBAL&#39;,orient_matrix_type=&#39;GLOBAL&#39;,
                constraint_axis=(False, False, True), mirror=True, use_proportional_edit=False,
                proportional_edit_falloff=&#39;SMOOTH&#39;,proportional_size=1, use_proportional_connected=False, use_proportional_projected=False)
        bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
        bpy.ops.object.shade_smooth()
        bpy.context.object.name = &#39;Arrow_stem&#39;</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.base_cone"><code class="name flex">
<span>def <span class="ident">base_cone</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a base cone with radius1=1.5, radius2=0, depth=2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_cone(self):
        &#34;&#34;&#34;
        Draws a base cone with radius1=1.5, radius2=0, depth=2
        &#34;&#34;&#34;
        bpy.ops.mesh.primitive_cone_add(radius1=1.5, radius2=0, depth=2, enter_editmode=False, location=(0, 0, 0))
        bpy.ops.transform.translate(value=(0, 0, 1), orient_type=&#39;GLOBAL&#39;,orient_matrix_type=&#39;GLOBAL&#39;,
                constraint_axis=(False, False, True), mirror=True, use_proportional_edit=False,
                proportional_edit_falloff=&#39;SMOOTH&#39;, proportional_size=1, use_proportional_connected=False, use_proportional_projected=False)
        bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
        bpy.ops.object.shade_smooth()
        bpy.context.object.name = &#39;Arrow_cone&#39;</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.base_is_canonica"><code class="name flex">
<span>def <span class="ident">base_is_canonica</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if sel.base is the canonical basis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_is_canonica(self):
        &#34;&#34;&#34;
        Returns True if sel.base is the canonical basis
        &#34;&#34;&#34;
        return Matrix(self.base).is_identity</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.base_no_canonica"><code class="name flex">
<span>def <span class="ident">base_no_canonica</span></span>(<span>self, origin=Vector((0.0, 0.0, 0.0)), u1=Vector((1.0, -1.0, 0.0)), u2=Vector((0.5, -0.5, -0.5)), u3=Vector((-1.0, 0.0, 1.0)), length=12, scale=0.04, name="Base B'")</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the base {u1,u2,u3} with origin in the point origin and sets the default
origin and default base to them</p>
<h2 id="parameters">Parameters</h2>
<p>origin: origin of the vector and the base</p>
<p>u1, u2, u3: vectors of the base</p>
<p>length: length of the axis</p>
<p>scale: scale of the base</p>
<p>name: name of the base</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_no_canonica(self,origin=Vector([0,0,0]),u1=Vector([1,-1,0]),u2=1/2*Vector([1,-1,-1]),u3=Vector([-1,0,1]),length=12,scale=0.04,name=&#34;Base B&#39;&#34;):
        &#34;&#34;&#34;
        Draws the base {u1,u2,u3} with origin in the point origin and sets the default
        origin and default base to them
        Parameters:
                origin: origin of the vector and the base

                u1, u2, u3: vectors of the base

                length: length of the axis

                scale: scale of the base

                name: name of the base
        &#34;&#34;&#34;
        if not isinstance(origin,Vector):
                origin = Vector(origin)
        if not isinstance(u1,Vector):
                u1 = Vector(u1)
        if not isinstance(u2,Vector):
                u2 = Vector(u2)
        if not isinstance(u3,Vector):
                u3 = Vector(u3)
        self.set_origin(origin)
        self.set_base([u1,u2,u3])
        self.draw_base_axis(axis=length,positive=False,scale=scale,name=name)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.canvi_base"><code class="name flex">
<span>def <span class="ident">canvi_base</span></span>(<span>self, vector=Vector((8.0, -6.0, 7.0)), u1=Vector((-0.3333333432674408, -0.6666666865348816, 0.6666666865348816)), u2=Vector((0.6666666865348816, 0.3333333432674408, 0.6666666865348816)), u3=Vector((-0.6666666865348816, 0.6666666865348816, 0.3333333432674408)), length=12)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw the components of a vectors in the canonical base and in the base {u1,u2,u3}. Sets the default
origin and default base to them</p>
<h2 id="parameters">Parameters</h2>
<p>vector: vector to draw</p>
<p>u1, u2, u3: vectors of the base</p>
<p>length: length of the axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def canvi_base(self,vector=Vector([8,-6,7]),u1=1/3*Vector([-1,-2,2]),u2=1/3*Vector([2,1,2]),u3=1/3*Vector([-2,2,1]),length=12):
        &#34;&#34;&#34;
        Draw the components of a vectors in the canonical base and in the base {u1,u2,u3}. Sets the default
        origin and default base to them
        Parameters:
                vector: vector to draw

                u1, u2, u3: vectors of the base

                length: length of the axis
        &#34;&#34;&#34;
        self.vector_base_canonica(vector=vector,length=length)
        self.set_colors([&#34;Magenta&#34;,&#34;Yellow&#34;,&#34;Cyan&#34;])
        self.base_no_canonica(u1=u1,u2=u2,u3=u3,length=length)
        v = self.components_in_base(vector)
        self.draw_components(v,color=&#34;White&#34;,name=&#34;Components en la base B&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.canvi_coordenades"><code class="name flex">
<span>def <span class="ident">canvi_coordenades</span></span>(<span>self, punt=Vector((8.0, -6.0, 7.0)), origin=Vector((-2.0, 3.0, 3.0)), u1=Vector((-0.3333333432674408, -0.6666666865348816, 0.6666666865348816)), u2=Vector((0.6666666865348816, 0.3333333432674408, 0.6666666865348816)), u3=Vector((-0.6666666865348816, 0.6666666865348816, 0.3333333432674408)), length=12, radius=0.1)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw the coordinates of a point in the canonical reference and in the reference {o;u1,u2,u3}. Sets the default
origin and default base to them</p>
<h2 id="parameters">Parameters</h2>
<p>punt: point to draw</p>
<p>origin: origin of the reference</p>
<p>u1, u2, u3: vectors of the base</p>
<p>length: length of the axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def canvi_coordenades(self,punt=Vector([8,-6,7]),origin=Vector([-2,3,3]),u1=1/3*Vector([-1,-2,2]),u2=1/3*Vector([2,1,2]),u3=1/3*Vector([-2,2,1]),length=12,radius=0.1):
        &#34;&#34;&#34;
        Draw the coordinates of a point in the canonical reference and in the reference {o;u1,u2,u3}. Sets the default
        origin and default base to them
        Parameters:
                punt: point to draw

                origin: origin of the reference

                u1, u2, u3: vectors of the base

                length: length of the axis
        &#34;&#34;&#34;
        self.punt_referencia_canonica(punt=punt,length=length,radius=radius)
        self.set_colors([&#34;Magenta&#34;,&#34;Yellow&#34;,&#34;Cyan&#34;])
        self.referencia_no_canonica(origin=origin,u1=u1,u2=u2,u3=u3,length=length)
        p = self.coordinates_en_referencia(punt)
        self.draw_components(p,color=&#34;White&#34;,name=&#34;Coordenades en la referència R&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.cilindre_elliptic"><code class="name flex">
<span>def <span class="ident">cilindre_elliptic</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, principal=True, canonica=True, color='AzureBlueDark', name='EllipticCylinder', zmax=20, cmax=15, pmax=15, thickness=0.02, opacity=1.0, change=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an elliptic cylinder</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the elliptic cylinder</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2: squares of semi-axes of the elliptic cylinder. The equation is x'^2/a^2 + y'^2/b^2 = 1</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the elliptic cylinder</p>
<p>zmax: the elliptic cylinder is drawn between -zmax and zmax</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the elliptic cylinder</p>
<p>opacity: opacity of the elliptic cylinder</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def elliptic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;EllipticCylinder&#34;,zmax=20,cmax=15,pmax=15,thickness=0.02,opacity=1.0,change=False):
        &#34;&#34;&#34;
        Draws an elliptic cylinder
        Parameters:
           o: center of the elliptic cylinder

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2: squares of semi-axes of the elliptic cylinder. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 = 1

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the elliptic cylinder

           zmax: the elliptic cylinder is drawn between -zmax and zmax

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the elliptic cylinder

           opacity: opacity of the elliptic cylinder
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        self.draw_elliptic_cylinder(a=1.0,b=1.0,length=zmax,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)
        if not change:
                self.set_origin()
                self.set_base()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.cilindre_elliptic_simple"><code class="name flex">
<span>def <span class="ident">cilindre_elliptic_simple</span></span>(<span>self, a=10, b=6, direccio='Z', pmax=26)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an elliptic cylinder with direction X, Y or Z</p>
<h2 id="parameters">Parameters</h2>
<p>a, b: semiaxis of the ellipse</p>
<p>direction: direction of translation of the ellipse</p>
<p>pmax = height of the cylindrer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cilindre_elliptic_simple(self,a=10,b=6,direccio=&#39;Z&#39;,pmax=26):
        &#34;&#34;&#34;
        Draws an elliptic cylinder with direction X, Y or Z
        Parameters:
                a, b: semiaxis of the ellipse

                direction: direction of translation of the ellipse

                pmax = height of the cylindrer
        &#34;&#34;&#34;
        if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                u1 = Vector([0,0,1])
                u2 = Vector([0,1,0])
        elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                u1 = Vector([1,0,0])
                u2 = Vector([0,0,1])
        else:
                u1 = Vector([1,0,0])
                u2 = Vector([0,1,0])
        self.elliptic_cylinder(a2=a**2,b2=b**2,u1=u1,u2=u2,zmax=pmax,canonica=True,principal=False)
        self.draw_ellipse(a=a,b=b,u1=u1,u2=u2,thickness=0.02,steps=128,axis=False)
        self.reset()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.cilindre_hiperbolic"><code class="name flex">
<span>def <span class="ident">cilindre_hiperbolic</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, principal=True, canonica=True, color='AzureBlueDark', name='HyperbolicCylinder', xmax=None, zmax=20, cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an hyperbolic cylinder</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the hyperbolic cylinder</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2: squares of semi-axes of the hyperbolic cylinder. The equation is x'^2/a^2 - y'^2/b^2 = 1</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the hyperbolic cylinder</p>
<p>xmax: maximum value of the x coordinate</p>
<p>zmax: the hyperbolic cylinder is drawn between -zmax and zmax</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the hyperbolic cylinder</p>
<p>opacity: opacity of the hyperbolic cylinder</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hyperbolic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicCylinder&#34;,xmax=None,zmax=20,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws an hyperbolic cylinder
        Parameters:
           o: center of the hyperbolic cylinder

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2: squares of semi-axes of the hyperbolic cylinder. The equation is x&#39;^2/a^2 - y&#39;^2/b^2 = 1

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the hyperbolic cylinder

           xmax: maximum value of the x coordinate

           zmax: the hyperbolic cylinder is drawn between -zmax and zmax

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the hyperbolic cylinder

           opacity: opacity of the hyperbolic cylinder
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        if xmax is None:
                xmax = 5.0/a + 2
        xmax /= a
        obj = self.draw_hyperbolic_cylinder(a=1.0,b=1.0,xmin=1.0,xmax=xmax,length=zmax,steps=128,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.cilindre_hiperbolic_simple"><code class="name flex">
<span>def <span class="ident">cilindre_hiperbolic_simple</span></span>(<span>self, a=4, b=3, direccio='Z', pmax=12, hmax=26)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an hyperbolic cylinder with direction X, Y or Z</p>
<h2 id="parameters">Parameters</h2>
<p>a, b: semiaxis of the hyperbole</p>
<p>direction: direction of translation of the hyperbole</p>
<p>pmax = maximum value of the independent variable</p>
<p>hmax = height of the cylindrer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cilindre_hiperbolic_simple(self,a=4,b=3,direccio=&#39;Z&#39;,pmax=12,hmax=26):
        &#34;&#34;&#34;
        Draws an hyperbolic cylinder with direction X, Y or Z
        Parameters:
                a, b: semiaxis of the hyperbole

                direction: direction of translation of the hyperbole

                pmax = maximum value of the independent variable

                hmax = height of the cylindrer
        &#34;&#34;&#34;
        if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                u1 = Vector([0,0,1])
                u2 = Vector([0,1,0])
        elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                u1 = Vector([1,0,0])
                u2 = Vector([0,0,1])
        else:
                u1 = Vector([1,0,0])
                u2 = Vector([0,1,0])
        self.hyperbolic_cylinder(a2=a**2,b2=b**2,u1=u1,u2=u2,xmax=pmax,zmax=hmax,canonica=True,principal=False)
        self.draw_hyperbole(a=a,b=b,u1=u1,u2=u2,thickness=0.02,ymax=b*math.sqrt(-1+(pmax/a)**2),steps=128,axis=False)
        self.reset()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.cilindre_parabolic"><code class="name flex">
<span>def <span class="ident">cilindre_parabolic</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a=1, principal=True, canonica=True, color='AzureBlueDark', name='ParabolicCylinder', xmax=None, ymax=30, cmax=20, pmax=20, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an hyperbolic paraboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: vertex of the hyperbolic paraboloid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a: coefficient of the intial parabola</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the elliptic paraboloid</p>
<p>xmax: maximum value of the coordinate x</p>
<p>ymax: maximum value of the coordinate y</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the hyperbolic paraboloid</p>
<p>opacity: opacity of the hyperbolic paraboloid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parabolic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;ParabolicCylinder&#34;,xmax=None,ymax=30,cmax=20,pmax=20,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws an hyperbolic paraboloid
        Parameters:
           o: vertex of the hyperbolic paraboloid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a: coefficient of the intial parabola

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the elliptic paraboloid

           xmax: maximum value of the coordinate x

           ymax: maximum value of the coordinate y

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the hyperbolic paraboloid

           opacity: opacity of the hyperbolic paraboloid
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        coef = 1.0
        if a &lt; 0:
                coef = -1
        if xmax is None:
                xmax = 5.0/a + 1.5
        xmax /= a
        self.draw_parabolic_cylinder(p=coef,xmin=0.0,xmax=xmax,length=ymax,color=color,name=name,scale=[a,1,1],thickness=thickness,opacity=opacity)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.cilindre_parabolic_simple"><code class="name flex">
<span>def <span class="ident">cilindre_parabolic_simple</span></span>(<span>self, a=3, direccio='Z', pmax=10, hmax=26)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a parabolic cylinder with direction X, Y or Z</p>
<h2 id="parameters">Parameters</h2>
<p>a: the initial parabola has equation of type z=\pm x^2/a^2</p>
<p>direction: direction of translation of the hyperbole</p>
<p>pmax = maximum value of the independent variable</p>
<p>hmax = height of the cylindrer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cilindre_parabolic_simple(self,a=3,direccio=&#39;Z&#39;,pmax=10,hmax=26):
        &#34;&#34;&#34;
        Draws a parabolic cylinder with direction X, Y or Z
        Parameters:
                a: the initial parabola has equation of type z=\pm x^2/a^2

                direction: direction of translation of the hyperbole

                pmax = maximum value of the independent variable

                hmax = height of the cylindrer
        &#34;&#34;&#34;
        if a == 0:
                return
        if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                u1 = Vector([0,0,1])
                u2 = Vector([0,-1,0])
                v1 = Vector([0,0,1])
                v2 = Vector([1,0,0])
        elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                u1 = Vector([1,0,0])
                u2 = Vector([0,0,-1])
                v1 = Vector([1,0,0])
                v2 = Vector([0,1,0])
        else:
                u1 = Vector([1,0,0])
                u2 = Vector([0,1,0])
                v1 = Vector([1,0,0])
                v2 = Vector([0,0,1])
        s = 1
        if a &lt; 0:
                s = -1
        self.parabolic_cylinder(a=a,u1=u1,u2=u2,xmax=pmax,canonica=True,principal=False)
        self.draw_parabola(a=s/a**2,u1=v1,u2=v2,thickness=0.02,xmax=pmax,steps=128,axis=False)
        self.reset()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears and removes all the elements</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
        &#34;&#34;&#34;
        Clears and removes all the elements
        &#34;&#34;&#34;
        self.reset()
        for obj in bpy.data.objects:
                bpy.data.objects.remove(obj)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.comp_times_vector"><code class="name flex">
<span>def <span class="ident">comp_times_vector</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the vectorial product u x v</p>
<h2 id="parameters">Parameters</h2>
<p>u, v: two Vectors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comp_times_vector(self,u,v):
        &#34;&#34;&#34;
        Computes the vectorial product u x v
        Parameters:
           u, v: two Vectors
        &#34;&#34;&#34;
        return Vector([u.x * v.x,u.y * v.y,u.z * v.z])</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.components_in_base"><code class="name flex">
<span>def <span class="ident">components_in_base</span></span>(<span>self, vector=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the components of the vector 'vector' in the basis determined by
self.rotation and the basis self.base</p>
<h2 id="parameters">Parameters</h2>
<p>vector: components of the vector in the canonical basis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def components_in_base(self,vector=None):
        &#34;&#34;&#34;
        Returns the components of the vector &#39;vector&#39; in the basis determined by
        self.rotation and the basis self.base
        Parameters:
           vector: components of the vector in the canonical basis
        &#34;&#34;&#34;
        if vector is None:
                return Vector([0,0,0])
        if isinstance(vector,Vector):
                u = vector
        else:
                u = Vector(vector)
        if self.rotation is not None:
                mat = self.rotation.quaternion.to_matrix()
                mat.invert()
                u = mat @ u
        mat = Matrix(self.base)
        mat.transpose()
        mat.invert()
        u = mat @ u
        return u</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.con"><code class="name flex">
<span>def <span class="ident">con</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, c2=1, half=False, principal=True, canonica=True, color='AzureBlueDark', name='Cone', xmax=None, cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a cone</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the cone</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2, c2: squares of semi-axes of the cone. The equation is x'^2/a^2 + y'^2/b^2 - z'^2/c^2 = 0</p>
<p>half: if True draws half cone</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the cone</p>
<p>xmax: maximum value of the x coordinate</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -pmax and pmax</p>
<p>thickness: thickness of the cone</p>
<p>opacity: opacity of the cone</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cone(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,half=False,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Cone&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws a cone
        Parameters:
           o: center of the cone

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2, c2: squares of semi-axes of the cone. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = 0

           half: if True draws half cone

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the cone

           xmax: maximum value of the x coordinate

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -pmax and pmax

           thickness: thickness of the cone

           opacity: opacity of the cone
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        c = math.sqrt(c2)
        if xmax is None:
                xmax = 10.0/a + 2
        xmax /= a
        self.draw_cone(a=1.0,xmin=0.0,xmax=xmax,steps=50,half=half,color=color,scale=[a,b,c],name=name,thickness=thickness,opacity=opacity)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.con_cilindre_elliptic"><code class="name flex">
<span>def <span class="ident">con_cilindre_elliptic</span></span>(<span>self, a2=1, b2=1, c2=1, x0=5, a=8, b=5, zmax=15)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a cone with vertex at (0,0,0) and equation x^2/a2 + y^2/b2 - z^2/c2 == 0,
an elliptic cylinder and their intersection</p>
<h2 id="parameters">Parameters</h2>
<p>a2, b2, c2: coefficients of the equation of the cone</p>
<p>x0: (x0,0,0) is the center of the ellipse in the plain XY</p>
<p>a, b: semiaxis of this ellipse</p>
<p>zmax: maximum value of the z coordinate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def con_cilindre_elliptic(self,a2=1,b2=1,c2=1,x0=5,a=8,b=5,zmax=15):
        &#34;&#34;&#34;
        Draws a cone with vertex at (0,0,0) and equation x^2/a2 + y^2/b2 - z^2/c2 == 0,
        an elliptic cylinder and their intersection
        Parameters:
                a2, b2, c2: coefficients of the equation of the cone

                x0: (x0,0,0) is the center of the ellipse in the plain XY

                a, b: semiaxis of this ellipse

                zmax: maximum value of the z coordinate
        &#34;&#34;&#34;
        a2, b2, c2 = abs(a2), abs(b2), abs(c2)
        if a2*b2*c2 == 0:
                return
        xmax = zmax*math.sqrt(a2/c2)
        def F(t):
                x = x0 + a*math.cos(t)
                y = b*math.sin(t)
                z = math.sqrt(c2*(x**2/a2 + y**2/b2))
                return (x,y,z)
        self.cone(a2=a2,b2=b2,c2=c2,principal=False,canonica=True,color=&#34;GrayLight&#34;,thickness=0.0001,name=&#34;Con&#34;,xmax=xmax,cmax=xmax+5,opacity=1.0)
        self.elliptic_cylinder(o=[x0,0,0],a2=a**2,b2=b**2,principal=False,canonica=False,zmax=2*(zmax+3),thickness=0.01,name=&#34;Cilindre&#34;)
        self.curve(F,tmin=0,tmax=2*pi,steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.con_revolucio"><code class="name flex">
<span>def <span class="ident">con_revolucio</span></span>(<span>self, a=1.5, pmax=8, direccio='Z', punt=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an animation showing a cone of revolution
a: slope of the initial straight line</p>
<pre><code>    pmax: maximum value of the independent variable

    direccio: 'X', the initial line is in the plane YX and rotates around the X axis
              'Y', the initial line is in the plane ZY and rotates around the Y axis
                  'Z', the initial line is in the plane XZ and rotates around the Z axis

    punt: if it's a value between -pmax and pmax, the animation shows a rotating point
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def con_revolucio(self,a=1.5,pmax=8,direccio=&#39;Z&#39;,punt=None):
        &#34;&#34;&#34;
        Draws an animation showing a cone of revolution
                a: slope of the initial straight line

                pmax: maximum value of the independent variable

                direccio: &#39;X&#39;, the initial line is in the plane YX and rotates around the X axis
                          &#39;Y&#39;, the initial line is in the plane ZY and rotates around the Y axis
                              &#39;Z&#39;, the initial line is in the plane XZ and rotates around the Z axis

                punt: if it&#39;s a value between -pmax and pmax, the animation shows a rotating point
        &#34;&#34;&#34;
        if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                F = lambda t: (a*t,t,0)
        elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                F = lambda t: (0,a*t,t)
        else:
                F = lambda t: (t,0,a*t)
        self.base_canonica()
        self.animate_revolution_surface(F,tmin=-pmax,tmax=pmax,steps=128,axis=direccio,point=punt)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.cone"><code class="name flex">
<span>def <span class="ident">cone</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, c2=1, half=False, principal=True, canonica=True, color='AzureBlueDark', name='Cone', xmax=None, cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a cone</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the cone</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2, c2: squares of semi-axes of the cone. The equation is x'^2/a^2 + y'^2/b^2 - z'^2/c^2 = 0</p>
<p>half: if True draws half cone</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the cone</p>
<p>xmax: maximum value of the x coordinate</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -pmax and pmax</p>
<p>thickness: thickness of the cone</p>
<p>opacity: opacity of the cone</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cone(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,half=False,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Cone&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws a cone
        Parameters:
           o: center of the cone

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2, c2: squares of semi-axes of the cone. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = 0

           half: if True draws half cone

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the cone

           xmax: maximum value of the x coordinate

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -pmax and pmax

           thickness: thickness of the cone

           opacity: opacity of the cone
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        c = math.sqrt(c2)
        if xmax is None:
                xmax = 10.0/a + 2
        xmax /= a
        self.draw_cone(a=1.0,xmin=0.0,xmax=xmax,steps=50,half=half,color=color,scale=[a,b,c],name=name,thickness=thickness,opacity=opacity)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.coordinates_en_referencia"><code class="name flex">
<span>def <span class="ident">coordinates_en_referencia</span></span>(<span>self, point=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the coordinates of the point 'point' in the reference determined by
self.origin, self.rotation and the basis self.base</p>
<h2 id="parameters">Parameters</h2>
<p>point: coordinates of the point in the canonical reference</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coordinates_en_referencia(self,point=None):
        &#34;&#34;&#34;
        Returns the coordinates of the point &#39;point&#39; in the reference determined by
        self.origin, self.rotation and the basis self.base
        Parameters:
           point: coordinates of the point in the canonical reference
        &#34;&#34;&#34;
        if point is None:
                return Vector([0,0,0])
        if isinstance(point,Vector):
                u = point
        else:
                u = Vector(point)
        if self.rotation is not None:
                mat = self.rotation.quaternion.to_matrix()
                mat.invert()
                u = mat @ u
        mat = Matrix(self.base)
        mat.transpose()
        mat.invert()
        u = mat @ (u - Vector(self.origin))
        return u</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.curve"><code class="name flex">
<span>def <span class="ident">curve</span></span>(<span>self, fun=None, tmin=0.0, tmax=1.0, steps=25, thickness=0.01, name='Curve', color='White', axis=False, zaxis=True, o=Vector((0.0, 0.0, 0.0)), u1=Vector((1.0, 0.0, 0.0)), u2=Vector((0.0, 1.0, 0.0)), symmetry=None, change=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a curve in a reference R' determined by the origin o and basis {v1, v2, v3} constructed from u1 and u2 and
the symmetric curve or curves from the parameter 'symmetry'</p>
<h2 id="parameters">Parameters</h2>
<p>fun: the parametric function</p>
<p>tmin: minimum value of the parameter</p>
<p>tmax: maximum value of the parameter</p>
<p>steps: number of steps</p>
<p>thickness: thickness of the curve</p>
<p>name: name of the curve</p>
<p>color: color of the curve</p>
<p>axis: if True draws the axis of the reference R'</p>
<p>zaxis: if True draws the z' axis</p>
<p>o: origin of the reference R'</p>
<p>u1, u2: vectors to construct the basis {v1, v2, v3}</p>
<p>symmetry: list of values in ('XY','XZ','YZ','X','Y','Z','O'). For every value S, draw the symmetric curve respect to S</p>
<p>change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,axis=False,zaxis=True,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),symmetry=None,change=False):
        &#34;&#34;&#34;
        Draws a curve in a reference R&#39; determined by the origin o and basis {v1, v2, v3} constructed from u1 and u2 and
        the symmetric curve or curves from the parameter &#39;symmetry&#39;
        Parameters:
           fun: the parametric function

           tmin: minimum value of the parameter

           tmax: maximum value of the parameter

           steps: number of steps

           thickness: thickness of the curve

           name: name of the curve

           color: color of the curve

           axis: if True draws the axis of the reference R&#39;

           zaxis: if True draws the z&#39; axis

           o: origin of the reference R&#39;

           u1, u2: vectors to construct the basis {v1, v2, v3}

           symmetry: list of values in (&#39;XY&#39;,&#39;XZ&#39;,&#39;YZ&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;,&#39;O&#39;). For every value S, draw the symmetric curve respect to S

           change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
        &#34;&#34;&#34;
        if fun is None:
                return None
        obj = self.draw_curve(fun,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=name,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)

        if symmetry is None:
                if change:
                        self.set_origin(o)
                        self.set_base([u1,u2],orthonormal=True)
                return obj
        objs = [obj]
        if isinstance(symmetry,str):
                symmetry = [symmetry]
        elif not isinstance(symmetry,list) and not isinstance(symmetry,tuple):
                if change:
                        self.set_origin(o)
                        self.set_base([u1,u2],orthonormal=True)
                return obj
        for s in symmetry:
                namem = name + s
                if s == &#39;XY&#39;:
                        def f(t):
                                p = fun(t)
                                return (p[0],p[1],-p[2])
                        obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                        objs.append(obj2)
                if s == &#39;XZ&#39;:
                        def f(t):
                                p = fun(t)
                                return (p[0],-p[1],p[2])
                        obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                        objs.append(obj2)
                if s == &#39;YZ&#39;:
                        def f(t):
                                p = fun(t)
                                return (-p[0],p[1],p[2])
                        obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                        objs.append(obj2)
                if s == &#39;X&#39;:
                        def f(t):
                                p = fun(t)
                                return (p[0],-p[1],-p[2])
                        obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                        objs.append(obj2)
                if s == &#39;Y&#39;:
                        def f(t):
                                p = fun(t)
                                return (-p[0],p[1],-p[2])
                        obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                        objs.append(obj2)
                if s == &#39;Z&#39;:
                        def f(t):
                                p = fun(t)
                                return (-p[0],-p[1],p[2])
                        obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                        objs.append(obj2)
                if s == &#39;O&#39;:
                        def f(t):
                                p = fun(t)
                                return (-p[0],-p[1],-p[2])
                        obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                        objs.append(obj2)
        if change:
                self.set_origin(o)
                self.set_base([u1,u2],orthonormal=True)
        return self.join(objs)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.delete_base_cilinder"><code class="name flex">
<span>def <span class="ident">delete_base_cilinder</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the base cilinder</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_base_cilinder(self):
        &#34;&#34;&#34;
        Removes the base cilinder
        &#34;&#34;&#34;
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        bpy.data.objects[&#39;Arrow_stem&#39;].select_set(True)
        bpy.ops.object.delete()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.delete_base_cone"><code class="name flex">
<span>def <span class="ident">delete_base_cone</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the base cone</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_base_cone(self):
        &#34;&#34;&#34;
        Removes the base cone
        &#34;&#34;&#34;
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        bpy.data.objects[&#39;Arrow_cone&#39;].select_set(True)
        bpy.ops.object.delete()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_base_axis"><code class="name flex">
<span>def <span class="ident">draw_base_axis</span></span>(<span>self, scale=0.05, head_height=0.15, axis=0, name='Axis', positive=True, zaxis=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a reference axis given by self.origin, self.rotation and the basis self.base</p>
<h2 id="parameters">Parameters</h2>
<p>scale: scale of the cylinder</p>
<p>head_height: height of the head of the vector from self.base</p>
<p>axis: length of the coordinate axis. If the length is 0, only the basis vectors are drawn</p>
<p>name: name of the result object</p>
<p>positive: if True, draw the positive part of the axis</p>
<p>zaxis: if True, draw the z axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_base_axis(self,scale=0.05,head_height=0.15,axis=0,name=&#34;Axis&#34;,positive=True,zaxis=True):
        &#34;&#34;&#34;
        Draws a reference axis given by self.origin, self.rotation and the basis self.base
        Parameters:
           scale: scale of the cylinder

           head_height: height of the head of the vector from self.base

           axis: length of the coordinate axis. If the length is 0, only the basis vectors are drawn

           name: name of the result object

           positive: if True, draw the positive part of the axis

           zaxis: if True, draw the z axis
        &#34;&#34;&#34;
        self.base_cilinder()
        self.base_cone()
        o = Vector([0,0,0])
        op = Vector(self.origin)
        color = 0

        if axis != 0 and axis &lt; 8:
                scale /= 3

        base = self.base
        if not zaxis:
                base = self.base[0:2]
        for vec in base:
                #
                # Draw the stem
                #
                v = Vector(vec)
                t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                obj = t.copy()
                obj.name = &#34;Axis%d&#34; % (color + 1)
                obj.data = obj.data.copy()
                obj.location = o
                obj.scale = (scale,scale,(v - o).length - 2 * head_height)
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                if self.colors is not None and len(self.colors) &gt; color:
                        c = self.colors[color]
                        self.add_material(obj,c.name,c.r,c.g,c.b)
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location = op
                self.scene.collection.objects.link(obj)
                #
                # Draw the arrow
                #
                t = bpy.data.objects.get(&#34;Arrow_cone&#34;)
                obj2 = t.copy()
                obj2.name = &#34;Arrow&#34;
                obj2.data = obj2.data.copy()
                obj2.location =  v - 2 * head_height * v / v.length
                obj2.scale = (scale + 0.05,scale + 0.05,head_height)
                obj2.rotation_mode = &#39;QUATERNION&#39;
                obj2.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                if self.colors is not None and len(self.colors) &gt; color:
                        c = self.colors[color]
                        self.add_material(obj2,c.name,c.r,c.g,c.b)
                if self.rotation is not None:
                        obj2.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj2.location.rotate(self.rotation.quaternion)
                obj2.location = op + obj2.location
                self.scene.collection.objects.link(obj2)
                #
                # Draw the line
                #
                obj3 = None
                if axis != 0:
                        v = axis * Vector(vec)
                        t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                        obj3 = t.copy()
                        obj3.name = &#34;Line&#34;
                        obj3.data = obj3.data.copy()
                        obj3.location = op - v
                        obj3.scale = (scale / 2,scale / 2,(2 * v).length)
                        obj3.rotation_mode = &#39;QUATERNION&#39;
                        obj3.rotation_quaternion = v.to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if self.colors is not None and len(self.colors) &gt; color:
                                c = self.colors[color]
                                self.add_material(obj3,c.name,c.r,c.g,c.b)
                        if self.rotation is not None:
                                obj3.rotation_quaternion.rotate(self.rotation.quaternion)
                        if positive:
                                obj3.location = op
                        else:
                                if self.rotation is not None:
                                        v.rotate(self.rotation.quaternion)
                                obj3.location = op - v
                        self.scene.collection.objects.link(obj3)
                #
                # Joint the three objects
                #
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.context.view_layer.objects.active = obj
                obj.select_set(True)
                obj2.select_set(True)
                if obj3 is not None:
                        obj3.select_set(True)
                bpy.ops.object.join()
                color += 1
        #
        # Join all the axis
        #
        t1 = bpy.data.objects.get(&#34;Axis1&#34;)
        t1.name = name
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        bpy.context.view_layer.objects.active = t1
        t1.select_set(True)
        t2 = bpy.data.objects.get(&#34;Axis2&#34;)
        t2.select_set(True)
        if zaxis:
                t3 = bpy.data.objects.get(&#34;Axis3&#34;)
                t3.select_set(True)
        bpy.ops.object.join()
        self.delete_base_cilinder()
        self.delete_base_cone()
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return t1</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_circle"><code class="name flex">
<span>def <span class="ident">draw_circle</span></span>(<span>self, center=[0, 0, 0], u1=Vector((1.0, 0.0, 0.0)), u2=Vector((0.0, 1.0, 0.0)), axis=False, zaxis=False, radius=1, steps=25, thickness=0.01, name='Circle', color='White', change=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a circle of center 'center' and radius 'radius' in the plane determined by vectors u1 and u2</p>
<h2 id="parameters">Parameters</h2>
<p>center: center of the circle</p>
<p>u1, u2: vectors to construct the basis {v1, v2, v3}</p>
<p>axis: if True draws the axis of the reference R'</p>
<p>zaxis: if True draws the z' axis</p>
<p>radius: radius of the circle</p>
<p>steps: number of steps</p>
<p>thickness: thickness of the curve</p>
<p>name: name of the curve</p>
<p>color: color of the curve</p>
<p>change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_circle(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),axis=False,zaxis=False,radius=1,steps=25,thickness=0.01,name=&#34;Circle&#34;,color=&#34;White&#34;,change=False):
        &#34;&#34;&#34;
        Draws a circle of center &#39;center&#39; and radius &#39;radius&#39; in the plane determined by vectors u1 and u2
        Parameters:
           center: center of the circle

           u1, u2: vectors to construct the basis {v1, v2, v3}

           axis: if True draws the axis of the reference R&#39;

           zaxis: if True draws the z&#39; axis

           radius: radius of the circle

           steps: number of steps

           thickness: thickness of the curve

           name: name of the curve

           color: color of the curve

           change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
        &#34;&#34;&#34;
        if change:
                self.set_origin(center)
                self.set_base([u1,u2],orthonormal=True)
        return self.draw_curve(lambda t: (radius*math.cos(t),radius*math.sin(t),0),tmin=0.0,tmax=2*math.pi,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_components"><code class="name flex">
<span>def <span class="ident">draw_components</span></span>(<span>self, vector=None, color='Cyan', name='Components', scale=0.0075)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the components of the the vector 'vector' in the reference given by self.origin,
self.rotation and the basis self.base</p>
<h2 id="parameters">Parameters</h2>
<p>vector: the vector</p>
<p>color: color of the lines of components</p>
<p>name: name of the object</p>
<p>scale: scale of the lines</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_components(self,vector=None,color=&#34;Cyan&#34;,name=&#34;Components&#34;,scale=0.0075):
        &#34;&#34;&#34;
        Draws the components of the the vector &#39;vector&#39; in the reference given by self.origin,
        self.rotation and the basis self.base
        Parameters:
           vector: the vector

           color: color of the lines of components

           name: name of the object

           scale: scale of the lines
        &#34;&#34;&#34;
        if vector is None:
                return
        if isinstance(vector,Vector):
                v = vector
        else:
                v = Vector(vector)
        mat = Matrix(self.base)
        mat.transpose()
        list = [[0,0,0],[1,0,0],[1,1,0],[0,1,0],[0,0,1],[1,0,1],[1,1,1],[0,1,1]]
        lines = [[0,1],[1,2],[2,3],[0,3],[0,4],[1,5],[2,6],[3,7],[4,5],[5,6],[6,7],[4,7]]
        vecs = [self.comp_times_vector(v,Vector(x)) for x in list]
        count = 0
        for first, last in lines:
                if count == 0:
                        this = name
                else:
                        this = f&#34;Line{count}&#34;
                count += 1
                self.draw_line(start=vecs[first],end=vecs[last],scale=scale,name=this,color=color)
        t = bpy.data.objects.get(name)
        list = [t]
        for count in range(1,12):
                obj = bpy.data.objects.get(f&#34;Line{count}&#34;)
                if obj is not None:
                        list.append(obj)
        t = self.join(list)
        bpy.context.view_layer.objects.active = None
        return t</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_cone"><code class="name flex">
<span>def <span class="ident">draw_cone</span></span>(<span>self, a=1.0, xmin=0.0, xmax=5.0, steps=50, scale=[1, 1, 1], half=False, color='AzureBlueDark', name='Cone', opacity=1.0, thickness=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a cone from the line z = a*x in the XZ plane</p>
<h2 id="parameters">Parameters</h2>
<p>a: slope of the line</p>
<p>xmin: minimum value of x</p>
<p>xmax: maximum value of x</p>
<p>steps: numbers of steps to draw the parabola</p>
<p>scale: scaling factors in the X, Y and Z directions</p>
<p>half: if True, draws half cone</p>
<p>color: color of the surface</p>
<p>name: name of the surface</p>
<p>opacity: opacity of the surface</p>
<p>thickness: thickness of the surface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_cone(self,a=1.0,xmin=0.0,xmax=5.0,steps=50,scale=[1,1,1],half=False,color=&#34;AzureBlueDark&#34;,name=&#34;Cone&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws a cone from the line z = a*x in the XZ plane
        Parameters:
           a: slope of the line

           xmin: minimum value of x

           xmax: maximum value of x

           steps: numbers of steps to draw the parabola

           scale: scaling factors in the X, Y and Z directions

           half: if True, draws half cone

           color: color of the surface

           name: name of the surface

           opacity: opacity of the surface

           thickness: thickness of the surface
        &#34;&#34;&#34;
        delta = (xmax - xmin) / steps
        x = xmax
        bm = bmesh.new()
        verts = []
        count = 2 * steps + 2
        if xmin == 0.0:
                count = 2 * steps + 1
        if half:
                count = steps + 1
        for k in range(count):
                z = a * x
                verts.append(bm.verts.new((x,0,z)))
                if k == steps and xmin &gt; 0:
                        x = - xmin
                else:
                        x -= delta
                if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                        continue
                bm.edges.new([verts[k-1], verts[k]])

        me = self.meshes.new(&#39;placeholder_mesh&#39;)
        obj = self.objects.new(name,me)
        bm.to_mesh(me)
        bm.free()

        modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
        modifier.angle = 2 * math.pi
        modifier.steps = 128
        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        self.scene.collection.objects.link(obj)
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_cube"><code class="name flex">
<span>def <span class="ident">draw_cube</span></span>(<span>self, origin=None, scale=[1, 1, 1], scalelines=0.05, vectors=False, color='Blue', linecolor='Red', vectorcolor='Black', name='Parallelepiped', opacity=1.0, thickness=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a rectangular parallelepiped</p>
<h2 id="parameters">Parameters</h2>
<p>origin: center of the parallelepiped</p>
<p>scale: scale of the sides of the parallelepiped</p>
<p>scalelines: scale of the edges of the parallelepiped</p>
<p>vectors: if True, draws vectors from the origin to the vertices</p>
<p>color: color of the parallelepiped</p>
<p>linecolor: color of the edges</p>
<p>vectorcolor: color of the vectors</p>
<p>name: name of the parallelepiped</p>
<p>opacity: opacity of the parallelepiped</p>
<p>thickness: thickness of the parallelepiped</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_cube(self,origin=None,scale=[1,1,1],scalelines=0.05,vectors=False,color=&#34;Blue&#34;,linecolor=&#34;Red&#34;,vectorcolor=&#34;Black&#34;,name=&#39;Parallelepiped&#39;,opacity=1.0,thickness=0.0):
        &#34;&#34;&#34;
        Draws a rectangular parallelepiped
        Parameters:
           origin: center of the parallelepiped

           scale: scale of the sides of the parallelepiped

           scalelines: scale of the edges of the parallelepiped

           vectors: if True, draws vectors from the origin to the vertices

           color: color of the parallelepiped

           linecolor: color of the edges

           vectorcolor: color of the vectors

           name: name of the parallelepiped

           opacity: opacity of the parallelepiped

           thickness: thickness of the parallelepiped
        &#34;&#34;&#34;
        bpy.ops.mesh.primitive_cube_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        if origin is not None:
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
        obj.location = o
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 0.0

        lines = None
        vecs = None
        s = 0.0
        nodes = [[1+s,1+s,1+s],[-1-s,1+s,1+s],[-1-s,-1-s,1+s],[1+s,-1-s,1+s],
                        [1+s,1+s,-1-s],[-1-s,1+s,-1-s],[-1-s,-1-s,-1-s],[1+s,-1-s,-1-s]]
        nodes = [self.comp_times_vector(Vector(scale),Vector(x)) for x in nodes]
        edges =[[0,1],[1,2],[2,3],[3,0],[0,4],[1,5],[2,6],[3,7],[4,5],[5,6],[6,7],[7,4]]
        if scalelines &gt; 0.0:
                objects = []
                for edge in edges:
                        l = self.draw_line(start=op+nodes[edge[0]],end=op+nodes[edge[1]],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                        objects.append(l)
                lines = self.join(objects)

        if vectors:
                vecs = self.draw_vectors(nodes,color=vectorcolor,scale=0.05,head_height=0.2,name=&#34;Vectors&#34;,axis=0)

        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.scale = scale

        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        obj.location = op
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        if lines is not None:
                obj = self.join([obj,lines])

        if vecs is not None:
                obj = self.join([obj,vecs])
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_curve"><code class="name flex">
<span>def <span class="ident">draw_curve</span></span>(<span>self, fun=None, tmin=0.0, tmax=1.0, steps=25, thickness=0.01, name='Curve', color='White', axis=False, zaxis=True, o=Vector((0.0, 0.0, 0.0)), u1=Vector((1.0, 0.0, 0.0)), u2=Vector((0.0, 1.0, 0.0)))</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a curve in a reference R' determined by the origin o and basis {v1, v2, v3} constructed from u1 and u2</p>
<h2 id="parameters">Parameters</h2>
<p>fun: the parametric function</p>
<p>tmin: minimum value of the parameter</p>
<p>tmax: maximum value of the parameter</p>
<p>steps: number of steps</p>
<p>thickness: thickness of the curve</p>
<p>name: name of the curve</p>
<p>color: color of the curve</p>
<p>axis: if True draws the axis of the reference R'</p>
<p>zaxis: if True draws the z' axis</p>
<p>o: origin of the reference R'</p>
<p>u1, u2: vectors to construct the basis {v1, v2, v3}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,axis=False,zaxis=True,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0])):
        &#34;&#34;&#34;
        Draws a curve in a reference R&#39; determined by the origin o and basis {v1, v2, v3} constructed from u1 and u2
        Parameters:
           fun: the parametric function

           tmin: minimum value of the parameter

           tmax: maximum value of the parameter

           steps: number of steps

           thickness: thickness of the curve

           name: name of the curve

           color: color of the curve

           axis: if True draws the axis of the reference R&#39;

           zaxis: if True draws the z&#39; axis

           o: origin of the reference R&#39;

           u1, u2: vectors to construct the basis {v1, v2, v3}
        &#34;&#34;&#34;
        if fun is None:
                return None
        qt = self.vectors_to_quaternion(u1,u2)
        delta = (tmax - tmin) / steps
        t = tmin
        bm = bmesh.new()
        verts = []

        pmax = 0
        for k in range(steps + 1):
                p = fun(t)
                m = max(map(abs,p))
                if m &gt; pmax:
                        pmax = m
                verts.append(bm.verts.new(p))
                t += delta
                if t &gt; tmax:
                        t = tmax

        for i in range(len(verts) - 1):
                bm.edges.new([verts[i], verts[i+1]])

        me = self.meshes.new(&#39;placeholder_mesh&#39;)
        obj = self.objects.new(name,me)
        bm.to_mesh(me)
        bm.free()

        modifier = obj.modifiers.new(type=&#39;SKIN&#39;,name = &#39;skin&#39;)
        for v in obj.data.skin_vertices[0].data:
                v.radius = (thickness,thickness)

        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
        self.set_origin(o)
        self.set_rotation(quaternion=qt)
        if self.rotation is not None:
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        if axis:
                self.draw_base_axis(axis = pmax+3,positive=False,name=&#34;Referència escollida&#34;,zaxis=zaxis)
        self.scene.collection.objects.link(obj)
        bpy.ops.object.shade_smooth()
        obj.location = o
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_ellipse"><code class="name flex">
<span>def <span class="ident">draw_ellipse</span></span>(<span>self, center=[0, 0, 0], u1=Vector((1.0, 0.0, 0.0)), u2=Vector((0.0, 1.0, 0.0)), a=1, b=1, axis=False, zaxis=False, steps=25, thickness=0.01, name='Ellipse', color='White', change=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an ellipse of center 'center' and semi-axes a and b in the plane determined by vectors u1 and u2</p>
<h2 id="parameters">Parameters</h2>
<p>center: center of the ellipse</p>
<p>u1, u2: vectors to construct the basis {v1, v2, v3}</p>
<p>a, b: semi-axes of the ellipse</p>
<p>axis: if True draws the axis of the reference R'</p>
<p>zaxis: if True draws the z' axis</p>
<p>steps: number of steps</p>
<p>thickness: thickness of the curve</p>
<p>name: name of the curve</p>
<p>color: color of the curve</p>
<p>change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_ellipse(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,b=1,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Ellipse&#34;,color=&#34;White&#34;,change=False):
        &#34;&#34;&#34;
        Draws an ellipse of center &#39;center&#39; and semi-axes a and b in the plane determined by vectors u1 and u2
        Parameters:
           center: center of the ellipse

           u1, u2: vectors to construct the basis {v1, v2, v3}

           a, b: semi-axes of the ellipse

           axis: if True draws the axis of the reference R&#39;

           zaxis: if True draws the z&#39; axis

           steps: number of steps

           thickness: thickness of the curve

           name: name of the curve

           color: color of the curve

           change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
        &#34;&#34;&#34;
        if change:
                self.set_origin(center)
                self.set_base([u1,u2],orthonormal=True)
        return self.draw_curve(lambda t: (a*math.cos(t),b*math.sin(t),0),tmin=0.0,tmax=2*math.pi,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_ellipsoid"><code class="name flex">
<span>def <span class="ident">draw_ellipsoid</span></span>(<span>self, radius=5.0, scale=[1.2, 1.8, 0.8], color='AzureBlueDark', name='Ellipsoid', opacity=1.0, thickness=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws en ellipsoid</p>
<h2 id="parameters">Parameters</h2>
<p>radius: radius of the sphere</p>
<p>scale: scaling factors in the X, Y and Z directions</p>
<p>color: color of the surface</p>
<p>name: name of the surface</p>
<p>opacity: opacity of the surface</p>
<p>thickness: thickness of the surface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_ellipsoid(self,radius=5.0,scale=[1.2,1.8,0.8],color=&#34;AzureBlueDark&#34;,name=&#34;Ellipsoid&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws en ellipsoid
        Parameters:
           radius: radius of the sphere

           scale: scaling factors in the X, Y and Z directions

           color: color of the surface

           name: name of the surface

           opacity: opacity of the surface

           thickness: thickness of the surface
        &#34;&#34;&#34;
        bpy.ops.mesh.primitive_uv_sphere_add(segments=128, ring_count=128, radius=radius, enter_editmode=False, location=(0, 0, 0))
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)

        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        obj.select_set(False)
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_elliptic_cylinder"><code class="name flex">
<span>def <span class="ident">draw_elliptic_cylinder</span></span>(<span>self, a=8.0, b=5.0, amin=0.0, amax=6.283185307179586, length=20, steps=200, scale=[1, 1, 1], color='AzureBlueDark', name='EllipticCylinder', opacity=1.0, thickness=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an eliptic cylinder from the ellipse
x = a<em>cos(t)
y = b</em>sin(t)
in the XY plane</p>
<h2 id="parameters">Parameters</h2>
<p>a, b: coefficients of the ellipsw</p>
<p>amin: minimum value of the angle t</p>
<p>amax: maximum value of the angle t</p>
<p>length: length in the Z direction</p>
<p>steps: numbers of steps to draw the parabola</p>
<p>scale: scaling factors in the X, Y and Z directions</p>
<p>color: color of the surface</p>
<p>name: name of the surface</p>
<p>opacity: opacity of the surface</p>
<p>thickness: thickness of the surface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_elliptic_cylinder(self,a=8.0,b=5.0,amin=0.0,amax=2*math.pi,length=20,steps=200,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;EllipticCylinder&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws an eliptic cylinder from the ellipse
          x = a*cos(t)
          y = b*sin(t)
        in the XY plane
        Parameters:
           a, b: coefficients of the ellipsw

           amin: minimum value of the angle t

           amax: maximum value of the angle t

           length: length in the Z direction

           steps: numbers of steps to draw the parabola

           scale: scaling factors in the X, Y and Z directions

           color: color of the surface

           name: name of the surface

           opacity: opacity of the surface

           thickness: thickness of the surface
        &#34;&#34;&#34;
        if amin &lt; 0.0:
                amin = 0.0
        if amax &gt; 2 * math.pi:
                amax = 2 * math.pi
        delta = (amax-amin)/steps
        bm = bmesh.new()
        verts = []
        t = amin
        for k in range(steps + 1):
                x = a * math.cos(t)
                y = b * math.sin(t)
                verts.append(bm.verts.new((x,y,0)))
                t += delta
                if k == 0:
                        continue
                bm.edges.new([verts[k-1], verts[k]])

        me = self.meshes.new(&#39;EllipticCylinderMesh&#39;)
        obj = self.objects.new(name, me)
        bm.to_mesh(me)
        bm.free()
        self.scene.collection.objects.link(obj)

        bpy.context.view_layer.objects.active = obj
        bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
        bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
        bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
        bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0,0,length),&#34;constraint_axis&#34;:(False,False,True),&#34;use_accurate&#34;:True})
        bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
        bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
        obj.select_set(True)
        bpy.ops.transform.translate(value=(0,0,-length/2),constraint_axis=(False,False,True))
        bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
        obj.select_set(False)

        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_elliptic_paraboloid"><code class="name flex">
<span>def <span class="ident">draw_elliptic_paraboloid</span></span>(<span>self, a=0.5, xmin=0.0, xmax=3.0, steps=50, scale=[1, 1, 1], color='AzureBlueDark', name='EllipticParaboloid', opacity=1.0, thickness=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an elliptic paraboloid from the parabola z=a*t^2</p>
<h2 id="parameters">Parameters</h2>
<p>a: coefficient of the parabola</p>
<p>xmin: minimum value of x</p>
<p>xmax: maximum value of x</p>
<p>steps: numbers of steps to draw the parabola</p>
<p>scale: scaling factors in the X, Y and Z directions</p>
<p>color: color of the surface</p>
<p>name: name of the surface</p>
<p>opacity: opacity of the surface</p>
<p>thickness: thickness of the surface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_elliptic_paraboloid(self,a=0.5,xmin=0.0,xmax=3.0,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;EllipticParaboloid&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws an elliptic paraboloid from the parabola z=a*t^2
        Parameters:
           a: coefficient of the parabola

           xmin: minimum value of x

           xmax: maximum value of x

           steps: numbers of steps to draw the parabola

           scale: scaling factors in the X, Y and Z directions

           color: color of the surface

           name: name of the surface

           opacity: opacity of the surface

           thickness: thickness of the surface
        &#34;&#34;&#34;
        obj = self.simple_curve(f=lambda t:(t,0,a*t**2),tmin=xmin,tmax=xmax,steps=steps,name=name)
        modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
        modifier.angle = 2 * math.pi
        modifier.steps = 128
        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        self.scene.collection.objects.link(obj)
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_frenet_curve"><code class="name flex">
<span>def <span class="ident">draw_frenet_curve</span></span>(<span>self, fun=None, var=None, tmin=0.0, tmax=1.0, radius=0.1, steps=25, thickness=0.01, name='Curve', color='White', point=True, tangent=False, acceleration=False, normal=False, osculator=False, frenet=False, units=False, sizex=8, sizey=8, axis=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a curve and diferents elements related to the curve</p>
<h2 id="parameters">Parameters</h2>
<p>fun: the parametric function</p>
<p>var = parameter variable of the function fun</p>
<p>tmin: minimum value of the parameter</p>
<p>tmax: maximum value of the parameter</p>
<p>radius: radius of the point</p>
<p>steps: number of steps</p>
<p>frames: increment of the frame set</p>
<p>thickness: thickness of the curve</p>
<p>name: name of the curve</p>
<p>color: color of the curve</p>
<p>point: if True draw a point along the curve</p>
<p>tangent: if True draw the tangent vector along the curve</p>
<p>acceleration: if True draw the acceleration vector along the curve</p>
<p>normal: if True draw the normal vector along the curve</p>
<p>osculator: if True draw the osculating plane along the curve</p>
<p>frenet: if True draw the Frenet trihedron along the curve</p>
<p>units: if True normalize the tangent and normal vectors</p>
<p>sizex, sizey: sizes of the osculating plane</p>
<p>axis: length of the coordinate axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_frenet_curve(self,fun=None,var=None,tmin=0.0,tmax=1.0,radius=0.1,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,point=True,tangent=False,acceleration=False,normal=False,osculator=False,frenet=False,units=False,sizex=8,sizey=8,axis=10):
        &#34;&#34;&#34;
        Draws a curve and diferents elements related to the curve
        Parameters:
           fun: the parametric function

           var = parameter variable of the function fun

           tmin: minimum value of the parameter

           tmax: maximum value of the parameter

           radius: radius of the point

           steps: number of steps

           frames: increment of the frame set

           thickness: thickness of the curve

           name: name of the curve

           color: color of the curve

           point: if True draw a point along the curve

           tangent: if True draw the tangent vector along the curve

           acceleration: if True draw the acceleration vector along the curve

           normal: if True draw the normal vector along the curve

           osculator: if True draw the osculating plane along the curve

           frenet: if True draw the Frenet trihedron along the curve

           units: if True normalize the tangent and normal vectors

           sizex, sizey: sizes of the osculating plane

           axis: length of the coordinate axis
        &#34;&#34;&#34;
        if fun is None:
                return None

        self.draw_base_axis(axis=axis,positive=False)

        def _fun_(x):
                return [u.subs(var,x) for u in fun]

        def frenet_quaternion(tangent,normal):
                v1 = tangent.normalized()
                v2 = normal.normalized()
                v3 = v1.cross(v2)
                return Matrix([v1,v2,v3]).transposed().to_quaternion()

        frames = 1
        curve = self.draw_curve(_fun_,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,color=color,axis=False)
        if not point and not tangent and not osculator and not frenet:
                return curve

        T = [diff(u,var) for u in fun]
        Tnorm = sqrt(sum([u**2 for u in T]))
        A = [diff(u,var) for u in T]
        p0 = Vector([u.subs(var,tmin) for u in fun])
        v0 = Vector([N(u.subs(var,tmin)) for u in T])
        a0 = Vector([N(u.subs(var,tmin)) for u in A])
        n0 = a0 - a0.project(v0)
        q0 = frenet_quaternion(v0,n0)
        f0 = [Vector([1,0,0]),Vector([0,1,0]),Vector([0,0,1])]

        if units:
                v0.normalize()
                n0.normalize()
        bpy.context.scene.frame_set(self.frame)

        if point:
                p = self.draw_point(radius=radius,location=p0,name=&#34;Punt&#34;,color=&#34;Black&#34;)
                p.keyframe_insert(data_path=&#34;location&#34;,index=-1)
        self.set_origin(p0)
        if tangent:
                l = v0.length
                if not units:
                        vp = 5*v0.normalized()
                else:
                        vp = v0
                if not units:
                        v = self.draw_vector(vp,color=&#34;Red&#34;,scale=0.035,head_height=0.3)
                        v.scale.z *= l / 5.0
                else:
                        v = self.draw_vector(vp,color=&#34;Red&#34;,scale=0.035,head_height=0.2)
                v.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                v.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                v.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        if acceleration:
                l = a0.length
                ap = 5*a0.normalized()
                a = self.draw_vector(ap,color=&#34;Green&#34;,scale=0.035,head_height=0.2)
                a.scale.z *= l / 5.0
                a.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                a.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                a.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        if normal:
                l = n0.length
                if not units:
                        np = 5*n0.normalized()
                else:
                        np = n0
                if not units:
                        n = self.draw_vector(np,color=&#34;Red&#34;,scale=0.035,head_height=0.2)
                        n.scale.z *= l / 5.0
                else:
                        n = self.draw_vector(np,color=&#34;Red&#34;,scale=0.035,head_height=0.1)
                n.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                n.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                n.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        if osculator:
                o = self.draw_plane_surface(base=[[1,0,0],[0,1,0]],color=&#34;GreenPaleDull&#34;,linecolor=&#34;GreenDarkDull&#34;,sizex=sizex,sizey=sizey,opacity=0.25)
                o.rotation_quaternion = q0
                o.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                o.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        if frenet:
                f = self.draw_vectors(f0,color=&#34;Red&#34;,scale=0.035,head_height=0.1)
                f.rotation_quaternion = q0
                f.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                f.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        self.set_origin()

        fn = frames + self.frame
        for i in range(steps):
                bpy.context.scene.frame_set(fn)
                x = tmin + (tmax - tmin)*i/steps
                pos = Vector([u.subs(var,x) for u in fun])
                v1 = Vector([N(u.subs(var,x)) for u in T])
                a1 = Vector([N(u.subs(var,x)) for u in A])
                n1 = a1 - a1.project(v1)
                q1 = frenet_quaternion(v1,n1)
                if point:
                        p.location = pos
                        p.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                if tangent:
                        if not units:
                                r = v1.length / v0.length
                                v.scale.z *= r
                        v.location = pos
                        v.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        v.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        q = v0.rotation_difference(v1)
                        v.rotation_quaternion.rotate(q)
                        v.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if acceleration:
                        r = a1.length / a0.length
                        a.scale.z *= r
                        a.location = pos
                        a.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        a.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        q = a0.rotation_difference(a1)
                        a.rotation_quaternion.rotate(q)
                        a.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if normal:
                        if not units:
                                r = n1.length / n0.length
                                n.scale.z *= r
                        n.location = pos
                        n.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        n.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        q = n0.rotation_difference(n1)
                        n.rotation_quaternion.rotate(q)
                        n.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if osculator:
                        o.location = pos
                        o.rotation_quaternion = q1
                        o.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        o.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if frenet:
                        f.location = pos
                        f.rotation_quaternion = q1
                        f.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        f.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                v0 = v1.copy()
                a0 = a1.copy()
                n0 = n1.copy()
                fn += frames
        self.frame = fn - frames
        bpy.context.scene.frame_end = self.frame
        bpy.context.scene.frame_set(0)
        bpy.context.view_layer.update()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_function"><code class="name flex">
<span>def <span class="ident">draw_function</span></span>(<span>self, f=None, xmin=-3, xmax=3, xsteps=64, ymin=-3, ymax=3, ysteps=64, thickness=0.02, opacity=1.0, pmax=10, name='Function', color='AzureBlueDark', axis=False, o=Vector((0.0, 0.0, 0.0)), u1=Vector((1.0, 0.0, 0.0)), u2=Vector((0.0, 1.0, 0.0)))</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a function of two variables f(x,y) i the reference R' = {o, v1, v2, v3}</p>
<h2 id="parameters">Parameters</h2>
<p>f: the function of two variables f(x,y)</p>
<p>xmin: minimum value of x</p>
<p>xmax: maximum value of x</p>
<p>xsteps: steps in the x direction</p>
<p>ymin: minimum value of y</p>
<p>ymax: maximum value of y</p>
<p>ysteps: steps in the x direction</p>
<p>thickness: thickness of the surface</p>
<p>opacity: opacity of the surface</p>
<p>pmax: the axis are drawn between -pmax and pmax</p>
<p>name: name of the surface</p>
<p>color: color of the surface</p>
<p>axis: if True the axis of the reference R' are drawn</p>
<p>o: origin of the reference R'</p>
<p>u1, u2: vectors to construct the basis {v1, v2, v3}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_function(self,f=None,xmin=-3,xmax=3,xsteps=64,ymin=-3,ymax=3,ysteps=64,thickness=0.02,opacity=1.0,pmax=10,name=&#34;Function&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0])):
        &#34;&#34;&#34;
        Draws a function of two variables f(x,y) i the reference R&#39; = {o, v1, v2, v3}
        Parameters:
           f: the function of two variables f(x,y)

           xmin: minimum value of x

           xmax: maximum value of x

           xsteps: steps in the x direction

           ymin: minimum value of y

           ymax: maximum value of y

           ysteps: steps in the x direction

           thickness: thickness of the surface

           opacity: opacity of the surface

           pmax: the axis are drawn between -pmax and pmax

           name: name of the surface

           color: color of the surface

           axis: if True the axis of the reference R&#39; are drawn

           o: origin of the reference R&#39;

           u1, u2: vectors to construct the basis {v1, v2, v3}
        &#34;&#34;&#34;
        if f is None:
                return None
        return self.draw_surface(eq=lambda x,y:(x,y,f(x,y)),umin=xmin,umax=xmax,usteps=xsteps,vmin=ymin,vmax=ymax,vsteps=ysteps,thickness=thickness,opacity=opacity,pmax=pmax,name=name,color=color,axis=axis,o=o,u1=u1,u2=u2,wrap_u=False,wrap_v=False,close_v=False)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_hyperbole"><code class="name flex">
<span>def <span class="ident">draw_hyperbole</span></span>(<span>self, center=[0, 0, 0], u1=Vector((1.0, 0.0, 0.0)), u2=Vector((0.0, 1.0, 0.0)), a=1, b=1, ymax=3.0, axis=False, zaxis=False, steps=25, thickness=0.01, name='Hyperbole', color='White', change=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an hyperbole of center 'center' and semi-axes a and b in the plane determined by vectors u1 and u2</p>
<h2 id="parameters">Parameters</h2>
<p>center: center of the hyperbole</p>
<p>u1, u2: vectors to construct the basis {v1, v2, v3}</p>
<p>a, b: semi-axes of the hyperbole</p>
<p>ymax: maximum value of the y'</p>
<p>axis: if True draws the axis of the reference R'</p>
<p>zaxis: if True draws the z' axis</p>
<p>steps: number of steps</p>
<p>thickness: thickness of the curve</p>
<p>name: name of the curve</p>
<p>color: color of the curve</p>
<p>change: if True, set the reference self.origin, self.base to {o; v1, v2, v3}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_hyperbole(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,b=1,ymax=3.0,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Hyperbole&#34;,color=&#34;White&#34;,change=False):
        &#34;&#34;&#34;
        Draws an hyperbole of center &#39;center&#39; and semi-axes a and b in the plane determined by vectors u1 and u2
        Parameters:
           center: center of the hyperbole

           u1, u2: vectors to construct the basis {v1, v2, v3}

           a, b: semi-axes of the hyperbole

           ymax: maximum value of the y&#39;

           axis: if True draws the axis of the reference R&#39;

           zaxis: if True draws the z&#39; axis

           steps: number of steps

           thickness: thickness of the curve

           name: name of the curve

           color: color of the curve

           change: if True, set the reference self.origin, self.base to {o; v1, v2, v3}
        &#34;&#34;&#34;
        c1 = self.draw_curve(lambda t: (a*math.sqrt(1+t**2/b**2),t,0),tmin=-ymax,tmax=ymax,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
        c2 = self.draw_curve(lambda t: (-a*math.sqrt(1+t**2/b**2),t,0),tmin=-ymax,tmax=ymax,axis=False,zaxis=False,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
        self.join([c1,c2])
        if change:
                self.set_origin(center)
                self.set_base([u1,u2],orthonormal=True)
        return c1</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_hyperbolic_cylinder"><code class="name flex">
<span>def <span class="ident">draw_hyperbolic_cylinder</span></span>(<span>self, a=1.0, b=4.0, xmin=2.0, xmax=6.0, length=20, steps=50, scale=[1, 1, 1], color='AzureBlueDark', name='HyperbolicCylinder', opacity=1.0, thickness=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an hyperbolic cylinder from the hyperbole y = a * sqrt(x**2 - b) in the XY plane</p>
<h2 id="parameters">Parameters</h2>
<p>a, b: coefficients of the hyperbole</p>
<p>xmin: minimum value of x</p>
<p>xmax: maximum value of x</p>
<p>length: length in the Z direction</p>
<p>steps: numbers of steps to draw the parabola</p>
<p>scale: scaling factors in the X, Y and Z directions</p>
<p>color: color of the surface</p>
<p>name: name of the surface</p>
<p>opacity: opacity of the surface</p>
<p>thickness: thickness of the surface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_hyperbolic_cylinder(self,a=1.0,b=4.0,xmin=2.0,xmax=6.0,length=20,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicCylinder&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws an hyperbolic cylinder from the hyperbole y = a * sqrt(x**2 - b) in the XY plane
        Parameters:
           a, b: coefficients of the hyperbole

           xmin: minimum value of x

           xmax: maximum value of x

           length: length in the Z direction

           steps: numbers of steps to draw the parabola

           scale: scaling factors in the X, Y and Z directions

           color: color of the surface

           name: name of the surface

           opacity: opacity of the surface

           thickness: thickness of the surface
        &#34;&#34;&#34;
        if xmin &lt; math.sqrt(b):
                xmin = math.sqrt(b)
        delta = (xmax-xmin)/steps
        bm = bmesh.new()
        verts = []
        count = 2 * steps + 2
        if xmin == 0.0:
                count = 2 * steps + 1
        for q, d in [[1,0],[-1,count]]:
                x = xmax
                sign = 1
                for k in range(count):
                        if k == steps + 1:
                                sign = -1
                        if x &lt; math.sqrt(b):
                                x = math.sqrt(b)
                        y = sign * a * math.sqrt(x**2 - b)
                        verts.append(bm.verts.new((q * x,y,0)))
                        if k == steps and xmin &gt; math.sqrt(b):
                                x = xmin
                        else:
                                x = x - sign * delta
                        if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                                continue
                        bm.edges.new([verts[d + k-1], verts[d + k]])

        me = self.meshes.new(&#39;HyperboliclinderMesh&#39;)
        obj = self.objects.new(name, me)
        bm.to_mesh(me)
        bm.free()

        self.scene.collection.objects.link(obj)
        bpy.context.view_layer.objects.active = obj
        bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
        bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
        bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
        bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0,0,length),&#34;constraint_axis&#34;:(False,False,True),&#34;use_accurate&#34;:True})
        bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
        bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
        obj.select_set(True)
        bpy.ops.transform.translate(value=(0,0,-length/2),constraint_axis=(False,False,True))
        bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
        obj.select_set(False)

        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_hyperbolic_paraboloid"><code class="name flex">
<span>def <span class="ident">draw_hyperbolic_paraboloid</span></span>(<span>self, a=0.2, b=0.4, xmax=10.0, ymax=10.0, steps=64, scale=[1, 1, 1], color='AzureBlueDark', name='HyperbolicParaboloid', opacity=1.0, thickness=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an hyperbolic paraboloid with equation z = a<em>x^2 - b</em>y^2</p>
<h2 id="parameters">Parameters</h2>
<p>a, b: coefficients of the parabolic hyperboloid</p>
<p>xmax: maximum
value of x</p>
<p>ymax: maxim value y</p>
<p>steps: numbers of steps to draw the parabola</p>
<p>scale: scaling factors in the X, Y and Z directions</p>
<p>color: color of the surface</p>
<p>name: name of the surface</p>
<p>opacity: opacity of the surface</p>
<p>thickness: thickness of the surface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_hyperbolic_paraboloid(self,a=0.2,b=0.4,xmax=10.0,ymax=10.0,steps=64,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicParaboloid&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws an hyperbolic paraboloid with equation z = a*x^2 - b*y^2
        Parameters:
           a, b: coefficients of the parabolic hyperboloid

           xmax: maximum  value of x

           ymax: maxim value y

           steps: numbers of steps to draw the parabola

           scale: scaling factors in the X, Y and Z directions

           color: color of the surface

           name: name of the surface

           opacity: opacity of the surface

           thickness: thickness of the surface
        &#34;&#34;&#34;
        equ = lambda x,y: (x,y,a*x**2-b*y**2)
        obj = self.draw_surface(eq=equ,umin=-xmax,umax=xmax,usteps=steps,vmin=-ymax,vmax=ymax,vsteps=steps,thickness=thickness,opacity=opacity,pmax=0,name=&#34;Hyperbolic paraboloid&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),wrap_u=False,wrap_v=False,close_v=False)
        obj.scale = scale
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_line"><code class="name flex">
<span>def <span class="ident">draw_line</span></span>(<span>self, start=[1, 1, 1], end=[10, 10, 10], scale=0.05, name='Line', color='Black')</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a line from the point start to the point end. The reference given by self.origin,
self.rotation and the basis self.base is used</p>
<h2 id="parameters">Parameters</h2>
<p>start: starting point of the line</p>
<p>end: ending point of the line</p>
<p>scale: scale of the cylinder</p>
<p>name: name of the object</p>
<p>color: color of the vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_line(self,start=[1,1,1],end=[10,10,10],scale=0.05,name=&#34;Line&#34;,color=&#34;Black&#34;):
        &#34;&#34;&#34;
        Draws a line from the point start to the point end. The reference given by self.origin,
        self.rotation and the basis self.base is used
        Parameters:
           start: starting point of the line

           end: ending point of the line

           scale: scale of the cylinder

           name: name of the object

           color: color of the vector
        &#34;&#34;&#34;
        if start is None or end is None:
                return
        self.base_cilinder()
        o = Vector([0,0,0])
        op = Vector(self.origin)
        if isinstance(start,Vector):
                u = start
        else:
                u = Vector(start)
        if isinstance(end,Vector):
                v = end
        else:
                v = Vector(end)
        mat = Matrix(self.base)
        mat.transpose()
        u = mat @ u
        v = mat @ v
        l = (v - u).length
        t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
        obj = t.copy()
        obj.name = name
        obj.location = u
        obj.scale = (scale / 2,scale / 2,l)
        obj.rotation_mode = &#39;QUATERNION&#39;
        obj.rotation_quaternion = (v - u).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
        if color is not None:
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b)
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        obj.location = obj.location + op
        self.scene.collection.objects.link(obj)
        bpy.ops.object.shade_flat()
        self.delete_base_cilinder()
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_mesh"><code class="name flex">
<span>def <span class="ident">draw_mesh</span></span>(<span>self, mesh=None, name='Mesh', color='Blue', opacity=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a mesh. This function is used by other functions</p>
<h2 id="parameters">Parameters</h2>
<p>mesh: the mesh to be drawn</p>
<p>name: name of the mesh</p>
<p>color: color of the mesh</p>
<p>opacity: opacity of the mesh</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_mesh(self,mesh=None,name=&#39;Mesh&#39;,color=&#34;Blue&#34;,opacity=1):
        &#34;&#34;&#34;
        Draws a mesh. This function is used by other functions
        Parameters:
           mesh: the mesh to be drawn

           name: name of the mesh

           color: color of the mesh

           opacity: opacity of the mesh
        &#34;&#34;&#34;
        bm = bmesh.new()
        verts = []
        for p in mesh.points:
                verts.append(bm.verts.new(p))
        edges = [[0,1],[1,2],[2,3],[3,0]]
        for s in mesh.simplices:
                for e in edges:
                        v = Vector(mesh.points[s[e[0]]]) - Vector(mesh.points[s[e[1]]])
                        edge = [verts[s[e[0]]],verts[s[e[1]]]]
                        try:
                                bm.edges.new(edge)
                        except:
                                pass
        me = self.meshes.new(&#39;PointsMesh&#39;)
        obj = self.objects.new(name, me)
        bm.to_mesh(me)
        bm.free()
        self.scene.collection.objects.link(obj)
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_one_sheet_hyperboloid"><code class="name flex">
<span>def <span class="ident">draw_one_sheet_hyperboloid</span></span>(<span>self, a=2.0, b=2.0, xmin=1.4142135623730951, xmax=5.0, steps=256, scale=[1, 1, 1], color='AzureBlueDark', name='HyperboloidOneSheet', opacity=1.0, thickness=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a one sheet hyperboloid from the hyperbole z = \pm a*sqrt(x^2-b) in the XZ plane</p>
<h2 id="parameters">Parameters</h2>
<p>a, b: coefficients of the hyperbole</p>
<p>xmin: minimum value of x</p>
<p>xmax: maximum value of x</p>
<p>steps: numbers of steps to draw the parabola</p>
<p>scale: scaling factors in the X, Y and Z directions</p>
<p>color: color of the surface</p>
<p>name: name of the surface</p>
<p>opacity: opacity of the surface</p>
<p>thickness: thickness of the surface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_one_sheet_hyperboloid(self,a=2.0,b=2.0,xmin=math.sqrt(2),xmax=5.0,steps=256,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperboloidOneSheet&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws a one sheet hyperboloid from the hyperbole z = \pm a*sqrt(x^2-b) in the XZ plane
        Parameters:
           a, b: coefficients of the hyperbole

           xmin: minimum value of x

           xmax: maximum value of x

           steps: numbers of steps to draw the parabola

           scale: scaling factors in the X, Y and Z directions

           color: color of the surface

           name: name of the surface

           opacity: opacity of the surface

           thickness: thickness of the surface
        &#34;&#34;&#34;
        if xmin &lt; math.sqrt(b):
                xmin = math.sqrt(b)
        delta = (xmax - xmin) / steps
        x = xmax
        bm = bmesh.new()
        verts = []

        for k in range(steps + 1):
                if x &lt; math.sqrt(b):
                        z = 0.0
                else:
                        z = - a * math.sqrt(x**2 - b)
                verts.append(bm.verts.new((x,0,z)))
                x -= delta
        x = math.sqrt(b)
        for k in range(steps):
                x += delta
                if x**2 &lt; b:
                        z = 0.0
                else:
                        z = a * math.sqrt(x**2 - b)
                verts.append(bm.verts.new((x,0,z)))

        for i in range(len(verts) - 1):
                bm.edges.new([verts[i], verts[i+1]])

        me = self.meshes.new(&#39;placeholder_mesh&#39;)
        obj = self.objects.new(name,me)
        bm.to_mesh(me)
        bm.free()
        modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
        modifier.angle = 2 * math.pi
        modifier.steps = 128
        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        self.scene.collection.objects.link(obj)
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_parabola"><code class="name flex">
<span>def <span class="ident">draw_parabola</span></span>(<span>self, vertex=[0, 0, 0], u1=Vector((1.0, 0.0, 0.0)), u2=Vector((0.0, 1.0, 0.0)), a=1, xmax=3.0, axis=False, zaxis=False, steps=25, thickness=0.01, name='Parabola', color='White', change=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a parabola of vertex 'vertex' of equation y'=ax'^2 in the reference {vertex; v1, v2, v3} determined by vectors u1 and u2</p>
<h2 id="parameters">Parameters</h2>
<p>vertex: vertex of the parabola</p>
<p>u1, u2: vectors to construct the basis {v1, v2, v3}</p>
<p>a: coefficient of the parabola</p>
<p>xmax: maximum value of x'</p>
<p>axis: if True draws the axis of the reference R'</p>
<p>zaxis: if True draws the z' axis</p>
<p>steps: number of steps</p>
<p>thickness: thickness of the curve</p>
<p>name: name of the curve</p>
<p>color: color of the curve</p>
<p>change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_parabola(self,vertex=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,xmax=3.0,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Parabola&#34;,color=&#34;White&#34;,change=False):
        &#34;&#34;&#34;
        Draws a parabola of vertex &#39;vertex&#39; of equation y&#39;=ax&#39;^2 in the reference {vertex; v1, v2, v3} determined by vectors u1 and u2
        Parameters:
           vertex: vertex of the parabola

           u1, u2: vectors to construct the basis {v1, v2, v3}

           a: coefficient of the parabola

           xmax: maximum value of x&#39;

           axis: if True draws the axis of the reference R&#39;

           zaxis: if True draws the z&#39; axis

           steps: number of steps

           thickness: thickness of the curve

           name: name of the curve

           color: color of the curve

           change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
        &#34;&#34;&#34;
        if change:
                self.set_origin(vertex)
                self.set_base([u1,u2],orthonormal=True)
        return self.draw_curve(lambda t: (t,a*t**2,0),tmin=-xmax,tmax=xmax,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=vertex,u1=u1,u2=u2)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_parabolic_cylinder"><code class="name flex">
<span>def <span class="ident">draw_parabolic_cylinder</span></span>(<span>self, p=0.25, xmin=0.0, xmax=6.0, length=20, steps=50, scale=[1, 1, 1], color='AzureBlueDark', name='ParabolicCylinder', opacity=1.0, thickness=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a parabolic cylinder from the parabola z=p*x^2 in the XZ plane</p>
<h2 id="parameters">Parameters</h2>
<p>p: coefficients of the parabola</p>
<p>xmin: minimum value of x</p>
<p>xmax: maximum value of x</p>
<p>length: length in the Y direction</p>
<p>steps: numbers of steps to draw the parabola</p>
<p>scale: scaling factors in the X, Y and Z directions</p>
<p>color: color of the surface</p>
<p>name: name of the surface</p>
<p>opacity: opacity of the surface</p>
<p>thickness: thickness of the surface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_parabolic_cylinder(self,p=0.25,xmin=0.0,xmax=6.0,length=20,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;ParabolicCylinder&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws a parabolic cylinder from the parabola z=p*x^2 in the XZ plane
        Parameters:
           p: coefficients of the parabola

           xmin: minimum value of x

           xmax: maximum value of x

           length: length in the Y direction

           steps: numbers of steps to draw the parabola

           scale: scaling factors in the X, Y and Z directions

           color: color of the surface

           name: name of the surface

           opacity: opacity of the surface

           thickness: thickness of the surface
        &#34;&#34;&#34;
        delta = (xmax - xmin) / steps
        x = xmax
        bm = bmesh.new()
        verts = []
        count = 2 * steps + 2
        if xmin == 0.0:
                count = 2 * steps + 1
        for k in range(count):
                z = p * x**2
                verts.append(bm.verts.new((x,0,z)))
                if k == steps and xmin &gt; 0:
                        x = - xmin
                else:
                        x -= delta
                if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                        continue
                bm.edges.new([verts[k-1], verts[k]])

        me = self.meshes.new(&#39;ParabolicCylinderMesh&#39;)
        obj = self.objects.new(name, me)
        bm.to_mesh(me)
        bm.free()

        bpy.context.scene.collection.objects.link(obj)
        bpy.context.view_layer.objects.active = obj
        bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
        bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
        bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
        bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0, length, 0),&#34;constraint_axis&#34;:(False, True, False),&#34;use_accurate&#34;:True})
        bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
        bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
        obj.select_set(True)
        bpy.ops.transform.translate(value=(0, -length/2, 0),constraint_axis=(False, True, False))
        bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
        obj.select_set(False)

        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_parallelepiped"><code class="name flex">
<span>def <span class="ident">draw_parallelepiped</span></span>(<span>self, origin=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], u3=[0, 0, 1], scalelines=0.025, color='AzureBlueDark', linecolor='OrangeObscureDull', name='Parallelepiped', opacity=1.0, thickness=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a parallelepiped</p>
<h2 id="parameters">Parameters</h2>
<p>origin: base vertex of the parallelepiped</p>
<p>u1, u2, u3: vectors that gives the edges</p>
<p>scalelines: scale of the edges of the parallelepiped</p>
<p>color: color of the parallelepiped</p>
<p>linecolor: color of the edges</p>
<p>name: name of the parallelepiped</p>
<p>opacity: opacity of the parallelepiped</p>
<p>thickness: thickness of the parallelepiped</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_parallelepiped(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],u3=[0,0,1],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Parallelepiped&#39;,opacity=1.0,thickness=0.0):
        &#34;&#34;&#34;
        Draws a parallelepiped
        Parameters:
           origin: base vertex of the parallelepiped

           u1, u2, u3: vectors that gives the edges

           scalelines: scale of the edges of the parallelepiped

           color: color of the parallelepiped

           linecolor: color of the edges

           name: name of the parallelepiped

           opacity: opacity of the parallelepiped

           thickness: thickness of the parallelepiped
        &#34;&#34;&#34;
        op = Vector(self.origin)
        if isinstance(origin,Vector):
                op = op + origin
        else:
                op = op + Vector(origin)
        if not isinstance(u1,Vector):
                u1 = Vector(u1)
        if not isinstance(u2,Vector):
                u2 = Vector(u2)
        if not isinstance(u3,Vector):
                u3 = Vector(u3)

        mat = Matrix(self.base)
        mat.transpose()
        u1 = mat @ u1
        u2 = mat @ u2
        u3 = mat @ u3

        bpy.ops.mesh.primitive_cube_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)

        verts = obj.data.vertices
        verts[0].co = op
        verts[1].co = op + u3
        verts[2].co = op + u2
        verts[3].co = op + u2 + u3
        verts[4].co = op + u1
        verts[5].co = op + u1 + u3
        verts[6].co = op + u1 + u2
        verts[7].co = op + u1 + u2 + u3

        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 0.0

        lines = None
        s = 0.0
        edges =[[0,1],[0,2],[0,4],[1,3],[1,5],[2,3],[2,6],[3,7],[4,5],[4,6],[5,7],[6,7]]
        if scalelines &gt; 0.0:
                objects = []
                for edge in edges:
                        l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                        objects.append(l)
                lines = self.join(objects)

        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

        if lines is not None:
                obj = self.join([obj,lines])

        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None

        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_parallelogram"><code class="name flex">
<span>def <span class="ident">draw_parallelogram</span></span>(<span>self, origin=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], scalelines=0.025, color='AzureBlueDark', linecolor='OrangeObscureDull', name='Parallelogram', opacity=1.0, thickness=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a parallelogram</p>
<h2 id="parameters">Parameters</h2>
<p>origin: base vertex of the parallelogram</p>
<p>u1, u2: vectors that gives the edges</p>
<p>scalelines: scale of the edges of the parallelogram</p>
<p>color: color of the parallelogram</p>
<p>linecolor: color of the edges</p>
<p>name: name of the parallelogram</p>
<p>opacity: opacity of the parallelogram</p>
<p>thickness: thickness of the parallelogram</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_parallelogram(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Parallelogram&#39;,opacity=1.0,thickness=0.0):
        &#34;&#34;&#34;
        Draws a parallelogram
        Parameters:
           origin: base vertex of the parallelogram

           u1, u2: vectors that gives the edges

           scalelines: scale of the edges of the parallelogram

           color: color of the parallelogram

           linecolor: color of the edges

           name: name of the parallelogram

           opacity: opacity of the parallelogram

           thickness: thickness of the parallelogram
        &#34;&#34;&#34;
        op = Vector(self.origin)
        if isinstance(origin,Vector):
                op = op + origin
        else:
                op = op + Vector(origin)
        if not isinstance(u1,Vector):
                u1 = Vector(u1)
        if not isinstance(u2,Vector):
                u2 = Vector(u2)

        mat = Matrix(self.base)
        mat.transpose()
        u1 = mat @ u1
        u2 = mat @ u2

        bpy.ops.mesh.primitive_plane_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)

        verts = obj.data.vertices
        verts[0].co = op
        verts[1].co = op + u1
        verts[2].co = op + u2
        verts[3].co = op + u1 + u2

        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 0.0

        lines = None
        s = 0.0
        edges =[[0,1],[0,2],[1,3],[2,3]]
        if scalelines &gt; 0.0:
                objects = []
                for edge in edges:
                        l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                        objects.append(l)
                lines = self.join(objects)

        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

        if lines is not None:
                obj = self.join([obj,lines])

        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None

        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_plane"><code class="name flex">
<span>def <span class="ident">draw_plane</span></span>(<span>self, normal=None, base=None, sizex=10, sizey=10, color='AzureBlueDark', name='Plane', opacity=1.0, thickness=0.01)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a plane with normal vector or base vectors. It passes through the point self.origin.
Only normal or base can be not None</p>
<h2 id="parameters">Parameters</h2>
<p>normal: normal vector to the plane</p>
<p>base: list of two independent vectors</p>
<p>sizex: x-size of the plane</p>
<p>sizey: y-size of the plane</p>
<p>color: color of the plane</p>
<p>name: name of the plane</p>
<p>opacity: opacity of the plane</p>
<p>thickness: thickness of the plane</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_plane(self,normal=None,base=None,sizex=10,sizey=10,color=&#34;AzureBlueDark&#34;,name=&#39;Plane&#39;,opacity=1.0,thickness=0.01):
        &#34;&#34;&#34;
        Draws a plane with normal vector or base vectors. It passes through the point self.origin.
        Only normal or base can be not None
        Parameters:
           normal: normal vector to the plane

           base: list of two independent vectors

           sizex: x-size of the plane

           sizey: y-size of the plane

           color: color of the plane

           name: name of the plane

           opacity: opacity of the plane

           thickness: thickness of the plane
        &#34;&#34;&#34;
        if sizex == 0.0:
                return
        bpy.ops.mesh.primitive_plane_add(size=sizex,enter_editmode=True,location=(0, 0, 0))
        bpy.context.object.name = name
        ##### bpy.ops.mesh.subdivide(number_cuts=6,quadcorner=&#39;INNERVERT&#39;)
        bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
        obj = bpy.data.objects.get(name)
        if sizey is not None and sizey != 0.0:
                t = sizey / sizex
                obj.scale = [1,t,1]
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        if normal is not None and base is not None:
                return
        if base is not None:
                if len(base) != 2:
                        return
                if isinstance(base[0],Vector):
                        v1 = base[0]
                else:
                        v1 = Vector(base[0])
                if isinstance(base[1],Vector):
                        v2 = base[1]
                else:
                        v2 = Vector(base[1])

                if self.base is None:
                        normal = v1.cross(v2)
                else:
                        u1 = v1[0]*self.base[0] + v1[1]*self.base[1] + v1[2]*self.base[2]
                        u2 = v2[0]*self.base[0] + v2[1]*self.base[1] + v2[2]*self.base[2]
                        normal = u1.cross(u2)
        if normal is not None and normal != Vector([0,0,0]):
                z = Vector([0,0,1])
                quaternion = z.rotation_difference(normal)
                obj.rotation_quaternion.rotate(quaternion)
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        obj.location = op
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_plane_surface"><code class="name flex">
<span>def <span class="ident">draw_plane_surface</span></span>(<span>self, origin=None, normal=None, base=None, sizex=10, sizey=10, vectors=False, scalelines=0.05, scalevector=0.01, color='AzureBlueDark', linecolor='BlueDarkDull', vectorcolor='Black', name='Plane', opacity=1.0, thickness=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a plane with normal vector or base vectors. It passes through the point origin.
Only normal or base can be not None</p>
<h2 id="parameters">Parameters</h2>
<p>origin: a point in the plane</p>
<p>normal: normal vector to the plane</p>
<p>base: list of two independent vectors</p>
<p>sizex: x-size of the plane</p>
<p>sizey: y-size of the plane</p>
<p>vectors: if True, draw the generators of the plane</p>
<p>scalelines: scale of the lines limiting the plane</p>
<p>scalevector: scale of the generators</p>
<p>color: color of the plane</p>
<p>linecolor: color of the lines limiting the plane</p>
<p>vectorcolor: color of the generators</p>
<p>name: name of the plane</p>
<p>opacity: opacity of the plane</p>
<p>thickness: thickness of the plane</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_plane_surface(self,origin=None,normal=None,base=None,sizex=10,sizey=10,vectors=False,scalelines=0.05,scalevector=0.01,
                                        color=&#34;AzureBlueDark&#34;,linecolor=&#34;BlueDarkDull&#34;,vectorcolor=&#34;Black&#34;,name=&#34;Plane&#34;,opacity=1.0,thickness=0.0):
        &#34;&#34;&#34;
        Draws a plane with normal vector or base vectors. It passes through the point origin.
        Only normal or base can be not None
        Parameters:
           origin: a point in the plane

           normal: normal vector to the plane

           base: list of two independent vectors

           sizex: x-size of the plane

           sizey: y-size of the plane

           vectors: if True, draw the generators of the plane

           scalelines: scale of the lines limiting the plane

           scalevector: scale of the generators

           color: color of the plane

           linecolor: color of the lines limiting the plane

           vectorcolor: color of the generators

           name: name of the plane

           opacity: opacity of the plane

           thickness: thickness of the plane
        &#34;&#34;&#34;
        if normal is not None and base is not None:
                return
        if normal is None and base is None:
                return
        mat = Matrix(self.base)
        mat.transpose()
        if normal is not None:
                if not isinstance(normal,Vector):
                        normal= Vector(normal)
                normal = mat @ normal
        if base is not None:
                if len(base) != 2:
                        return
                if isinstance(base[0],Vector):
                        v1 = base[0]
                else:
                        v1 = Vector(base[0])
                if isinstance(base[1],Vector):
                        v2 = base[1]
                else:
                        v2 = Vector(base[1])
                v1 = mat @ v1
                v2 = mat @ v2
                normal = v1.cross(v2)

        if normal == Vector([0,0,0]):
                return

        steps = 4
        delta = sizex / steps
        x = - sizex / 2
        bm = bmesh.new()
        verts = []
        for k in range(steps + 1):
                verts.append(bm.verts.new((x,0,0)))
                x += delta
                if k == 0:
                        continue
                bm.edges.new([verts[k-1], verts[k]])

        me = self.meshes.new(&#39;PlaneSurfaceMesh&#39;)
        obj = self.objects.new(&#39;PlaneSurface&#39;, me)
        bm.to_mesh(me)
        bm.free()

        bpy.context.scene.collection.objects.link(obj)
        bpy.context.view_layer.objects.active = obj
        bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
        bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
        bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
        bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0, sizey, 0),&#34;constraint_axis&#34;:(False, True, False),&#34;use_accurate&#34;:True})
        bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
        bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
        obj.select_set(True)
        bpy.ops.transform.translate(value=(0, -sizey/2, 0),constraint_axis=(False, True, False))
        bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
        obj.select_set(False)

        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        if origin is not None:
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
        obj.location = o
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

        lines = None
        vecs = None
        s = 0.0
        nodes = [[1,1,0],[-1,1,0],[-1,-1,0],[1,-1,0]]
        nodes = [self.comp_times_vector(Vector([sizex / 2,sizey / 2,0]),Vector(x)) for x in nodes]
        edges = [[0,1],[1,2],[2,3],[3,0]]

        if scalelines &gt; 0.0:
                aux = self.origin
                self.origin = Vector([0,0,0])
                objects = []
                aux2 = self.base
                self.reset_base()
                for edge in edges:
                        l = self.draw_line(start=nodes[edge[0]],end=nodes[edge[1]],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                        objects.append(l)
                lines = self.join(objects)
                self.set_origin(aux)
                self.set_base(aux2)

        if lines is not None:
                obj = self.join([obj,lines])

        if vectors:
                vecs = self.draw_vectors(nodes,True,color=vectorcolor,scale=scalevector,head_height=0.2,name=&#34;Vectors&#34;,axis=0)

        if vecs is not None:
                obj = self.join([obj,vecs])
        obj.name = name

        if isinstance(normal,Vector):
                n = normal
        else:
                n = Vector(normal)
        z = Vector([0,0,1])
        quaternion = z.rotation_difference(n)
        tmp = obj.rotation_quaternion
        quaternion = tmp @ quaternion
        obj.rotation_quaternion = quaternion
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        obj.location = op
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_point"><code class="name flex">
<span>def <span class="ident">draw_point</span></span>(<span>self, radius=0.1, location=(0, 0, 0), name='Point', color='Black', opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a point (in the reference self.origin, self.base)</p>
<h2 id="parameters">Parameters</h2>
<p>radius: radius of the point</p>
<p>location: location of the point</p>
<p>name: name of the point</p>
<p>color: color of the point</p>
<p>opacity: opacity of the point</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_point(self,radius=0.1,location=(0,0,0),name=&#34;Point&#34;,color=&#34;Black&#34;,opacity=1.0):
        &#34;&#34;&#34;
        Draws a point (in the reference self.origin, self.base)
        Parameters:
           radius: radius of the point

           location: location of the point

           name: name of the point

           color: color of the point

           opacity: opacity of the point
        &#34;&#34;&#34;
        bpy.ops.mesh.primitive_uv_sphere_add(segments=16, ring_count=16, radius=radius, enter_editmode=False, location=location)
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)

        if not isinstance(location,Vector):
                location = Vector(location)
        mat = Matrix(self.base)
        mat.transpose()
        location = mat @ location

        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
        modifier.thickness = 0.1
        modifier.offset = 0.0
        c = Colors.color(color)
        op = Vector(self.origin)
        obj.location = op + location
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        bpy.ops.object.shade_smooth()
        obj.select_set(False)
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_points"><code class="name flex">
<span>def <span class="ident">draw_points</span></span>(<span>self, points=[], name='Points', color='Blue', opacity=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a list of points</p>
<h2 id="parameters">Parameters</h2>
<p>points: list of points</p>
<p>name: name of the list of points</p>
<p>color: color of the points</p>
<p>opacity: opacity of the points</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_points(self,points=[],name=&#39;Points&#39;,color=&#34;Blue&#34;,opacity=1):
        &#34;&#34;&#34;
        Draws a list of points
        Parameters:
           points: list of points

           name: name of the list of points

           color: color of the points

           opacity: opacity of the points
        &#34;&#34;&#34;
        bm = bmesh.new()
        verts = []
        for p in points:
                verts.append(bm.verts.new(p))

        me = self.meshes.new(&#39;PointsMesh&#39;)
        obj = self.objects.new(name, me)
        bm.to_mesh(me)
        bm.free()
        self.scene.collection.objects.link(obj)
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_polygon"><code class="name flex">
<span>def <span class="ident">draw_polygon</span></span>(<span>self, origin=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], points=[[0, 0], [1, 0], [0, 1]], scalelines=0.075, color='AzureBlueDark', linecolor='OrangeObscureDull', name='Polygon', opacity=1.0, thickness=0.0, vectors=None, scalevectors=0.01)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a polygon</p>
<h2 id="parameters">Parameters</h2>
<p>origin: base vertex of the polygon</p>
<p>u1, u2: base vectors for the polygon</p>
<p>points: list of coordinates of points. The coordinates are taken in the reference {origin; u1, u2}</p>
<p>scalelines: scale of the edges of the polygon</p>
<p>color: color of the polygon</p>
<p>linecolor: color of the edges</p>
<p>name: name of the polygon</p>
<p>opacity: opacity of the polygon</p>
<p>thickness: thickness of the polygon</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_polygon(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],points=[[0,0],[1,0],[0,1]],scalelines=0.075,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Polygon&#39;,opacity=1.0,thickness=0.0,vectors=None,scalevectors=0.01):
        &#34;&#34;&#34;
        Draws a polygon
        Parameters:
           origin: base vertex of the polygon

           u1, u2: base vectors for the polygon

           points: list of coordinates of points. The coordinates are taken in the reference {origin; u1, u2}

           scalelines: scale of the edges of the polygon

           color: color of the polygon

           linecolor: color of the edges

           name: name of the polygon

           opacity: opacity of the polygon

           thickness: thickness of the polygon
        &#34;&#34;&#34;
        if len(points) &lt; 3:
                return
        op = Vector(self.origin)
        if isinstance(origin,Vector):
                op = op + origin
        else:
                op = op + Vector(origin)
        if not isinstance(u1,Vector):
                u1 = Vector(u1)
        if not isinstance(u2,Vector):
                u2 = Vector(u2)
        for i in range(len(points)):
                if not isinstance(points[i],Vector):
                        points[i] = Vector(points[i])

        mat = Matrix(self.base)
        mat.transpose()
        u1 = mat @ u1
        u2 = mat @ u2

        bpy.ops.curve.simple(Simple_Type=&#39;Polygon&#39;,Simple_sides=len(points),align=&#39;WORLD&#39;,location=(0, 0, 0))
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)
        bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)

        baricentre = Vector([0,0,0])
        verts = obj.data.splines[0].bezier_points
        for i in range(len(verts)):
                verts[i].co = op + points[i][0] * u1 + points[i][1] * u2
                baricentre += verts[i].co
        baricentre /= len(verts)

        for i in range(len(verts)):
                verts[i].co -= baricentre
        obj.location = baricentre

        obj.select_set(True)
        bpy.ops.object.convert(target=&#39;MESH&#39;)

        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 0.0

        ps = [op + points[i][0] * u1 + points[i][1] * u2 for i in range(len(points))]
        lines = None
        if scalelines &gt; 0.0:
                objects = []
                for i in range(len(points)):
                        l = self.draw_line(start=ps[i],end=ps[(i + 1) % len(points)],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                        objects.append(l)
                lines = self.join(objects)

        if vectors is not None:
                old = self.origin
                self.set_origin(op)
                ps = [points[i][0] * u1 + points[i][1] * u2 for i in range(len(points))]
                vecs = self.draw_vectors(ps,color=vectors,scale=scalevectors)
                self.set_origin(old)

        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

        if lines is not None:
                obj = self.join([obj,lines])
        if vectors is not None:
                obj = self.join([obj,vecs])

        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None

        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_pyramid"><code class="name flex">
<span>def <span class="ident">draw_pyramid</span></span>(<span>self, origin=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], u3=[0.5, 0.5, 1], scalelines=0.025, color='AzureBlueDark', linecolor='OrangeObscureDull', name='Pyramid', opacity=1.0, thickness=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a pyramid</p>
<h2 id="parameters">Parameters</h2>
<p>origin: base vertex of the pyramid</p>
<p>u1, u2, u3: vectors that gives the edges</p>
<p>scalelines: scale of the edges of the pyramid</p>
<p>color: color of the pyramid</p>
<p>linecolor: color of the edges</p>
<p>name: name of the pyramid</p>
<p>opacity: opacity of the pyramid</p>
<p>thickness: thickness of the pyramid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_pyramid(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],u3=[0.5,0.5,1],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Pyramid&#39;,opacity=1.0,thickness=0.0):
        &#34;&#34;&#34;
        Draws a pyramid
        Parameters:
           origin: base vertex of the pyramid

           u1, u2, u3: vectors that gives the edges

           scalelines: scale of the edges of the pyramid

           color: color of the pyramid

           linecolor: color of the edges

           name: name of the pyramid

           opacity: opacity of the pyramid

           thickness: thickness of the pyramid
        &#34;&#34;&#34;
        op = Vector(self.origin)
        if isinstance(origin,Vector):
                op = op + origin
        else:
                op = op + Vector(origin)
        if not isinstance(u1,Vector):
                u1 = Vector(u1)
        if not isinstance(u2,Vector):
                u2 = Vector(u2)
        if not isinstance(u3,Vector):
                u3 = Vector(u3)

        mat = Matrix(self.base)
        mat.transpose()
        u1 = mat @ u1
        u2 = mat @ u2
        u3 = mat @ u3

        bpy.ops.mesh.primitive_cone_add(radius1=1, radius2=0, depth=2, enter_editmode=False, align=&#39;WORLD&#39;,vertices=4)
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)

        verts = obj.data.vertices
        verts[0].co = op
        verts[1].co = op + u1
        verts[2].co = op + u1 + u2
        verts[3].co = op + u2
        verts[4].co = op + u3

        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 0.0

        lines = None
        s = 0.0
        edges =[[0,1],[0,3],[0,4],[1,2],[1,4],[2,3],[2,4],[3,4]]
        if scalelines &gt; 0.0:
                objects = []
                for edge in edges:
                        l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                        objects.append(l)
                lines = self.join(objects)

        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

        if lines is not None:
                obj = self.join([obj,lines])

        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None

        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_regular_polygon"><code class="name flex">
<span>def <span class="ident">draw_regular_polygon</span></span>(<span>self, origin=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], vertexs=5, radius=1, scalelines=0.075, color='AzureBlueDark', linecolor='OrangeObscureDull', name='RegularPolygon', opacity=1.0, thickness=0.0, vectors=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a regular polygon</p>
<h2 id="parameters">Parameters</h2>
<p>origin: base vertex of the polygon</p>
<p>u1, u2: base vectors for the polygon</p>
<p>vertexs: number of vertices of the polygon</p>
<p>radius: radius of the polygon</p>
<p>scalelines: scale of the edges of the polygon</p>
<p>color: color of the polygon</p>
<p>linecolor: color of the edges</p>
<p>name: name of the polygon</p>
<p>opacity: opacity of the polygon</p>
<p>thickness: thickness of the polygon</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_regular_polygon(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],vertexs=5,radius=1,scalelines=0.075,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;RegularPolygon&#39;,opacity=1.0,thickness=0.0,vectors=None):
        &#34;&#34;&#34;
        Draws a regular polygon
        Parameters:
           origin: base vertex of the polygon

           u1, u2: base vectors for the polygon

           vertexs: number of vertices of the polygon

           radius: radius of the polygon

           scalelines: scale of the edges of the polygon

           color: color of the polygon

           linecolor: color of the edges

           name: name of the polygon

           opacity: opacity of the polygon

           thickness: thickness of the polygon
        &#34;&#34;&#34;
        angle = 2*math.pi/vertexs
        points = [[radius*math.cos(i*angle),radius*math.sin(i*angle)] for i in range(vertexs)]
        return self.draw_polygon(origin=origin,u1=u1,u2=u2,points=points,scalelines=scalelines,color=color,linecolor=linecolor,name=name,opacity=opacity,thickness=thickness,vectors=vectors,scalevectors=radius/400)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_simple_curve"><code class="name flex">
<span>def <span class="ident">draw_simple_curve</span></span>(<span>self, fun=None, tmin=0.0, tmax=1.0, steps=25, thickness=0.02, color='White', name='Curve')</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a parametric curve</p>
<h2 id="parameters">Parameters</h2>
<p>fun: the parametric function</p>
<p>tmin: minimum value of the parameter</p>
<p>tmax: maximum value of the parameter</p>
<p>steps: number of steps</p>
<p>thickness: thickness of the curve</p>
<p>color: color of the curve</p>
<p>name: name of the curve</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_simple_curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.02,color=&#34;White&#34;,name=&#34;Curve&#34;):
        &#34;&#34;&#34;
        Draws a parametric curve
        Parameters:
           fun: the parametric function

           tmin: minimum value of the parameter

           tmax: maximum value of the parameter

           steps: number of steps

           thickness: thickness of the curve

           color: color of the curve

           name: name of the curve
        &#34;&#34;&#34;
        if fun is None:
                return None
        delta = (tmax - tmin) / steps
        t = tmin

        curve = bpy.data.curves.new(&#39;myCurve&#39;, type=&#39;CURVE&#39;)
        curve.dimensions = &#39;3D&#39;
        curve.resolution_u = 2

        line = curve.splines.new(&#39;POLY&#39;)
        line.points.add(steps)

        for i in range(steps+1):
                p = fun(t)
                p.append(1)
                line.points[i].co = p
                t += delta

        obj = bpy.data.objects.new(name, curve)
        curve.bevel_depth = thickness

        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
        self.scene.collection.objects.link(obj)
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_surface"><code class="name flex">
<span>def <span class="ident">draw_surface</span></span>(<span>self, eq=None, umin=-1, umax=1, usteps=64, vmin=-1, vmax=1, vsteps=64, thickness=0.02, opacity=1.0, pmax=10, name='Surface', color='AzureBlueDark', axis=False, o=Vector((0.0, 0.0, 0.0)), u1=Vector((1.0, 0.0, 0.0)), u2=Vector((0.0, 1.0, 0.0)), wrap_u=False, wrap_v=False, close_v=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a parametric surface in the reference R'</p>
<h2 id="parameters">Parameters</h2>
<p>eq: parametric equacion f(u,v)</p>
<p>umin: minimum value of u</p>
<p>umax: maximum value of u</p>
<p>usteps: steps in the u direction</p>
<p>vmin: minimum value of v</p>
<p>vmax: maximum value of v</p>
<p>vsteps: steps in the v direction</p>
<p>thickness: thickness of the surface</p>
<p>opacity: opacity of the surface</p>
<p>color: color of the surface</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>name: name of the surface</p>
<p>color: color of the surface</p>
<p>axis: if True draw the axis of the reference {o, v1, v2, v3}</p>
<p>o: origin of the reference R'</p>
<p>u1, u2: vectors to construct the basis {v1, v2, v3}</p>
<p>scale: scale coefficients</p>
<p>wrap_u: wrap the u coordinate</p>
<p>wrap_v: wrap the u coordinate</p>
<p>close_v: close the v coordinate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_surface(self,eq=None,umin=-1,umax=1,usteps=64,vmin=-1,vmax=1,vsteps=64,thickness=0.02,opacity=1.0,pmax=10,name=&#34;Surface&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),wrap_u=False,wrap_v=False,close_v=False):
        &#34;&#34;&#34;
        Draws a parametric surface in the reference R&#39;
        Parameters:
           eq: parametric equacion f(u,v)

           umin: minimum value of u

           umax: maximum value of u

           usteps: steps in the u direction

           vmin: minimum value of v

           vmax: maximum value of v

           vsteps: steps in the v direction

           thickness: thickness of the surface

           opacity: opacity of the surface

           color: color of the surface

           pmax: the principal axis are drawn between -cmax and cmax

           name: name of the surface

           color: color of the surface

           axis: if True draw the axis of the reference {o, v1, v2, v3}

           o: origin of the reference R&#39;

           u1, u2: vectors to construct the basis {v1, v2, v3}

           scale: scale coefficients

           wrap_u: wrap the u coordinate

           wrap_v: wrap the u coordinate

           close_v: close the v coordinate
        &#34;&#34;&#34;
        if eq is None:
                return

        q = self.vectors_to_quaternion(u1,u2)
        draw_parametric_surface(eq=eq,range_u_min=umin,range_u_max=umax,range_u_step=usteps,range_v_min=vmin,range_v_max=vmax,range_v_step=vsteps,name=name,wrap_u=wrap_u,wrap_v=wrap_v,close_v=close_v)

        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)
        obj.show_wire = False

        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if self.rotation is not None:
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        if axis:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència escollida&#34;)

        bpy.ops.object.shade_smooth()
        obj.location = o
        obj.select_set(False)
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_tetrahedron"><code class="name flex">
<span>def <span class="ident">draw_tetrahedron</span></span>(<span>self, origin=[0, 0, 0], u1=[2, 0, 0], u2=[1.0000000000000002, 1.7320508075688772, 0], u3=[1.0, 0.5773502691896257, 2], scalelines=0.025, color='AzureBlueDark', linecolor='OrangeObscureDull', name='Tetrahedron', opacity=1.0, thickness=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a tetrahedron</p>
<h2 id="parameters">Parameters</h2>
<p>origin: base vertex of the tetrahedron</p>
<p>u1, u2, u3: vectors that gives the edges</p>
<p>scalelines: scale of the edges of the tetrahedron</p>
<p>color: color of the tetrahedron</p>
<p>linecolor: color of the edges</p>
<p>name: name of the tetrahedron</p>
<p>opacity: opacity of the tetrahedron</p>
<p>thickness: thickness of the tetrahedron</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_tetrahedron(self,origin=[0,0,0],u1=[2,0,0],u2=[2*math.cos(math.pi/3),2*math.sin(math.pi/3),0],u3=[(2+2*math.cos(math.pi/3))/3,2*math.sin(math.pi/3)/3,2],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Tetrahedron&#39;,opacity=1.0,thickness=0.0):
        &#34;&#34;&#34;
        Draws a tetrahedron
        Parameters:
           origin: base vertex of the tetrahedron

           u1, u2, u3: vectors that gives the edges

           scalelines: scale of the edges of the tetrahedron

           color: color of the tetrahedron

           linecolor: color of the edges

           name: name of the tetrahedron

           opacity: opacity of the tetrahedron

           thickness: thickness of the tetrahedron
        &#34;&#34;&#34;
        op = Vector(self.origin)
        if isinstance(origin,Vector):
                op = op + origin
        else:
                op = op + Vector(origin)
        if not isinstance(u1,Vector):
                u1 = Vector(u1)
        if not isinstance(u2,Vector):
                u2 = Vector(u2)
        if not isinstance(u3,Vector):
                u3 = Vector(u3)

        mat = Matrix(self.base)
        mat.transpose()
        u1 = mat @ u1
        u2 = mat @ u2
        u3 = mat @ u3

        bpy.ops.mesh.primitive_solid_add()
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)

        verts = obj.data.vertices
        verts[0].co = op + u3
        verts[1].co = op
        verts[2].co = op + u1
        verts[3].co = op + u2

        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 0.0

        lines = None
        s = 0.0
        edges =[[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]]
        if scalelines &gt; 0.0:
                objects = []
                for edge in edges:
                        l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                        objects.append(l)
                lines = self.join(objects)

        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

        if lines is not None:
                obj = self.join([obj,lines])

        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None

        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_triangle"><code class="name flex">
<span>def <span class="ident">draw_triangle</span></span>(<span>self, origin=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], points=[[0, 0], [1, 0], [0, 1]], scalelines=0.075, color='AzureBlueDark', linecolor='OrangeObscureDull', name='Triangle', opacity=1.0, thickness=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a triangle. It's a polygon with three vertices</p>
<h2 id="parameters">Parameters</h2>
<p>origin: base vertex of the triangle</p>
<p>u1, u2: base vectors for the triangle</p>
<p>points: list of coordinates of points. The coordinates are taken in the reference {origin; u1, u2}</p>
<p>scalelines: scale of the edges of the triangle</p>
<p>color: color of the triangle</p>
<p>linecolor: color of the edges</p>
<p>name: name of the triangle</p>
<p>opacity: opacity of the triangle</p>
<p>thickness: thickness of the triangle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_triangle(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],points=[[0,0],[1,0],[0,1]],scalelines=0.075,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#34;Triangle&#34;,opacity=1.0,thickness=0.0):
        &#34;&#34;&#34;
        Draws a triangle. It&#39;s a polygon with three vertices
        Parameters:
           origin: base vertex of the triangle

           u1, u2: base vectors for the triangle

           points: list of coordinates of points. The coordinates are taken in the reference {origin; u1, u2}

           scalelines: scale of the edges of the triangle

           color: color of the triangle

           linecolor: color of the edges

           name: name of the triangle

           opacity: opacity of the triangle

           thickness: thickness of the triangle
        &#34;&#34;&#34;
        if len(points) != 3:
                return
        self.draw_polygon(origin=origin,u1=u1,u2=u2,points=points,scalelines=scalelines,color=color,linecolor=linecolor,name=name,opacity=opacity,thickness=thickness)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_two_sheets_hyperboloid"><code class="name flex">
<span>def <span class="ident">draw_two_sheets_hyperboloid</span></span>(<span>self, a=2.0, b=1.0, xmin=0.0, xmax=5.0, steps=50, scale=[1, 1, 1], color='AzureBlueDark', name='HyperboloidTwoSheets', opacity=1.0, thickness=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a two sheet hyperboloid from the hyperbole z = \pm a * math.sqrt(x**2+b) in the XZ plane</p>
<h2 id="parameters">Parameters</h2>
<p>a, b: coefficients of the hyperbole</p>
<p>xmin: minimum value of x</p>
<p>xmax: maximum value of x</p>
<p>steps: numbers of steps to draw the parabola</p>
<p>scale: scaling factors in the X, Y and Z directions</p>
<p>color: color of the surface</p>
<p>name: name of the surface</p>
<p>opacity: opacity of the surface</p>
<p>thickness: thickness of the surface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_two_sheets_hyperboloid(self,a=2.0,b=1.0,xmin=0.0,xmax=5.0,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperboloidTwoSheets&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws a two sheet hyperboloid from the hyperbole z = \pm a * math.sqrt(x**2+b) in the XZ plane
        Parameters:
           a, b: coefficients of the hyperbole

           xmin: minimum value of x

           xmax: maximum value of x

           steps: numbers of steps to draw the parabola

           scale: scaling factors in the X, Y and Z directions

           color: color of the surface

           name: name of the surface

           opacity: opacity of the surface

           thickness: thickness of the surface
        &#34;&#34;&#34;
        delta = (xmax - xmin) / steps
        x = xmax
        bm = bmesh.new()
        verts = []
        count = 2 * steps + 2
        sign = 1
        for k in range(count):
                if k == steps + 1:
                        sign = -1
                z = sign * a * math.sqrt(x**2+b)
                verts.append(bm.verts.new((x,0,z)))
                if k == steps and xmin &gt; 0:
                        x = xmin
                else:
                        x = x - sign * delta
                if k == 0 or k == steps + 1:
                        continue
                bm.edges.new([verts[k-1], verts[k]])

        me = self.meshes.new(&#39;placeholder_mesh&#39;)
        obj = self.objects.new(name,me)
        bm.to_mesh(me)
        bm.free()

        modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
        modifier.angle = 2 * math.pi
        modifier.steps = 128
        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        self.scene.collection.objects.link(obj)
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_vector"><code class="name flex">
<span>def <span class="ident">draw_vector</span></span>(<span>self, vector=None, canonica=False, color='Black', scale=0.05, arrow=True, head_height=0.15, axis=0, name='Vector', positive=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw the vector with components 'vector'</p>
<h2 id="parameters">Parameters</h2>
<p>vector: components of the vector</p>
<p>canonica: if True, the components are in the canonical basis, else they are in the basis self.base. Finally,
self.rotation is applied</p>
<p>color: color of the vector</p>
<p>scale: scale of the cylinder</p>
<p>arrow: if True draws the vector itself</p>
<p>head_height: height of the head of the vector</p>
<p>head_scale: scale of the head of the vector</p>
<p>axis: if not zero, draw also the line generated by the vector</p>
<p>positive: if axis is not zero and positive is True, draw only the positive part of the line
generated by the vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_vector(self,vector=None,canonica=False,color=&#34;Black&#34;,scale=0.05,arrow=True,head_height=0.15,axis=0,name=&#34;Vector&#34;,positive=True):
        &#34;&#34;&#34;
        Draw the vector with components &#39;vector&#39;
        Parameters:
           vector: components of the vector

           canonica: if True, the components are in the canonical basis, else they are in the basis self.base. Finally,
              self.rotation is applied

           color: color of the vector

           scale: scale of the cylinder

           arrow: if True draws the vector itself

           head_height: height of the head of the vector

           head_scale: scale of the head of the vector

           axis: if not zero, draw also the line generated by the vector

           positive: if axis is not zero and positive is True, draw only the positive part of the line
              generated by the vector
        &#34;&#34;&#34;
        if vector is None:
                return None
        if isinstance(vector,Vector):
                vec = vector
        else:
                vec = Vector(vector)
        if vec.length == 0:
                return None
        self.base_cilinder()
        self.base_cone()
        o = Vector([0,0,0])
        op = Vector(self.origin)
        if color is not None:
                color = Colors.color(color)
        v = vec
        if not canonica:
                mat = Matrix(self.base)
                mat.transpose()
                v = mat @ vec

        if arrow:
                t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                obj = t.copy()
                obj.name = name
                obj.data = obj.data.copy()
                obj.location = o
                obj.scale = (scale,scale,(v - o).length - 2 * head_height)
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                if color is not None:
                        self.add_material(obj,color.name,color.r,color.g,color.b)
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location = op
                self.scene.collection.objects.link(obj)

                t = bpy.data.objects.get(&#34;Arrow_cone&#34;)
                obj2 = t.copy()
                obj2.data = obj2.data.copy()
                obj2.name = &#34;Arrow&#34;
                obj2.location =  v - 2 * head_height * v / v.length
                obj2.scale = (1.05*scale,1.05*scale + 0.05,head_height)
                obj2.rotation_mode = &#39;QUATERNION&#39;
                obj2.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                if color is not None:
                        self.add_material(obj2,color.name,color.r,color.g,color.b)
                if self.rotation is not None:
                        obj2.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj2.location.rotate(self.rotation.quaternion)
                obj2.location = op + obj2.location
                self.scene.collection.objects.link(obj2)

        obj3 = None
        if axis != 0:
                v = axis * v / v.length
                t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                obj3 = t.copy()
                if not arrow:
                        obj3.name = &#34;Line&#34;
                else:
                        obj3.name = &#34;Generated&#34;
                obj3.data = obj3.data.copy()
                obj3.scale = (scale / 2,scale / 2,(2 * v).length)
                obj3.rotation_mode = &#39;QUATERNION&#39;
                obj3.rotation_quaternion = v.to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                if color is not None:
                        self.add_material(obj3,color.name,color.r,color.g,color.b)
                if self.rotation is not None:
                        obj3.rotation_quaternion.rotate(self.rotation.quaternion)
                if positive:
                        obj3.location = op
                else:
                        obj3.location = op - v
                self.scene.collection.objects.link(obj3)

        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        if arrow:
                bpy.context.view_layer.objects.active = obj
        elif axis != 0:
                bpy.context.view_layer.objects.active = obj3
        if arrow:
                obj.select_set(True)
                obj2.select_set(True)
        if obj3 is not None:
                obj3.select_set(True)
        if arrow:
                bpy.ops.object.join()
        bpy.ops.object.shade_smooth()
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        self.delete_base_cilinder()
        self.delete_base_cone()
        bpy.context.view_layer.objects.active = None
        if arrow:
                return obj
        if axis != 0:
                return obj3
        return None</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_vector_field"><code class="name flex">
<span>def <span class="ident">draw_vector_field</span></span>(<span>self, f=None, xmin=-3, xmax=3, xsteps=8, ymin=-3, ymax=3, ysteps=8, zmin=-3, zmax=3, zsteps=8, name='Vector Field', color='Red', scale=0.02, head_height=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a vector field</p>
<h2 id="parameters">Parameters</h2>
<p>f: the vector field</p>
<p>xmin: minimum value of x</p>
<p>xmax: maximum value of x</p>
<p>xsteps: steps in the x direction</p>
<p>ymin: minimum value of y</p>
<p>ymax: maximum value of y</p>
<p>ysteps: steps in the y direction</p>
<p>zmin: minimum value of z</p>
<p>zmax: maximum value of z</p>
<p>zsteps: steps in the z direction</p>
<p>name: name of the vector field</p>
<p>color: color of the vector field</p>
<p>scale: scale of the vectors</p>
<p>head_height: head height of the vectors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_vector_field(self,f=None,xmin=-3,xmax=3,xsteps=8,ymin=-3,ymax=3,ysteps=8,zmin=-3,zmax=3,zsteps=8,name=&#34;Vector Field&#34;,color=&#34;Red&#34;,scale=0.02,head_height=0.05):
        &#34;&#34;&#34;
        Draws a vector field
        Parameters:
           f: the vector field

           xmin: minimum value of x

           xmax: maximum value of x

           xsteps: steps in the x direction

           ymin: minimum value of y

           ymax: maximum value of y

           ysteps: steps in the y direction

           zmin: minimum value of z

           zmax: maximum value of z

           zsteps: steps in the z direction

           name: name of the vector field

           color: color of the vector field

           scale: scale of the vectors

           head_height: head height of the vectors
        &#34;&#34;&#34;
        if f is None:
                return None
        xstep = (xmax - xmin)/xsteps
        ystep = (ymax - ymin)/ysteps
        zstep = (zmax - zmin)/zsteps
        if xstep == 0 or ystep == 0 or zstep == 0:
                return None
        vectors = []
        count = 1
        x = xmin
        while x &lt;= xmax:
                y = ymin
                while y &lt;= ymax:
                        z = zmin
                        while z &lt;= zmax:
                                o = Vector([x,y,z])
                                v = f(x,y,z)
                                if not isinstance(v,Vector):
                                        v = Vector(v)
                                self.set_origin(o)
                                vec = self.draw_vector(v,color=color,name=f&#34;Vector{count}&#34;,scale=scale,head_height=head_height)
                                if vec is not None:
                                        vectors.append(vec)
                                z += zstep
                                count += 1
                        y += ystep
                x += xstep
        v = self.join(vectors)
        bpy.context.object.name = name
        return v</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_vectors"><code class="name flex">
<span>def <span class="ident">draw_vectors</span></span>(<span>self, vectors=[], canonica=False, color='Black', scale=0.05, head_height=0.2, name='Vectors', axis=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a list of vectors.</p>
<h2 id="parameters">Parameters</h2>
<p>vectors: list of vectors</p>
<p>anonica: if True, the the vectors are expressed in the canonical basis.</p>
<p>color: color of the vectors</p>
<p>scale: scale of the cylinder</p>
<p>head_height: height of the head of the vector</p>
<p>axis: if not zero, draw also the line generated by every vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_vectors(self,vectors=[],canonica=False,color=&#34;Black&#34;,scale=0.05,head_height=0.2,name=&#34;Vectors&#34;,axis=0):
        &#34;&#34;&#34;
        Draws a list of vectors.
        Parameters:
           vectors: list of vectors

           anonica: if True, the the vectors are expressed in the canonical basis.

           color: color of the vectors

           scale: scale of the cylinder

           head_height: height of the head of the vector

           axis: if not zero, draw also the line generated by every vector
        &#34;&#34;&#34;
        if len(vectors) == 0:
                return
        count = 0
        for v in vectors:
                if count == 0:
                        this = name
                else:
                        this = f&#34;Vector{count}&#34;
                count += 1
                t = self.draw_vector(v,canonica,color=color,scale=scale,head_height=head_height,axis=axis,name=this)
        t = bpy.data.objects.get(name)
        list = [t]
        for count in range(1,len(vectors)+1):
                obj = bpy.data.objects.get(f&#34;Vector{count}&#34;)
                if obj is not None:
                        list.append(obj)
        t = self.join(list)
        return t</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.ellipse"><code class="name flex">
<span>def <span class="ident">ellipse</span></span>(<span>self, center=Vector((0.0, 0.0, 0.0)), a=8, b=5, canonica=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the ellipse of equation (x-x0)^2/a^2 + (y-y0)^2/b^2 == 1</p>
<h2 id="parameters">Parameters</h2>
<p>centre: center of the ellipse</p>
<p>a, b: semiaxis of the ellipse</p>
<p>canonica: if True, draws the x and y axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ellipse(self,center=Vector([0,0,0]),a=8,b=5,canonica=True):
        &#34;&#34;&#34;
        Draws the ellipse of equation (x-x0)^2/a^2 + (y-y0)^2/b^2 == 1
        Parameters:
                centre: center of the ellipse

                a, b: semiaxis of the ellipse

                canonica: if True, draws the x and y axis
        &#34;&#34;&#34;
        if len(center) == 2:
                center = (center[0],center[1],0)
        if not isinstance(center,Vector):
                center = Vector(center)
        if a &gt;= b:
                c = sqrt(a**2 - b**2)
                f1 = Vector([c,0,0])
                f2 = Vector([-c,0,0])
        else:
                c = sqrt(b**2 - a**2)
                f1 = Vector([0,c,0])
                f2 = Vector([0,-c,0])
        if canonica:
                self.referencia_canonica(zaxis=False)
        self.draw_ellipse(center=center,a=a,b=b,thickness=0.02,steps=128,axis=False)
        self.draw_point(radius=0.167,location=(0,0,0),name=&#34;Centre&#34;,color=&#34;White&#34;)
        self.draw_point(radius=0.167,location=f1,name=&#34;F1&#34;,color=&#34;Black&#34;)
        self.draw_point(radius=0.167,location=f2,name=&#34;F2&#34;,color=&#34;Black&#34;)
        self.set_origin()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.ellipsoid"><code class="name flex">
<span>def <span class="ident">ellipsoid</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, c2=1, principal=True, canonica=True, color='AzureBlueDark', name='Ellipsoid', cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an ellipsoid</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the ellipsoid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
v1 = u1
v2 = u2 - u2.project(v1)
v1.normalize()
v2.normalize()
v3 = v1.cross(v2)</p>
<p>a2, b2, c2: squares of semi-axes of the ellipsoid. The equation is x'^2/a^2 + y'^2/b^2 + z'^2/c^2 = 1</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the ellipsoid</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -pmax and pmax</p>
<p>thickness: thickness of the ellipsoid</p>
<p>opacity: opaccity of the ellipsoid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ellipsoid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Ellipsoid&#34;,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws an ellipsoid
        Parameters:
           o: center of the ellipsoid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
               v1 = u1
                   v2 = u2 - u2.project(v1)
                   v1.normalize()
                   v2.normalize()
                   v3 = v1.cross(v2)

           a2, b2, c2: squares of semi-axes of the ellipsoid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 + z&#39;^2/c^2 = 1

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the ellipsoid

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -pmax and pmax

           thickness: thickness of the ellipsoid

           opacity: opaccity of the ellipsoid
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        c = math.sqrt(c2)
        self.draw_ellipsoid(radius=1,scale=[a,b,c],color=color,name=name,thickness=thickness,opacity=opacity)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.ellipsoide"><code class="name flex">
<span>def <span class="ident">ellipsoide</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, c2=1, principal=True, canonica=True, color='AzureBlueDark', name='Ellipsoid', cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an ellipsoid</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the ellipsoid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
v1 = u1
v2 = u2 - u2.project(v1)
v1.normalize()
v2.normalize()
v3 = v1.cross(v2)</p>
<p>a2, b2, c2: squares of semi-axes of the ellipsoid. The equation is x'^2/a^2 + y'^2/b^2 + z'^2/c^2 = 1</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the ellipsoid</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -pmax and pmax</p>
<p>thickness: thickness of the ellipsoid</p>
<p>opacity: opaccity of the ellipsoid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ellipsoid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Ellipsoid&#34;,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws an ellipsoid
        Parameters:
           o: center of the ellipsoid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
               v1 = u1
                   v2 = u2 - u2.project(v1)
                   v1.normalize()
                   v2.normalize()
                   v3 = v1.cross(v2)

           a2, b2, c2: squares of semi-axes of the ellipsoid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 + z&#39;^2/c^2 = 1

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the ellipsoid

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -pmax and pmax

           thickness: thickness of the ellipsoid

           opacity: opaccity of the ellipsoid
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        c = math.sqrt(c2)
        self.draw_ellipsoid(radius=1,scale=[a,b,c],color=color,name=name,thickness=thickness,opacity=opacity)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.ellipsoide_revolucio"><code class="name flex">
<span>def <span class="ident">ellipsoide_revolucio</span></span>(<span>self, a=12, b=8, direccio='Z', punt=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an animation showing an ellipsoid of revolution
a, b: semiaxis of the initial ellipse</p>
<pre><code>    direccio: 'X', the initial ellipse is in the plane XZ and rotates around the X axis
                      'Y', the initial ellipse is in the plane YZ and rotates around the Y axis
                      'Z', the initial ellipse is in the plane ZX and rotates around the Z axis

    punt: if it's a value between 0 and pi, the animation shows a rotating point
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ellipsoide_revolucio(self,a=12,b=8,direccio=&#39;Z&#39;,punt=None):
        &#34;&#34;&#34;
        Draws an animation showing an ellipsoid of revolution
                a, b: semiaxis of the initial ellipse

                direccio: &#39;X&#39;, the initial ellipse is in the plane XZ and rotates around the X axis
                                  &#39;Y&#39;, the initial ellipse is in the plane YZ and rotates around the Y axis
                                  &#39;Z&#39;, the initial ellipse is in the plane ZX and rotates around the Z axis

                punt: if it&#39;s a value between 0 and pi, the animation shows a rotating point
        &#34;&#34;&#34;
        if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                F = lambda t: (a*cos(t),0,b*sin(t))
        elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                F = lambda t: (0,a*cos(t),b*sin(t))
        else:
                F = lambda t: (b*sin(t),0,a*cos(t))
        self.base_canonica()
        self.animate_revolution_surface(F,tmin=0,tmax=pi,steps=128,axis=direccio,point=punt)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.elliptic_cylinder"><code class="name flex">
<span>def <span class="ident">elliptic_cylinder</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, principal=True, canonica=True, color='AzureBlueDark', name='EllipticCylinder', zmax=20, cmax=15, pmax=15, thickness=0.02, opacity=1.0, change=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an elliptic cylinder</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the elliptic cylinder</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2: squares of semi-axes of the elliptic cylinder. The equation is x'^2/a^2 + y'^2/b^2 = 1</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the elliptic cylinder</p>
<p>zmax: the elliptic cylinder is drawn between -zmax and zmax</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the elliptic cylinder</p>
<p>opacity: opacity of the elliptic cylinder</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def elliptic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;EllipticCylinder&#34;,zmax=20,cmax=15,pmax=15,thickness=0.02,opacity=1.0,change=False):
        &#34;&#34;&#34;
        Draws an elliptic cylinder
        Parameters:
           o: center of the elliptic cylinder

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2: squares of semi-axes of the elliptic cylinder. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 = 1

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the elliptic cylinder

           zmax: the elliptic cylinder is drawn between -zmax and zmax

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the elliptic cylinder

           opacity: opacity of the elliptic cylinder
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        self.draw_elliptic_cylinder(a=1.0,b=1.0,length=zmax,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)
        if not change:
                self.set_origin()
                self.set_base()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.elliptic_paraboloid"><code class="name flex">
<span>def <span class="ident">elliptic_paraboloid</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, principal=True, canonica=True, color='AzureBlueDark', name='EllipticParaboloid', xmax=None, cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an elliptic paraboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: vertex of the elliptic paraboloid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2: squares of semi-axes of the elliptic paraboloid. The equation is z = x'^2/a^2 + y'^2/b^2</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the elliptic paraboloid</p>
<p>xmax: maximum value of the coordinate x</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the elliptic paraboloid</p>
<p>opacity: opacity of the elliptic paraboloid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def elliptic_paraboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;EllipticParaboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws an elliptic paraboloid
        Parameters:
           o: vertex of the elliptic paraboloid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2: squares of semi-axes of the elliptic paraboloid. The equation is z = x&#39;^2/a^2 + y&#39;^2/b^2

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the elliptic paraboloid

           xmax: maximum value of the coordinate x

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the elliptic paraboloid

           opacity: opacity of the elliptic paraboloid
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        if xmax is None:
                xmax = 10.0/a
        xmax /= a
        self.draw_elliptic_paraboloid(a=1.0,xmin=0.0,xmax=xmax,steps=50,scale=[a,b,1],color=color,name=name,opacity=opacity,thickness=thickness)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.esfera"><code class="name flex">
<span>def <span class="ident">esfera</span></span>(<span>self, centre=Vector((0.0, 0.0, 0.0)), radi=10, cmax=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a sphere</p>
<h2 id="parametre">Parametre</h2>
<p>centre: center of the sphere</p>
<p>radi: radius of the sphere</p>
<p>cmax: maximum values of the x, y and z coordinates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esfera(self,centre=Vector([0,0,0]),radi=10,cmax=20):
        &#34;&#34;&#34;
        Draws a sphere
        Parametre:
                centre: center of the sphere

                radi: radius of the sphere

                cmax: maximum values of the x, y and z coordinates
        &#34;&#34;&#34;
        self.sphere(o=centre,r2=radi**2,canonica=True,principal=False,cmax=cmax)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.esfera_cilindre_elliptic"><code class="name flex">
<span>def <span class="ident">esfera_cilindre_elliptic</span></span>(<span>self, radi=10, x0=5, a=5, b=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an sphere centered at (0,0,0), an elliptic cylinder and their intersection</p>
<h2 id="parameters">Parameters</h2>
<p>radi: radius of the sphere</p>
<p>x0: (x0,0,0) is the center of the ellipse in the plain XY</p>
<p>a, b: semiaxis of this ellipse</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esfera_cilindre_elliptic(self,radi=10,x0=5,a=5,b=5):
        &#34;&#34;&#34;
        Draws an sphere centered at (0,0,0), an elliptic cylinder and their intersection
        Parameters:
                radi: radius of the sphere

                x0: (x0,0,0) is the center of the ellipse in the plain XY

                a, b: semiaxis of this ellipse
        &#34;&#34;&#34;
        if radi &lt;= 0:
                return
        def F(t):
                x = x0 + a*math.cos(t)
                y = b*math.sin(t)
                z = radi**2 - x**2 - y**2
                if z &lt; 0:
                        z  = 0
                z = math.sqrt(z)
                return (x,y,z)
        self.sphere(r2=radi**2,canonica=True,color=&#34;GrayLight&#34;,thickness=0.0001,pmax=3*radi+3,name=&#34;Esfera&#34;)
        self.elliptic_cylinder(o=[x0,0,0],a2=a**2,b2=b**2,principal=False,canonica=False,zmax=3*radi,thickness=0.01,name=&#34;Cilindre&#34;)
        x, y = symbols(&#39;x y&#39;,real=True)
        sol = solve([x**2 + y**2 - radi**2, (x-x0)**2/a**2 + y**2/b**2 - 1],[x,y],dict=True)
        #
        # 1. solve retorna una única solució
        # La solució és el punt (x0+a,0) o (x0-a,0,0)
        #
        if len(sol) == 1:
                #
                # L&#39;altre vèrtex està dins o fora de la circumferència x^2 + y^2 = radi^2
                #
                if (sol[0][x] == radi and abs(x0 - a) &lt; radi) or (sol[0][x] == - radi and abs(x0 + a) &lt; radi):
                        self.curve(F,tmin=0,tmax=2*pi,steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
                else:
                        self.draw_point(radius=0.2,location=(sol[0][x],sol[0][y],0),name=&#34;Punt intersecció&#34;,color=&#34;Black&#34;,opacity=1.0)
        #
        # 2. solve retorna dues solucions
        #
        if len(sol) == 2:
                try:
                        sol[0][x]
                        sol[0][y]
                        sol[1][x]
                        sol[1][y]
                        circ = False
                except:
                        circ = True
                if circ:
                        #
                        # El cilindre és de revolució i les circumferències al pla XY coincideixen
                        #
                        self.draw_circle(radius=radi,steps=64,thickness=0.05,name=&#34;Circumferència&#34;,color=&#34;Black&#34;)
                else:
                        #
                        # Tenim dues solucions diferents, que han de ser (radi,0) i (-radi,0)
                        #
                        if abs(b) &lt; radi:
                                theta = [math.atan2(sol[i][y]/b,(sol[i][x] - x0)/a) for i in range(2)]
                                theta.sort()
                                if x0 &gt; 0:
                                        self.curve(F,tmin=theta[1],tmax=2*pi-theta[1],steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
                                else:
                                        self.curve(F,tmin=theta[0],tmax=theta[1],steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
                        else:
                                self.draw_point(radius=0.2,location=(sol[0][x],sol[0][y],0),name=&#34;Punt intersecció 1&#34;,color=&#34;Black&#34;,opacity=1.0)
                                self.draw_point(radius=0.2,location=(sol[1][x],sol[1][y],0),name=&#34;Punt intersecció 2&#34;,color=&#34;Black&#34;,opacity=1.0)
        #
        # 2. solve retorna tres solucions
        #
        if len(sol) == 3:
                theta = [math.atan2(sol[i][y]/b,(sol[i][x] - x0)/a) for i in range(3)]
                theta.sort()
                if theta[1] == 0.0:
                        self.curve(F,tmin=theta[0],tmax=theta[2],steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
                if theta[2] == math.pi:
                        self.curve(F,tmin=theta[1],tmax=theta[0]+2*math.pi,steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
        #
        # 2. solve retorna quatre solucions
        #
        if len(sol) == 4:
                theta = [math.atan2(sol[i][y]/b,(sol[i][x] - x0)/a) for i in range(4)]
                theta.sort()
                self.curve(F,tmin=theta[2],tmax=theta[3],steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=(&#39;XY&#39;,&#39;XZ&#39;,&#39;X&#39;),name=&#34;Corba intersecció&#34;)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.gir_poligon"><code class="name flex">
<span>def <span class="ident">gir_poligon</span></span>(<span>self, centre=Vector((0.0, 0.0, 0.0)), costats=6, origen=Vector((0.0, 0.0, 0.0)), radi=8)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an animation of the rotation around a point of a polygon in the plane XY</p>
<h2 id="parameters">Parameters</h2>
<p>centre: center of the polygon</p>
<p>costats: sides of the polygon</p>
<p>origen: center of the rotation</p>
<p>radi: radius of the polygon</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gir_poligon(self,centre=Vector([0,0,0]),costats=6,origen=Vector([0,0,0]),radi=8):
        &#34;&#34;&#34;
        Draws an animation of the rotation around a point of a polygon in the plane XY
        Parameters:
                centre: center of the polygon

                costats: sides of the polygon

                origen: center of the rotation

                radi: radius of the polygon
        &#34;&#34;&#34;
        if len(centre) == 2:
                centre = [centre[0],centre[1],0]
        if len(origen) == 2:
                origen = [origen[0],origen[1],0]
        if not isinstance(centre,Vector):
                centre = Vector(centre)
        if not isinstance(origen,Vector):
                origen = Vector(origen)
        self.base_canonica(zaxis=False)
        self.draw_point(radius=0.167,location=origen,name=&#34;Centre del gir&#34;,color=&#34;White&#34;)
        poligon = self.draw_regular_polygon(origin=centre,vertexs=costats,radius=radi,name=&#34;Polígon regular&#34;)
        self.rotate_object(poligon,axis=&#39;Z&#39;,origin=origen,draw=False)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.hiperbola"><code class="name flex">
<span>def <span class="ident">hiperbola</span></span>(<span>self, center=Vector((0.0, 0.0, 0.0)), a=8, b=5, negatiu=False, canonica=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the hyperbole of equation (x-x0)^2/a^2 - (y-y0)^2/b^2 == 1 (or -1)</p>
<h2 id="parameters">Parameters</h2>
<p>centre: center of the hyperbole</p>
<p>a, b: semiaxis of the hyperbole</p>
<p>canonica: if True, draws the x and y axis</p>
<p>negatiu: if True, draws the hyperbole (x-x0)^2/a^2 - (y-y0)^2/b^2 == -1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hiperbola(self,center=Vector([0,0,0]),a=8,b=5,negatiu=False,canonica=True):
        &#34;&#34;&#34;
        Draws the hyperbole of equation (x-x0)^2/a^2 - (y-y0)^2/b^2 == 1 (or -1)
        Parameters:
                centre: center of the hyperbole

                a, b: semiaxis of the hyperbole

                canonica: if True, draws the x and y axis

                negatiu: if True, draws the hyperbole (x-x0)^2/a^2 - (y-y0)^2/b^2 == -1
        &#34;&#34;&#34;
        if len(center) == 2:
                center = (center[0],center[1],0)
        if not isinstance(center,Vector):
                center = Vector(center)
        u1 = Vector([a,b,0])
        u2 = Vector([a,-b,0])
        c = sqrt(a**2 + b**2)
        f1 = [c,0,0]
        f2 = [-c,0,0]
        if canonica:
                self.referencia_canonica(zaxis=False)
        v1 = Vector([1,0,0])
        v2 = Vector([0,1,0])
        if negatiu:
                self.set_base(base=[[0,1,0],[-1,0,0],[0,0,1]])
                v1 = Vector([0,1,0])
                v2 = Vector([-1,0,0])
                u1 = Vector([b,a,0])
                u2 = Vector([b,-a,0])
        self.draw_hyperbole(center=center,u1=v1,u2=v2,a=a,b=b,ymax=14,thickness=0.02,steps=128,axis=False)
        self.draw_point(radius=0.167,location=(0,0,0),name=&#34;Centre&#34;,color=&#34;White&#34;)
        self.draw_point(radius=0.167,location=f1,name=&#34;F1&#34;,color=&#34;Black&#34;)
        self.draw_point(radius=0.167,location=f2,name=&#34;F2&#34;,color=&#34;Black&#34;)
        self.draw_line(start=-5*u1,end=5*u1,color=&#34;Blue&#34;,scale=0.03,name=&#34;Asímptota 1&#34;)
        self.draw_line(start=-5*u2,end=5*u2,color=&#34;Blue&#34;,scale=0.03,name=&#34;Asímptota 2&#34;)
        self.set_origin()
        self.set_base()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.hiperboloide_dues_fulles"><code class="name flex">
<span>def <span class="ident">hiperboloide_dues_fulles</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, c2=1, principal=True, canonica=True, color='AzureBlueDark', name='TwoSheetParaboloid', xmax=None, cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a two sheets hyperboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the hyperboloid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x'^2/a^2 + y'^2/b^2 - z'^2/c^2 = -1</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the hyperboloid</p>
<p>xmax: maximum value of the x coordinate</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the hyperboloid</p>
<p>opacity: opacity of the hyperboloid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def two_sheets_hyperboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;TwoSheetParaboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws a two sheets hyperboloid
        Parameters:
           o: center of the hyperboloid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = -1

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the hyperboloid

           xmax: maximum value of the x coordinate

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the hyperboloid

           opacity: opacity of the hyperboloid
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        c = math.sqrt(c2)
        if xmax is None:
                xmax = 5.0/a + 2
        xmax /= a
        self.draw_two_sheets_hyperboloid(a=1.0,b=1.0,xmin=0.0,xmax=xmax,color=color,scale=[a,b,c],name=name,thickness=thickness,opacity=opacity)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.hiperboloide_dues_fulles_revolucio"><code class="name flex">
<span>def <span class="ident">hiperboloide_dues_fulles_revolucio</span></span>(<span>self, a=3, b=2, pmax=8, direccio='Z', punt=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an animation showing a two sheet hyperboloid of revolution
a, b: semiaxis of the initial hyperbole</p>
<pre><code>    pmax: maximum value of the independent variable

    direccio: 'X', the initial hyperbole is in the plane YX and rotates around the X axis
              'Y', the initial hyperbole is in the plane ZY and rotates around the Y axis
                  'Z', the initial hyperbole is in the plane XZ and rotates around the Z axis

    punt: if it's a value between 0 and pi, the animation shows a rotating point
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hiperboloide_dues_fulles_revolucio(self,a=3,b=2,pmax=8,direccio=&#39;Z&#39;,punt=None):
        &#34;&#34;&#34;
        Draws an animation showing a two sheet hyperboloid of revolution
                a, b: semiaxis of the initial hyperbole

                pmax: maximum value of the independent variable

                direccio: &#39;X&#39;, the initial hyperbole is in the plane YX and rotates around the X axis
                          &#39;Y&#39;, the initial hyperbole is in the plane ZY and rotates around the Y axis
                              &#39;Z&#39;, the initial hyperbole is in the plane XZ and rotates around the Z axis

                punt: if it&#39;s a value between 0 and pi, the animation shows a rotating point
        &#34;&#34;&#34;
        if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                s = &#39;Z&#39;
                F = lambda t: (a*math.sqrt(1+t**2/b**2),t,0)
        elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                F = lambda t: (0,a*math.sqrt(1+t**2/b**2),t)
                s = &#39;Z&#39;
        else:
                F = lambda t: (t,0,a*math.sqrt(1+t**2/b**2))
                s = &#39;X&#39;
        self.base_canonica()
        self.animate_revolution_surface(F,tmin=-pmax,tmax=pmax,steps=128,axis=direccio,symmetry=s,point=punt)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.hiperboloide_una_fulla"><code class="name flex">
<span>def <span class="ident">hiperboloide_una_fulla</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, c2=1, principal=True, canonica=True, color='AzureBlueDark', name='OneSheetHyperboloid', xmax=None, cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an one sheet hyperboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the hyperboloid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x'^2/a^2 + y'^2/b^2 - z'^2/c^2 = 1</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the hyperboloid</p>
<p>xmax: maximum value of the x coordinate</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the hyperboloid</p>
<p>opacity: opacity of the hyperboloid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def one_sheet_hyperboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;OneSheetHyperboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws an one sheet hyperboloid
        Parameters:
           o: center of the hyperboloid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = 1

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the hyperboloid

           xmax: maximum value of the x coordinate

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the hyperboloid

           opacity: opacity of the hyperboloid
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        c = math.sqrt(c2)
        if xmax is None:
                xmax=5.0/a + 2
        xmax /= a
        self.draw_one_sheet_hyperboloid(a=1.0,b=1.0,xmin=1.0,xmax=xmax,scale=[a,b,c],color=color,name=name,thickness=thickness,opacity=opacity)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.hiperboloide_una_fulla_revolucio"><code class="name flex">
<span>def <span class="ident">hiperboloide_una_fulla_revolucio</span></span>(<span>self, a=3, b=2, pmax=8, direccio='Z', punt=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an animation showing an one sheet hyperboloid of revolution
a, b: semiaxis of the initial hyperbole</p>
<pre><code>    pmax: maximum value of the independent variable

    direccio: 'X', the initial hyperbole is in the plane XZ and rotates around the X axis
              'Y', the initial hyperbole is in the plane YX and rotates around the Y axis
                  'Z', the initial hyperbole is in the plane ZX and rotates around the Z axis

    punt: if it's a value between 0 and pi, the animation shows a rotating point
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hiperboloide_una_fulla_revolucio(self,a=3,b=2,pmax=8,direccio=&#39;Z&#39;,punt=None):
        &#34;&#34;&#34;
        Draws an animation showing an one sheet hyperboloid of revolution
                a, b: semiaxis of the initial hyperbole

                pmax: maximum value of the independent variable

                direccio: &#39;X&#39;, the initial hyperbole is in the plane XZ and rotates around the X axis
                          &#39;Y&#39;, the initial hyperbole is in the plane YX and rotates around the Y axis
                              &#39;Z&#39;, the initial hyperbole is in the plane ZX and rotates around the Z axis

                punt: if it&#39;s a value between 0 and pi, the animation shows a rotating point
        &#34;&#34;&#34;
        if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                F = lambda t: (t,0,a*math.sqrt(1+t**2/b**2))
        elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                F = lambda t: (a*math.sqrt(1+t**2/b**2),t,0)
        else:
                F = lambda t: (a*math.sqrt(1+t**2/b**2),0,t)
        self.base_canonica()
        self.animate_revolution_surface(F,tmin=-pmax,tmax=pmax,steps=128,axis=direccio,point=punt)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.hyperbolic_cylinder"><code class="name flex">
<span>def <span class="ident">hyperbolic_cylinder</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, principal=True, canonica=True, color='AzureBlueDark', name='HyperbolicCylinder', xmax=None, zmax=20, cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an hyperbolic cylinder</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the hyperbolic cylinder</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2: squares of semi-axes of the hyperbolic cylinder. The equation is x'^2/a^2 - y'^2/b^2 = 1</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the hyperbolic cylinder</p>
<p>xmax: maximum value of the x coordinate</p>
<p>zmax: the hyperbolic cylinder is drawn between -zmax and zmax</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the hyperbolic cylinder</p>
<p>opacity: opacity of the hyperbolic cylinder</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hyperbolic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicCylinder&#34;,xmax=None,zmax=20,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws an hyperbolic cylinder
        Parameters:
           o: center of the hyperbolic cylinder

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2: squares of semi-axes of the hyperbolic cylinder. The equation is x&#39;^2/a^2 - y&#39;^2/b^2 = 1

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the hyperbolic cylinder

           xmax: maximum value of the x coordinate

           zmax: the hyperbolic cylinder is drawn between -zmax and zmax

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the hyperbolic cylinder

           opacity: opacity of the hyperbolic cylinder
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        if xmax is None:
                xmax = 5.0/a + 2
        xmax /= a
        obj = self.draw_hyperbolic_cylinder(a=1.0,b=1.0,xmin=1.0,xmax=xmax,length=zmax,steps=128,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.hyperbolic_paraboloid"><code class="name flex">
<span>def <span class="ident">hyperbolic_paraboloid</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, principal=True, canonica=True, color='AzureBlueDark', name='HyperbolicParaboloid', xmax=None, ymax=None, cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an hyperbolic paraboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: vertex of the hyperbolic paraboloid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2: squares of semi-axes of the hyperbolic paraboloid. The equation is z = x'^2/a^2 - y'^2/b^2</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the elliptic paraboloid</p>
<p>xmax: maximum value of the coordinate x</p>
<p>ymax: maximum value of the coordinate y</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the hyperbolic paraboloid</p>
<p>opacity: opacity of the hyperbolic paraboloid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hyperbolic_paraboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicParaboloid&#34;,xmax=None,ymax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws an hyperbolic paraboloid
        Parameters:
           o: vertex of the hyperbolic paraboloid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2: squares of semi-axes of the hyperbolic paraboloid. The equation is z = x&#39;^2/a^2 - y&#39;^2/b^2

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the elliptic paraboloid

           xmax: maximum value of the coordinate x

           ymax: maximum value of the coordinate y

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the hyperbolic paraboloid

           opacity: opacity of the hyperbolic paraboloid
        &#34;&#34;&#34;
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        if xmax is None:
                xmax = 10.0/a + 2
        if ymax is None:
                ymax = 10.0/b + 1
        xmax /= a
        ymax /= b
        obj = self.draw_hyperbolic_paraboloid(a=1.0,b=1.0,xmax=xmax,ymax=ymax,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)

        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        obj.location = o</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>self, list)</span>
</code></dt>
<dd>
<div class="desc"><p>Joins a list of objects</p>
<h2 id="parameters">Parameters</h2>
<p>list: list of objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join(self,list):
        &#34;&#34;&#34;
        Joins a list of objects
        Parameters:
           list: list of objects
        &#34;&#34;&#34;
        if len(list) &lt;= 1:
                return
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        bpy.context.view_layer.objects.active = list[0]
        for obj in list:
                obj.select_set(True)
        bpy.ops.object.join()
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        return list[0]</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.moviment_helicoidal_ortoedre"><code class="name flex">
<span>def <span class="ident">moviment_helicoidal_ortoedre</span></span>(<span>self, centre=Vector((0.0, 0.0, 0.0)), costats=Vector((3.0, 4.0, 2.0)), opacity=1, origen=Vector((4.0, 3.0, 0.0)), eix='Z', translacio=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an animation of the helical motion of an orthohedron around an affine line</p>
<h2 id="parameters">Parameters</h2>
<p>centre: center of the orthohedron</p>
<p>costats: half sides of the orthohedron</p>
<p>origen: point of the affine line</p>
<p>eix: axis of rotation</p>
<p>opacity: opacity of the orthohedron</p>
<p>translation: translation of the helical motion (distance by frame)
if translation = 0.0, it's a rotation motion</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def moviment_helicoidal_ortoedre(self,centre=Vector([0,0,0]),costats=Vector([3,4,2]),opacity=1,origen=Vector([4,3,0]),eix=&#39;Z&#39;,translacio=0.0):
        &#34;&#34;&#34;
        Draws an animation of the helical motion of an orthohedron around an affine line
        Parameters:
                centre: center of the orthohedron

                costats: half sides of the orthohedron

                origen: point of the affine line

                eix: axis of rotation

                opacity: opacity of the orthohedron

                translation: translation of the helical motion (distance by frame)
                             if translation = 0.0, it&#39;s a rotation motion
        &#34;&#34;&#34;
        self.base_canonica()
        if not isinstance(centre,Vector):
                centre = Vector(centre)
        if not isinstance(costats,Vector):
                costats = Vector(costats)
        if not isinstance(origen,Vector):
                origen = Vector(origen)
        ortoedre = self.draw_cube(origin=centre,scale=costats,color=&#34;AzureBlueDark&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Ortoedre&#34;)
        self.rotate_object(ortoedre,axis=eix,origin=origen,helicoidal=translacio)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.one_sheet_hyperboloid"><code class="name flex">
<span>def <span class="ident">one_sheet_hyperboloid</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, c2=1, principal=True, canonica=True, color='AzureBlueDark', name='OneSheetHyperboloid', xmax=None, cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an one sheet hyperboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the hyperboloid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x'^2/a^2 + y'^2/b^2 - z'^2/c^2 = 1</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the hyperboloid</p>
<p>xmax: maximum value of the x coordinate</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the hyperboloid</p>
<p>opacity: opacity of the hyperboloid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def one_sheet_hyperboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;OneSheetHyperboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws an one sheet hyperboloid
        Parameters:
           o: center of the hyperboloid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = 1

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the hyperboloid

           xmax: maximum value of the x coordinate

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the hyperboloid

           opacity: opacity of the hyperboloid
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        c = math.sqrt(c2)
        if xmax is None:
                xmax=5.0/a + 2
        xmax /= a
        self.draw_one_sheet_hyperboloid(a=1.0,b=1.0,xmin=1.0,xmax=xmax,scale=[a,b,c],color=color,name=name,thickness=thickness,opacity=opacity)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.parabola"><code class="name flex">
<span>def <span class="ident">parabola</span></span>(<span>self, vertex=Vector((0.0, 0.0, 0.0)), p=5, xmax=15, eixos='XY', canonica=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the parabola of equation y - y0 = (x-x0)^2/(2<em>p) or x - x0 = (y-y0)^2/(2</em>p)</p>
<h2 id="parameters">Parameters</h2>
<p>vertex: vertex of the parabola</p>
<p>p: parameter of the parabola</p>
<p>pmax: maximum value of the independent variable</p>
<p>eixos: 'XY', draws y - y0 = (x-x0)^2/(2<em>p)
'YX', draws x - x0 = (y-y0)^2/(2</em>p)</p>
<p>canonica: if True, draws the x and y axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parabola(self,vertex=Vector([0,0,0]),p=5,xmax=15,eixos=&#39;XY&#39;,canonica=True):
        &#34;&#34;&#34;
        Draws the parabola of equation y - y0 = (x-x0)^2/(2*p) or x - x0 = (y-y0)^2/(2*p)
        Parameters:
                vertex: vertex of the parabola

                p: parameter of the parabola

                pmax: maximum value of the independent variable

                eixos: &#39;XY&#39;, draws y - y0 = (x-x0)^2/(2*p)
                           &#39;YX&#39;, draws x - x0 = (y-y0)^2/(2*p)

                canonica: if True, draws the x and y axis
        &#34;&#34;&#34;
        if len(vertex) == 2:
                vertex = (vertex[0],vertex[1],0)
        if not isinstance(vertex,Vector):
                vertex = Vector(vertex)
        f = [0,p/2,0]
        if canonica:
                self.referencia_canonica(zaxis=False)
        u1 = Vector([1,0,0])
        u2 = Vector([0,1,0])
        if eixos == &#39;YX&#39; or eixos == &#39;yx&#39;:
                self.set_base(base=[[0,1,0],[1,0,0],[0,0,-1]])
                u1 = Vector([0,1,0])
                u2 = Vector([1,0,0])
        self.draw_parabola(vertex=vertex,a=1/(2*p),u1=u1,u2=u2,xmax=xmax,thickness=0.02,steps=128,axis=False)
        self.reset_rotation()
        self.draw_point(radius=0.167,location=f,name=&#34;Focus&#34;,color=&#34;Black&#34;)
        self.draw_point(radius=0.167,location=(0,0,0),name=&#34;Vèrtex&#34;,color=&#34;White&#34;)
        self.draw_line(start=[-xmax-3,-p/2,0],end=[xmax+3,-p/2,0],color=&#34;Blue&#34;,scale=0.04,name=&#34;Recta directriu&#34;)
        self.set_origin()
        self.set_base()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.parabolic_cylinder"><code class="name flex">
<span>def <span class="ident">parabolic_cylinder</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a=1, principal=True, canonica=True, color='AzureBlueDark', name='ParabolicCylinder', xmax=None, ymax=30, cmax=20, pmax=20, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an hyperbolic paraboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: vertex of the hyperbolic paraboloid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a: coefficient of the intial parabola</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the elliptic paraboloid</p>
<p>xmax: maximum value of the coordinate x</p>
<p>ymax: maximum value of the coordinate y</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the hyperbolic paraboloid</p>
<p>opacity: opacity of the hyperbolic paraboloid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parabolic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;ParabolicCylinder&#34;,xmax=None,ymax=30,cmax=20,pmax=20,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws an hyperbolic paraboloid
        Parameters:
           o: vertex of the hyperbolic paraboloid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a: coefficient of the intial parabola

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the elliptic paraboloid

           xmax: maximum value of the coordinate x

           ymax: maximum value of the coordinate y

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the hyperbolic paraboloid

           opacity: opacity of the hyperbolic paraboloid
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        coef = 1.0
        if a &lt; 0:
                coef = -1
        if xmax is None:
                xmax = 5.0/a + 1.5
        xmax /= a
        self.draw_parabolic_cylinder(p=coef,xmin=0.0,xmax=xmax,length=ymax,color=color,name=name,scale=[a,1,1],thickness=thickness,opacity=opacity)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.paraboloide_elliptic"><code class="name flex">
<span>def <span class="ident">paraboloide_elliptic</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, principal=True, canonica=True, color='AzureBlueDark', name='EllipticParaboloid', xmax=None, cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an elliptic paraboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: vertex of the elliptic paraboloid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2: squares of semi-axes of the elliptic paraboloid. The equation is z = x'^2/a^2 + y'^2/b^2</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the elliptic paraboloid</p>
<p>xmax: maximum value of the coordinate x</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the elliptic paraboloid</p>
<p>opacity: opacity of the elliptic paraboloid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def elliptic_paraboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;EllipticParaboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws an elliptic paraboloid
        Parameters:
           o: vertex of the elliptic paraboloid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2: squares of semi-axes of the elliptic paraboloid. The equation is z = x&#39;^2/a^2 + y&#39;^2/b^2

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the elliptic paraboloid

           xmax: maximum value of the coordinate x

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the elliptic paraboloid

           opacity: opacity of the elliptic paraboloid
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        if xmax is None:
                xmax = 10.0/a
        xmax /= a
        self.draw_elliptic_paraboloid(a=1.0,xmin=0.0,xmax=xmax,steps=50,scale=[a,b,1],color=color,name=name,opacity=opacity,thickness=thickness)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.paraboloide_elliptic_revolucio"><code class="name flex">
<span>def <span class="ident">paraboloide_elliptic_revolucio</span></span>(<span>self, a=0.5, pmax=5, direccio='Z', punt=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an animation showing an elliptic paraboloid of revolution
a: The constant of the initial parabola</p>
<pre><code>    pmax: maximum value of the independent variable

    direccio: 'X', the initial parabola is in the plane YX and rotates around the X axis
              'Y', the initial parabola is in the plane ZY and rotates around the Y axis
                  'Z', the initial parabola is in the plane XZ and rotates around the Z axis

    punt: if it's a value between -pmax and pmax, the animation shows a rotating point
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paraboloide_elliptic_revolucio(self,a=0.5,pmax=5,direccio=&#39;Z&#39;,punt=None):
        &#34;&#34;&#34;
        Draws an animation showing an elliptic paraboloid of revolution
                a: The constant of the initial parabola

                pmax: maximum value of the independent variable

                direccio: &#39;X&#39;, the initial parabola is in the plane YX and rotates around the X axis
                          &#39;Y&#39;, the initial parabola is in the plane ZY and rotates around the Y axis
                              &#39;Z&#39;, the initial parabola is in the plane XZ and rotates around the Z axis

                punt: if it&#39;s a value between -pmax and pmax, the animation shows a rotating point
        &#34;&#34;&#34;
        if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                F = lambda t: (a*t**2,t,0)
        elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                F = lambda t: (0,a*t**2,t)
        else:
                F = lambda t: (t,0,a*t**2)
        self.base_canonica()
        self.animate_revolution_surface(F,tmin=0,tmax=pmax,steps=128,axis=direccio,point=punt)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.paraboloide_hiperbolic"><code class="name flex">
<span>def <span class="ident">paraboloide_hiperbolic</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, principal=True, canonica=True, color='AzureBlueDark', name='HyperbolicParaboloid', xmax=None, ymax=None, cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an hyperbolic paraboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: vertex of the hyperbolic paraboloid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2: squares of semi-axes of the hyperbolic paraboloid. The equation is z = x'^2/a^2 - y'^2/b^2</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the elliptic paraboloid</p>
<p>xmax: maximum value of the coordinate x</p>
<p>ymax: maximum value of the coordinate y</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the hyperbolic paraboloid</p>
<p>opacity: opacity of the hyperbolic paraboloid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hyperbolic_paraboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicParaboloid&#34;,xmax=None,ymax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws an hyperbolic paraboloid
        Parameters:
           o: vertex of the hyperbolic paraboloid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2: squares of semi-axes of the hyperbolic paraboloid. The equation is z = x&#39;^2/a^2 - y&#39;^2/b^2

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the elliptic paraboloid

           xmax: maximum value of the coordinate x

           ymax: maximum value of the coordinate y

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the hyperbolic paraboloid

           opacity: opacity of the hyperbolic paraboloid
        &#34;&#34;&#34;
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        if xmax is None:
                xmax = 10.0/a + 2
        if ymax is None:
                ymax = 10.0/b + 1
        xmax /= a
        ymax /= b
        obj = self.draw_hyperbolic_paraboloid(a=1.0,b=1.0,xmax=xmax,ymax=ymax,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)

        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        obj.location = o</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.paraboloide_hiperbolic_simple"><code class="name flex">
<span>def <span class="ident">paraboloide_hiperbolic_simple</span></span>(<span>self, a=3, b=4, xmax=12, ymax=12)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the hyperbolic paraboloid of equation z = x^2/a^2 - y^2/b^2</p>
<h2 id="parameters">Parameters</h2>
<p>a, b: constants the defines he hyperbolic paraboloid</p>
<p>xmax, ymax: maximun values of the x and y coordinates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paraboloide_hiperbolic_simple(self,a=3,b=4,xmax=12,ymax=12):
        &#34;&#34;&#34;
        Draws the hyperbolic paraboloid of equation z = x^2/a^2 - y^2/b^2
        Parameters:
                a, b: constants the defines he hyperbolic paraboloid

                xmax, ymax: maximun values of the x and y coordinates
        &#34;&#34;&#34;
        self.hyperbolic_paraboloid(a2=a**2,b2=b**2,xmax=xmax,ymax=ymax,canonica=True,principal=False)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.pla_afi"><code class="name flex">
<span>def <span class="ident">pla_afi</span></span>(<span>self, punt=Vector((0.0, 0.0, 0.0)), v1=Vector((3.0, 2.0, 1.0)), v2=Vector((1.0, -2.0, 0.5)), canonica=False, name='Pla afí', length=15, color='Cyan', sizex=25, sizey=20, opacity=0.8, elements=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the affine plane generated by two vectors passing through a point</p>
<h2 id="parameters">Parameters</h2>
<p>punt: point of the plane</p>
<p>v1, v2: generators of the plane</p>
<p>canonica: if True, draws the x, y and z axis</p>
<p>name: name of the affine plane</p>
<p>length: length of the axis x, y and z</p>
<p>color: color of the plane</p>
<p>sizex, sizey: size of the plane</p>
<p>opacicity: opacity of the plane</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pla_afi(self,punt=Vector([0,0,0]),v1=Vector([3,2,1]),v2=Vector([1,-2,0.5]),canonica=False,name=&#34;Pla afí&#34;,length=15,color=&#34;Cyan&#34;,sizex=25,sizey=20,opacity=0.8,elements=True):
        &#34;&#34;&#34;
        Draws the affine plane generated by two vectors passing through a point
        Parameters:
                punt: point of the plane

                v1, v2: generators of the plane

                canonica: if True, draws the x, y and z axis

                name: name of the affine plane

                length: length of the axis x, y and z

                color: color of the plane

                sizex, sizey: size of the plane

                opacicity: opacity of the plane
        &#34;&#34;&#34;
        if canonica:
                self.base_canonica(length=length)
        self.draw_plane_surface(origin=punt,base=[v1,v2],color=color,sizex=sizex,sizey=sizey,name=name,opacity=opacity)
        if elements:
                self.set_origin(punt)
                self.draw_point(color=&#34;Blue&#34;)
                self.draw_vectors([v1,v2],color=&#34;Blue&#34;)
                self.set_origin()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.pla_vectorial"><code class="name flex">
<span>def <span class="ident">pla_vectorial</span></span>(<span>self, v1=Vector((3.0, 2.0, 1.0)), v2=Vector((1.0, -2.0, 0.5)), canonica=False, length=15, color='Cyan', sizex=25, sizey=20, opacity=0.8)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the plane generated by two vectors</p>
<h2 id="parameters">Parameters</h2>
<p>v1, v2: generators of the plane</p>
<p>canonica: if True, draws the x, y and z axis</p>
<p>length: length of the axis x, y and z</p>
<p>color: color of the plane</p>
<p>sizex, sizey: size of the plane</p>
<p>opacicity: opacity of the plane</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pla_vectorial(self,v1=Vector([3,2,1]),v2=Vector([1,-2,0.5]),canonica=False,length=15,color=&#34;Cyan&#34;,sizex=25,sizey=20,opacity=0.8):
        &#34;&#34;&#34;
        Draws the plane generated by two vectors
        Parameters:
                v1, v2: generators of the plane

                canonica: if True, draws the x, y and z axis

                length: length of the axis x, y and z

                color: color of the plane

                sizex, sizey: size of the plane

                opacicity: opacity of the plane
        &#34;&#34;&#34;
        if canonica:
                self.base_canonica(length=length)
        self.draw_vectors([v1,v2],color=&#34;Blue&#34;)
        self.draw_plane_surface(base=[v1,v2],color=color,sizex=sizex,sizey=sizey,opacity=opacity)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_pla_afi"><code class="name flex">
<span>def <span class="ident">projeccio_ortogonal_simetric_pla_afi</span></span>(<span>self, punt=Vector((6.0, -5.0, 8.0)), p0=Vector((3.0, -2.0, -3.0)), v1=Vector((3.0, -1.0, 1.0)), v2=Vector((1.0, 0.5, 0.5)), radi=0.15, sizex=35, sizey=30, canonica=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the orthogonal projection and the symmetric of a point with respect an affine plane</p>
<h2 id="parameters">Parameters</h2>
<p>punt: the initial point</p>
<p>p0: point of the affine plane</p>
<p>v1, v2: generators of the plane</p>
<p>radi: radius of the points</p>
<p>sizex, sizey: sizes of the affine plane</p>
<p>canonica: if True, draws the x, y and z axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projeccio_ortogonal_simetric_pla_afi(self,punt=Vector([6,-5,8]),p0=Vector([3,-2,-3]),v1=Vector([3,-1,1]),v2=Vector([1,0.5,0.5]),radi=0.15,sizex=35,sizey=30,canonica=True):
        &#34;&#34;&#34;
        Draws the orthogonal projection and the symmetric of a point with respect an affine plane
        Parameters:
                punt: the initial point

                p0: point of the affine plane

                v1, v2: generators of the plane

                radi: radius of the points

                sizex, sizey: sizes of the affine plane

                canonica: if True, draws the x, y and z axis
        &#34;&#34;&#34;
        if not isinstance(punt,Vector):
                punt = Vector(punt)
        if not isinstance(p0,Vector):
                p0 = Vector(p0)
        if not isinstance(v1,Vector):
                v1 = Vector(v1)
        if not isinstance(v2,Vector):
                v2 = Vector(v2)
        self.draw_point(location=punt,color=&#34;Black&#34;,radius=radi)
        w = v1.cross(v2)
        self.pla_afi(punt=p0,v1=v1,v2=v2,sizex=sizex,sizey=sizey,canonica=canonica)
        u = punt - p0
        up = punt - u.project(w)
        self.draw_point(location=up,color=&#34;Red&#34;,radius=radi)
        us = punt - 2*u.project(w)
        self.draw_point(location=us,color=&#34;Green&#34;,radius=radi)
        u = punt - up
        self.draw_line(start=up-1.5*u,end=up+1.5*u,scale=0.04,color=&#34;White&#34;)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_pla_vectorial"><code class="name flex">
<span>def <span class="ident">projeccio_ortogonal_simetric_pla_vectorial</span></span>(<span>self, vector=Vector((7.0, -1.0, 12.0)), v1=Vector((3.0, -1.0, 1.0)), v2=Vector((1.0, 0.5, 0.5)), canonica=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the otoghonal projection and the symmetric of a vector with respecte a plane</p>
<h2 id="parameters">Parameters</h2>
<p>vector: the initial vector</p>
<p>v1, v2: generators of the plane</p>
<p>canonica: if True, draws the x, y and z axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projeccio_ortogonal_simetric_pla_vectorial(self,vector=Vector([7,-1,12]),v1=Vector([3,-1,1]),v2=Vector([1,0.5,0.5]),canonica=True):
        &#34;&#34;&#34;
        Draws the otoghonal projection and the symmetric of a vector with respecte a plane
        Parameters:
                vector: the initial vector

                v1, v2: generators of the plane

                canonica: if True, draws the x, y and z axis
        &#34;&#34;&#34;
        if not isinstance(vector,Vector):
                vector = Vector(vector)
        if not isinstance(v1,Vector):
                v1 = Vector(v1)
        if not isinstance(v2,Vector):
                v2 = Vector(v2)
        self.draw_vector(vector)
        w = v1.cross(v2)
        vp = vector - vector.project(w)
        self.draw_vector(vp,color=&#34;Red&#34;)
        self.pla_vectorial(v1,v2,sizex=3*vp.length,sizey=2.6*vp.length,canonica=canonica)
        self.set_origin(vp)
        self.draw_vector(vector.project(w),scale=0.025,color=&#34;White&#34;)
        self.set_origin()
        self.set_base([v1,v2,w])
        vb = self.components_in_base(vector)
        self.set_base()
        p1 = vb.x * v1
        p2 = vb.y * v2
        self.draw_line(start=[0,0,0],end=p1,scale=0.04,color=&#34;Blue&#34;)
        self.draw_line(start=[0,0,0],end=p2,scale=0.04,color=&#34;Blue&#34;)
        self.draw_line(start=vp,end=p1,scale=0.04,color=&#34;Blue&#34;)
        self.draw_line(start=vp,end=p2,scale=0.04,color=&#34;Blue&#34;)
        self.draw_vector(2 * vp - vector,color=&#34;Green&#34;)
        self.draw_line(start=2 * vp - vector,end=vp,scale=0.04,color=&#34;White&#34;)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_recta_afi"><code class="name flex">
<span>def <span class="ident">projeccio_ortogonal_simetric_recta_afi</span></span>(<span>self, punt=Vector((6.0, -5.0, 8.0)), p0=Vector((3.0, -2.0, -3.0)), v1=Vector((3.0, -1.0, 1.0)), scale=0.1, radi=0.15, canonica=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the orthogonal projection and the symmetric of a point with respect an affine line</p>
<h2 id="parameters">Parameters</h2>
<p>punt: the initial point</p>
<p>p0: point of the affine line</p>
<p>v1: generator of the line</p>
<p>radi: radius of the points</p>
<p>canonica: if True, draws the x, y and z axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projeccio_ortogonal_simetric_recta_afi(self,punt=Vector([6,-5,8]),p0=Vector([3,-2,-3]),v1=Vector([3,-1,1]),scale=0.1,radi=0.15,canonica=True):
        &#34;&#34;&#34;
        Draws the orthogonal projection and the symmetric of a point with respect an affine line
        Parameters:
                punt: the initial point

                p0: point of the affine line

                v1: generator of the line

                radi: radius of the points

                canonica: if True, draws the x, y and z axis
        &#34;&#34;&#34;
        self.draw_point(location=p0,color=&#34;Blue&#34;,radius=radius,name=&#34;Punt de la recta&#34;)
        self.set_origin(p0)
        self.draw_vector(vector=v1,canonica=canonica,scale=scale,head_height=0.15,axis=20,name=&#34;Recta afí&#34;,color=&#34;Blue&#34;,positive=False)
        self.set_origin()
        self.draw_point(location=punt,color=&#34;Black&#34;,radius=radi,name=&#34;Punt inicial&#34;)
        u = punt - p0
        p1 = p0 + u.project(v1)
        size = 4 * (p1-p0).length
        if size &lt; 20:
                size = 20
        self.draw_point(location=p1,color=&#34;Red&#34;,radius=radi,name=&#34;Projecció ortogonal&#34;)
        self.draw_plane_surface(origin=p1,normal=v1,name=&#34;Pla perpendicular a la recta&#34;,sizex=size,sizey=size)
        self.draw_point(location=2*p1-punt,color=&#34;Green&#34;,radius=radi,name=&#34;Simètric&#34;)
        self.draw_line(start=punt,end=2*p1-punt,scale=0.04,color=&#34;White&#34;)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_recta_vectorial"><code class="name flex">
<span>def <span class="ident">projeccio_ortogonal_simetric_recta_vectorial</span></span>(<span>self, vector=Vector((7.0, -1.0, 12.0)), v1=Vector((3.0, -1.0, 1.0)), canonica=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the otoghonal projection and the symmetric of a vector with respecte a line</p>
<h2 id="parameters">Parameters</h2>
<p>vector: the initial vector</p>
<p>v1: generator of the line</p>
<p>canonica: if True, draws the x, y and z axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projeccio_ortogonal_simetric_recta_vectorial(self,vector=Vector([7,-1,12]),v1=Vector([3,-1,1]),canonica=True):
        &#34;&#34;&#34;
        Draws the otoghonal projection and the symmetric of a vector with respecte a line
        Parameters:
                vector: the initial vector

                v1: generator of the line

                canonica: if True, draws the x, y and z axis
        &#34;&#34;&#34;
        if not isinstance(vector,Vector):
                vector = Vector(vector)
        if not isinstance(v1,Vector):
                v1 = Vector(v1)
        if canonica:
                self.base_canonica()
        self.draw_vector(v1,axis=20,positive=False,color=&#34;Blue&#34;,scale=0.066)
        self.draw_vector(vector)
        vp = vector.project(v1)
        self.draw_vector(vp,color=&#34;Red&#34;)
        self.set_origin(vp)
        self.draw_vector(vector - vp,scale=0.025,color=&#34;White&#34;)
        self.set_origin()
        self.draw_vector(2 * vp - vector,color=&#34;Green&#34;)
        self.draw_line(start=2 * vp - vector,end=vp,scale=0.04,color=&#34;White&#34;)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.punt_referencia_canonica"><code class="name flex">
<span>def <span class="ident">punt_referencia_canonica</span></span>(<span>self, punt=Vector((-4.0, 7.0, 6.0)), radius=0.1, length=12, name='Punt p', coordenades=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a point expressed in the canonical reference</p>
<h2 id="parameters">Parameters</h2>
<p>punt: the point to draw</p>
<p>length: length of the axis</p>
<p>name: name of the point</p>
<p>components: if True draws lines representing the coordinates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def punt_referencia_canonica(self,punt=Vector([-4,7,6]),radius=0.1,length=12,name=&#34;Punt p&#34;,coordenades=True):
        &#34;&#34;&#34;
        Draws a point expressed in the canonical reference
        Parameters:
           punt: the point to draw

           length: length of the axis

           name: name of the point

           components: if True draws lines representing the coordinates
        &#34;&#34;&#34;
        self.base_canonica(length=length)
        if not isinstance(punt,Vector):
                punt = Vector(punt)
        self.draw_point(location=punt,color=&#34;Black&#34;,radius=radius,name=name)
        if coordenades:
                self.draw_components(punt,name=&#34;Coordenades en referència canònica&#34;)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.punt_referencia_no_canonica"><code class="name flex">
<span>def <span class="ident">punt_referencia_no_canonica</span></span>(<span>self, punt=Vector((5.0, 6.0, -5.0)), origin=Vector((-2.0, 3.0, 3.0)), u1=Vector((-0.3333333432674408, -0.6666666865348816, 0.6666666865348816)), u2=Vector((0.6666666865348816, 0.3333333432674408, 0.6666666865348816)), u3=Vector((-0.6666666865348816, 0.6666666865348816, 0.3333333432674408)), length=12, scale=0.04, radius=0.1, name='Punt p')</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a point expressed in the reference {o,u1,u2,u3} with origin in the point origin and sets the default
origin and default base to them</p>
<h2 id="parameters">Parameters</h2>
<p>punt: point to draw</p>
<p>origin: origin of the reference</p>
<p>u1, u2, u3: vectors of the base</p>
<p>length: length of the axis</p>
<p>scale: scale of the axis</p>
<p>name: name of the reference</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def punt_referencia_no_canonica(self,punt=Vector([5,6,-5]),origin=Vector([-2,3,3]),u1=1/3*Vector([-1,-2,2]),u2=1/3*Vector([2,1,2]),u3=1/3*Vector([-2,2,1]),length=12,scale=0.04,radius=0.1,name=&#34;Punt p&#34;):
        &#34;&#34;&#34;
        Draws a point expressed in the reference {o,u1,u2,u3} with origin in the point origin and sets the default
        origin and default base to them
        Parameters:
                punt: point to draw

                origin: origin of the reference

                u1, u2, u3: vectors of the base

                length: length of the axis

                scale: scale of the axis

                name: name of the reference
        &#34;&#34;&#34;
        self.referencia_no_canonica(origin=origin,u1=u1,u2=u2,u3=u3,length=length,scale=scale,name=&#34;Referència R&#39;&#34;)
        if not isinstance(punt,Vector):
                punt = Vector(punt)
        self.draw_point(location=punt,color=&#34;Black&#34;,radius=radius,name=name)
        self.draw_components(punt,scale=0.015,name=&#34;Coordenades en referència R&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.referencia_canonica"><code class="name flex">
<span>def <span class="ident">referencia_canonica</span></span>(<span>self, origin=Vector((0.0, 0.0, 0.0)), length=15, scale=0.04, zaxis=True, name='Referència canònica')</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the canonical reference</p>
<h2 id="parameters">Parameters</h2>
<p>origin: point where to represent the base</p>
<p>length: length of the axis</p>
<p>scale: scale of the cylinder</p>
<p>zaxis: if False the z axis is not drawn</p>
<p>name: name of the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def referencia_canonica(self,origin=Vector([0,0,0]),length=15,scale=0.04,zaxis=True,name=&#34;Referència canònica&#34;):
        &#34;&#34;&#34;
        Draws the canonical reference
        Parameters:
           origin: point where to represent the base

           length: length of the axis

           scale: scale of the cylinder

           zaxis: if False the z axis is not drawn

           name: name of the object
        &#34;&#34;&#34;
        if not isinstance(origin,Vector):
                origin = Vector(origin)
        self.set_origin(origin)
        self.draw_base_axis(axis=length,positive=False,scale=scale,zaxis=zaxis,name=name)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.referencia_no_canonica"><code class="name flex">
<span>def <span class="ident">referencia_no_canonica</span></span>(<span>self, origin=Vector((0.0, 0.0, 0.0)), u1=Vector((1.0, -1.0, 0.0)), u2=Vector((-0.5, 1.0, 0.5)), u3=Vector((-1.0, 0.0, 1.0)), length=12, scale=0.04, name="Referència R'")</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the reference {o;u1,u2,u3} with origin in the point origin and sets the default
origin and default base to them</p>
<h2 id="parameters">Parameters</h2>
<p>origin: origin of the reference</p>
<p>u1, u2, u3: vectors of the base</p>
<p>length: length of the axis</p>
<p>scale: scale of the axis</p>
<p>name: name of the reference</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def referencia_no_canonica(self,origin=Vector([0,0,0]),u1=Vector([1,-1,0]),u2=1/2*Vector([-1,2,1]),u3=Vector([-1,0,1]),length=12,scale=0.04,name=&#34;Referència R&#39;&#34;):
        &#34;&#34;&#34;
        Draws the reference {o;u1,u2,u3} with origin in the point origin and sets the default
        origin and default base to them
        Parameters:
                origin: origin of the reference

                u1, u2, u3: vectors of the base

                length: length of the axis

                scale: scale of the axis

                name: name of the reference
        &#34;&#34;&#34;
        if not isinstance(origin,Vector):
                origin = Vector(origin)
        if not isinstance(u1,Vector):
                u1 = Vector(u1)
        if not isinstance(u2,Vector):
                u2 = Vector(u2)
        if not isinstance(u3,Vector):
                u3 = Vector(u3)
        self.set_origin(origin)
        self.set_base([u1,u2,u3])
        self.draw_base_axis(axis=length,positive=False,scale=scale,name=name)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets origin, base, rotation, frames and colors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
        &#34;&#34;&#34;
        Resets origin, base, rotation, frames and colors
        &#34;&#34;&#34;
        self.reset_origin()
        self.reset_base()
        self.reset_rotation()
        self.reset_frames()
        self.reset_colors()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.reset_base"><code class="name flex">
<span>def <span class="ident">reset_base</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets self.base to the canonical basis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_base(self):
        &#34;&#34;&#34;
        Sets self.base to the canonical basis
        &#34;&#34;&#34;
        self.base = [[1,0,0],[0,1,0],[0,0,1]]</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.reset_colors"><code class="name flex">
<span>def <span class="ident">reset_colors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set self.colors to default colors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_colors(self):
        &#34;&#34;&#34;
        Set self.colors to default colors
        &#34;&#34;&#34;
        self.colors= Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.reset_frames"><code class="name flex">
<span>def <span class="ident">reset_frames</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set self.frame to 0</p>
<h2 id="parameters">Parameters</h2>
<p>name: name of a color</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_frames(self):
        &#34;&#34;&#34;
        Set self.frame to 0
        Parameters:
           name: name of a color
        &#34;&#34;&#34;
        self.frame = 0</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.reset_origin"><code class="name flex">
<span>def <span class="ident">reset_origin</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the origin to the point (0,0,0)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_origin(self):
        &#34;&#34;&#34;
        Sets the origin to the point (0,0,0)
        &#34;&#34;&#34;
        self.origin = Vector([0,0,0])</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.reset_rotation"><code class="name flex">
<span>def <span class="ident">reset_rotation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the rotation to identity, i.e., rotation of 0 degrees around the
vector (1,0,0)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_rotation(self):
        &#34;&#34;&#34;
        Sets the rotation to identity, i.e., rotation of 0 degrees around the
        vector (1,0,0)
        &#34;&#34;&#34;
        self.set_rotation()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.revolution_surface"><code class="name flex">
<span>def <span class="ident">revolution_surface</span></span>(<span>self, fun=None, tmin=0.0, tmax=1.0, o=Vector((0.0, 0.0, 0.0)), u1=Vector((1.0, 0.0, 0.0)), u2=Vector((0.0, 1.0, 0.0)), pmax=0, steps=256, thickness=0.025, axis='Z', name='Revolution surface', color='AzureBlueDark')</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a revolution surface from a curve in the reference R'</p>
<h2 id="parameters">Parameters</h2>
<p>fun: parametric equacion of the curve</p>
<p>steps: number of steps</p>
<p>axis: axis of revolution. It must be 'X', 'Y' or 'Z'</p>
<p>o: origin of the reference R'</p>
<p>u1, u2: vectors to construct the basis {v1, v2, v3}</p>
<p>pmax: the principal axis are drawn between -pmax and pmax</p>
<p>color: color of the surface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def revolution_surface(self,fun=None,tmin=0.0,tmax=1.0,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),pmax=0,steps=256,thickness=0.025,axis=&#39;Z&#39;,name=&#34;Revolution surface&#34;,color=&#34;AzureBlueDark&#34;):
        &#34;&#34;&#34;
        Draws a revolution surface from a curve in the reference R&#39;
        Parameters:
           fun: parametric equacion of the curve

           steps: number of steps

           axis: axis of revolution. It must be &#39;X&#39;, &#39;Y&#39; or &#39;Z&#39;

           o: origin of the reference R&#39;

           u1, u2: vectors to construct the basis {v1, v2, v3}

           pmax: the principal axis are drawn between -pmax and pmax

           color: color of the surface
        &#34;&#34;&#34;
        if fun is None:
                return None
        q = self.vectors_to_quaternion(u1,u2)
        obj = self.simple_curve(fun,tmin=tmin,tmax=tmax,steps=steps,name=name)
        m = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        m.levels = 4
        m.subdivision_type = &#39;SIMPLE&#39;
        m = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
        m.thickness = thickness
        m.offset = 1.0
        m = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
        m.angle = 2*math.pi
        m.steps = steps
        m.axis =  axis
        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
        bpy.context.scene.collection.objects.link(obj)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if self.rotation is not None:
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        if pmax &gt; 0.0:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència R&#39;&#34;)
        bpy.ops.object.shade_smooth()
        obj.location = o
        obj.select_set(False)
        bpy.context.view_layer.objects.active = None</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rotacio_ortoedre"><code class="name flex">
<span>def <span class="ident">rotacio_ortoedre</span></span>(<span>self, centre=Vector((0.0, 0.0, 0.0)), costats=Vector((8.0, 5.0, 4.0)), eix='Z', opacity=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an animation of an orthohedron rotating around a vectorial line</p>
<h2 id="parameters">Parameters</h2>
<p>centre: center of the orthohedron</p>
<p>costats: half sides of the orthohedron</p>
<p>eix: axis of rotation</p>
<p>opacity: opacity of the orthohedron</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotacio_ortoedre(self,centre=Vector([0,0,0]),costats=Vector([8,5,4]),eix=&#39;Z&#39;,opacity=1):
        &#34;&#34;&#34;
        Draws an animation of an orthohedron rotating around a vectorial line
        Parameters:
                centre: center of the orthohedron

                costats: half sides of the orthohedron

                eix: axis of rotation

                opacity: opacity of the orthohedron
        &#34;&#34;&#34;
        self.base_canonica()
        if not isinstance(centre,Vector):
                centre = Vector(centre)
        if not isinstance(costats,Vector):
                costats = Vector(costats)
        ortoedre = self.draw_cube(origin=centre,scale=costats,color=&#34;AzureBlueDark&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Ortoedre&#34;)
        self.rotate_object(ortoedre,axis=eix,draw=False)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rotacio_ortoedre_angles_euler"><code class="name flex">
<span>def <span class="ident">rotacio_ortoedre_angles_euler</span></span>(<span>self, centre=Vector((0.0, 0.0, 0.0)), costats=Vector((8.0, 5.0, 4.0)), psi=90, theta=60, phi=45, radians=False, opacity=1, eixos='zxz')</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an animation of an orthohedron rotating given the Euler's angles</p>
<h2 id="parameters">Parameters</h2>
<p>centre: center of the orthohedron</p>
<p>costats: half sides of the orthohedron</p>
<p>psi, theta, phi: Euler's angles</p>
<p>radians: if True the Euler's angles must in radians. If False in degrees</p>
<p>opacity: opacity of the orthohedron</p>
<p>eixos: axis of the three rotations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotacio_ortoedre_angles_euler(self,centre=Vector([0,0,0]),costats=Vector([8,5,4]),psi=90,theta=60,phi=45,radians=False,opacity=1,eixos=&#39;zxz&#39;):
        &#34;&#34;&#34;
        Draws an animation of an orthohedron rotating given the Euler&#39;s angles
        Parameters:
                centre: center of the orthohedron

                costats: half sides of the orthohedron

                psi, theta, phi: Euler&#39;s angles

                radians: if True the Euler&#39;s angles must in radians. If False in degrees

                opacity: opacity of the orthohedron

                eixos: axis of the three rotations
        &#34;&#34;&#34;
        if not isinstance(centre,Vector):
                centre = Vector(centre)
        if not isinstance(costats,Vector):
                costats = Vector(costats)
        ortoedre = self.draw_cube(origin=centre,scale=costats,color=&#34;AzureBlueDark&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Ortoedre&#34;)
        self.rotate_euler(ortoedre,psi,theta,phi,radians=radians,axis=eixos)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rotacio_ortoedre_voltant_vector"><code class="name flex">
<span>def <span class="ident">rotacio_ortoedre_voltant_vector</span></span>(<span>self, centre=Vector((0.0, 0.0, 0.0)), costats=Vector((8.0, 5.0, 4.0)), angle=80, radians=False, vector=Vector((1.0, -2.0, 1.0)), opacity=0.7, euler=None, reverse=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an animation of a vector rotating around a vectorial line</p>
<h2 id="parameters">Parameters</h2>
<p>centre: center of the orthohedron</p>
<p>costats: half sides of the orthohedron</p>
<p>angle: angle of rotation</p>
<p>radians: if True the Euler's angles must in radians. If False in degrees</p>
<p>vector: generator of the vectorial line</p>
<p>opacity: opacity of the orthohedron</p>
<p>euler: None or the value of the three Euler's axis</p>
<p>reverse: if True, shows the rotation with Euler's angles in reverse order</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotacio_ortoedre_voltant_vector(self,centre=Vector([0,0,0]),costats=Vector([8,5,4]),angle=80,radians=False,vector=Vector([1,-2,1]),opacity=0.7,euler=None,reverse=False):
        &#34;&#34;&#34;
        Draws an animation of a vector rotating around a vectorial line
        Parameters:
                centre: center of the orthohedron

                costats: half sides of the orthohedron

                angle: angle of rotation

                radians: if True the Euler&#39;s angles must in radians. If False in degrees

                vector: generator of the vectorial line

                opacity: opacity of the orthohedron

                euler: None or the value of the three Euler&#39;s axis

                reverse: if True, shows the rotation with Euler&#39;s angles in reverse order
        &#34;&#34;&#34;
        if not isinstance(centre,Vector):
                centre = Vector(centre)
        if not isinstance(costats,Vector):
                costats = Vector(costats)
        if not isinstance(vector,Vector):
                vector = Vector(vector)
        ortoedre = self.draw_cube(origin=centre,scale=costats,color=&#34;AzureBlueDark&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Primer ortoedre&#34;)
        if euler is not None:
                ortoedre2 = self.draw_cube(origin=centre,scale=costats,color=&#34;Green&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Segon ortoedre&#34;)
        self.rotate_object_by_axis_angle(obj=ortoedre,axis=vector,angle=angle,frames=3)
        if euler is not None:
                R = Rotation(angle=angle,vector=vector)
                psi, theta, phi = R.to_euler_angles(axis=euler)
                self.rotate_euler(ortoedre2,psi=psi,theta=theta,phi=phi,axis=euler,canonica=False,reverse=reverse)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rotacio_vector"><code class="name flex">
<span>def <span class="ident">rotacio_vector</span></span>(<span>self, vector=Vector((6.0, 8.0, 5.0)), eix=Vector((1.0, 1.0, 1.0)))</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an animation of a vector rotating around a vectorial line</p>
<h2 id="parameters">Parameters</h2>
<p>vector: vector to rotate</p>
<p>eix: axis of rotation, given by a vector or by X, Y or Z</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotacio_vector(self,vector=Vector([6,8,5]),eix=Vector([1,1,1])):
        &#34;&#34;&#34;
        Draws an animation of a vector rotating around a vectorial line
        Parameters:
                vector: vector to rotate

                eix: axis of rotation, given by a vector or by X, Y or Z
        &#34;&#34;&#34;
        self.base_canonica(length=vector.length + 2)
        self.rotate_vector(vector,eix)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rotate_euler"><code class="name flex">
<span>def <span class="ident">rotate_euler</span></span>(<span>self, obj=None, psi=0.0, theta=0.0, phi=0.0, frames=3, axis='ZXZ', amax=15, scaleaxis=0.075, reverse=False, local=False, radians=False, canonica=True, positive=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotates an object by the Euler angles psi, theta and phi</p>
<h2 id="parameters">Parameters</h2>
<p>object: the object</p>
<p>psi, theta, phi: the Euler angles expressed in degrees</p>
<p>axis: it must be 'XYZ', 'XZY', 'YXZ', 'YZX', 'ZXY', 'ZYX', 'XYX', 'XZX', 'YXY', 'YZY', 'ZXZ' or 'ZYZ'</p>
<p>amax: axis valur for draw_base_axis</p>
<p>scaleaxis: scale value for draw_base_axis</p>
<p>local: if True the center of rotation is the location of the object</p>
<p>radians: if True, psi, theta and phi must be in radians</p>
<p>positive: if False and psi, theta or phi are greather than 180 degrees, they rae converted
to negative angles</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_euler(self,obj=None,psi=0.0,theta=0.0,phi=0.0,frames=3,axis=&#39;ZXZ&#39;,amax=15,scaleaxis=0.075,reverse=False,local=False,radians=False,canonica=True,positive=False):
        &#34;&#34;&#34;
        Rotates an object by the Euler angles psi, theta and phi
        Parameters:
           object: the object

           psi, theta, phi: the Euler angles expressed in degrees

           axis: it must be &#39;XYZ&#39;, &#39;XZY&#39;, &#39;YXZ&#39;, &#39;YZX&#39;, &#39;ZXY&#39;, &#39;ZYX&#39;, &#39;XYX&#39;, &#39;XZX&#39;, &#39;YXY&#39;, &#39;YZY&#39;, &#39;ZXZ&#39; or &#39;ZYZ&#39;

           amax: axis valur for draw_base_axis

           scaleaxis: scale value for draw_base_axis

           local: if True the center of rotation is the location of the object

           radians: if True, psi, theta and phi must be in radians

           positive: if False and psi, theta or phi are greather than 180 degrees, they rae converted
                     to negative angles
        &#34;&#34;&#34;
        def vector_from_axis(axis):
                if axis == &#39;X&#39;:
                        return Vector([1,0,0])
                if axis == &#39;Y&#39;:
                        return Vector([0,1,0])
                if axis == &#39;Z&#39;:
                        return Vector([0,0,1])
                return None

        if obj is None or axis is None:
                return None

        if not isinstance(axis,str):
                return None

        axis = axis.upper()
        if axis not in (&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,&#39;XYX&#39;,&#39;XZX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;):
                return None

        u1 = vector_from_axis(axis[0])
        u2 = vector_from_axis(axis[1])
        u3 = vector_from_axis(axis[2])

        if radians:
                psi *= 180/math.pi
                theta *= 180/math.pi
                phi *= 180/math.pi
        if positive:
                if psi &lt; 0.0:
                        psi += 360
                if theta &lt; 0.0:
                        theta += 360
                if phi &lt; 0.0:
                        phi += 360
        else:
                if psi &gt; 180.0:
                        psi -= 360
                if theta &gt; 180.0:
                        theta -= 360
                if phi &gt; 180.0:
                        phi -= 360

        if reverse:
                self.set_colors([&#34;OrangeRedDark&#34;,&#34;Yellow&#34;,&#34;Magenta&#34;])
                axis = self.draw_base_axis(axis=amax,scale=scaleaxis,positive=False,name=&#34;Eixos transformats&#34;)
                obj = self.join([obj,axis])
                u1, u2, u3 = u3, u2, u1
                psi, theta, phi = phi, theta, psi
                s = Rotation(psi,u1)
                u2 = s.apply(u2)
                u3 = s.apply(u3)
                s = Rotation(theta,u2)
                u3 = s.apply(u3)
        elif canonica:
                self.draw_base_axis(axis=amax,scale=scaleaxis,positive=False,name=&#34;Base canònica&#34;)

        bpy.context.scene.frame_set(self.frame)
        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        if not local:
                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
        fn = frames + self.frame
        if psi &gt; 0:
                num = int(psi)
        elif psi &lt; 0:
                num = int(-psi)
        alfa = psi / num
        r = Rotation(alfa,u1)
        for i in range(num):
                bpy.context.scene.frame_set(fn)
                obj.rotation_quaternion.rotate(r.quaternion)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if not local:
                        w = obj.location
                        w.rotate(r.quaternion)
                        obj.location = w
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn += frames

        if theta &gt; 0:
                num = int(theta)
        elif theta &lt; 0:
                num = int(-theta)
        alfa = theta / num
        r = Rotation(alfa,u2)
        for i in range(num):
                bpy.context.scene.frame_set(fn)
                obj.rotation_quaternion.rotate(r.quaternion)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if not local:
                        w = obj.location
                        w.rotate(r.quaternion)
                        obj.location = w
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn += frames

        if phi &gt; 0:
                num = int(phi)
        elif phi &lt; 0:
                num = int(-phi)
        alfa = phi / num
        r = Rotation(alfa,u3)
        for i in range(num):
                bpy.context.scene.frame_set(fn)
                obj.rotation_quaternion.rotate(r.quaternion)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if not local:
                        w = obj.location
                        w.rotate(r.quaternion)
                        obj.location = w
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn += frames

        self.frame = fn - frames
        bpy.context.scene.frame_end = self.frame
        bpy.context.scene.frame_set(0)
        bpy.context.view_layer.update()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rotate_object"><code class="name flex">
<span>def <span class="ident">rotate_object</span></span>(<span>self, obj=None, axis='Z', frames=1, origin=Vector((0.0, 0.0, 0.0)), localaxis=None, localangle=None, helicoidal=0.0, rounds=1, draw=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotates an object around the axis</p>
<h2 id="parameters">Parameters</h2>
<p>obj: the object</p>
<p>axis: it must be 'X', 'Y', 'Z' or a Vector</p>
<p>local: if True the center of rotation is the location of the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_object(self,obj=None,axis=&#39;Z&#39;,frames=1,origin=Vector([0,0,0]),localaxis=None,localangle=None,helicoidal=0.0,rounds=1,draw=True):
        &#34;&#34;&#34;
        Rotates an object around the axis
        Parameters:
           obj: the object

           axis: it must be &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39; or a Vector

           local: if True the center of rotation is the location of the object
        &#34;&#34;&#34;
        if obj is None:
                return None
        if not isinstance(origin,Vector):
                origin = Vector(origin)
        if isinstance(axis,str):
                axis = axis.strip().upper()
        if axis == &#39;X&#39;:
                u = Vector([1,0,0])
        elif axis == &#39;Y&#39;:
                u = Vector([0,1,0])
        elif axis == &#39;Z&#39;:
                u = Vector([0,0,1])
        elif isinstance(axis,Vector):
                u = axis
        else:
                u = Vector(axis)

        line = None
        if localaxis is not None and localangle is not None:
                old = self.origin
                self.set_origin(obj.location)
                l = obj.dimensions.length / 2
                line = self.draw_vector(localaxis,axis=l,scale=0.1,arrow=False,positive=False,color=&#34;Orange&#34;,name=&#34;Eix rotació local&#34;)
                line.select_set(True)
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CENTER_OF_MASS&#39;, center=&#39;MEDIAN&#39;)
                line.select_set(False)
                self.set_origin(old)
                lr = Rotation(localangle,localaxis)
        if draw:
                self.set_origin(origin)
                self.draw_vector(u,axis=15/u.length,positive=False,color=&#34;White&#34;)
                self.set_origin()
        r = Rotation(1/int(frames),u)
        axis, angle = r.to_axis_angle()
        t = helicoidal * axis
        bpy.context.scene.frame_set(self.frame)
        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
        fn = self.frame + 1
        for i in range(int(frames) * int(rounds) * 360):
                bpy.context.scene.frame_set(fn)
                if line is None:
                        obj.rotation_quaternion.rotate(r.quaternion)
                else:
                        obj.rotation_quaternion.rotate(lr.quaternion)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                w = obj.location - origin
                w.rotate(r.quaternion)
                obj.location = origin + w + t
                if line is not None:
                        line.location = origin + w + t
                        line.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn += 1
        self.frame = fn - frames
        bpy.context.scene.frame_end = self.frame
        bpy.context.scene.frame_set(0)
        bpy.context.view_layer.update()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rotate_object_by_axis_angle"><code class="name flex">
<span>def <span class="ident">rotate_object_by_axis_angle</span></span>(<span>self, obj=None, axis=Vector((1.0, 0.0, 0.0)), angle=90, amax=15, frames=1, scaleaxis=0.075, local=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotates an object around an angle 'angle' around the axis</p>
<h2 id="parameters">Parameters</h2>
<p>obj: the object</p>
<p>axis: any non nul Vectors</p>
<p>angle: the angle of rotation in degrees</p>
<p>frames: increment of the frame set</p>
<p>scaleaxis: scale value for draw_base_axis</p>
<p>local: if True the center of rotation is the location of the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_object_by_axis_angle(self,obj=None,axis=Vector([1,0,0]),angle=90,amax=15,frames=1,scaleaxis=0.075,local=False):
        &#34;&#34;&#34;
        Rotates an object around an angle &#39;angle&#39; around the axis
        Parameters:
           obj: the object

           axis: any non nul Vectors

           angle: the angle of rotation in degrees

           frames: increment of the frame set

           scaleaxis: scale value for draw_base_axis

           local: if True the center of rotation is the location of the object
        &#34;&#34;&#34;
        if obj is None:
                return None
        if isinstance(axis,Vector):
                u = axis
        else:
                u = Vector(axis)
        if u.length == 0.0 or angle &lt;= 1:
                return

        self.draw_base_axis(axis = amax,scale=scaleaxis,positive=False,name=&#34;Base canònica&#34;)
        self.draw_vector(u,scale=0.1,axis=amax,positive=False,color=&#34;Black&#34;,name=&#34;Eix rotació&#34;)

        num = int(angle)
        alfa = angle / num
        r = Rotation(alfa,u)
        bpy.context.scene.frame_set(self.frame)
        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        if not local:
                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
        fn = frames + self.frame

        for i in range(num):
                bpy.context.scene.frame_set(fn)
                obj.rotation_quaternion.rotate(r.quaternion)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if not local:
                        w = obj.location
                        w.rotate(r.quaternion)
                        obj.location = w
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn += frames
        self.frame = fn - frames
        bpy.context.scene.frame_end = self.frame
        bpy.context.scene.frame_set(0)
        bpy.context.view_layer.update()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rotate_vector"><code class="name flex">
<span>def <span class="ident">rotate_vector</span></span>(<span>self, vector=None, axis='Z')</span>
</code></dt>
<dd>
<div class="desc"><p>Rotates a vector around the axis</p>
<h2 id="parameters">Parameters</h2>
<p>vector: the vector</p>
<p>axis: it must be 'X', 'Y', 'Z' or a vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_vector(self,vector=None,axis=&#39;Z&#39;):
        &#34;&#34;&#34;
        Rotates a vector around the axis
        Parameters:
           vector: the vector

           axis: it must be &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39; or a vector
        &#34;&#34;&#34;
        draw = False
        if vector is None:
                return None
        if axis == &#39;X&#39;:
                u = Vector([1,0,0])
        elif axis == &#39;Y&#39;:
                u = Vector([0,1,0])
        elif axis == &#39;Z&#39;:
                u = Vector([0,0,1])
        elif isinstance(axis,Vector):
                u = axis
        else:
                u = Vector(axis)

        self.draw_vector(vector,color=&#34;Black&#34;)
        obj = self.draw_vector(vector,color=&#34;Red&#34;)
        w1 = u.orthogonal().normalized()
        vec1 = vector.project(u)
        w3 = vec1.normalized()
        w2 = w3.cross(w1)
        a = vec1.length
        b = (vector-vec1).length
        p2 = b**2/a**2
        self.rotate_object(obj,u)
        self.cone(u1=w1,u2=w2,a2=p2,b2=p2,c2=1,half=True, principal=False,canonica=False,xmax=b,color=&#34;GrayLight&#34;,opacity=0.2)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.set_base"><code class="name flex">
<span>def <span class="ident">set_base</span></span>(<span>self, base=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], orthonormal=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the self.base, i.e., the basis of the reference coordinates used to display
objects</p>
<h2 id="parameters">Parameters</h2>
<p>base: list of three vectors</p>
<p>orthonormal: if True, the Gram-Schmidt method is applied and the vectors
are normalized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_base(self,base=[[1,0,0],[0,1,0],[0,0,1]],orthonormal=False):
        &#34;&#34;&#34;
        Sets the self.base, i.e., the basis of the reference coordinates used to display
        objects
        Parameters:
           base: list of three vectors

           orthonormal: if True, the Gram-Schmidt method is applied and the vectors
           are normalized.
        &#34;&#34;&#34;
        if orthonormal:
                u1 = base[0]
                u2 = base[1]
                if isinstance(u1,Vector):
                        v1 = u1
                else:
                        v1 = Vector(u1)
                if isinstance(u2,Vector):
                        v2 = u2
                else:
                        v2 = Vector(u2)
                v2 = v2 - v2.project(v1)
                v1.normalize()
                v2.normalize()
                v3 = v1.cross(v2)
                self.base=[v1,v2,v3]
        else:
                self.base = base</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.set_colors"><code class="name flex">
<span>def <span class="ident">set_colors</span></span>(<span>self, names)</span>
</code></dt>
<dd>
<div class="desc"><p>Set self.colors to the list of colors with names 'names'</p>
<h2 id="parameters">Parameters</h2>
<p>names: list of name colors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_colors(self,names):
        &#34;&#34;&#34;
        Set self.colors to the list of colors with names &#39;names&#39;
        Parameters:
           names: list of name colors
        &#34;&#34;&#34;
        self.colors = Colors.colors(names)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.set_cursor"><code class="name flex">
<span>def <span class="ident">set_cursor</span></span>(<span>self, origin=[0, 0, 0], direction=[1, 0, 0], axis='x')</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the cursor position and direction</p>
<h2 id="parameters">Parameters</h2>
<p>origin: position of the cursor</p>
<p>direction: vector that indicates the direction of the axis 'axis'</p>
<p>axis: 'x', 'y' or 'z'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cursor(self,origin=[0,0,0],direction=[1,0,0],axis=&#39;x&#39;):
        &#34;&#34;&#34;
        Sets the cursor position and direction
        Parameters:
          origin: position of the cursor

          direction: vector that indicates the direction of the axis &#39;axis&#39;

          axis: &#39;x&#39;, &#39;y&#39; or &#39;z&#39;
        &#34;&#34;&#34;
        axis = axis.lower()
        if axis not in [&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]:
                return
        eixos = {&#39;x&#39; : Vector([1,0,0]),
                         &#39;y&#39; : Vector([0,1,0]),
                         &#39;z&#39; : Vector([0,0,1])
        }
        if isinstance(direction,Vector):
                d = direction
        else:
                d = Vector(direction)
        x = eixos[axis]
        quaternion = x.rotation_difference(d)
        self.scene.cursor.location = origin
        self.scene.cursor.rotation_mode = &#39;QUATERNION&#39;
        self.scene.cursor.rotation_quaternion = quaternion</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.set_cursor_rotation"><code class="name flex">
<span>def <span class="ident">set_cursor_rotation</span></span>(<span>self, origin=[0, 0, 0], rotation=Matrix(((1.0, 0.0, 0.0),
(0.0, 1.0, 0.0),
(0.0, 0.0, 1.0))))</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the rotation of the cursor</p>
<h2 id="parameters">Parameters</h2>
<p>origin: position of the cursor</p>
<p>rotation: matrix of a rotation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cursor_rotation(self,origin=[0,0,0],rotation=Matrix.Identity(3)):
        &#34;&#34;&#34;
        Sets the rotation of the cursor
        Parameters:
           origin: position of the cursor

           rotation: matrix of a rotation
        &#34;&#34;&#34;
        m = rotation.copy()
        det = m.determinant()
        if abs(- det - 1.0) &lt; 0.1:
                m[2] = - m[2]
        quaternion = m.to_quaternion()
        self.scene.cursor.location = origin
        self.scene.cursor.rotation_mode = &#39;QUATERNION&#39;
        self.scene.cursor.rotation_quaternion = quaternion.conjugated()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.set_default_color"><code class="name flex">
<span>def <span class="ident">set_default_color</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Set self.defaultcolor to the color with name 'name'</p>
<h2 id="parameters">Parameters</h2>
<p>name: name of a color</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_default_color(self,name):
        &#34;&#34;&#34;
        Set self.defaultcolor to the color with name &#39;name&#39;
        Parameters:
           name: name of a color
        &#34;&#34;&#34;
        self.defaultcolor = name</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.set_origin"><code class="name flex">
<span>def <span class="ident">set_origin</span></span>(<span>self, vector=[0, 0, 0])</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the origin of the reference coordinates used to display objects.</p>
<h2 id="parameters">Parameters</h2>
<p>vector: origin's position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_origin(self,vector=[0,0,0]):
        &#34;&#34;&#34;
        Sets the origin of the reference coordinates used to display objects.
        Parameters:
           vector: origin&#39;s position
        &#34;&#34;&#34;
        if isinstance(vector,Vector):
                v1 = vector.copy()
        else:
                v1 = Vector(vector)
        self.origin = v1</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.set_rotation"><code class="name flex">
<span>def <span class="ident">set_rotation</span></span>(<span>self, angle=None, vector=None, quaternion=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets self.rotation to the rotation defined by an angle and an axis or
by a quaternion.</p>
<h2 id="parameters">Parameters</h2>
<p>angle: angle of rotation in degrees</p>
<p>vector: axis of rotation</p>
<p>quaternion: quaternion that defines a rotation</p>
<p>The angle and vector takes precedence over the quaternion</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_rotation(self,angle=None,vector=None,quaternion=None):
        &#34;&#34;&#34;
        Sets self.rotation to the rotation defined by an angle and an axis or
        by a quaternion.
        Parameters:
           angle: angle of rotation in degrees

           vector: axis of rotation

           quaternion: quaternion that defines a rotation

        The angle and vector takes precedence over the quaternion
        &#34;&#34;&#34;
        if angle is not None:
                self.rotation = Rotation(angle,vector)
        elif quaternion is not None:
                self.rotation = Rotation(quaternion=quaternion)
        else:
                self.rotation = Rotation(0,[1,0,0])</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.simple_curve"><code class="name flex">
<span>def <span class="ident">simple_curve</span></span>(<span>self, f=None, tmin=0.0, tmax=1.0, steps=25, name='Simple curve', symmetry=None, draw=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a curve defined by the parametrization f</p>
<h2 id="parameters">Parameters</h2>
<p>f: Parametrization of the curve</p>
<p>tmin: minimum value of the parameter</p>
<p>tmax: maximum value of the parameter</p>
<p>steps: number of steps</p>
<p>name: name of the curve</p>
<p>symmetry: None or a value in the list ('XY','XZ','YZ','X','Y','Z','O'). Symmetry of the curve</p>
<p>draw: if True, the curve is drawn</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simple_curve(self,f=None,tmin=0.0,tmax=1.0,steps=25,name=&#34;Simple curve&#34;,symmetry=None,draw=False):
        &#34;&#34;&#34;
        Return a curve defined by the parametrization f
        Parameters:
           f: Parametrization of the curve

           tmin: minimum value of the parameter

           tmax: maximum value of the parameter

           steps: number of steps

           name: name of the curve

           symmetry: None or a value in the list (&#39;XY&#39;,&#39;XZ&#39;,&#39;YZ&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;,&#39;O&#39;). Symmetry of the curve

           draw: if True, the curve is drawn
        &#34;&#34;&#34;
        if f is None:
                return None

        delta = (tmax - tmin)/steps
        t = tmin
        bm = bmesh.new()
        verts = []
        verts2 = []

        for k in range(steps + 1):
                p = f(t)
                q = None
                verts.append(bm.verts.new(p))
                if symmetry == &#39;XY&#39;:
                        q = (p[0],p[1],-p[2])
                elif symmetry == &#39;XZ&#39;:
                        q = (p[0],-p[1],p[2])
                elif symmetry == &#39;YZ&#39;:
                        q = (-p[0],p[1],p[2])
                elif symmetry == &#39;X&#39;:
                        q = (p[0],-p[1],-p[2])
                elif symmetry == &#39;Y&#39;:
                        q = (-p[0],p[1],-p[2])
                elif symmetry == &#39;Z&#39;:
                        q = (-p[0],-p[1],p[2])
                elif symmetry == &#39;O&#39;:
                        q = (-p[0],-p[1],-p[2])

                if q is not None:
                        verts2.append(bm.verts.new(q))
                t += delta
                if t &gt; tmax:
                        t = tmax

        for i in range(len(verts) - 1):
                bm.edges.new([verts[i], verts[i+1]])
                if len(verts2) &gt; 0:
                        bm.edges.new([verts2[i], verts2[i+1]])

        me = bpy.data.meshes.new(&#39;placeholder_mesh&#39;)
        obj = bpy.data.objects.new(name,me)
        bm.to_mesh(me)
        bm.free()

        if draw:
                self.scene.collection.objects.link(obj)
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.sphere"><code class="name flex">
<span>def <span class="ident">sphere</span></span>(<span>self, o=[0, 0, 0], r2=1, principal=True, canonica=True, color='AzureBlueDark', name='Sphere', cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a sphere of center 'o' and radius squared equal to 'r2'</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the spherecmax=15</p>
<p>r2: radius of the sphere squared</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the sphere</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the sphere</p>
<p>opacity: opacity of the sphere</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sphere(self,o=[0,0,0],r2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Sphere&#34;,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws a sphere of center &#39;o&#39; and radius squared equal to &#39;r2&#39;
        Parameters:
           o: center of the spherecmax=15

           r2: radius of the sphere squared

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the sphere

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the sphere

           opacity: opacity of the sphere
        &#34;&#34;&#34;
        u1 = Vector([1,0,0])
        u2 = Vector([0,1,0])
        return self.ellipsoid(o=o,u1=u1,u2=u2,a2=r2,b2=r2,c2=r2,principal=principal,canonica=canonica,color=color,name=name,cmax=cmax,pmax=pmax,thickness=thickness,opacity=opacity)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.superficie_revolucio_parabola"><code class="name flex">
<span>def <span class="ident">superficie_revolucio_parabola</span></span>(<span>self, a=0.2, vertex=Vector((0.0, 0.0, 0.0)), pmax=8, pla='XZ', punt=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an animation of a revolution surface from a paràbola</p>
<h2 id="parameters">Parameters</h2>
<p>a: the paràbola is of the form y = a*x^2</p>
<p>vertex: vertex of the parabola</p>
<p>pmax: maximum value of the independent variable</p>
<p>pla: a value from the list ('XY','YX','XZ','ZX','YZ','ZY') representing
the variables for the equation
'XY' y = a<em>x^2 and rotaqtion around the X axis
'YX' x = a</em>y^2 and rotaqtion around the Y axis
'XZ' z = a<em>x^2 and rotaqtion around the X axis
'ZX' x = a</em>x^2 and rotaqtion around the Z axis
'YZ' z = a<em>y^2 and rotaqtion around the Y axis
'ZY' y = a</em>z^2 and rotaqtion around the Z axis</p>
<p>punt: punt: if it's a float value, draws a moving poing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def superficie_revolucio_parabola(self,a=0.2,vertex=Vector([0,0,0]),pmax=8,pla=&#39;XZ&#39;,punt=None):
        &#34;&#34;&#34;
        Draws an animation of a revolution surface from a paràbola
        Parameters:
                a: the paràbola is of the form y = a*x^2

                vertex: vertex of the parabola

                pmax: maximum value of the independent variable

                pla: a value from the list (&#39;XY&#39;,&#39;YX&#39;,&#39;XZ&#39;,&#39;ZX&#39;,&#39;YZ&#39;,&#39;ZY&#39;) representing
                     the variables for the equation
                         &#39;XY&#39; y = a*x^2 and rotaqtion around the X axis
                         &#39;YX&#39; x = a*y^2 and rotaqtion around the Y axis
                         &#39;XZ&#39; z = a*x^2 and rotaqtion around the X axis
                         &#39;ZX&#39; x = a*x^2 and rotaqtion around the Z axis
                         &#39;YZ&#39; z = a*y^2 and rotaqtion around the Y axis
                         &#39;ZY&#39; y = a*z^2 and rotaqtion around the Z axis

                punt: punt: if it&#39;s a float value, draws a moving poing
        &#34;&#34;&#34;
        self.base_canonica()
        if not isinstance(vertex,Vector):
                vertex = Vector(vertex)
        def F(t):
                if pla.upper() == &#39;XZ&#39;:
                        return (vertex + Vector([t,0,a*t**2]))
                if pla.upper() == &#39;XY&#39;:
                        return (vertex + Vector([t,a*t**2,0]))
                if pla.upper() == &#39;ZX&#39;:
                        return (vertex + Vector([a*t**2,0,t]))
                if pla.upper() == &#39;ZY&#39;:
                        return (vertex + Vector([0,a*t**2,t]))
                if pla.upper() == &#39;YZ&#39;:
                        return (vertex + Vector([0,t,a*t**2]))
                if pla.upper() == &#39;YX&#39;:
                        return (vertex + Vector([a*t**2,t,0]))
        self.animate_revolution_surface(F,tmin=-pmax,tmax=pmax,steps=128,axis=pla[0],point=punt)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.tor"><code class="name flex">
<span>def <span class="ident">tor</span></span>(<span>self, centre=Vector((8.0, 0.0, 3.0)), radi=3, punt=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a torus of revolution from a circumference</p>
<h2 id="parameters">Parameters</h2>
<p>centre: center of the circumference</p>
<p>radi: radius of the circumference</p>
<p>cmax: maximum values of the x, y and z coordinates</p>
<p>punt: if it's a float value, draws a moving poing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tor(self,centre=Vector([8,0,3]),radi=3,punt=None):
        &#34;&#34;&#34;
        Draws a torus of revolution from a circumference
        Parameters:
                centre: center of the circumference

                radi: radius of the circumference

                cmax: maximum values of the x, y and z coordinates

                punt: if it&#39;s a float value, draws a moving poing
        &#34;&#34;&#34;
        self.base_canonica(length=cmax)
        if len(centre) == 2:
                centre = (centre[0],0,centre[1])
        if not isinstance(centre,Vector):
                centre = Vector(centre)
        def F(t):
                return (centre + Vector([radi*math.cos(t),0,radi*math.sin(t)]))
        self.animate_revolution_surface(F,tmin=0,tmax=2*pi,steps=128,axis=&#39;Z&#39;,point=punt)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.two_sheets_hyperboloid"><code class="name flex">
<span>def <span class="ident">two_sheets_hyperboloid</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, c2=1, principal=True, canonica=True, color='AzureBlueDark', name='TwoSheetParaboloid', xmax=None, cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a two sheets hyperboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the hyperboloid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x'^2/a^2 + y'^2/b^2 - z'^2/c^2 = -1</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the hyperboloid</p>
<p>xmax: maximum value of the x coordinate</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the hyperboloid</p>
<p>opacity: opacity of the hyperboloid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def two_sheets_hyperboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;TwoSheetParaboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws a two sheets hyperboloid
        Parameters:
           o: center of the hyperboloid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = -1

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the hyperboloid

           xmax: maximum value of the x coordinate

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the hyperboloid

           opacity: opacity of the hyperboloid
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        c = math.sqrt(c2)
        if xmax is None:
                xmax = 5.0/a + 2
        xmax /= a
        self.draw_two_sheets_hyperboloid(a=1.0,b=1.0,xmin=0.0,xmax=xmax,color=color,scale=[a,b,c],name=name,thickness=thickness,opacity=opacity)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.vector_base_canonica"><code class="name flex">
<span>def <span class="ident">vector_base_canonica</span></span>(<span>self, vector=Vector((-4.0, 7.0, 6.0)), length=12, name='Vector', components=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a vector expressed in the canonical base</p>
<h2 id="parameters">Parameters</h2>
<p>vector: the vector to draw</p>
<p>length: length of the axis</p>
<p>name: name of the vector</p>
<p>components: if True draws lines representing the components</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vector_base_canonica(self,vector=Vector([-4,7,6]),length=12,name=&#34;Vector&#34;,components=True):
        &#34;&#34;&#34;
        Draws a vector expressed in the canonical base
        Parameters:
           vector: the vector to draw

           length: length of the axis

           name: name of the vector

           components: if True draws lines representing the components
        &#34;&#34;&#34;
        self.base_canonica(length=length)
        if not isinstance(vector,Vector):
                vector = Vector(vector)
        self.draw_vector(vector,name=name)
        if components:
                self.draw_components(vector,name=&#34;Components en base canònica&#34;)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.vector_base_no_canonica"><code class="name flex">
<span>def <span class="ident">vector_base_no_canonica</span></span>(<span>self, vector=Vector((5.0, 6.0, -5.0)), origin=Vector((0.0, 0.0, 0.0)), u1=Vector((-0.3333333432674408, -0.6666666865348816, 0.6666666865348816)), u2=Vector((0.6666666865348816, 0.3333333432674408, 0.6666666865348816)), u3=Vector((-0.6666666865348816, 0.6666666865348816, 0.3333333432674408)), length=12, scale=0.04, name="Base B'")</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a vector expressed in the base {u1,u2,u3} with origin in the point origin and sets the default
origin and default base to them</p>
<h2 id="parameters">Parameters</h2>
<p>vector: vector to draw</p>
<p>origin: origin of the vector and the base</p>
<p>u1, u2, u3: vectors of the base</p>
<p>length: length of the axis</p>
<p>scale: scale of the base</p>
<p>name: name of the base</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vector_base_no_canonica(self,vector=Vector([5,6,-5]),origin=Vector([0,0,0]),u1=1/3*Vector([-1,-2,2]),u2=1/3*Vector([2,1,2]),u3=1/3*Vector([-2,2,1]),length=12,scale=0.04,name=&#34;Base B&#39;&#34;):
        &#34;&#34;&#34;
        Draws a vector expressed in the base {u1,u2,u3} with origin in the point origin and sets the default
        origin and default base to them
        Parameters:
                vector: vector to draw

                origin: origin of the vector and the base

                u1, u2, u3: vectors of the base

                length: length of the axis

                scale: scale of the base

                name: name of the base
        &#34;&#34;&#34;
        self.base_no_canonica(origin=origin,u1=u1,u2=u2,u3=u3,length=length,scale=scale,name=name)
        if not isinstance(vector,Vector):
                vector = Vector(vector)
        self.draw_vector(vector,scale=0.06,head_height=0.25)
        self.draw_components(vector,scale=0.015,name=&#34;Components en base B&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.vectors_to_quaternion"><code class="name flex">
<span>def <span class="ident">vectors_to_quaternion</span></span>(<span>self, u1=Vector((1.0, 0.0, 0.0)), u2=Vector((0.0, 1.0, 0.0)))</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the quaternion correspondint to the base {v1,v2,v3}
u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
v1 = u1
v2 = u2 - u2.project(v1)
v1.normalize()
v2.normalize()
v3 = v1.cross(v2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vectors_to_quaternion(self,u1=Vector([1,0,0]),u2=Vector([0,1,0])):
        &#34;&#34;&#34;
        Returns the quaternion correspondint to the base {v1,v2,v3}
        u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
               v1 = u1
                   v2 = u2 - u2.project(v1)
                   v1.normalize()
                   v2.normalize()
                   v3 = v1.cross(v2)
        &#34;&#34;&#34;
        if isinstance(u1,Vector):
                v1 = u1
        else:
                v1 = Vector(u1)
        if isinstance(u2,Vector):
                v2 = u2
        else:
                v2 = Vector(u2)
        v2 = v2 - v2.project(v1)
        v1.normalize()
        v2.normalize()
        v3 = v1.cross(v2)
        mat = Matrix([v1,v2,v3])
        mat.transpose()
        return mat.to_quaternion()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="LinearAlgebra.Rotation"><code class="flex name class">
<span>class <span class="ident">Rotation</span></span>
<span>(</span><span>angle=None, vector=None, axis=None, quaternion=None, radians=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class used for work with rotations. The stored value in the class is a quaternion</p>
<p>Initializes the value for a rotation</p>
<h2 id="parameters">Parameters</h2>
<p>angle: angle of rotation</p>
<p>vector: axis of rotation</p>
<p>quaternion: The quaternion itself</p>
<p>radians: must be True if the angle is entered in radians and False if the
is entered in degrees.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rotation():
        &#34;&#34;&#34;
    Class used for work with rotations. The stored value in the class is a quaternion
        &#34;&#34;&#34;
        def __init__(self,angle=None,vector=None,axis=None,quaternion=None,radians=False):
                &#34;&#34;&#34;
                Initializes the value for a rotation
                Parameters:
                   angle: angle of rotation

                   vector: axis of rotation

                   quaternion: The quaternion itself

                   radians: must be True if the angle is entered in radians and False if the
                            is entered in degrees.
                &#34;&#34;&#34;
                if vector is not None and axis is not None:
                        return
                if axis is not None:
                        if axis in (&#39;X&#39;,&#39;x&#39;):
                                vector = Vector([1,0,0])
                        elif axis in (&#39;Y&#39;,&#39;y&#39;):
                                vector = Vector([0,1,0])
                        elif axis in (&#39;Z&#39;,&#39;z&#39;):
                                vector = Vector([0,0,1])
                        else:
                                return

                if angle is not None:
                        if not radians:
                                angle = math.radians(angle)
                        if not isinstance(vector,Vector):
                                vector = Vector(vector)
                        self.quaternion = Quaternion(vector,angle)
                elif quaternion is not None:
                        self.quaternion = quaternion
                else:
                        self.quaternion = (1,0,0,0)
        #
        #
        #
        @classmethod
        def from_euler_angles(self,psi,theta,phi,axis=&#39;ZXZ&#39;,radians=False):
                &#34;&#34;&#34;
                Initializes a rotation from its Euler angles in the order ZXZ
                Parameters:
                   phi, theta, psi: Euler angles

                   axis: it must be &#39;XYZ&#39;, &#39;XZY&#39;, &#39;YXZ&#39;, &#39;YZX&#39;, &#39;ZXY&#39;, &#39;ZYX&#39;, &#39;XYX&#39;, &#39;XZX&#39;, &#39;YXY&#39;, &#39;YZY&#39;, &#39;ZXZ&#39; or &#39;ZYZ&#39;

                   radians: if radians, psi, theta and must be in radians
                &#34;&#34;&#34;
                if not radians:
                        phi = math.radians(phi)
                        theta = math.radians(theta)
                        psi = math.radians(psi)

                if axis is None:
                        return None
                if not isinstance(axis,str):
                        return None
                axis = axis.upper()
                if axis not in (&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,&#39;XYX&#39;,&#39;XZX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;):
                        return None

                r1 = Matrix.Rotation(psi,3,axis[0])
                r2 = Matrix.Rotation(theta,3,axis[1])
                r3 = Matrix.Rotation(phi,3,axis[2])
                m = r3 @ r2 @ r1
                q = m.to_quaternion()
                return self(quaternion=q)
        #
        #
        #
        def apply(self,v):
                &#34;&#34;&#34;
        Applies the rotation to an object v
                Parameters:
                   v: any object that can be transformed by a rotation
                &#34;&#34;&#34;
                return self.quaternion @ v
        #
        #
        #
        def to_axis_angle(self,radians=False):
                &#34;&#34;&#34;
                Returns the axis and angle of the rotation
                Parameters:
                   radians: if True, the angle returned is in radians, if not, is
                            returned in degrees
                &#34;&#34;&#34;
                v, alpha = self.quaternion.to_axis_angle()
                if radians:
                        return v, alpha
                return v, 180*alpha/math.pi
        #
        #
        #
        def to_euler_angles(self,axis=&#39;ZXZ&#39;,randomize=False,radians=False):
                &#34;&#34;&#34;
                Returns the Euler angles according to axis &#39;axis&#39;
                Parameters:
                   axis: it must be &#39;XYZ&#39;, &#39;XZY&#39;, &#39;YXZ&#39;, &#39;YZX&#39;, &#39;ZXY&#39;, &#39;ZYX&#39;, &#39;XYX&#39;, &#39;XZX&#39;, &#39;YXY&#39;, &#39;YZY&#39;, &#39;ZXZ&#39; or &#39;ZYZ&#39;

                   radians: if True, the angle returned is in radians, if not, is
                            returned in degrees
                &#34;&#34;&#34;
                def ACOS(x):
                        if x &gt; 1.0:
                                x = 1.0
                        if x &lt; -1.0:
                                x = -1.0
                        return math.acos(x)

                def ASIN(x):
                        if x &gt; 1.0:
                                x = 1.0
                        if x &lt; -1.0:
                                x = -1.0
                        return math.asin(x)

                axis = axis.upper()
                if axis not in (&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,&#39;XYX&#39;,&#39;XZX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;):
                        return None
                rndm = 0
                A = self.quaternion.to_matrix()
                if axis == &#39;ZXZ&#39;:
                        theta = ACOS(A[2][2])
                        if abs(A[2][2]) != 1:
                                psi = math.atan2(A[2][0],A[2][1])
                                phi = math.atan2(A[0][2],-A[1][2])
                        else:
                                rndm = A[2][2]
                                phi = 0
                                psi = math.atan2(A[1][0],A[0][0])
                if axis == &#39;XZX&#39;:
                        theta = ACOS(A[0][0])
                        if abs(A[0][0]) != 1:
                                psi = math.atan2(A[0][2],-A[0][1])
                                phi = math.atan2(A[2][0],A[1][0])
                        else:
                                rndm = A[0][0]
                                phi = 0
                                psi = math.atan2(-A[1][2],A[2][2])
                if axis == &#39;ZYZ&#39;:
                        theta = ACOS(A[2][2])
                        if abs(A[2][2]) != 1:
                                psi = math.atan2(A[2][1],-A[2][0])
                                phi = math.atan2(A[1][2],A[0][2])
                        else:
                                rndm = A[2][2]
                                phi = 0
                                psi = math.atan2(-A[0][1],A[1][1])
                if axis == &#39;YZY&#39;:
                        theta = ACOS(A[1][1])
                        if abs(A[1][1]) != 1:
                                psi = math.atan2(A[1][2],A[1][0])
                                phi = math.atan2(A[2][1],-A[0][1])
                        else:
                                rndm = A[1][1]
                                phi = 0
                                psi = math.atan2(A[0][2],A[2][2])
                if axis == &#39;XYX&#39;:
                        theta = ACOS(A[0][0])
                        if abs(A[0][0]) != 1:
                                psi = math.atan2(A[0][1],A[0][2])
                                phi = math.atan2(A[1][0],-A[2][0])
                        else:
                                rndm = A[0][0]
                                phi = 0
                                psi = math.atan2(A[2][1],A[1][1])
                if axis == &#39;YXY&#39;:
                        theta = ACOS(A[1][1])
                        if abs(A[1][1]) != 1:
                                psi = math.atan2(A[1][0],-A[1][2])
                                phi = math.atan2(A[0][1],A[2][1])
                        else:
                                rndm = A[1][1]
                                phi = 0
                                psi = math.atan2(-A[2][0],A[0][0])
                if axis == &#39;XYZ&#39;:
                        theta = ASIN(-A[2][0])
                        if abs(A[2][0]) != 1:
                                psi = math.atan2(A[2][1],A[2][2])
                                phi = math.atan2(A[1][0],A[0][0])
                        else:
                                rndm = A[2][0]
                                phi = 0
                                psi = math.atan2(-A[0][1],A[1][1])
                if axis == &#39;XZY&#39;:
                        theta = ASIN(A[1][0])
                        if abs(A[1][0]) != 1:
                                psi = math.atan2(-A[1][2],A[1][1])
                                phi = math.atan2(-A[2][0],A[0][0])
                        else:
                                rndm = A[1][0]
                                phi = 0
                                psi = math.atan2(A[0][2],A[2][2])
                if axis == &#39;YXZ&#39;:
                        theta = ASIN(A[2][1])
                        if abs(A[2][1]) != 1:
                                psi = math.atan2(-A[2][0],A[2][2])
                                phi = math.atan2(-A[0][1],A[1][1])
                        else:
                                rndm = A[2][1]
                                phi = 0
                                psi = math.atan2(A[1][0],A[0][0])
                if axis == &#39;YZX&#39;:
                        theta = ASIN(-A[0][1])
                        if abs(A[0][1]) != 1:
                                psi = math.atan2(A[0][2],A[0][0])
                                phi = math.atan2(A[2][1],A[1][1])
                        else:
                                rndm = A[0][1]
                                phi = 0
                                psi = math.atan2(-A[1][2],A[2][2])
                if axis == &#39;ZXY&#39;:
                        theta = ASIN(-A[1][2])
                        if abs(A[1][2]) != 1:
                                psi = math.atan2(A[1][0],A[1][1])
                                phi = math.atan2(A[0][2],A[2][2])
                        else:
                                rndm = A[1][2]
                                phi = 0
                                psi = math.atan2(-A[0][2],A[0][0])
                if axis == &#39;ZYX&#39;:
                        theta = ASIN(A[0][2])
                        if abs(A[0][2]) != 1:
                                psi = math.atan2(-A[0][1],A[0][0])
                                phi = math.atan2(-A[1][2],A[2][2])
                        else:
                                rndm = A[0][2]
                                phi = 0
                                psi = math.atan2(A[2][1],A[1][1])

                if psi &lt; 0:
                        psi += 2*math.pi
                if theta &lt; 0:
                        theta += 2*math.pi
                if phi &lt; 0:
                        phi += 2*math.pi

                if rndm != 0 and randomize:
                        phi = random.uniform(0.0,psi)
                        psi = rndm * (psi - phi)
                        if psi &lt; 0:
                                psi += 2*math.pi

                if not radians:
                        psi, theta, phi = 180.0/math.pi * psi, 180.0/math.pi * theta, 180.0/math.pi * phi
                        T = 359.9
                else:
                        T = 359.9 * math.pi / 180.0
                if psi &gt; T:
                        psi = 0.0
                if theta &gt; T:
                        theta = 0.0
                if phi &gt; T:
                        phi = 0.0
                return psi, theta, phi</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="LinearAlgebra.Rotation.from_euler_angles"><code class="name flex">
<span>def <span class="ident">from_euler_angles</span></span>(<span>psi, theta, phi, axis='ZXZ', radians=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a rotation from its Euler angles in the order ZXZ</p>
<h2 id="parameters">Parameters</h2>
<p>phi, theta, psi: Euler angles</p>
<p>axis: it must be 'XYZ', 'XZY', 'YXZ', 'YZX', 'ZXY', 'ZYX', 'XYX', 'XZX', 'YXY', 'YZY', 'ZXZ' or 'ZYZ'</p>
<p>radians: if radians, psi, theta and must be in radians</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_euler_angles(self,psi,theta,phi,axis=&#39;ZXZ&#39;,radians=False):
        &#34;&#34;&#34;
        Initializes a rotation from its Euler angles in the order ZXZ
        Parameters:
           phi, theta, psi: Euler angles

           axis: it must be &#39;XYZ&#39;, &#39;XZY&#39;, &#39;YXZ&#39;, &#39;YZX&#39;, &#39;ZXY&#39;, &#39;ZYX&#39;, &#39;XYX&#39;, &#39;XZX&#39;, &#39;YXY&#39;, &#39;YZY&#39;, &#39;ZXZ&#39; or &#39;ZYZ&#39;

           radians: if radians, psi, theta and must be in radians
        &#34;&#34;&#34;
        if not radians:
                phi = math.radians(phi)
                theta = math.radians(theta)
                psi = math.radians(psi)

        if axis is None:
                return None
        if not isinstance(axis,str):
                return None
        axis = axis.upper()
        if axis not in (&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,&#39;XYX&#39;,&#39;XZX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;):
                return None

        r1 = Matrix.Rotation(psi,3,axis[0])
        r2 = Matrix.Rotation(theta,3,axis[1])
        r3 = Matrix.Rotation(phi,3,axis[2])
        m = r3 @ r2 @ r1
        q = m.to_quaternion()
        return self(quaternion=q)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="LinearAlgebra.Rotation.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, v)</span>
</code></dt>
<dd>
<div class="desc"><p>Applies the rotation to an object v
Parameters:
v: any object that can be transformed by a rotation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self,v):
        &#34;&#34;&#34;
Applies the rotation to an object v
        Parameters:
           v: any object that can be transformed by a rotation
        &#34;&#34;&#34;
        return self.quaternion @ v</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.Rotation.to_axis_angle"><code class="name flex">
<span>def <span class="ident">to_axis_angle</span></span>(<span>self, radians=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the axis and angle of the rotation</p>
<h2 id="parameters">Parameters</h2>
<p>radians: if True, the angle returned is in radians, if not, is
returned in degrees</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_axis_angle(self,radians=False):
        &#34;&#34;&#34;
        Returns the axis and angle of the rotation
        Parameters:
           radians: if True, the angle returned is in radians, if not, is
                    returned in degrees
        &#34;&#34;&#34;
        v, alpha = self.quaternion.to_axis_angle()
        if radians:
                return v, alpha
        return v, 180*alpha/math.pi</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.Rotation.to_euler_angles"><code class="name flex">
<span>def <span class="ident">to_euler_angles</span></span>(<span>self, axis='ZXZ', randomize=False, radians=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the Euler angles according to axis 'axis'</p>
<h2 id="parameters">Parameters</h2>
<p>axis: it must be 'XYZ', 'XZY', 'YXZ', 'YZX', 'ZXY', 'ZYX', 'XYX', 'XZX', 'YXY', 'YZY', 'ZXZ' or 'ZYZ'</p>
<p>radians: if True, the angle returned is in radians, if not, is
returned in degrees</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_euler_angles(self,axis=&#39;ZXZ&#39;,randomize=False,radians=False):
        &#34;&#34;&#34;
        Returns the Euler angles according to axis &#39;axis&#39;
        Parameters:
           axis: it must be &#39;XYZ&#39;, &#39;XZY&#39;, &#39;YXZ&#39;, &#39;YZX&#39;, &#39;ZXY&#39;, &#39;ZYX&#39;, &#39;XYX&#39;, &#39;XZX&#39;, &#39;YXY&#39;, &#39;YZY&#39;, &#39;ZXZ&#39; or &#39;ZYZ&#39;

           radians: if True, the angle returned is in radians, if not, is
                    returned in degrees
        &#34;&#34;&#34;
        def ACOS(x):
                if x &gt; 1.0:
                        x = 1.0
                if x &lt; -1.0:
                        x = -1.0
                return math.acos(x)

        def ASIN(x):
                if x &gt; 1.0:
                        x = 1.0
                if x &lt; -1.0:
                        x = -1.0
                return math.asin(x)

        axis = axis.upper()
        if axis not in (&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,&#39;XYX&#39;,&#39;XZX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;):
                return None
        rndm = 0
        A = self.quaternion.to_matrix()
        if axis == &#39;ZXZ&#39;:
                theta = ACOS(A[2][2])
                if abs(A[2][2]) != 1:
                        psi = math.atan2(A[2][0],A[2][1])
                        phi = math.atan2(A[0][2],-A[1][2])
                else:
                        rndm = A[2][2]
                        phi = 0
                        psi = math.atan2(A[1][0],A[0][0])
        if axis == &#39;XZX&#39;:
                theta = ACOS(A[0][0])
                if abs(A[0][0]) != 1:
                        psi = math.atan2(A[0][2],-A[0][1])
                        phi = math.atan2(A[2][0],A[1][0])
                else:
                        rndm = A[0][0]
                        phi = 0
                        psi = math.atan2(-A[1][2],A[2][2])
        if axis == &#39;ZYZ&#39;:
                theta = ACOS(A[2][2])
                if abs(A[2][2]) != 1:
                        psi = math.atan2(A[2][1],-A[2][0])
                        phi = math.atan2(A[1][2],A[0][2])
                else:
                        rndm = A[2][2]
                        phi = 0
                        psi = math.atan2(-A[0][1],A[1][1])
        if axis == &#39;YZY&#39;:
                theta = ACOS(A[1][1])
                if abs(A[1][1]) != 1:
                        psi = math.atan2(A[1][2],A[1][0])
                        phi = math.atan2(A[2][1],-A[0][1])
                else:
                        rndm = A[1][1]
                        phi = 0
                        psi = math.atan2(A[0][2],A[2][2])
        if axis == &#39;XYX&#39;:
                theta = ACOS(A[0][0])
                if abs(A[0][0]) != 1:
                        psi = math.atan2(A[0][1],A[0][2])
                        phi = math.atan2(A[1][0],-A[2][0])
                else:
                        rndm = A[0][0]
                        phi = 0
                        psi = math.atan2(A[2][1],A[1][1])
        if axis == &#39;YXY&#39;:
                theta = ACOS(A[1][1])
                if abs(A[1][1]) != 1:
                        psi = math.atan2(A[1][0],-A[1][2])
                        phi = math.atan2(A[0][1],A[2][1])
                else:
                        rndm = A[1][1]
                        phi = 0
                        psi = math.atan2(-A[2][0],A[0][0])
        if axis == &#39;XYZ&#39;:
                theta = ASIN(-A[2][0])
                if abs(A[2][0]) != 1:
                        psi = math.atan2(A[2][1],A[2][2])
                        phi = math.atan2(A[1][0],A[0][0])
                else:
                        rndm = A[2][0]
                        phi = 0
                        psi = math.atan2(-A[0][1],A[1][1])
        if axis == &#39;XZY&#39;:
                theta = ASIN(A[1][0])
                if abs(A[1][0]) != 1:
                        psi = math.atan2(-A[1][2],A[1][1])
                        phi = math.atan2(-A[2][0],A[0][0])
                else:
                        rndm = A[1][0]
                        phi = 0
                        psi = math.atan2(A[0][2],A[2][2])
        if axis == &#39;YXZ&#39;:
                theta = ASIN(A[2][1])
                if abs(A[2][1]) != 1:
                        psi = math.atan2(-A[2][0],A[2][2])
                        phi = math.atan2(-A[0][1],A[1][1])
                else:
                        rndm = A[2][1]
                        phi = 0
                        psi = math.atan2(A[1][0],A[0][0])
        if axis == &#39;YZX&#39;:
                theta = ASIN(-A[0][1])
                if abs(A[0][1]) != 1:
                        psi = math.atan2(A[0][2],A[0][0])
                        phi = math.atan2(A[2][1],A[1][1])
                else:
                        rndm = A[0][1]
                        phi = 0
                        psi = math.atan2(-A[1][2],A[2][2])
        if axis == &#39;ZXY&#39;:
                theta = ASIN(-A[1][2])
                if abs(A[1][2]) != 1:
                        psi = math.atan2(A[1][0],A[1][1])
                        phi = math.atan2(A[0][2],A[2][2])
                else:
                        rndm = A[1][2]
                        phi = 0
                        psi = math.atan2(-A[0][2],A[0][0])
        if axis == &#39;ZYX&#39;:
                theta = ASIN(A[0][2])
                if abs(A[0][2]) != 1:
                        psi = math.atan2(-A[0][1],A[0][0])
                        phi = math.atan2(-A[1][2],A[2][2])
                else:
                        rndm = A[0][2]
                        phi = 0
                        psi = math.atan2(A[2][1],A[1][1])

        if psi &lt; 0:
                psi += 2*math.pi
        if theta &lt; 0:
                theta += 2*math.pi
        if phi &lt; 0:
                phi += 2*math.pi

        if rndm != 0 and randomize:
                phi = random.uniform(0.0,psi)
                psi = rndm * (psi - phi)
                if psi &lt; 0:
                        psi += 2*math.pi

        if not radians:
                psi, theta, phi = 180.0/math.pi * psi, 180.0/math.pi * theta, 180.0/math.pi * phi
                T = 359.9
        else:
                T = 359.9 * math.pi / 180.0
        if psi &gt; T:
                psi = 0.0
        if theta &gt; T:
                theta = 0.0
        if phi &gt; T:
                phi = 0.0
        return psi, theta, phi</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="LinearAlgebra.createFaces" href="#LinearAlgebra.createFaces">createFaces</a></code></li>
<li><code><a title="LinearAlgebra.create_mesh_object" href="#LinearAlgebra.create_mesh_object">create_mesh_object</a></code></li>
<li><code><a title="LinearAlgebra.draw_parametric_surface" href="#LinearAlgebra.draw_parametric_surface">draw_parametric_surface</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="LinearAlgebra.Color" href="#LinearAlgebra.Color">Color</a></code></h4>
</li>
<li>
<h4><code><a title="LinearAlgebra.Colors" href="#LinearAlgebra.Colors">Colors</a></code></h4>
<ul class="">
<li><code><a title="LinearAlgebra.Colors.color" href="#LinearAlgebra.Colors.color">color</a></code></li>
<li><code><a title="LinearAlgebra.Colors.colors" href="#LinearAlgebra.Colors.colors">colors</a></code></li>
<li><code><a title="LinearAlgebra.Colors.colorsbyname" href="#LinearAlgebra.Colors.colorsbyname">colorsbyname</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="LinearAlgebra.LinearAlgebra" href="#LinearAlgebra.LinearAlgebra">LinearAlgebra</a></code></h4>
<ul class="">
<li><code><a title="LinearAlgebra.LinearAlgebra.add_ligth" href="#LinearAlgebra.LinearAlgebra.add_ligth">add_ligth</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.add_ligths" href="#LinearAlgebra.LinearAlgebra.add_ligths">add_ligths</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.add_material" href="#LinearAlgebra.LinearAlgebra.add_material">add_material</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.animate_revolution_surface" href="#LinearAlgebra.LinearAlgebra.animate_revolution_surface">animate_revolution_surface</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.base_canonica" href="#LinearAlgebra.LinearAlgebra.base_canonica">base_canonica</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.base_cilinder" href="#LinearAlgebra.LinearAlgebra.base_cilinder">base_cilinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.base_cone" href="#LinearAlgebra.LinearAlgebra.base_cone">base_cone</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.base_is_canonica" href="#LinearAlgebra.LinearAlgebra.base_is_canonica">base_is_canonica</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.base_no_canonica" href="#LinearAlgebra.LinearAlgebra.base_no_canonica">base_no_canonica</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.canvi_base" href="#LinearAlgebra.LinearAlgebra.canvi_base">canvi_base</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.canvi_coordenades" href="#LinearAlgebra.LinearAlgebra.canvi_coordenades">canvi_coordenades</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.cilindre_elliptic" href="#LinearAlgebra.LinearAlgebra.cilindre_elliptic">cilindre_elliptic</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.cilindre_elliptic_simple" href="#LinearAlgebra.LinearAlgebra.cilindre_elliptic_simple">cilindre_elliptic_simple</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.cilindre_hiperbolic" href="#LinearAlgebra.LinearAlgebra.cilindre_hiperbolic">cilindre_hiperbolic</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.cilindre_hiperbolic_simple" href="#LinearAlgebra.LinearAlgebra.cilindre_hiperbolic_simple">cilindre_hiperbolic_simple</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.cilindre_parabolic" href="#LinearAlgebra.LinearAlgebra.cilindre_parabolic">cilindre_parabolic</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.cilindre_parabolic_simple" href="#LinearAlgebra.LinearAlgebra.cilindre_parabolic_simple">cilindre_parabolic_simple</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.clear" href="#LinearAlgebra.LinearAlgebra.clear">clear</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.comp_times_vector" href="#LinearAlgebra.LinearAlgebra.comp_times_vector">comp_times_vector</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.components_in_base" href="#LinearAlgebra.LinearAlgebra.components_in_base">components_in_base</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.con" href="#LinearAlgebra.LinearAlgebra.con">con</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.con_cilindre_elliptic" href="#LinearAlgebra.LinearAlgebra.con_cilindre_elliptic">con_cilindre_elliptic</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.con_revolucio" href="#LinearAlgebra.LinearAlgebra.con_revolucio">con_revolucio</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.cone" href="#LinearAlgebra.LinearAlgebra.cone">cone</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.coordinates_en_referencia" href="#LinearAlgebra.LinearAlgebra.coordinates_en_referencia">coordinates_en_referencia</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.curve" href="#LinearAlgebra.LinearAlgebra.curve">curve</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.delete_base_cilinder" href="#LinearAlgebra.LinearAlgebra.delete_base_cilinder">delete_base_cilinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.delete_base_cone" href="#LinearAlgebra.LinearAlgebra.delete_base_cone">delete_base_cone</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_base_axis" href="#LinearAlgebra.LinearAlgebra.draw_base_axis">draw_base_axis</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_circle" href="#LinearAlgebra.LinearAlgebra.draw_circle">draw_circle</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_components" href="#LinearAlgebra.LinearAlgebra.draw_components">draw_components</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_cone" href="#LinearAlgebra.LinearAlgebra.draw_cone">draw_cone</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_cube" href="#LinearAlgebra.LinearAlgebra.draw_cube">draw_cube</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_curve" href="#LinearAlgebra.LinearAlgebra.draw_curve">draw_curve</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_ellipse" href="#LinearAlgebra.LinearAlgebra.draw_ellipse">draw_ellipse</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_ellipsoid" href="#LinearAlgebra.LinearAlgebra.draw_ellipsoid">draw_ellipsoid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_elliptic_cylinder" href="#LinearAlgebra.LinearAlgebra.draw_elliptic_cylinder">draw_elliptic_cylinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_elliptic_paraboloid" href="#LinearAlgebra.LinearAlgebra.draw_elliptic_paraboloid">draw_elliptic_paraboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_frenet_curve" href="#LinearAlgebra.LinearAlgebra.draw_frenet_curve">draw_frenet_curve</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_function" href="#LinearAlgebra.LinearAlgebra.draw_function">draw_function</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_hyperbole" href="#LinearAlgebra.LinearAlgebra.draw_hyperbole">draw_hyperbole</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_hyperbolic_cylinder" href="#LinearAlgebra.LinearAlgebra.draw_hyperbolic_cylinder">draw_hyperbolic_cylinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_hyperbolic_paraboloid" href="#LinearAlgebra.LinearAlgebra.draw_hyperbolic_paraboloid">draw_hyperbolic_paraboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_line" href="#LinearAlgebra.LinearAlgebra.draw_line">draw_line</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_mesh" href="#LinearAlgebra.LinearAlgebra.draw_mesh">draw_mesh</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_one_sheet_hyperboloid" href="#LinearAlgebra.LinearAlgebra.draw_one_sheet_hyperboloid">draw_one_sheet_hyperboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_parabola" href="#LinearAlgebra.LinearAlgebra.draw_parabola">draw_parabola</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_parabolic_cylinder" href="#LinearAlgebra.LinearAlgebra.draw_parabolic_cylinder">draw_parabolic_cylinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_parallelepiped" href="#LinearAlgebra.LinearAlgebra.draw_parallelepiped">draw_parallelepiped</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_parallelogram" href="#LinearAlgebra.LinearAlgebra.draw_parallelogram">draw_parallelogram</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_plane" href="#LinearAlgebra.LinearAlgebra.draw_plane">draw_plane</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_plane_surface" href="#LinearAlgebra.LinearAlgebra.draw_plane_surface">draw_plane_surface</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_point" href="#LinearAlgebra.LinearAlgebra.draw_point">draw_point</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_points" href="#LinearAlgebra.LinearAlgebra.draw_points">draw_points</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_polygon" href="#LinearAlgebra.LinearAlgebra.draw_polygon">draw_polygon</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_pyramid" href="#LinearAlgebra.LinearAlgebra.draw_pyramid">draw_pyramid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_regular_polygon" href="#LinearAlgebra.LinearAlgebra.draw_regular_polygon">draw_regular_polygon</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_simple_curve" href="#LinearAlgebra.LinearAlgebra.draw_simple_curve">draw_simple_curve</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_surface" href="#LinearAlgebra.LinearAlgebra.draw_surface">draw_surface</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_tetrahedron" href="#LinearAlgebra.LinearAlgebra.draw_tetrahedron">draw_tetrahedron</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_triangle" href="#LinearAlgebra.LinearAlgebra.draw_triangle">draw_triangle</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_two_sheets_hyperboloid" href="#LinearAlgebra.LinearAlgebra.draw_two_sheets_hyperboloid">draw_two_sheets_hyperboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_vector" href="#LinearAlgebra.LinearAlgebra.draw_vector">draw_vector</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_vector_field" href="#LinearAlgebra.LinearAlgebra.draw_vector_field">draw_vector_field</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_vectors" href="#LinearAlgebra.LinearAlgebra.draw_vectors">draw_vectors</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.ellipse" href="#LinearAlgebra.LinearAlgebra.ellipse">ellipse</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.ellipsoid" href="#LinearAlgebra.LinearAlgebra.ellipsoid">ellipsoid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.ellipsoide" href="#LinearAlgebra.LinearAlgebra.ellipsoide">ellipsoide</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.ellipsoide_revolucio" href="#LinearAlgebra.LinearAlgebra.ellipsoide_revolucio">ellipsoide_revolucio</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.elliptic_cylinder" href="#LinearAlgebra.LinearAlgebra.elliptic_cylinder">elliptic_cylinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.elliptic_paraboloid" href="#LinearAlgebra.LinearAlgebra.elliptic_paraboloid">elliptic_paraboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.esfera" href="#LinearAlgebra.LinearAlgebra.esfera">esfera</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.esfera_cilindre_elliptic" href="#LinearAlgebra.LinearAlgebra.esfera_cilindre_elliptic">esfera_cilindre_elliptic</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.gir_poligon" href="#LinearAlgebra.LinearAlgebra.gir_poligon">gir_poligon</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.hiperbola" href="#LinearAlgebra.LinearAlgebra.hiperbola">hiperbola</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.hiperboloide_dues_fulles" href="#LinearAlgebra.LinearAlgebra.hiperboloide_dues_fulles">hiperboloide_dues_fulles</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.hiperboloide_dues_fulles_revolucio" href="#LinearAlgebra.LinearAlgebra.hiperboloide_dues_fulles_revolucio">hiperboloide_dues_fulles_revolucio</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.hiperboloide_una_fulla" href="#LinearAlgebra.LinearAlgebra.hiperboloide_una_fulla">hiperboloide_una_fulla</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.hiperboloide_una_fulla_revolucio" href="#LinearAlgebra.LinearAlgebra.hiperboloide_una_fulla_revolucio">hiperboloide_una_fulla_revolucio</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.hyperbolic_cylinder" href="#LinearAlgebra.LinearAlgebra.hyperbolic_cylinder">hyperbolic_cylinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.hyperbolic_paraboloid" href="#LinearAlgebra.LinearAlgebra.hyperbolic_paraboloid">hyperbolic_paraboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.join" href="#LinearAlgebra.LinearAlgebra.join">join</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.moviment_helicoidal_ortoedre" href="#LinearAlgebra.LinearAlgebra.moviment_helicoidal_ortoedre">moviment_helicoidal_ortoedre</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.one_sheet_hyperboloid" href="#LinearAlgebra.LinearAlgebra.one_sheet_hyperboloid">one_sheet_hyperboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.parabola" href="#LinearAlgebra.LinearAlgebra.parabola">parabola</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.parabolic_cylinder" href="#LinearAlgebra.LinearAlgebra.parabolic_cylinder">parabolic_cylinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.paraboloide_elliptic" href="#LinearAlgebra.LinearAlgebra.paraboloide_elliptic">paraboloide_elliptic</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.paraboloide_elliptic_revolucio" href="#LinearAlgebra.LinearAlgebra.paraboloide_elliptic_revolucio">paraboloide_elliptic_revolucio</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.paraboloide_hiperbolic" href="#LinearAlgebra.LinearAlgebra.paraboloide_hiperbolic">paraboloide_hiperbolic</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.paraboloide_hiperbolic_simple" href="#LinearAlgebra.LinearAlgebra.paraboloide_hiperbolic_simple">paraboloide_hiperbolic_simple</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.pla_afi" href="#LinearAlgebra.LinearAlgebra.pla_afi">pla_afi</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.pla_vectorial" href="#LinearAlgebra.LinearAlgebra.pla_vectorial">pla_vectorial</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_pla_afi" href="#LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_pla_afi">projeccio_ortogonal_simetric_pla_afi</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_pla_vectorial" href="#LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_pla_vectorial">projeccio_ortogonal_simetric_pla_vectorial</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_recta_afi" href="#LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_recta_afi">projeccio_ortogonal_simetric_recta_afi</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_recta_vectorial" href="#LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_recta_vectorial">projeccio_ortogonal_simetric_recta_vectorial</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.punt_referencia_canonica" href="#LinearAlgebra.LinearAlgebra.punt_referencia_canonica">punt_referencia_canonica</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.punt_referencia_no_canonica" href="#LinearAlgebra.LinearAlgebra.punt_referencia_no_canonica">punt_referencia_no_canonica</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.referencia_canonica" href="#LinearAlgebra.LinearAlgebra.referencia_canonica">referencia_canonica</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.referencia_no_canonica" href="#LinearAlgebra.LinearAlgebra.referencia_no_canonica">referencia_no_canonica</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.reset" href="#LinearAlgebra.LinearAlgebra.reset">reset</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.reset_base" href="#LinearAlgebra.LinearAlgebra.reset_base">reset_base</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.reset_colors" href="#LinearAlgebra.LinearAlgebra.reset_colors">reset_colors</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.reset_frames" href="#LinearAlgebra.LinearAlgebra.reset_frames">reset_frames</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.reset_origin" href="#LinearAlgebra.LinearAlgebra.reset_origin">reset_origin</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.reset_rotation" href="#LinearAlgebra.LinearAlgebra.reset_rotation">reset_rotation</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.revolution_surface" href="#LinearAlgebra.LinearAlgebra.revolution_surface">revolution_surface</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rotacio_ortoedre" href="#LinearAlgebra.LinearAlgebra.rotacio_ortoedre">rotacio_ortoedre</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rotacio_ortoedre_angles_euler" href="#LinearAlgebra.LinearAlgebra.rotacio_ortoedre_angles_euler">rotacio_ortoedre_angles_euler</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rotacio_ortoedre_voltant_vector" href="#LinearAlgebra.LinearAlgebra.rotacio_ortoedre_voltant_vector">rotacio_ortoedre_voltant_vector</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rotacio_vector" href="#LinearAlgebra.LinearAlgebra.rotacio_vector">rotacio_vector</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rotate_euler" href="#LinearAlgebra.LinearAlgebra.rotate_euler">rotate_euler</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rotate_object" href="#LinearAlgebra.LinearAlgebra.rotate_object">rotate_object</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rotate_object_by_axis_angle" href="#LinearAlgebra.LinearAlgebra.rotate_object_by_axis_angle">rotate_object_by_axis_angle</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rotate_vector" href="#LinearAlgebra.LinearAlgebra.rotate_vector">rotate_vector</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.set_base" href="#LinearAlgebra.LinearAlgebra.set_base">set_base</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.set_colors" href="#LinearAlgebra.LinearAlgebra.set_colors">set_colors</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.set_cursor" href="#LinearAlgebra.LinearAlgebra.set_cursor">set_cursor</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.set_cursor_rotation" href="#LinearAlgebra.LinearAlgebra.set_cursor_rotation">set_cursor_rotation</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.set_default_color" href="#LinearAlgebra.LinearAlgebra.set_default_color">set_default_color</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.set_origin" href="#LinearAlgebra.LinearAlgebra.set_origin">set_origin</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.set_rotation" href="#LinearAlgebra.LinearAlgebra.set_rotation">set_rotation</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.simple_curve" href="#LinearAlgebra.LinearAlgebra.simple_curve">simple_curve</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.sphere" href="#LinearAlgebra.LinearAlgebra.sphere">sphere</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.superficie_revolucio_parabola" href="#LinearAlgebra.LinearAlgebra.superficie_revolucio_parabola">superficie_revolucio_parabola</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.tor" href="#LinearAlgebra.LinearAlgebra.tor">tor</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.two_sheets_hyperboloid" href="#LinearAlgebra.LinearAlgebra.two_sheets_hyperboloid">two_sheets_hyperboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.vector_base_canonica" href="#LinearAlgebra.LinearAlgebra.vector_base_canonica">vector_base_canonica</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.vector_base_no_canonica" href="#LinearAlgebra.LinearAlgebra.vector_base_no_canonica">vector_base_no_canonica</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.vectors_to_quaternion" href="#LinearAlgebra.LinearAlgebra.vectors_to_quaternion">vectors_to_quaternion</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="LinearAlgebra.Rotation" href="#LinearAlgebra.Rotation">Rotation</a></code></h4>
<ul class="">
<li><code><a title="LinearAlgebra.Rotation.apply" href="#LinearAlgebra.Rotation.apply">apply</a></code></li>
<li><code><a title="LinearAlgebra.Rotation.from_euler_angles" href="#LinearAlgebra.Rotation.from_euler_angles">from_euler_angles</a></code></li>
<li><code><a title="LinearAlgebra.Rotation.to_axis_angle" href="#LinearAlgebra.Rotation.to_axis_angle">to_axis_angle</a></code></li>
<li><code><a title="LinearAlgebra.Rotation.to_euler_angles" href="#LinearAlgebra.Rotation.to_euler_angles">to_euler_angles</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>