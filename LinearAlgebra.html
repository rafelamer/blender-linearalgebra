<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>LinearAlgebra API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>LinearAlgebra</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Filename:   LinearAlgebra.py
# Author:     Rafel Amer (rafel.amer AT upc.edu)
# Copyright:  Rafel Amer 2020-2022
#
#             This file contains code from the file add_mesh_3d_function_surface.py
#             distributed with Blender
#
# Disclaimer: This code is presented &#34;as is&#34; and it has been written to learn
#             to use the python scripting language and the Blender sofware
#             use them in the studies of Linear Algebra and Geometry
#cos
# License:    This software is free software; you can redistribute it and/or
#             modify it under the terms of either:
#
#             1 the GNU Lesser General Public License as published by the Free
#               Software Foundation; either version 3 of the License, or (at your
#               option) any later version.
#
#             or
#
#             2 the GNU General Public License as published by the Free
#               Foundation; either version 2 of the License, or (at your option)
#               any later version.
#
#                 See https://www.gnu.org/licenses/
#########################################################################################
import math
import bpy
import bmesh
import random
from bpy_extras import object_utils
try:
        from sympy import *
except:
        print(&#34;Python sympy not available&#34;)
        pass
from mathutils import Vector, Matrix, Euler, Quaternion

def create_mesh_object(context,verts,edges,faces,name):
        mesh = bpy.data.meshes.new(name)
        mesh.from_pydata(verts, edges, faces)
        mesh.update()
        return object_utils.object_data_add(context, mesh, operator=None)
#
#
#
def createFaces(vertIdx1,vertIdx2,closed=False,flipped=False):
        faces = []
        if not vertIdx1 or not vertIdx2:
                return None
        if len(vertIdx1) &lt; 2 and len(vertIdx2) &lt; 2:
                return None

        fan = False
        if (len(vertIdx1) != len(vertIdx2)):
                if (len(vertIdx1) == 1 and len(vertIdx2) &gt; 1):
                        fan = True
                else:
                        return None

        total = len(vertIdx2)
        if closed:
                if flipped:
                        face = [vertIdx1[0],vertIdx2[0],vertIdx2[total - 1]]
                        if not fan:
                                face.append(vertIdx1[total - 1])
                        faces.append(face)
                else:
                        face = [vertIdx2[0], vertIdx1[0]]
                        if not fan:
                                face.append(vertIdx1[total - 1])
                        face.append(vertIdx2[total - 1])
                        faces.append(face)
        for num in range(total - 1):
                if flipped:
                        if fan:
                                face = [vertIdx2[num], vertIdx1[0], vertIdx2[num + 1]]
                        else:
                                face = [vertIdx2[num], vertIdx1[num],vertIdx1[num + 1], vertIdx2[num + 1]]
                        faces.append(face)
                else:
                        if fan:
                                face = [vertIdx1[0], vertIdx2[num], vertIdx2[num + 1]]
                        else:
                                face = [vertIdx1[num], vertIdx2[num],vertIdx2[num + 1], vertIdx1[num + 1]]
                        faces.append(face)
        return faces
#
#
#
def draw_parametric_surface(eq,range_u_min,range_u_max,range_u_step,range_v_min,range_v_max,range_v_step,name,wrap_u=False,wrap_v=False,close_v=False):
        verts = []
        faces = []
        if not callable(range_u_min) and not callable(range_u_max):
                uStep = (range_u_max - range_u_min) / range_u_step
        vStep = (range_v_max - range_v_min) / range_v_step
        uRange = range_u_step + 1
        vRange = range_v_step + 1

        if wrap_u:
                uRange = uRange - 1
        if wrap_v:
                vRange = vRange - 1

        for vN in range(vRange):
                v = range_v_min + (vN * vStep)
                if callable(range_u_min):
                        u_min = range_u_min(v)
                else:
                        u_min = range_u_min
                if callable(range_u_max):
                        u_max = range_u_max(v)
                else:
                        u_max = range_u_max
                uStep = (u_max - u_min) / range_u_step
                for uN in range(uRange):
                        u = u_min + (uN * uStep)
                        verts.append(eq(u,v))

        for vN in range(range_v_step):
                vNext = vN + 1
                if vNext &gt;= vRange:
                        vNext = 0
                for uN in range(range_u_step):
                        uNext = uN + 1
                        if uNext &gt;= uRange:
                                uNext = 0
                        faces.append([(vNext * uRange) + uNext,(vNext * uRange) + uN,(vN * uRange) + uN,(vN * uRange) + uNext])

        if close_v and wrap_u and (not wrap_v):
                for uN in range(1, range_u_step - 1):
                        faces.append([range_u_step - 1,range_u_step - 1 - uN,range_u_step - 2 - uN])
                        faces.append([range_v_step * uRange,range_v_step * uRange + uN,range_v_step * uRange + uN + 1])
        create_mesh_object(bpy.context,verts, [], faces, name)
#
#
#
class Color():
        &#34;&#34;&#34;
    Class that defines a color in RGB format
    &#34;&#34;&#34;
        def __init__(self,r,g,b,name):
                self.r = r
                self.g = g
                self.b = b
                self.name = name
#
#
#
class Colors():
        &#34;&#34;&#34;
        Class that defines a list of colors by name
        &#34;&#34;&#34;
        colorsbyname = {
                &#39;Black&#39; : Color(0,0,0,&#39;Black&#39;),
                &#39;GrayObscure&#39; : Color(0.2,0.2,0.2,&#39;GrayObscure&#39;),
                &#39;GrayDark&#39; : Color(0.4,0.4,0.4,&#39;GrayDark&#39;),
                &#39;GrayLight&#39; : Color(0.6,0.6,0.6,&#39;GrayLight&#39;),
                &#39;GrayPale&#39; : Color(0.8,0.8,0.8,&#39;GrayPale&#39;),
                &#39;White&#39; : Color(1,1,1,&#39;White&#39;),
                &#39;Red&#39; : Color(1,0,0,&#39;Red&#39;),
                &#39;RedDarkHard&#39; : Color(0.8,0,0,&#39;RedDarkHard&#39;),
                &#39;RedLightHard&#39; : Color(1,0.2,0.2,&#39;RedLightHard&#39;),
                &#39;RedDarkFaded&#39; : Color(0.6,0,0,&#39;RedDarkFaded&#39;),
                &#39;RedMediumFaded&#39; : Color(0.8,0.2,0.2,&#39;RedMediumFaded&#39;),
                &#39;RedLightFaded&#39; : Color(1,0.4,0.4,&#39;RedLightFaded&#39;),
                &#39;RedObscureDull&#39; : Color(0.4,0,0,&#39;RedObscureDull&#39;),
                &#39;RedDarkDull&#39; : Color(0.6,0.2,0.2,&#39;RedDarkDull&#39;),
                &#39;RedLightDull&#39; : Color(0.8,0.4,0.4,&#39;RedLightDull&#39;),
                &#39;RedPaleDull&#39; : Color(1,0.6,0.6,&#39;RedPaleDull&#39;),
                &#39;RedObscureWeak&#39; : Color(0.2,0,0,&#39;RedObscureWeak&#39;),
                &#39;RedDarkWeak&#39; : Color(0.4,0.2,0.2,&#39;RedDarkWeak&#39;),
                &#39;RedMediumWeak&#39; : Color(0.6,0.4,0.4,&#39;RedMediumWeak&#39;),
                &#39;RedLightWeak&#39; : Color(0.8,0.6,0.6,&#39;RedLightWeak&#39;),
                &#39;RedPaleWeak&#39; : Color(1,0.8,0.8,&#39;RedPaleWeak&#39;),
                &#39;Orange&#39; : Color(1,0.37,0.12,&#39;Orange&#39;),
                &#39;OrangeRedDark&#39; : Color(0.6,0.2,0,&#39;OrangeRedDark&#39;),
                &#39;OrangeRedMedium&#39; : Color(0.8,0.4,0.2,&#39;OrangeRedMedium&#39;),
                &#39;OrangeRedLight&#39; : Color(1,0.6,0.4,&#39;OrangeRedLight&#39;),
                &#39;OrangeOrangeRed&#39; : Color(1,0.4,0,&#39;OrangeOrangeRed&#39;),
                &#39;RedOrangeDark&#39; : Color(0.8,0.2,0,&#39;RedOrangeDark&#39;),
                &#39;RedOrangeLight&#39; : Color(1,0.4,0.2,&#39;RedOrangeLight&#39;),
                &#39;RedRedOrange&#39; : Color(1,0.2,0,&#39;RedRedOrange&#39;),
                &#39;OrangeDarkHard&#39; : Color(0.8,0.4,0,&#39;OrangeDarkHard&#39;),
                &#39;OrangeLightHard&#39; : Color(1,0.6,0.2,&#39;OrangeLightHard&#39;),
                &#39;OrangeObscureDull&#39; : Color(0.4,0.2,0,&#39;OrangeObscureDull&#39;),
                &#39;OrangeDarkDull&#39; : Color(0.6,0.4,0.2,&#39;OrangeDarkDull&#39;),
                &#39;OrangeLightDull&#39; : Color(0.8,0.6,0.4,&#39;OrangeLightDull&#39;),
                &#39;OrangePaleDull&#39; : Color(1,0.8,0.6,&#39;OrangePaleDull&#39;),
                &#39;OrangeYellowDark&#39; : Color(0.6,0.4,0,&#39;OrangeYellowDark&#39;),
                &#39;OrangeYellowMedium&#39; : Color(0.8,0.6,0.2,&#39;OrangeYellowMedium&#39;),
                &#39;OrangeYellowLight&#39; : Color(1,0.8,0.4,&#39;OrangeYellowLight&#39;),
                &#39;OrangeOrangeYellow&#39; : Color(1,0.6,0,&#39;OrangeOrangeYellow&#39;),
                &#39;YellowOrangeDark&#39; : Color(0.8,0.6,0,&#39;YellowOrangeDark&#39;),
                &#39;YellowOrangeLight&#39; : Color(1,0.8,0.2,&#39;YellowOrangeLight&#39;),
                &#39;YellowYellowOrange&#39; : Color(1,0.8,0,&#39;YellowYellowOrange&#39;),
                &#39;Yellow&#39; : Color(1,1,0,&#39;Yellow&#39;),
                &#39;YellowDarkHard&#39; : Color(0.8,0.8,0,&#39;YellowDarkHard&#39;),
                &#39;YellowLightHard&#39; : Color(1,1,0.2,&#39;YellowLightHard&#39;),
                &#39;YellowDarkFaded&#39; : Color(0.6,0.6,0,&#39;YellowDarkFaded&#39;),
                &#39;YellowMediumFaded&#39; : Color(0.8,0.8,0.2,&#39;YellowMediumFaded&#39;),
                &#39;YellowLightFaded&#39; : Color(1,1,0.4,&#39;YellowLightFaded&#39;),
                &#39;YellowObscureDull&#39; : Color(0.4,0.4,0,&#39;YellowObscureDull&#39;),
                &#39;YellowDarkDull&#39; : Color(0.6,0.6,0.2,&#39;YellowDarkDull&#39;),
                &#39;YellowLightDull&#39; : Color(0.8,0.8,0.4,&#39;YellowLightDull&#39;),
                &#39;YellowPaleDull&#39; : Color(1,1,0.6,&#39;YellowPaleDull&#39;),
                &#39;YellowObscureWeak&#39; : Color(0.2,0.2,0,&#39;YellowObscureWeak&#39;),
                &#39;YellowDarkWeak&#39; : Color(0.4,0.4,0.2,&#39;YellowDarkWeak&#39;),
                &#39;YellowMediumWeak&#39; : Color(0.6,0.6,0.4,&#39;YellowMediumWeak&#39;),
                &#39;YellowLightWeak&#39; : Color(0.8,0.8,0.6,&#39;YellowLightWeak&#39;),
                &#39;YellowPaleWeak&#39; : Color(1,1,0.8,&#39;YellowPaleWeak&#39;),
                &#39;SpringYellowDark&#39; : Color(0.4,0.6,0,&#39;SpringYellowDark&#39;),
                &#39;SpringYellowMedium&#39; : Color(0.6,0.8,0.2,&#39;SpringYellowMedium&#39;),
                &#39;SpringYellowLight&#39; : Color(0.8,1,0.4,&#39;SpringYellowLight&#39;),
                &#39;SpringSpringYellow&#39; : Color(0.6,1,0,&#39;SpringSpringYellow&#39;),
                &#39;YellowSpringDark&#39; : Color(0.6,0.8,0,&#39;YellowSpringDark&#39;),
                &#39;YellowSpringLight&#39; : Color(0.8,1,0.2,&#39;YellowSpringLight&#39;),
                &#39;YellowYellowSpring&#39; : Color(0.8,1,0,&#39;YellowYellowSpring&#39;),
                &#39;SpringDarkHard&#39; : Color(0.4,0.8,0,&#39;SpringDarkHard&#39;),
                &#39;SpringLightHard&#39; : Color(0.6,1,0.2,&#39;SpringLightHard&#39;),
                &#39;SpringObscureDull&#39; : Color(0.2,0.4,0,&#39;SpringObscureDull&#39;),
                &#39;SpringDarkDull&#39; : Color(0.4,0.6,0.2,&#39;SpringDarkDull&#39;),
                &#39;SpringLightDull&#39; : Color(0.6,0.8,0.4,&#39;SpringLightDull&#39;),
                &#39;SpringPaleDull&#39; : Color(0.8,1,0.6,&#39;SpringPaleDull&#39;),
                &#39;SpringGreenDark&#39; : Color(0.2,0.6,0,&#39;SpringGreenDark&#39;),
                &#39;SpringGreenMedium&#39; : Color(0.4,0.8,0.2,&#39;SpringGreenMedium&#39;),
                &#39;SpringGreenLight&#39; : Color(0.6,1,0.4,&#39;SpringGreenLight&#39;),
                &#39;SpringSpringGreen&#39; : Color(0.4,1,0,&#39;SpringSpringGreen&#39;),
                &#39;GreenSpringDark&#39; : Color(0.2,0.8,0,&#39;GreenSpringDark&#39;),
                &#39;GreenSpringLight&#39; : Color(0.4,1,0.2,&#39;GreenSpringLight&#39;),
                &#39;GreenGreenSpring&#39; : Color(0.2,1,0,&#39;GreenGreenSpring&#39;),
                &#39;Green&#39; : Color(0,1,0,&#39;Green&#39;),
                &#39;GreenDarkHard&#39; : Color(0,0.8,0,&#39;GreenDarkHard&#39;),
                &#39;GreenLightHard&#39; : Color(0.2,1,0.2,&#39;GreenLightHard&#39;),
                &#39;GreenDarkFaded&#39; : Color(0,0.6,0,&#39;GreenDarkFaded&#39;),
                &#39;GreenMediumFaded&#39; : Color(0.2,0.8,0.2,&#39;GreenMediumFaded&#39;),
                &#39;GreenLightFaded&#39; : Color(0.4,1,0.4,&#39;GreenLightFaded&#39;),
                &#39;GreenObscureDull&#39; : Color(0,0.4,0,&#39;GreenObscureDull&#39;),
                &#39;GreenDarkDull&#39; : Color(0.2,0.6,0.2,&#39;GreenDarkDull&#39;),
                &#39;GreenLightDull&#39; : Color(0.4,0.8,0.4,&#39;GreenLightDull&#39;),
                &#39;GreenPaleDull&#39; : Color(0.6,1,0.6,&#39;GreenPaleDull&#39;),
                &#39;GreenObscureWeak&#39; : Color(0,0.2,0,&#39;GreenObscureWeak&#39;),
                &#39;GreenDarkWeak&#39; : Color(0.2,0.4,0.2,&#39;GreenDarkWeak&#39;),
                &#39;GreenMediumWeak&#39; : Color(0.4,0.6,0.4,&#39;GreenMediumWeak&#39;),
                &#39;GreenLightWeak&#39; : Color(0.6,0.8,0.6,&#39;GreenLightWeak&#39;),
                &#39;GreenPaleWeak&#39; : Color(0.8,1,0.8,&#39;GreenPaleWeak&#39;),
                &#39;TealGreenDark&#39; : Color(0,0.6,0.2,&#39;TealGreenDark&#39;),
                &#39;TealGreenMedium&#39; : Color(0.2,0.8,0.4,&#39;TealGreenMedium&#39;),
                &#39;TealGreenLight&#39; : Color(0.4,1,0.6,&#39;TealGreenLight&#39;),
                &#39;TealTealGreen&#39; : Color(0,1,0.4,&#39;TealTealGreen&#39;),
                &#39;GreenTealDark&#39; : Color(0,0.8,0.2,&#39;GreenTealDark&#39;),
                &#39;GreenTealLight&#39; : Color(0.2,1,0.4,&#39;GreenTealLight&#39;),
                &#39;GreenGreenTeal&#39; : Color(0,1,0.2,&#39;GreenGreenTeal&#39;),
                &#39;TealDarkHard&#39; : Color(0,0.8,0.4,&#39;TealDarkHard&#39;),
                &#39;TealLightHard&#39; : Color(0.2,1,0.6,&#39;TealLightHard&#39;),
                &#39;TealObscureDull&#39; : Color(0,0.4,0.2,&#39;TealObscureDull&#39;),
                &#39;TealDarkDull&#39; : Color(0.2,0.6,0.4,&#39;TealDarkDull&#39;),
                &#39;TealLightDull&#39; : Color(0.4,0.8,0.6,&#39;TealLightDull&#39;),
                &#39;TealPaleDull&#39; : Color(0.6,1,0.8,&#39;TealPaleDull&#39;),
                &#39;TealCyanDark&#39; : Color(0,0.6,0.4,&#39;TealCyanDark&#39;),
                &#39;TealCyanMedium&#39; : Color(0.2,0.8,0.6,&#39;TealCyanMedium&#39;),
                &#39;TealCyanLight&#39; : Color(0.4,1,0.8,&#39;TealCyanLight&#39;),
                &#39;TealTealCyan&#39; : Color(0,1,0.6,&#39;TealTealCyan&#39;),
                &#39;CyanTealDark&#39; : Color(0,0.8,0.6,&#39;CyanTealDark&#39;),
                &#39;CyanTealLight&#39; : Color(0.2,1,0.8,&#39;CyanTealLight&#39;),
                &#39;CyanCyanTeal&#39; : Color(0,1,0.8,&#39;CyanCyanTeal&#39;),
                &#39;Cyan&#39; : Color(0,1,1,&#39;Cyan&#39;),
                &#39;CyanDarkHard&#39; : Color(0,0.8,0.8,&#39;CyanDarkHard&#39;),
                &#39;CyanLightHard&#39; : Color(0.2,1,1,&#39;CyanLightHard&#39;),
                &#39;CyanDarkFaded&#39; : Color(0,0.6,0.6,&#39;CyanDarkFaded&#39;),
                &#39;CyanMediumFaded&#39; : Color(0.2,0.8,0.8,&#39;CyanMediumFaded&#39;),
                &#39;CyanLightFaded&#39; : Color(0.4,1,1,&#39;CyanLightFaded&#39;),
                &#39;CyanObscureDull&#39; : Color(0,0.4,0.4,&#39;CyanObscureDull&#39;),
                &#39;CyanDarkDull&#39; : Color(0.2,0.6,0.6,&#39;CyanDarkDull&#39;),
                &#39;CyanLightDull&#39; : Color(0.4,0.8,0.8,&#39;CyanLightDull&#39;),
                &#39;CyanPaleDull&#39; : Color(0.6,1,1,&#39;CyanPaleDull&#39;),
                &#39;CyanObscureWeak&#39; : Color(0,0.2,0.2,&#39;CyanObscureWeak&#39;),
                &#39;CyanDarkWeak&#39; : Color(0.2,0.4,0.4,&#39;CyanDarkWeak&#39;),
                &#39;CyanMediumWeak&#39; : Color(0.4,0.6,0.6,&#39;CyanMediumWeak&#39;),
                &#39;CyanLightWeak&#39; : Color(0.6,0.8,0.8,&#39;CyanLightWeak&#39;),
                &#39;CyanPaleWeak&#39; : Color(0.8,1,1,&#39;CyanPaleWeak&#39;),
                &#39;AzureCyanDark&#39; : Color(0,0.4,0.6,&#39;AzureCyanDark&#39;),
                &#39;AzureCyanMedium&#39; : Color(0.2,0.6,0.8,&#39;AzureCyanMedium&#39;),
                &#39;AzureCyanLight&#39; : Color(0.4,0.8,1,&#39;AzureCyanLight&#39;),
                &#39;AzureAzureCyan&#39; : Color(0,0.6,1,&#39;AzureAzureCyan&#39;),
                &#39;CyanAzureDark&#39; : Color(0,0.6,0.8,&#39;CyanAzureDark&#39;),
                &#39;CyanAzureLight&#39; : Color(0.2,0.8,1,&#39;CyanAzureLight&#39;),
                &#39;CyanCyanAzure&#39; : Color(0,0.8,1,&#39;CyanCyanAzure&#39;),
                &#39;AzureDarkHard&#39; : Color(0,0.4,0.8,&#39;AzureDarkHard&#39;),
                &#39;AzureLightHard&#39; : Color(0.2,0.6,1,&#39;AzureLightHard&#39;),
                &#39;AzureObscureDull&#39; : Color(0,0.2,0.4,&#39;AzureObscureDull&#39;),
                &#39;AzureDarkDull&#39; : Color(0.2,0.4,0.6,&#39;AzureDarkDull&#39;),
                &#39;AzureLightDull&#39; : Color(0.4,0.6,0.8,&#39;AzureLightDull&#39;),
                &#39;AzurePaleDull&#39; : Color(0.6,0.8,1,&#39;AzurePaleDull&#39;),
                &#39;AzureBlueDark&#39; : Color(0,0.2,0.6,&#39;AzureBlueDark&#39;),
                &#39;AzureBlueMedium&#39; : Color(0.2,0.4,0.8,&#39;AzureBlueMedium&#39;),
                &#39;AzureBlueLight&#39; : Color(0.4,0.6,1,&#39;AzureBlueLight&#39;),
                &#39;AzureAzureBlue&#39; : Color(0,0.4,1,&#39;AzureAzureBlue&#39;),
                &#39;BlueAzureDark&#39; : Color(0,0.2,0.8,&#39;BlueAzureDark&#39;),
                &#39;BlueAzureLight&#39; : Color(0.2,0.4,1,&#39;BlueAzureLight&#39;),
                &#39;BlueBlueAzure&#39; : Color(0,0.2,1,&#39;BlueBlueAzure&#39;),
                &#39;Blue&#39; : Color(0,0,1,&#39;Blue&#39;),
                &#39;BlueDarkHard&#39; : Color(0,0,0.8,&#39;BlueDarkHard&#39;),
                &#39;BlueLightHard&#39; : Color(0.2,0.2,1,&#39;BlueLightHard&#39;),
                &#39;BlueDarkFaded&#39; : Color(0,0,0.6,&#39;BlueDarkFaded&#39;),
                &#39;BlueMediumFaded&#39; : Color(0.2,0.2,0.8,&#39;BlueMediumFaded&#39;),
                &#39;BlueLightFaded&#39; : Color(0.4,0.4,1,&#39;BlueLightFaded&#39;),
                &#39;BlueObscureDull&#39; : Color(0,0,0.4,&#39;BlueObscureDull&#39;),
                &#39;BlueDarkDull&#39; : Color(0.2,0.2,0.6,&#39;BlueDarkDull&#39;),
                &#39;BlueLightDull&#39; : Color(0.4,0.4,0.8,&#39;BlueLightDull&#39;),
                &#39;BluePaleDull&#39; : Color(0.6,0.6,1,&#39;BluePaleDull&#39;),
                &#39;BlueObscureWeak&#39; : Color(0,0,0.2,&#39;BlueObscureWeak&#39;),
                &#39;BlueDarkWeak&#39; : Color(0.2,0.2,0.4,&#39;BlueDarkWeak&#39;),
                &#39;BlueMediumWeak&#39; : Color(0.4,0.4,0.6,&#39;BlueMediumWeak&#39;),
                &#39;BlueLightWeak&#39; : Color(0.6,0.6,0.8,&#39;BlueLightWeak&#39;),
                &#39;BluePaleWeak&#39; : Color(0.8,0.8,1,&#39;BluePaleWeak&#39;),
                &#39;VioletBlueDark&#39; : Color(0.2,0,0.6,&#39;VioletBlueDark&#39;),
                &#39;VioletBlueMedium&#39; : Color(0.4,0.2,0.8,&#39;VioletBlueMedium&#39;),
                &#39;VioletBlueLight&#39; : Color(0.6,0.4,1,&#39;VioletBlueLight&#39;),
                &#39;VioletVioletBlue&#39; : Color(0.4,0,1,&#39;VioletVioletBlue&#39;),
                &#39;BlueVioletDark&#39; : Color(0.2,0,0.8,&#39;BlueVioletDark&#39;),
                &#39;BlueVioletLight&#39; : Color(0.4,0.2,1,&#39;BlueVioletLight&#39;),
                &#39;BlueBlueViolet&#39; : Color(0.2,0,1,&#39;BlueBlueViolet&#39;),
                &#39;VioletDarkHard&#39; : Color(0.4,0,0.8,&#39;VioletDarkHard&#39;),
                &#39;VioletLightHard&#39; : Color(0.6,0.2,1,&#39;VioletLightHard&#39;),
                &#39;VioletObscureDull&#39; : Color(0.2,0,0.4,&#39;VioletObscureDull&#39;),
                &#39;VioletDarkDull&#39; : Color(0.4,0.2,0.6,&#39;VioletDarkDull&#39;),
                &#39;VioletLightDull&#39; : Color(0.6,0.4,0.8,&#39;VioletLightDull&#39;),
                &#39;VioletPaleDull&#39; : Color(0.8,0.6,1,&#39;VioletPaleDull&#39;),
                &#39;VioletMagentaDark&#39; : Color(0.4,0,0.6,&#39;VioletMagentaDark&#39;),
                &#39;VioletMagentaMedium&#39; : Color(0.6,0.2,0.8,&#39;VioletMagentaMedium&#39;),
                &#39;VioletMagentaLight&#39; : Color(0.8,0.4,1,&#39;VioletMagentaLight&#39;),
                &#39;VioletVioletMagenta&#39; : Color(0.6,0,1,&#39;VioletVioletMagenta&#39;),
                &#39;MagentaVioletDark&#39; : Color(0.6,0,0.8,&#39;MagentaVioletDark&#39;),
                &#39;MagentaVioletLight&#39; : Color(0.8,0.2,1,&#39;MagentaVioletLight&#39;),
                &#39;MagentaMagentaViolet&#39; : Color(0.8,0,1,&#39;MagentaMagentaViolet&#39;),
                &#39;Magenta&#39; : Color(1,0,1,&#39;Magenta&#39;),
                &#39;MagentaDarkHard&#39; : Color(0.8,0,0.8,&#39;MagentaDarkHard&#39;),
                &#39;MagentaLightHard&#39; : Color(1,0.2,1,&#39;MagentaLightHard&#39;),
                &#39;MagentaDarkFaded&#39; : Color(0.6,0,0.6,&#39;MagentaDarkFaded&#39;),
                &#39;MagentaMediumFaded&#39; : Color(0.8,0.2,0.8,&#39;MagentaMediumFaded&#39;),
                &#39;MagentaLightFaded&#39; : Color(1,0.4,1,&#39;MagentaLightFaded&#39;),
                &#39;MagentaObscureDull&#39; : Color(0.4,0,0.4,&#39;MagentaObscureDull&#39;),
                &#39;MagentaDarkDull&#39; : Color(0.6,0.2,0.6,&#39;MagentaDarkDull&#39;),
                &#39;MagentaLightDull&#39; : Color(0.8,0.4,0.8,&#39;MagentaLightDull&#39;),
                &#39;MagentaPaleDull&#39; : Color(1,0.6,1,&#39;MagentaPaleDull&#39;),
                &#39;MagentaObscureWeak&#39; : Color(0.2,0,0.2,&#39;MagentaObscureWeak&#39;),
                &#39;MagentaDarkWeak&#39; : Color(0.4,0.2,0.4,&#39;MagentaDarkWeak&#39;),
                &#39;MagentaMediumWeak&#39; : Color(0.6,0.4,0.6,&#39;MagentaMediumWeak&#39;),
                &#39;MagentaLightWeak&#39; : Color(0.8,0.6,0.8,&#39;MagentaLightWeak&#39;),
                &#39;MagentaPaleWeak&#39; : Color(1,0.8,1,&#39;MagentaPaleWeak&#39;),
                &#39;PinkMagentaDark&#39; : Color(0.6,0,0.4,&#39;PinkMagentaDark&#39;),
                &#39;PinkMagentaMedium&#39; : Color(0.8,0.2,0.6,&#39;PinkMagentaMedium&#39;),
                &#39;PinkMagentaLight&#39; : Color(1,0.4,0.8,&#39;PinkMagentaLight&#39;),
                &#39;PinkPinkMagenta&#39; : Color(1,0,0.6,&#39;PinkPinkMagenta&#39;),
                &#39;MagentaPinkDark&#39; : Color(0.8,0,0.6,&#39;MagentaPinkDark&#39;),
                &#39;MagentaPinkLight&#39; : Color(1,0.2,0.8,&#39;MagentaPinkLight&#39;),
                &#39;MagentaMagentaPink&#39; : Color(1,0,0.8,&#39;MagentaMagentaPink&#39;),
                &#39;PinkDarkHard&#39; : Color(0.8,0,0.4,&#39;PinkDarkHard&#39;),
                &#39;PinkLightHard&#39; : Color(1,0.2,0.6,&#39;PinkLightHard&#39;),
                &#39;PinkObscureDull&#39; : Color(0.4,0,0.2,&#39;PinkObscureDull&#39;),
                &#39;PinkDarkDull&#39; : Color(0.6,0.2,0.4,&#39;PinkDarkDull&#39;),
                &#39;PinkLightDull&#39; : Color(0.8,0.4,0.6,&#39;PinkLightDull&#39;),
                &#39;PinkPaleDull&#39; : Color(1,0.6,0.8,&#39;PinkPaleDull&#39;),
                &#39;PinkRedDark&#39; : Color(0.6,0,0.2,&#39;PinkRedDark&#39;),
                &#39;PinkRedMedium&#39; : Color(0.8,0.2,0.4,&#39;PinkRedMedium&#39;),
                &#39;PinkRedLight&#39; : Color(1,0.4,0.6,&#39;PinkRedLight&#39;),
                &#39;PinkPinkRed&#39; : Color(1,0,0.4,&#39;PinkPinkRed&#39;),
                &#39;RedPinkDark&#39; : Color(0.8,0,0.2,&#39;RedPinkDark&#39;),
                &#39;RedPinkLight&#39; : Color(1,0.2,0.4,&#39;RedPinkLight&#39;),
                &#39;RedRedPink&#39; : Color(1,0,0.2,&#39;RedRedPink&#39;)
        }
        #
        #
        #
        @classmethod
        def color(self,name):
                &#34;&#34;&#34;
                Function that returns a color from his name
                Parameters:
                   name: name of the color
                &#34;&#34;&#34;
                try:
                        color = self.colorsbyname[name]
                except:
                        return self.colorsbyname[&#34;Black&#34;]
                return color
        #
        #
        #
        @classmethod
        def colors(self,names):
                &#34;&#34;&#34;
                Return a list of colors fron their names
                Parameters:
                   names: list of names
                &#34;&#34;&#34;
                return [self.colorsbyname[x] for x in names]
#
#
#
class Rotation():
        &#34;&#34;&#34;
    Class used for work with rotations. The stored value in the class is a quaternion
        &#34;&#34;&#34;
        def __init__(self,angle=None,vector=None,axis=None,quaternion=None,radians=False):
                &#34;&#34;&#34;
                Initializes the value for a rotation
                Parameters:
                   angle: angle of rotation
                   vector: axis of rotation
                   quaternion: The quaternion itself
                   radians: must be True if the angle is entered in radians and False if the
                            is entered in degrees.
                &#34;&#34;&#34;
                if vector is not None and axis is not None:
                        return
                if axis is not None:
                        if axis in (&#39;X&#39;,&#39;x&#39;):
                                vector = Vector([1,0,0])
                        elif axis in (&#39;Y&#39;,&#39;y&#39;):
                                vector = Vector([0,1,0])
                        elif axis in (&#39;Z&#39;,&#39;z&#39;):
                                vector = Vector([0,0,1])
                        else:
                                return

                if angle is not None:
                        if not radians:
                                angle = math.radians(angle)
                        if not isinstance(vector,Vector):
                                vector = Vector(vector)
                        self.quaternion = Quaternion(vector,angle)
                elif quaternion is not None:
                        self.quaternion = quaternion
                else:
                        self.quaternion = (1,0,0,0)
        #
        #
        #
        @classmethod
        def from_euler_angles(self,psi,theta,phi,axis=&#39;ZXZ&#39;,radians=False):
                &#34;&#34;&#34;
                Initializes a rotation from its Euler angles in the order ZXZ
                Parameters:
                   phi, theta, psi: Euler angles
                   axis: it must be &#39;XYZ&#39;, &#39;XZY&#39;, &#39;YXZ&#39;, &#39;YZX&#39;, &#39;ZXY&#39;, &#39;ZYX&#39;, &#39;XYX&#39;, &#39;XZX&#39;, &#39;YXY&#39;, &#39;YZY&#39;, &#39;ZXZ&#39; or &#39;ZYZ&#39;
                   radians: if radians, psi, theta and must be in radians
                &#34;&#34;&#34;
                if not radians:
                        phi = math.radians(phi)
                        theta = math.radians(theta)
                        psi = math.radians(psi)

                if axis is None:
                        return None
                if not isinstance(axis,str):
                        return None
                axis = axis.upper()
                if axis not in (&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,&#39;XYX&#39;,&#39;XZX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;):
                        return None

                r1 = Matrix.Rotation(psi,3,axis[0])
                r2 = Matrix.Rotation(theta,3,axis[1])
                r3 = Matrix.Rotation(phi,3,axis[2])
                m = r3 @ r2 @ r1
                q = m.to_quaternion()
                return self(quaternion=q)
        #
        #
        #
        def apply(self,v):
                &#34;&#34;&#34;
        Applies the rotation to an object v
                Parameters:
                   v: any object that can be transformed by a rotation
                &#34;&#34;&#34;
                return self.quaternion @ v
        #
        #
        #
        def to_axis_angle(self,radians=False):
                &#34;&#34;&#34;
                Returns the axis and angle of the rotation
                Parameters:
                   radians: if True, the angle returned is in radians, if not, is
                            returned in degrees
                &#34;&#34;&#34;
                v, alpha = self.quaternion.to_axis_angle()
                if radians:
                        return v, alpha
                return v, 180*alpha/math.pi
        #
        #
        #
        def to_euler_angles(self,axis=&#39;ZXZ&#39;,randomize=False,radians=False):
                &#34;&#34;&#34;
                Returns the Euler angles according to axis &#39;axis&#39;
                Parameters:
                   axis: it must be &#39;XYZ&#39;, &#39;XZY&#39;, &#39;YXZ&#39;, &#39;YZX&#39;, &#39;ZXY&#39;, &#39;ZYX&#39;, &#39;XYX&#39;, &#39;XZX&#39;, &#39;YXY&#39;, &#39;YZY&#39;, &#39;ZXZ&#39; or &#39;ZYZ&#39;
                   radians: if True, the angle returned is in radians, if not, is
                            returned in degrees
                &#34;&#34;&#34;
                def ACOS(x):
                        if x &gt; 1.0:
                                x = 1.0
                        if x &lt; -1.0:
                                x = -1.0
                        return math.acos(x)

                def ASIN(x):
                        if x &gt; 1.0:
                                x = 1.0
                        if x &lt; -1.0:
                                x = -1.0
                        return math.asin(x)

                axis = axis.upper()
                if axis not in (&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,&#39;XYX&#39;,&#39;XZX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;):
                        return None
                rndm = 0
                A = self.quaternion.to_matrix()
                if axis == &#39;ZXZ&#39;:
                        theta = ACOS(A[2][2])
                        if abs(A[2][2]) != 1:
                                psi = math.atan2(A[2][0],A[2][1])
                                phi = math.atan2(A[0][2],-A[1][2])
                        else:
                                rndm = A[2][2]
                                phi = 0
                                psi = math.atan2(A[1][0],A[0][0])
                if axis == &#39;XZX&#39;:
                        theta = ACOS(A[0][0])
                        if abs(A[0][0]) != 1:
                                psi = math.atan2(A[0][2],-A[0][1])
                                phi = math.atan2(A[2][0],A[1][0])
                        else:
                                rndm = A[0][0]
                                phi = 0
                                psi = math.atan2(-A[1][2],A[2][2])
                if axis == &#39;ZYZ&#39;:
                        theta = ACOS(A[2][2])
                        if abs(A[2][2]) != 1:
                                psi = math.atan2(A[2][1],-A[2][0])
                                phi = math.atan2(A[1][2],A[0][2])
                        else:
                                rndm = A[2][2]
                                phi = 0
                                psi = math.atan2(-A[0][1],A[1][1])
                if axis == &#39;YZY&#39;:
                        theta = ACOS(A[1][1])
                        if abs(A[1][1]) != 1:
                                psi = math.atan2(A[1][2],A[1][0])
                                phi = math.atan2(A[2][1],-A[0][1])
                        else:
                                rndm = A[1][1]
                                phi = 0
                                psi = math.atan2(A[0][2],A[2][2])
                if axis == &#39;XYX&#39;:
                        theta = ACOS(A[0][0])
                        if abs(A[0][0]) != 1:
                                psi = math.atan2(A[0][1],A[0][2])
                                phi = math.atan2(A[1][0],-A[2][0])
                        else:
                                rndm = A[0][0]
                                phi = 0
                                psi = math.atan2(A[2][1],A[1][1])
                if axis == &#39;YXY&#39;:
                        theta = ACOS(A[1][1])
                        if abs(A[1][1]) != 1:
                                psi = math.atan2(A[1][0],-A[1][2])
                                phi = math.atan2(A[0][1],A[2][1])
                        else:
                                rndm = A[1][1]
                                phi = 0
                                psi = math.atan2(-A[2][0],A[0][0])
                if axis == &#39;XYZ&#39;:
                        theta = ASIN(-A[2][0])
                        if abs(A[2][0]) != 1:
                                psi = math.atan2(A[2][1],A[2][2])
                                phi = math.atan2(A[1][0],A[0][0])
                        else:
                                rndm = A[2][0]
                                phi = 0
                                psi = math.atan2(-A[0][1],A[1][1])
                if axis == &#39;XZY&#39;:
                        theta = ASIN(A[1][0])
                        if abs(A[1][0]) != 1:
                                psi = math.atan2(-A[1][2],A[1][1])
                                phi = math.atan2(-A[2][0],A[0][0])
                        else:
                                rndm = A[1][0]
                                phi = 0
                                psi = math.atan2(A[0][2],A[2][2])
                if axis == &#39;YXZ&#39;:
                        theta = ASIN(A[2][1])
                        if abs(A[2][1]) != 1:
                                psi = math.atan2(-A[2][0],A[2][2])
                                phi = math.atan2(-A[0][1],A[1][1])
                        else:
                                rndm = A[2][1]
                                phi = 0
                                psi = math.atan2(A[1][0],A[0][0])
                if axis == &#39;YZX&#39;:
                        theta = ASIN(-A[0][1])
                        if abs(A[0][1]) != 1:
                                psi = math.atan2(A[0][2],A[0][0])
                                phi = math.atan2(A[2][1],A[1][1])
                        else:
                                rndm = A[0][1]
                                phi = 0
                                psi = math.atan2(-A[1][2],A[2][2])
                if axis == &#39;ZXY&#39;:
                        theta = ASIN(-A[1][2])
                        if abs(A[1][2]) != 1:
                                psi = math.atan2(A[1][0],A[1][1])
                                phi = math.atan2(A[0][2],A[2][2])
                        else:
                                rndm = A[1][2]
                                phi = 0
                                psi = math.atan2(-A[0][2],A[0][0])
                if axis == &#39;ZYX&#39;:
                        theta = ASIN(A[0][2])
                        if abs(A[0][2]) != 1:
                                psi = math.atan2(-A[0][1],A[0][0])
                                phi = math.atan2(-A[1][2],A[2][2])
                        else:
                                rndm = A[0][2]
                                phi = 0
                                psi = math.atan2(A[2][1],A[1][1])

                if psi &lt; 0:
                        psi += 2*math.pi
                if theta &lt; 0:
                        theta += 2*math.pi
                if phi &lt; 0:
                        phi += 2*math.pi

                if rndm != 0 and randomize:
                        phi = random.uniform(0.0,psi)
                        psi = rndm * (psi - phi)
                        if psi &lt; 0:
                                psi += 2*math.pi

                if not radians:
                        psi, theta, phi = 180.0/math.pi * psi, 180.0/math.pi * theta, 180.0/math.pi * phi
                        T = 359.9
                else:
                        T = 359.9 * math.pi / 180.0
                if psi &gt; T:
                        psi = 0.0
                if theta &gt; T:
                        theta = 0.0
                if phi &gt; T:
                        phi = 0.0
                return psi, theta, phi
#
#
#
class LinearAlgebra():
        &#34;&#34;&#34;
        Class used to define all the functions in this module to work with graphics in Blender
        &#34;&#34;&#34;
        def __init__(self):
                &#34;&#34;&#34;
        Initializes the values for scene, objects, meshes, collection, etc.
                &#34;&#34;&#34;
                self.scene = bpy.context.scene
                self.objects = bpy.data.objects
                self.meshes = bpy.data.meshes
                self.collection = bpy.context.collection
                self.ops = bpy.ops
                self.colors= Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                self.rotation = None
                self.origin = [0,0,0]
                self.base = [[1,0,0],[0,1,0],[0,0,1]]
                self.defaultcolor = None
                self.frame = 0
        #
        #
        #
        def base_cilinder(self):
                &#34;&#34;&#34;
                Draws a base cilinder with radius 1 and depth 1
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_cylinder_add(radius=1,depth=1,enter_editmode=False,location=(0, 0, 0))
                bpy.ops.transform.translate(value=(0, 0, 0.5), orient_type=&#39;GLOBAL&#39;,orient_matrix_type=&#39;GLOBAL&#39;,
                        constraint_axis=(False, False, True), mirror=True, use_proportional_edit=False,
                        proportional_edit_falloff=&#39;SMOOTH&#39;,proportional_size=1, use_proportional_connected=False, use_proportional_projected=False)
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                bpy.ops.object.shade_smooth()
                bpy.context.object.name = &#39;Arrow_stem&#39;
        #
        #
        #
        def base_cone(self):
                &#34;&#34;&#34;
                Draws a base cone with radius1=1.5, radius2=0, depth=2
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_cone_add(radius1=1.5, radius2=0, depth=2, enter_editmode=False, location=(0, 0, 0))
                bpy.ops.transform.translate(value=(0, 0, 1), orient_type=&#39;GLOBAL&#39;,orient_matrix_type=&#39;GLOBAL&#39;,
                        constraint_axis=(False, False, True), mirror=True, use_proportional_edit=False,
                        proportional_edit_falloff=&#39;SMOOTH&#39;, proportional_size=1, use_proportional_connected=False, use_proportional_projected=False)
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                bpy.ops.object.shade_smooth()
                bpy.context.object.name = &#39;Arrow_cone&#39;
        #
        #
        #
        def delete_base_cilinder(self):
                &#34;&#34;&#34;
                Removes the base cilinder
                &#34;&#34;&#34;
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.data.objects[&#39;Arrow_stem&#39;].select_set(True)
                bpy.ops.object.delete()
        #
        #
        #
        def delete_base_cone(self):
                &#34;&#34;&#34;
                Removes the base cone
                &#34;&#34;&#34;
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.data.objects[&#39;Arrow_cone&#39;].select_set(True)
                bpy.ops.object.delete()
        #
        #
        #
        def set_colors(self,names):
                &#34;&#34;&#34;
                Set self.colors to the list of colors with names &#39;names&#39;
                Parameters:
                   names: list of name colors
                &#34;&#34;&#34;
                self.colors = Colors.colors(names)
        #
        #
        #
        def reset_colors(self):
                &#34;&#34;&#34;
                Set self.colors to default colors
                &#34;&#34;&#34;
                self.colors= Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        #
        #
        #
        def set_default_color(self,name):
                &#34;&#34;&#34;
                Set self.defaultcolor to the color with name &#39;name&#39;
                Parameters:
                   name: name of a color
                &#34;&#34;&#34;
                self.defaultcolor = name
        #
        #
        #
        def reset_frames(self):
                &#34;&#34;&#34;
                Set self.frame to 0
                Parameters:
                   name: name of a color
                &#34;&#34;&#34;
                self.frame = 0
        #
        #
        #
        def reset(self):
                &#34;&#34;&#34;
                Resets origin, base, rotation, frames and colors
                &#34;&#34;&#34;
                self.reset_origin()
                self.reset_base()
                self.reset_rotation()
                self.reset_frames()
                self.reset_colors()
        #
        #
        #
        def set_rotation(self,angle=None,vector=None,quaternion=None):
                &#34;&#34;&#34;
                Sets self.rotation to the rotation defined by an angle and an axis or
                by a quaternion.
                Parameters:
                   angle: angle of rotation in degrees
                   vector: axis of rotation
                   quaternion: quaternion that defines a rotation
                The angle and vector takes precedence over the quaternion
                &#34;&#34;&#34;
                if angle is not None:
                        self.rotation = Rotation(angle,vector)
                elif quaternion is not None:
                        self.rotation = Rotation(quaternion=quaternion)
                else:
                        self.rotation = Rotation(0,[1,0,0])
        #
        #
        #
        def reset_rotation(self):
                &#34;&#34;&#34;
                Sets the rotation to identity, i.e., rotation of 0 degrees around the
                vector (1,0,0)
                &#34;&#34;&#34;
                self.set_rotation()
        #
        #
        #
        def set_origin(self,vector=[0,0,0]):
                &#34;&#34;&#34;
                Sets the origin of the reference coordinates used to display objects.
                Parameters:
                   vector: origin&#39;s position
                &#34;&#34;&#34;
                if isinstance(vector,Vector):
                        v1 = vector.copy()
                else:
                        v1 = Vector(vector)
                self.origin = v1
        #
        #
        #
        def reset_origin(self):
                &#34;&#34;&#34;
                Sets the origin to the point (0,0,0)
                &#34;&#34;&#34;
                self.origin = Vector([0,0,0])
        #
        #
        #
        def reset_base(self):
                &#34;&#34;&#34;
                Sets self.base to the canonical basis
                &#34;&#34;&#34;
                self.base = [[1,0,0],[0,1,0],[0,0,1]]
        #
        #
        #
        def set_base(self,base,orthonormal=False):
                &#34;&#34;&#34;
                Sets the self.base, i.e., the basis of the reference coordinates used to display
                objects
                Parameters:
                   base: list of three vectors
                   orthonormal: if True, the Gram-Schmidt method is applied and the vectors
                   are normalized.
                &#34;&#34;&#34;
                if orthonormal:
                        u1 = base[0]
                        u2 = base[1]
                        if isinstance(u1,Vector):
                                v1 = u1
                        else:
                                v1 = Vector(u1)
                        if isinstance(u2,Vector):
                                v2 = u2
                        else:
                                v2 = Vector(u2)
                        v2 = v2 - v2.project(v1)
                        v1.normalize()
                        v2.normalize()
                        v3 = v1.cross(v2)
                        self.base=[v1,v2,v3]
                else:
                        self.base = base
        #
        #
        #
        def base_is_canonica(self):
                &#34;&#34;&#34;
                Returns True if sel.base is the canonical basis
                &#34;&#34;&#34;
                return Matrix(self.base).is_identity
        #
        #
        #
        def add_material(self,obj,material_name,r,g,b,opacity=1.0):
                &#34;&#34;&#34;
                Adds a material and color to an object
                Parameters:
                   obj: object
                   material_name: material&#39;s name
                   r, g, b: RGB color values
                   opacity: the opacity
                &#34;&#34;&#34;
                material = bpy.data.materials.get(material_name)
                if material is None:
                        material = bpy.data.materials.new(material_name)
                material.use_nodes = True
                principled_bsdf = material.node_tree.nodes[&#39;Principled BSDF&#39;]
                if principled_bsdf is not None:
                        #for i, o in enumerate(principled_bsdf.inputs):
                        #       print(i, o.name)
                        principled_bsdf.inputs[&#39;Base Color&#39;].default_value = (r, g, b, 0.5)
                        principled_bsdf.inputs[&#39;IOR&#39;].default_value = 0.0
                        principled_bsdf.inputs[&#39;Specular&#39;].default_value = 1.0
                        principled_bsdf.inputs[&#39;Emission&#39;].default_value = (r, g, b, 0.5)
                        principled_bsdf.inputs[&#39;Emission Strength&#39;].default_value = 0.0
                        if opacity &lt; 1.0:
                                material.blend_method = &#39;BLEND&#39;
                                principled_bsdf.inputs[&#39;Alpha&#39;].default_value = opacity
                        else:
                                material.blend_method = &#39;OPAQUE&#39;
                                principled_bsdf.inputs[&#39;Alpha&#39;].default_value = 1.0
                obj.active_material = material
        #
        #
        #
        def add_ligth(self,location=[0,0,100],energy=3,direction=[0,0,-1]):
                &#34;&#34;&#34;
                Adds a ligth to the scene
                Parameters:
                   location: location point of the light
                   energy: energy of the ligth
                   direction: direction of the light
                &#34;&#34;&#34;
                l = bpy.data.lights.new(name=&#34;Light&#34;, type=&#39;SUN&#39;)
                l.energy = energy
                l.specular_factor = 4
                obj = self.objects.new(name=&#34;Light&#34;, object_data=l)
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.location = location
                n = Vector(direction)
                mat = Matrix(self.base)
                mat.transpose()
                n = mat @ n
                z = Vector([0,0,-1])
                quaternion = z.rotation_difference(n)
                obj.rotation_quaternion.rotate(quaternion)
                self.collection.objects.link(obj)
        #
        #
        #
        def add_ligths(self,energy=1):
                &#34;&#34;&#34;
                Adds diferent lights to the scene
                Parameters:
                   energy: energy of the lights
                &#34;&#34;&#34;
                self.add_ligth()
                self.add_ligth(location=[100,0,0],direction=[-1,0,0],energy=energy)
                self.add_ligth(location=[0,100,0],direction=[0,-1,0],energy=energy)
                self.add_ligth(location=[-100,0,0],direction=[1,0,0],energy=energy)
                self.add_ligth(location=[0,-100,0],direction=[0,1,0],energy=energy)
        #
        #
        #
        def new_components(self,vector=None):
                &#34;&#34;&#34;
                Returns the components of the vector &#39;vector&#39; in the basis determined by
                self.rotation ans the basis self.base
                Parameters:
                   vector: components of the vector in the canonical basis
                &#34;&#34;&#34;
                if vector is None:
                        return Vector([0,0,0])
                if isinstance(vector,Vector):
                        u = vector
                else:
                        u = Vector(vector)
                if self.rotation is not None:
                        mat = self.rotation.quaternion.to_matrix()
                        mat.invert()
                        u = mat @ u
                mat = Matrix(self.base)
                mat.transpose()
                mat.invert()
                u = mat @ u
                return u
        #
        #
        #
        def new_coordinates(self,point=None):
                &#34;&#34;&#34;
                Returns the coordinates of the point &#39;point&#39; in the reference determined by
                self.origin, self.rotation and the basis self.base
                Parameters:
                   point: coordinates of the point in the canonical reference
                &#34;&#34;&#34;
                if point is None:
                        return Vector([0,0,0])
                if isinstance(point,Vector):
                        u = point
                else:
                        u = Vector(point)
                if self.rotation is not None:
                        mat = self.rotation.quaternion.to_matrix()
                        mat.invert()
                        u = mat @ u
                mat = Matrix(self.base)
                mat.transpose()
                mat.invert()
                u = mat @ (u - Vector(self.origin))
                return u
        #
        #
        #
        def set_cursor(self,origin=[0,0,0],direction=[1,0,0],axis=&#39;x&#39;):
                &#34;&#34;&#34;
                Sets the cursor position and direction
                Parameters:
                  origin: position of the cursor
                  direction: vector that indicates the direction of the axis &#39;axis&#39;
                  axis: &#39;x&#39;, &#39;y&#39; or &#39;z&#39;
                &#34;&#34;&#34;
                axis = axis.lower()
                if axis not in [&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]:
                        return
                eixos = {&#39;x&#39; : Vector([1,0,0]),
                                 &#39;y&#39; : Vector([0,1,0]),
                                 &#39;z&#39; : Vector([0,0,1])
                }
                if isinstance(direction,Vector):
                        d = direction
                else:
                        d = Vector(direction)
                x = eixos[axis]
                quaternion = x.rotation_difference(d)
                self.scene.cursor.location = origin
                self.scene.cursor.rotation_mode = &#39;QUATERNION&#39;
                self.scene.cursor.rotation_quaternion = quaternion
        #
        #
        #
        def set_cursor_rotation(self,origin=[0,0,0],rotation=Matrix.Identity(3)):
                &#34;&#34;&#34;
                Sets the rotation of the cursor
                Parameters:
                   origin: position of the cursor
                   rotation: matrix of a rotation
                &#34;&#34;&#34;
                m = rotation.copy()
                det = m.determinant()
                if abs(- det - 1.0) &lt; 0.1:
                        m[2] = - m[2]
                quaternion = m.to_quaternion()
                self.scene.cursor.location = origin
                self.scene.cursor.rotation_mode = &#39;QUATERNION&#39;
                self.scene.cursor.rotation_quaternion = quaternion.conjugated()
        #
        #
        #
        def draw_base_axis(self,scale=0.05,head_height=0.15,axis=0,name=&#34;Axis&#34;,positive=True,zaxis=True):
                &#34;&#34;&#34;
                Draws a reference axis given by self.origin, self.rotation and the basis self.base
                Parameters:
                   scale: scale of the cylinder
                   head_height: height of the head of the vector from self.base
                   axis: length of the coordinate axis. If the length is 0, only the basis vectors are drawn
                   name: name of the result object
                   positive: if True, draw the positive part of the axis
                   zaxis: if True, draw the z axis
                &#34;&#34;&#34;
                self.base_cilinder()
                self.base_cone()
                o = Vector([0,0,0])
                op = Vector(self.origin)
                color = 0

                if axis != 0 and axis &lt; 8:
                        scale /= 3

                base = self.base
                if not zaxis:
                        base = self.base[0:2]
                for vec in base:
                        #
                        # Draw the stem
                        #
                        v = Vector(vec)
                        t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                        obj = t.copy()
                        obj.name = &#34;Axis%d&#34; % (color + 1)
                        obj.data = obj.data.copy()
                        obj.location = o
                        obj.scale = (scale,scale,(v - o).length - 2 * head_height)
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if self.colors is not None and len(self.colors) &gt; color:
                                c = self.colors[color]
                                self.add_material(obj,c.name,c.r,c.g,c.b)
                        if self.rotation is not None:
                                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location = op
                        self.scene.collection.objects.link(obj)
                        #
                        # Draw the arrow
                        #
                        t = bpy.data.objects.get(&#34;Arrow_cone&#34;)
                        obj2 = t.copy()
                        obj2.name = &#34;Arrow&#34;
                        obj2.data = obj2.data.copy()
                        obj2.location =  v - 2 * head_height * v / v.length
                        obj2.scale = (scale + 0.05,scale + 0.05,head_height)
                        obj2.rotation_mode = &#39;QUATERNION&#39;
                        obj2.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if self.colors is not None and len(self.colors) &gt; color:
                                c = self.colors[color]
                                self.add_material(obj2,c.name,c.r,c.g,c.b)
                        if self.rotation is not None:
                                obj2.rotation_quaternion.rotate(self.rotation.quaternion)
                                obj2.location.rotate(self.rotation.quaternion)
                        obj2.location = op + obj2.location
                        self.scene.collection.objects.link(obj2)
                        #
                        # Draw the line
                        #
                        obj3 = None
                        if axis != 0:
                                v = axis * Vector(vec)
                                t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                                obj3 = t.copy()
                                obj3.name = &#34;Line&#34;
                                obj3.data = obj3.data.copy()
                                obj3.location = op - v
                                obj3.scale = (scale / 2,scale / 2,(2 * v).length)
                                obj3.rotation_mode = &#39;QUATERNION&#39;
                                obj3.rotation_quaternion = v.to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                                if self.colors is not None and len(self.colors) &gt; color:
                                        c = self.colors[color]
                                        self.add_material(obj3,c.name,c.r,c.g,c.b)
                                if self.rotation is not None:
                                        obj3.rotation_quaternion.rotate(self.rotation.quaternion)
                                if positive:
                                        obj3.location = op
                                else:
                                        if self.rotation is not None:
                                                v.rotate(self.rotation.quaternion)
                                        obj3.location = op - v
                                self.scene.collection.objects.link(obj3)
                        #
                        # Joint the three objects
                        #
                        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                        bpy.context.view_layer.objects.active = obj
                        obj.select_set(True)
                        obj2.select_set(True)
                        if obj3 is not None:
                                obj3.select_set(True)
                        bpy.ops.object.join()
                        color += 1
                #
                # Join all the axis
                #
                t1 = bpy.data.objects.get(&#34;Axis1&#34;)
                t1.name = name
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.context.view_layer.objects.active = t1
                t1.select_set(True)
                t2 = bpy.data.objects.get(&#34;Axis2&#34;)
                t2.select_set(True)
                if zaxis:
                        t3 = bpy.data.objects.get(&#34;Axis3&#34;)
                        t3.select_set(True)
                bpy.ops.object.join()
                self.delete_base_cilinder()
                self.delete_base_cone()
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return t1
        #
        #
        #
        def draw_vector(self,vector=None,canonica=False,color=&#34;Black&#34;,scale=0.05,arrow=True,head_height=0.15,axis=0,name=&#34;Vector&#34;,positive=True):
                &#34;&#34;&#34;
                Draw the vector with components &#39;vector&#39;
                Parameters:
                   vector: components of the vector
                   canonica: if True, the components are in the canonical basis, else they are in the basis self.base. Finally,
                      self.rotation is applied
                   color: color of the vector
                   scale: scale of the cylinder
                   arrow: if True draws the vector itself
                   head_height: height of the head of the vector
                   axis: if not zero, draw also the line generated by the vector
                   positive: if axis is not zero and positive is True, draw only the positive part of the line
                      generated by the vector
                &#34;&#34;&#34;
                if vector is None:
                        return None
                if isinstance(vector,Vector):
                        vec = vector
                else:
                        vec = Vector(vector)
                if vec.length == 0:
                        return None
                self.base_cilinder()
                self.base_cone()
                o = Vector([0,0,0])
                op = Vector(self.origin)
                if color is not None:
                        color = Colors.color(color)
                v = vec
                if not canonica:
                        mat = Matrix(self.base)
                        mat.transpose()
                        v = mat @ vec

                if arrow:
                        t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                        obj = t.copy()
                        obj.name = name
                        obj.data = obj.data.copy()
                        obj.location = o
                        obj.scale = (scale,scale,(v - o).length - 2 * head_height)
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if color is not None:
                                self.add_material(obj,color.name,color.r,color.g,color.b)
                        if self.rotation is not None:
                                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location = op
                        self.scene.collection.objects.link(obj)

                        t = bpy.data.objects.get(&#34;Arrow_cone&#34;)
                        obj2 = t.copy()
                        obj2.data = obj2.data.copy()
                        obj2.name = &#34;Arrow&#34;
                        obj2.location =  v - 2 * head_height * v / v.length
                        obj2.scale = (scale + 0.01,scale + 0.01,head_height)
                        obj2.rotation_mode = &#39;QUATERNION&#39;
                        obj2.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if color is not None:
                                self.add_material(obj2,color.name,color.r,color.g,color.b)
                        if self.rotation is not None:
                                obj2.rotation_quaternion.rotate(self.rotation.quaternion)
                                obj2.location.rotate(self.rotation.quaternion)
                        obj2.location = op + obj2.location
                        self.scene.collection.objects.link(obj2)

                obj3 = None
                if axis != 0:
                        v = axis * v / v.length
                        t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                        obj3 = t.copy()
                        if not arrow:
                                obj3.name = &#34;Line&#34;
                        else:
                                obj3.name = &#34;Generated&#34;
                        obj3.data = obj3.data.copy()
                        obj3.scale = (scale / 2,scale / 2,(2 * v).length)
                        obj3.rotation_mode = &#39;QUATERNION&#39;
                        obj3.rotation_quaternion = v.to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if color is not None:
                                self.add_material(obj3,color.name,color.r,color.g,color.b)
                        if self.rotation is not None:
                                obj3.rotation_quaternion.rotate(self.rotation.quaternion)
                        if positive:
                                obj3.location = op
                        else:
                                obj3.location = op - v
                        self.scene.collection.objects.link(obj3)

                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                if arrow:
                        bpy.context.view_layer.objects.active = obj
                elif axis != 0:
                        bpy.context.view_layer.objects.active = obj3
                if arrow:
                        obj.select_set(True)
                        obj2.select_set(True)
                if obj3 is not None:
                        obj3.select_set(True)
                if arrow:
                        bpy.ops.object.join()
                bpy.ops.object.shade_smooth()
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                self.delete_base_cilinder()
                self.delete_base_cone()
                bpy.context.view_layer.objects.active = None
                if arrow:
                        return obj
                if axis != 0:
                        return obj3
                return None
        #
        #
        #
        def comp_times_vector(self,u,v):
                &#34;&#34;&#34;
                Computes the vectorial product u x v
                Parameters:
                   u, v: two Vectors
                &#34;&#34;&#34;
                return Vector([u.x * v.x,u.y * v.y,u.z * v.z])
        #
        #
        #
        def draw_line(self,start=[1,1,1],end=[10,10,10],scale=0.05,name=&#34;Line&#34;,color=&#34;Black&#34;):
                &#34;&#34;&#34;
                Draws a line from the point start to the point end. The reference given by self.origin,
                self.rotation and the basis self.base is used
                Parameters:
                   start: starting point of the line
                   end: ending point of the line
                   scale: scale of the cylinder
                   name: name of the object
                   color: color of the vector
                &#34;&#34;&#34;
                if start is None or end is None:
                        return
                self.base_cilinder()
                o = Vector([0,0,0])
                op = Vector(self.origin)
                if isinstance(start,Vector):
                        u = start
                else:
                        u = Vector(start)
                if isinstance(end,Vector):
                        v = end
                else:
                        v = Vector(end)
                mat = Matrix(self.base)
                mat.transpose()
                u = mat @ u
                v = mat @ v
                l = (v - u).length
                t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                obj = t.copy()
                obj.name = name
                obj.location = u
                obj.scale = (scale / 2,scale / 2,l)
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.rotation_quaternion = (v - u).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                if color is not None:
                        c = Colors.color(color)
                        self.add_material(obj,c.name,c.r,c.g,c.b)
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                obj.location = obj.location + op
                self.scene.collection.objects.link(obj)
                bpy.ops.object.shade_flat()
                self.delete_base_cilinder()
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_components(self,vector=None,color=&#34;Cyan&#34;,name=&#34;Components&#34;,scale=0.005):
                &#34;&#34;&#34;
                Draws the components of the the vector &#39;vector&#39; in the reference given by self.origin,
                self.rotation and the basis self.base
                Parameters:
                   vector: the vector
                   color: color of the lines of components
                   name: name of the object
                   scale: scale of the lines
                &#34;&#34;&#34;
                if vector is None:
                        return
                if isinstance(vector,Vector):
                        v = vector
                else:
                        v = Vector(vector)
                mat = Matrix(self.base)
                mat.transpose()
                list = [[0,0,0],[1,0,0],[1,1,0],[0,1,0],[0,0,1],[1,0,1],[1,1,1],[0,1,1]]
                lines = [[0,1],[1,2],[2,3],[0,3],[0,4],[1,5],[2,6],[3,7],[4,5],[5,6],[6,7],[4,7]]
                vecs = [self.comp_times_vector(v,Vector(x)) for x in list]
                count = 0
                for first, last in lines:
                        if count == 0:
                                this = name
                        else:
                                this = f&#34;Line{count}&#34;
                        count += 1
                        self.draw_line(start=vecs[first],end=vecs[last],scale=scale,name=this,color=color)
                t = bpy.data.objects.get(name)
                list = [t]
                for count in range(1,12):
                        obj = bpy.data.objects.get(f&#34;Line{count}&#34;)
                        if obj is not None:
                                list.append(obj)
                t = self.join(list)
                bpy.context.view_layer.objects.active = None
                return t
        #
        #
        #
        def draw_vectors(self,vectors=[],canonica=False,color=&#34;Black&#34;,scale=0.05,head_height=0.2,name=&#34;Vectors&#34;,axis=0):
                &#34;&#34;&#34;
                Draws a list of vectors.
                Parameters:
                   vectors: list of vectors
                   canonica: if True, the the vectors are expressed in the canonical basis.
                   color: color of the vectors
                   scale: scale of the cylinder
                   head_height: height of the head of the vector
                   axis: if not zero, draw also the line generated by every vector
                &#34;&#34;&#34;
                if len(vectors) == 0:
                        return
                count = 0
                for v in vectors:
                        if count == 0:
                                this = name
                        else:
                                this = f&#34;Vector{count}&#34;
                        count += 1
                        t = self.draw_vector(v,canonica,color,scale,head_height,axis,this)
                t = bpy.data.objects.get(name)
                list = [t]
                for count in range(1,len(vectors)+1):
                        obj = bpy.data.objects.get(f&#34;Vector{count}&#34;)
                        if obj is not None:
                                list.append(obj)
                t = self.join(list)
                return t
        #
        #
        #
        def draw_plane(self,normal=None,base=None,sizex=10,sizey=10,color=&#34;AzureBlueDark&#34;,name=&#39;Plane&#39;,opacity=1.0,thickness=0.01):
                &#34;&#34;&#34;
                Draws a plane with normal vector or base vectors. It passes through the point self.origin.
                Only normal or base can be not None
                Parameters:
                   normal: normal vector to the plane
                   base: list of two independent vectors
                   sizex: x-size of the plane
                   sizey: y-size of the plane
                   color: color of the plane
                   name: name of the plane
                   opacity: opacity of the plane
                   thickness: thickness of the plane
                &#34;&#34;&#34;
                if sizex == 0.0:
                        return
                bpy.ops.mesh.primitive_plane_add(size=sizex,enter_editmode=True,location=(0, 0, 0))
                bpy.context.object.name = name
                ##### bpy.ops.mesh.subdivide(number_cuts=6,quadcorner=&#39;INNERVERT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj = bpy.data.objects.get(name)
                if sizey is not None and sizey != 0.0:
                        t = sizey / sizex
                        obj.scale = [1,t,1]
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                if normal is not None and base is not None:
                        return
                if base is not None:
                        if len(base) != 2:
                                return
                        if isinstance(base[0],Vector):
                                v1 = base[0]
                        else:
                                v1 = Vector(base[0])
                        if isinstance(base[1],Vector):
                                v2 = base[1]
                        else:
                                v2 = Vector(base[1])

                        if self.base is None:
                                normal = v1.cross(v2)
                        else:
                                u1 = v1[0]*self.base[0] + v1[1]*self.base[1] + v1[2]*self.base[2]
                                u2 = v2[0]*self.base[0] + v2[1]*self.base[1] + v2[2]*self.base[2]
                                normal = u1.cross(u2)
                if normal is not None and normal != Vector([0,0,0]):
                        z = Vector([0,0,1])
                        quaternion = z.rotation_difference(normal)
                        obj.rotation_quaternion.rotate(quaternion)
                        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def simple_curve(self,f=None,tmin=0.0,tmax=1.0,steps=25,name=&#34;Simple curve&#34;,symmetry=None,draw=False):
                &#34;&#34;&#34;
                Return a curve defined by the parametrization f
                Parameters:
                   f: Parametrization of the curve
                   tmin: minimum value of the parameter
                   tmax: maximum value of the parameter
                   steps: number of steps
                   name: name of the curve
                   symmetry: None or a value in the list (&#39;XY&#39;,&#39;XZ&#39;,&#39;YZ&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;,&#39;O&#39;). Symmetry of the curve
                   draw: if True, the curve is drawn
                &#34;&#34;&#34;
                if f is None:
                        return None

                delta = (tmax - tmin)/steps
                t = tmin
                bm = bmesh.new()
                verts = []
                verts2 = []

                for k in range(steps + 1):
                        p = f(t)
                        q = None
                        verts.append(bm.verts.new(p))
                        if symmetry == &#39;XY&#39;:
                                q = (p[0],p[1],-p[2])
                        elif symmetry == &#39;XZ&#39;:
                                q = (p[0],-p[1],p[2])
                        elif symmetry == &#39;YZ&#39;:
                                q = (-p[0],p[1],p[2])
                        elif symmetry == &#39;X&#39;:
                                q = (p[0],-p[1],-p[2])
                        elif symmetry == &#39;Y&#39;:
                                q = (-p[0],p[1],-p[2])
                        elif symmetry == &#39;Z&#39;:
                                q = (-p[0],-p[1],p[2])
                        elif symmetry == &#39;O&#39;:
                                q = (-p[0],-p[1],-p[2])

                        if q is not None:
                                verts2.append(bm.verts.new(q))
                        t += delta
                        if t &gt; tmax:
                                t = tmax

                for i in range(len(verts) - 1):
                        bm.edges.new([verts[i], verts[i+1]])
                        if len(verts2) &gt; 0:
                                bm.edges.new([verts2[i], verts2[i+1]])

                me = bpy.data.meshes.new(&#39;placeholder_mesh&#39;)
                obj = bpy.data.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()

                if draw:
                        self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_elliptic_paraboloid(self,a=0.5,xmin=0.0,xmax=3.0,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;EllipticParaboloid&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws an elliptic paraboloid from the parabola z=a*t^2
                Parameters:
                   a: coefficient of the parabola
                   xmin: minimum value of x
                   xmax: maximum value of x
                   steps: numbers of steps to draw the parabola
                   scale: scaling factors in the X, Y and Z directions
                   color: color of the surface
                   name: name of the surface
                   opacity: opacity of the surface
                   thickness: thickness of the surface
                &#34;&#34;&#34;
                obj = self.simple_curve(f=lambda t:(t,0,a*t**2),tmin=xmin,tmax=xmax,steps=steps,name=name)
                modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                modifier.angle = 2 * math.pi
                modifier.steps = 128
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                self.scene.collection.objects.link(obj)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_one_sheet_hyperboloid(self,a=2.0,b=2.0,xmin=math.sqrt(2),xmax=5.0,steps=256,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperboloidOneSheet&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws a one sheet hyperboloid from the hyperbole z = \pm a*sqrt(x^2-b) in the XZ plane
                Parameters:
                   a, b: coefficients of the hyperbole
                   xmin: minimum value of x
                   xmax: maximum value of x
                   steps: numbers of steps to draw the parabola
                   scale: scaling factors in the X, Y and Z directions
                   color: color of the surface
                   name: name of the surface
                   opacity: opacity of the surface
                   thickness: thickness of the surface
                &#34;&#34;&#34;
                if xmin &lt; math.sqrt(b):
                        xmin = math.sqrt(b)
                delta = (xmax - xmin) / steps
                x = xmax
                bm = bmesh.new()
                verts = []

                for k in range(steps + 1):
                        if x &lt; math.sqrt(b):
                                z = 0.0
                        else:
                                z = - a * math.sqrt(x**2 - b)
                        verts.append(bm.verts.new((x,0,z)))
                        x -= delta
                x = math.sqrt(b)
                for k in range(steps):
                        x += delta
                        if x**2 &lt; b:
                                z = 0.0
                        else:
                                z = a * math.sqrt(x**2 - b)
                        verts.append(bm.verts.new((x,0,z)))

                for i in range(len(verts) - 1):
                        bm.edges.new([verts[i], verts[i+1]])

                me = self.meshes.new(&#39;placeholder_mesh&#39;)
                obj = self.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()
                modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                modifier.angle = 2 * math.pi
                modifier.steps = 128
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_two_sheets_hyperboloid(self,a=2.0,b=1.0,xmin=0.0,xmax=5.0,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperboloidTwoSheets&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws a two sheet hyperboloid from the hyperbole z = \pm a * math.sqrt(x**2+b) in the XZ plane
                Parameters:
                   a, b: coefficients of the hyperbole
                   xmin: minimum value of x
                   xmax: maximum value of x
                   steps: numbers of steps to draw the parabola
                   scale: scaling factors in the X, Y and Z directions
                   color: color of the surface
                   name: name of the surface
                   opacity: opacity of the surface
                   thickness: thickness of the surface
                &#34;&#34;&#34;
                delta = (xmax - xmin) / steps
                x = xmax
                bm = bmesh.new()
                verts = []
                count = 2 * steps + 2
                sign = 1
                for k in range(count):
                        if k == steps + 1:
                                sign = -1
                        z = sign * a * math.sqrt(x**2+b)
                        verts.append(bm.verts.new((x,0,z)))
                        if k == steps and xmin &gt; 0:
                                x = xmin
                        else:
                                x = x - sign * delta
                        if k == 0 or k == steps + 1:
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;placeholder_mesh&#39;)
                obj = self.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()

                modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                modifier.angle = 2 * math.pi
                modifier.steps = 128
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_cone(self,a=1.0,xmin=0.0,xmax=5.0,steps=50,scale=[1,1,1],half=False,color=&#34;AzureBlueDark&#34;,name=&#34;Cone&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws a cone from the line z = a*x in the XZ plane
                Parameters:
                   a: slope of the line
                   xmin: minimum value of x
                   xmax: maximum value of x
                   steps: numbers of steps to draw the parabola
                   scale: scaling factors in the X, Y and Z directions
                   half: if True, draws half cone
                   color: color of the surface
                   name: name of the surface
                   opacity: opacity of the surface
                   thickness: thickness of the surface
                &#34;&#34;&#34;
                delta = (xmax - xmin) / steps
                x = xmax
                bm = bmesh.new()
                verts = []
                count = 2 * steps + 2
                if xmin == 0.0:
                        count = 2 * steps + 1
                if half:
                        count = steps + 1
                for k in range(count):
                        z = a * x
                        verts.append(bm.verts.new((x,0,z)))
                        if k == steps and xmin &gt; 0:
                                x = - xmin
                        else:
                                x -= delta
                        if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;placeholder_mesh&#39;)
                obj = self.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()

                modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                modifier.angle = 2 * math.pi
                modifier.steps = 128
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_parabolic_cylinder(self,p=0.25,xmin=0.0,xmax=6.0,length=20,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;ParabolicCylinder&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws a parabolic cylinder from the parabola z=p*x^2 in the XZ plane
                Parameters:
                   p: coefficients of the parabola
                   xmin: minimum value of x
                   xmax: maximum value of x
                   length: length in the Y direction
                   steps: numbers of steps to draw the parabola
                   scale: scaling factors in the X, Y and Z directions
                   color: color of the surface
                   name: name of the surface
                   opacity: opacity of the surface
                   thickness: thickness of the surface
                &#34;&#34;&#34;
                delta = (xmax - xmin) / steps
                x = xmax
                bm = bmesh.new()
                verts = []
                count = 2 * steps + 2
                if xmin == 0.0:
                        count = 2 * steps + 1
                for k in range(count):
                        z = p * x**2
                        verts.append(bm.verts.new((x,0,z)))
                        if k == steps and xmin &gt; 0:
                                x = - xmin
                        else:
                                x -= delta
                        if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;ParabolicCylinderMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()

                bpy.context.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = obj
                bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
                bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
                bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
                bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0, length, 0),&#34;constraint_axis&#34;:(False, True, False),&#34;use_accurate&#34;:True})
                bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj.select_set(True)
                bpy.ops.transform.translate(value=(0, -length/2, 0),constraint_axis=(False, True, False))
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                obj.select_set(False)

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_hyperbolic_cylinder(self,a=1.0,b=4.0,xmin=2.0,xmax=6.0,length=20,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicCylinder&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws an hyperbolic cylinder from the hyperbole y = a * sqrt(x**2 - b) in the XY plane
                Parameters:
                   a, b: coefficients of the hyperbole
                   xmin: minimum value of x
                   xmax: maximum value of x
                   length: length in the Z direction
                   steps: numbers of steps to draw the parabola
                   scale: scaling factors in the X, Y and Z directions
                   color: color of the surface
                   name: name of the surface
                   opacity: opacity of the surface
                   thickness: thickness of the surface
                &#34;&#34;&#34;
                if xmin &lt; math.sqrt(b):
                        xmin = math.sqrt(b)
                delta = (xmax-xmin)/steps
                bm = bmesh.new()
                verts = []
                count = 2 * steps + 2
                if xmin == 0.0:
                        count = 2 * steps + 1
                for q, d in [[1,0],[-1,count]]:
                        x = xmax
                        sign = 1
                        for k in range(count):
                                if k == steps + 1:
                                        sign = -1
                                if x &lt; math.sqrt(b):
                                        x = math.sqrt(b)
                                y = sign * a * math.sqrt(x**2 - b)
                                verts.append(bm.verts.new((q * x,y,0)))
                                if k == steps and xmin &gt; math.sqrt(b):
                                        x = xmin
                                else:
                                        x = x - sign * delta
                                if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                                        continue
                                bm.edges.new([verts[d + k-1], verts[d + k]])

                me = self.meshes.new(&#39;HyperboliclinderMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()

                self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = obj
                bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
                bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
                bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
                bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0,0,length),&#34;constraint_axis&#34;:(False,False,True),&#34;use_accurate&#34;:True})
                bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj.select_set(True)
                bpy.ops.transform.translate(value=(0,0,-length/2),constraint_axis=(False,False,True))
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                obj.select_set(False)

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_elliptic_cylinder(self,a=8.0,b=5.0,amin=0.0,amax=2*math.pi,length=20,steps=200,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;EllipticCylinder&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws an eliptic cylinder from the ellipse
                  x = a*cos(t)
                  y = b*sin(t)
                in the XY plane
                Parameters:
                   a, b: coefficients of the ellipsw
                   amin: minimum value of the angle t
                   amax: maximum value of the angle t
                   length: length in the Z direction
                   steps: numbers of steps to draw the parabola
                   scale: scaling factors in the X, Y and Z directions
                   color: color of the surface
                   name: name of the surface
                   opacity: opacity of the surface
                   thickness: thickness of the surface
                &#34;&#34;&#34;
                if amin &lt; 0.0:
                        amin = 0.0
                if amax &gt; 2 * math.pi:
                        amax = 2 * math.pi
                delta = (amax-amin)/steps
                bm = bmesh.new()
                verts = []
                t = amin
                for k in range(steps + 1):
                        x = a * math.cos(t)
                        y = b * math.sin(t)
                        verts.append(bm.verts.new((x,y,0)))
                        t += delta
                        if k == 0:
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;EllipticCylinderMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()
                self.scene.collection.objects.link(obj)

                bpy.context.view_layer.objects.active = obj
                bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
                bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
                bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
                bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0,0,length),&#34;constraint_axis&#34;:(False,False,True),&#34;use_accurate&#34;:True})
                bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj.select_set(True)
                bpy.ops.transform.translate(value=(0,0,-length/2),constraint_axis=(False,False,True))
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                obj.select_set(False)

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_hyperbolic_paraboloid(self,a=0.2,b=0.4,xmax=10.0,ymax=10.0,steps=64,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicParaboloid&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws an hyperbolic paraboloid with equation z = a*x^2 - b*y^2
                Parameters:
                   a, b: coefficients of the parabolic hyperboloid
                   xmax: maximum  value of x
                   ymax: maxim value y
                   steps: numbers of steps to draw the parabola
                   scale: scaling factors in the X, Y and Z directions
                   color: color of the surface
                   name: name of the surface
                   opacity: opacity of the surface
                   thickness: thickness of the surface
                &#34;&#34;&#34;
                equ = lambda x,y: (x,y,a*x**2-b*y**2)
                obj = self.draw_surface(eq=equ,umin=-xmax,umax=xmax,usteps=steps,vmin=-ymax,vmax=ymax,vsteps=steps,thickness=thickness,opacity=opacity,pmax=0,name=&#34;Hyperbolic paraboloid&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),wrap_u=False,wrap_v=False,close_v=False)
                obj.scale = scale
                return obj
        #
        #
        #
        def draw_ellipsoid(self,radius=5.0,scale=[1.2,1.8,0.8],color=&#34;AzureBlueDark&#34;,name=&#34;Ellipsoid&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws en ellipsoid
                Parameters:
                   radius: radius of the sphere
                   scale: scaling factors in the X, Y and Z directions
                   color: color of the surface
                   name: name of the surface
                   opacity: opacity of the surface
                   thickness: thickness of the surface
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_uv_sphere_add(segments=128, ring_count=128, radius=radius, enter_editmode=False, location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                obj.select_set(False)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_plane_surface(self,origin=None,normal=None,base=None,sizex=10,sizey=10,vectors=False,scalelines=0.05,scalevector=0.01,
                                                color=&#34;AzureBlueDark&#34;,linecolor=&#34;BlueDarkDull&#34;,vectorcolor=&#34;Black&#34;,name=&#34;Plane&#34;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a plane with normal vector or base vectors. It passes through the point origin.
                Only normal or base can be not None
                Parameters:
                   origin: a point in the plane
                   normal: normal vector to the plane
                   base: list of two independent vectors
                   sizex: x-size of the plane
                   sizey: y-size of the plane
                   vectors: if True, draw the generators of the plane
                   scalelines: scale of the lines limiting the plane
                   scalevector: scale of the generators
                   color: color of the plane
                   linecolor: color of the lines limiting the plane
                   vectorcolor: color of the generators
                   name: name of the plane
                   opacity: opacity of the plane
                   thickness: thickness of the plane
                &#34;&#34;&#34;
                if normal is not None and base is not None:
                        return
                if normal is None and base is None:
                        return
                mat = Matrix(self.base)
                mat.transpose()
                if normal is not None:
                        if not isinstance(normal,Vector):
                                normal= Vector(normal)
                        normal = mat @ normal
                if base is not None:
                        if len(base) != 2:
                                return
                        if isinstance(base[0],Vector):
                                v1 = base[0]
                        else:
                                v1 = Vector(base[0])
                        if isinstance(base[1],Vector):
                                v2 = base[1]
                        else:
                                v2 = Vector(base[1])
                        v1 = mat @ v1
                        v2 = mat @ v2
                        normal = v1.cross(v2)

                if normal == Vector([0,0,0]):
                        return

                steps = 4
                delta = sizex / steps
                x = - sizex / 2
                bm = bmesh.new()
                verts = []
                for k in range(steps + 1):
                        verts.append(bm.verts.new((x,0,0)))
                        x += delta
                        if k == 0:
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;PlaneSurfaceMesh&#39;)
                obj = self.objects.new(&#39;PlaneSurface&#39;, me)
                bm.to_mesh(me)
                bm.free()

                bpy.context.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = obj
                bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
                bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
                bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
                bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0, sizey, 0),&#34;constraint_axis&#34;:(False, True, False),&#34;use_accurate&#34;:True})
                bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj.select_set(True)
                bpy.ops.transform.translate(value=(0, -sizey/2, 0),constraint_axis=(False, True, False))
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                obj.select_set(False)

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                if origin is not None:
                        if isinstance(origin,Vector):
                                op = op + origin
                        else:
                                op = op + Vector(origin)
                obj.location = o
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                lines = None
                vecs = None
                s = 0.0
                nodes = [[1,1,0],[-1,1,0],[-1,-1,0],[1,-1,0]]
                nodes = [self.comp_times_vector(Vector([sizex / 2,sizey / 2,0]),Vector(x)) for x in nodes]
                edges = [[0,1],[1,2],[2,3],[3,0]]

                if scalelines &gt; 0.0:
                        aux = self.origin
                        self.origin = Vector([0,0,0])
                        objects = []
                        aux2 = self.base
                        self.reset_base()
                        for edge in edges:
                                l = self.draw_line(start=nodes[edge[0]],end=nodes[edge[1]],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)
                        self.set_origin(aux)
                        self.set_base(aux2)


                if lines is not None:
                        obj = self.join([obj,lines])

                if vectors:
                        vecs = self.draw_vectors(nodes,True,color=vectorcolor,scale=scalevector,head_height=0.2,name=&#34;Vectors&#34;,axis=0)
                if vecs is not None:
                        obj = self.join([obj,vecs])
                obj.name = name

                if isinstance(normal,Vector):
                        n = normal
                else:
                        n = Vector(normal)
                z = Vector([0,0,1])
                quaternion = z.rotation_difference(n)
                tmp = obj.rotation_quaternion
                quaternion = tmp @ quaternion
                obj.rotation_quaternion = quaternion
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_point(self,radius=0.2,location=(0,0,0),name=&#34;Point&#34;,color=&#34;Black&#34;,opacity=1.0):
                &#34;&#34;&#34;
                Draws a point (in the reference self.origin, self.base)
                Parameters:
                   radius: radius of the point
                   location: location of the point
                   name: name of the point
                   color: color of the point
                   opacity: opacity of the point
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_uv_sphere_add(segments=16, ring_count=16, radius=radius, enter_editmode=False, location=location)
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                if not isinstance(location,Vector):
                        location = Vector(location)
                mat = Matrix(self.base)
                mat.transpose()
                location = mat @ location

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = 0.1
                modifier.offset = 0.0
                c = Colors.color(color)
                op = Vector(self.origin)
                obj.location = op + location
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                bpy.ops.object.shade_smooth()
                obj.select_set(False)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_cube(self,origin=None,scale=[1,1,1],scalelines=0.05,vectors=False,color=&#34;Blue&#34;,linecolor=&#34;Red&#34;,vectorcolor=&#34;Black&#34;,name=&#39;Parallelepiped&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a rectangular parallelepiped
                Parameters:
                   origin: center of the parallelepiped
                   scale: scale of the sides of the parallelepiped
                   scalelines: scale of the edges of the parallelepiped
                   vectors: if True, draws vectors from the origin to the vertices
                   color: color of the parallelepiped
                   linecolor: color of the edges
                   vectorcolor: color of the vectors
                   name: name of the parallelepiped
                   opacity: opacity of the parallelepiped
                   thickness: thickness of the parallelepiped
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_cube_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                if origin is not None:
                        if isinstance(origin,Vector):
                                op = op + origin
                        else:
                                op = op + Vector(origin)
                obj.location = o
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                vecs = None
                s = 0.0
                nodes = [[1+s,1+s,1+s],[-1-s,1+s,1+s],[-1-s,-1-s,1+s],[1+s,-1-s,1+s],
                                [1+s,1+s,-1-s],[-1-s,1+s,-1-s],[-1-s,-1-s,-1-s],[1+s,-1-s,-1-s]]
                nodes = [self.comp_times_vector(Vector(scale),Vector(x)) for x in nodes]
                edges =[[0,1],[1,2],[2,3],[3,0],[0,4],[1,5],[2,6],[3,7],[4,5],[5,6],[6,7],[7,4]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=op+nodes[edge[0]],end=op+nodes[edge[1]],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                if vectors:
                        vecs = self.draw_vectors(nodes,color=vectorcolor,scale=0.05,head_height=0.2,name=&#34;Vectors&#34;,axis=0)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.scale = scale

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                if lines is not None:
                        obj = self.join([obj,lines])

                if vecs is not None:
                        obj = self.join([obj,vecs])
                return obj
        #
        #
        #
        def draw_parallelepiped(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],u3=[0,0,1],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Parallelepiped&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a parallelepiped
                Parameters:
                   origin: base vertex of the parallelepiped
                   u1, u2, u3: vectors that gives the edges
                   scalelines: scale of the edges of the parallelepiped
                   color: color of the parallelepiped
                   linecolor: color of the edges
                   name: name of the parallelepiped
                   opacity: opacity of the parallelepiped
                   thickness: thickness of the parallelepiped
                &#34;&#34;&#34;
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                if not isinstance(u3,Vector):
                        u3 = Vector(u3)

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2
                u3 = mat @ u3

                bpy.ops.mesh.primitive_cube_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                verts = obj.data.vertices
                verts[0].co = op
                verts[1].co = op + u3
                verts[2].co = op + u2
                verts[3].co = op + u2 + u3
                verts[4].co = op + u1
                verts[5].co = op + u1 + u3
                verts[6].co = op + u1 + u2
                verts[7].co = op + u1 + u2 + u3

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                s = 0.0
                edges =[[0,1],[0,2],[0,4],[1,3],[1,5],[2,3],[2,6],[3,7],[4,5],[4,6],[5,7],[6,7]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj
        #
        #
        #
        def draw_tetrahedron(self,origin=[0,0,0],u1=[2,0,0],u2=[2*math.cos(math.pi/3),2*math.sin(math.pi/3),0],u3=[(2+2*math.cos(math.pi/3))/3,2*math.sin(math.pi/3)/3,2],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Tetrahedron&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a tetrahedron
                Parameters:
                   origin: base vertex of the tetrahedron
                   u1, u2, u3: vectors that gives the edges
                   scalelines: scale of the edges of the tetrahedron
                   color: color of the tetrahedron
                   linecolor: color of the edges
                   name: name of the tetrahedron
                   opacity: opacity of the tetrahedron
                   thickness: thickness of the tetrahedron
                &#34;&#34;&#34;
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                if not isinstance(u3,Vector):
                        u3 = Vector(u3)

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2
                u3 = mat @ u3

                bpy.ops.mesh.primitive_solid_add()
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                verts = obj.data.vertices
                verts[0].co = op + u3
                verts[1].co = op
                verts[2].co = op + u1
                verts[3].co = op + u2

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                s = 0.0
                edges =[[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj
        #
        #
        #
        def draw_pyramid(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],u3=[0.5,0.5,1],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Pyramid&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a pyramid
                Parameters:
                   origin: base vertex of the pyramid
                   u1, u2, u3: vectors that gives the edges
                   scalelines: scale of the edges of the pyramid
                   color: color of the pyramid
                   linecolor: color of the edges
                   name: name of the pyramid
                   opacity: opacity of the pyramid
                   thickness: thickness of the pyramid
                &#34;&#34;&#34;
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                if not isinstance(u3,Vector):
                        u3 = Vector(u3)

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2
                u3 = mat @ u3

                bpy.ops.mesh.primitive_cone_add(radius1=1, radius2=0, depth=2, enter_editmode=False, align=&#39;WORLD&#39;,vertices=4)
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                verts = obj.data.vertices
                verts[0].co = op
                verts[1].co = op + u1
                verts[2].co = op + u1 + u2
                verts[3].co = op + u2
                verts[4].co = op + u3

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                s = 0.0
                edges =[[0,1],[0,3],[0,4],[1,2],[1,4],[2,3],[2,4],[3,4]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj
        #
        #
        #
        def draw_parallelogram(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Parallelogram&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a parallelogram
                Parameters:
                   origin: base vertex of the parallelogram
                   u1, u2: vectors that gives the edges
                   scalelines: scale of the edges of the parallelogram
                   color: color of the parallelogram
                   linecolor: color of the edges
                   name: name of the parallelogram
                   opacity: opacity of the parallelogram
                   thickness: thickness of the parallelogram
                &#34;&#34;&#34;
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2

                bpy.ops.mesh.primitive_plane_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                verts = obj.data.vertices
                verts[0].co = op
                verts[1].co = op + u1
                verts[2].co = op + u2
                verts[3].co = op + u1 + u2

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                s = 0.0
                edges =[[0,1],[0,2],[1,3],[2,3]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj
        #
        #
        #
        def draw_polygon(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],points=[[0,0],[1,0],[0,1]],scalelines=0.075,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Polygon&#39;,opacity=1.0,thickness=0.0,vectors=None,scalevectors=0.01):
                &#34;&#34;&#34;
                Draws a polygon
                Parameters:
                   origin: base vertex of the polygon
                   u1, u2: base vectors for the polygon
                   points: list of coordinates of points. The coordinates are taken in the reference {origin; u1, u2}
                   scalelines: scale of the edges of the polygon
                   color: color of the polygon
                   linecolor: color of the edges
                   name: name of the polygon
                   opacity: opacity of the polygon
                   thickness: thickness of the polygon
                &#34;&#34;&#34;
                if len(points) &lt; 3:
                        return
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                for i in range(len(points)):
                        if not isinstance(points[i],Vector):
                                points[i] = Vector(points[i])

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2



                bpy.ops.curve.simple(Simple_Type=&#39;Polygon&#39;,Simple_sides=len(points),align=&#39;WORLD&#39;,location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)

                baricentre = Vector([0,0,0])
                verts = obj.data.splines[0].bezier_points
                for i in range(len(verts)):
                        verts[i].co = op + points[i][0] * u1 + points[i][1] * u2
                        baricentre += verts[i].co
                baricentre /= len(verts)

                for i in range(len(verts)):
                        verts[i].co -= baricentre
                obj.location = baricentre

                obj.select_set(True)
                bpy.ops.object.convert(target=&#39;MESH&#39;)

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                ps = [op + points[i][0] * u1 + points[i][1] * u2 for i in range(len(points))]
                lines = None
                if scalelines &gt; 0.0:
                        objects = []
                        for i in range(len(points)):
                                l = self.draw_line(start=ps[i],end=ps[(i + 1) % len(points)],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                if vectors is not None:
                        old = self.origin
                        self.set_origin(op)
                        ps = [points[i][0] * u1 + points[i][1] * u2 for i in range(len(points))]
                        vecs = self.draw_vectors(ps,color=vectors,scale=scalevectors)
                        self.set_origin(old)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])
                if vectors is not None:
                        obj = self.join([obj,vecs])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj

        #
        #
        #
        def draw_regular_polygon(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],vertexs=5,radius=1,scalelines=0.075,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;RegularPolygon&#39;,opacity=1.0,thickness=0.0,vectors=None):
                &#34;&#34;&#34;
                Draws a regular polygon
                Parameters:
                   origin: base vertex of the polygon
                   u1, u2: base vectors for the polygon
                   vertexs: number of vertices of the polygon
                   radius: radius of the polygon
                   scalelines: scale of the edges of the polygon
                   color: color of the polygon
                   linecolor: color of the edges
                   name: name of the polygon
                   opacity: opacity of the polygon
                   thickness: thickness of the polygon
                &#34;&#34;&#34;
                angle = 2*math.pi/vertexs
                points = [[radius*math.cos(i*angle),radius*math.sin(i*angle)] for i in range(vertexs)]
                return self.draw_polygon(origin=origin,u1=u1,u2=u2,points=points,scalelines=scalelines,color=color,linecolor=linecolor,name=name,opacity=opacity,thickness=thickness,vectors=vectors,scalevectors=radius/400)
        #
        #
        #
        def draw_triangle(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],points=[[0,0],[1,0],[0,1]],scalelines=0.075,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#34;Triangle&#34;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a triangle. It&#39;s a polygon with three vertices
                Parameters:
                   origin: base vertex of the triangle
                   u1, u2: base vectors for the triangle
                   points: list of coordinates of points. The coordinates are taken in the reference {origin; u1, u2}
                   scalelines: scale of the edges of the triangle
                   color: color of the triangle
                   linecolor: color of the edges
                   name: name of the triangle
                   opacity: opacity of the triangle
                   thickness: thickness of the triangle
                &#34;&#34;&#34;
                if len(points) != 3:
                        return
                self.draw_polygon(origin=origin,u1=u1,u2=u2,points=points,scalelines=scalelines,color=color,linecolor=linecolor,name=name,opacity=opacity,thickness=thickness)

        #
        #
        #
        def draw_points(self,points=[],name=&#39;Points&#39;,color=&#34;Blue&#34;,opacity=1):
                &#34;&#34;&#34;
                Draws a list of points
                Parameters:
                   origin:
                   points: list of points
                   name: name of the list of points
                   color: color of the points
                   opacity: opacity of the points
                &#34;&#34;&#34;
                bm = bmesh.new()
                verts = []
                for p in points:
                        verts.append(bm.verts.new(p))

                me = self.meshes.new(&#39;PointsMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()
                self.scene.collection.objects.link(obj)
                return obj
        #
        #
        #
        def draw_mesh(self,mesh=None,name=&#39;Mesh&#39;,color=&#34;Blue&#34;,opacity=1):
                &#34;&#34;&#34;
                Draws a mesh. This function is used by other functions
                Parameters:
                   mesh: the mesh to be drawn
                   name: name of the mesh
                   color: color of the mesh
                   opacity: opacity of the mesh
                &#34;&#34;&#34;
                bm = bmesh.new()
                verts = []
                for p in mesh.points:
                        verts.append(bm.verts.new(p))
                edges = [[0,1],[1,2],[2,3],[3,0]]
                for s in mesh.simplices:
                        for e in edges:
                                v = Vector(mesh.points[s[e[0]]]) - Vector(mesh.points[s[e[1]]])
                                edge = [verts[s[e[0]]],verts[s[e[1]]]]
                                try:
                                        bm.edges.new(edge)
                                except:
                                        pass
                me = self.meshes.new(&#39;PointsMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()
                self.scene.collection.objects.link(obj)
                return obj
        #
        #
        #
        def join(self,list):
                &#34;&#34;&#34;
                Joins a list of objects
                Parameters:
                   list: list of objects
                &#34;&#34;&#34;
                if len(list) &lt;= 1:
                        return
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.context.view_layer.objects.active = list[0]
                for obj in list:
                        obj.select_set(True)
                bpy.ops.object.join()
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                return list[0]
        #
        #
        #
        def vectors_to_quaternion(self,u1=Vector([1,0,0]),u2=Vector([0,1,0])):
                &#34;&#34;&#34;
                Returns the quaternion correspondint to the base {v1,v2,v3}
                u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
                       v1 = u1
                           v2 = u2 - u2.project(v1)
                           v1.normalize()
                           v2.normalize()
                           v3 = v1.cross(v2)
                &#34;&#34;&#34;
                if isinstance(u1,Vector):
                        v1 = u1
                else:
                        v1 = Vector(u1)
                if isinstance(u2,Vector):
                        v2 = u2
                else:
                        v2 = Vector(u2)
                v2 = v2 - v2.project(v1)
                v1.normalize()
                v2.normalize()
                v3 = v1.cross(v2)
                mat = Matrix([v1,v2,v3])
                mat.transpose()
                return mat.to_quaternion()
        #
        #
        #
        def ellipsoid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Ellipsoid&#34;,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an ellipsoid
                Parameters:
                   o: center of the ellipsoid
                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
                       v1 = u1
                           v2 = u2 - u2.project(v1)
                           v1.normalize()
                           v2.normalize()
                           v3 = v1.cross(v2)
                   a2, b2, c2: squares of semi-axes of the ellipsoid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 + z&#39;^2/c^2 = 1
                   principal: if True, the principal axis are drawn
                   canonica: if True, the canonical axis are drawn
                   color: color of the surface
                   name: name of the ellipsoid
                   cmax: the canonical axis are drawn between -cmax and cmax
                   pmax: the principal axis are drawn between -pmax and pmax
                   thickness: thickness of the ellipsoid
                   opacity: opaccity of the ellipsoid
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                c = math.sqrt(c2)
                self.draw_ellipsoid(radius=1,scale=[a,b,c],color=color,name=name,thickness=thickness,opacity=opacity)
        #
        #
        #
        def sphere(self,o=[0,0,0],r2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Sphere&#34;,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws a sphere of center &#39;o&#39; and radius squared equal to &#39;r2&#39;
                Parameters:
                   o: center of the sphere
                   r2: radius squared
                   principal: if True, the principal axis are drawn
                   canonica: if True, the canonical axis are drawn
                   color: color of the surface
                   name: name of the sphere
                   cmax: the canonical axis are drawn between -cmax and cmax
                   pmax: the principal axis are drawn between -cmax and cmax
                   thickness: thickness of the sphere
                   opacity: opacity of the sphere
                &#34;&#34;&#34;
                u1 = Vector([1,0,0])
                u2 = Vector([0,1,0])
                return self.ellipsoid(o=o,u1=u1,u2=u2,a2=r2,b2=r2,c2=r2,principal=principal,canonica=canonica,color=color,name=name,cmax=cmax,pmax=pmax,thickness=thickness,opacity=opacity)
        #
        #
        #
        def one_sheet_hyperboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;OneSheetHyperboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an one sheet hyperboloid
                Parameters:
                   o: center of the hyperboloid
                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
                   a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = 1
                   principal: if True, the principal axis are drawn
                   canonica: if True, the canonical axis are drawn
                   color: color of the surface
                   name: name of the hyperboloid
                   xmax: maximum value of the x coordinate
                   cmax: the canonical axis are drawn between -cmax and cmax
                   pmax: the principal axis are drawn between -cmax and cmax
                   thickness: thickness of the hyperboloid
                   opacity: opacity of the hyperboloid
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                c = math.sqrt(c2)
                if xmax is None:
                        xmax=5.0/a + 2
                xmax /= a
                self.draw_one_sheet_hyperboloid(a=1.0,b=1.0,xmin=1.0,xmax=xmax,scale=[a,b,c],color=color,name=name,thickness=thickness,opacity=opacity)
        #
        #
        #
        def two_sheets_hyperboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;TwoSheetParaboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws a two sheets hyperboloid
                Parameters:
                   o: center of the hyperboloid
                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
                   a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = -1
                   principal: if True, the principal axis are drawn
                   canonica: if True, the canonical axis are drawn
                   color: color of the surface
                   name: name of the hyperboloid
                   xmax: maximum value of the x coordinate
                   cmax: the canonical axis are drawn between -cmax and cmax
                   pmax: the principal axis are drawn between -cmax and cmax
                   thickness: thickness of the hyperboloid
                   opacity: opacity of the hyperboloid
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                c = math.sqrt(c2)
                if xmax is None:
                        xmax = 5.0/a + 2
                xmax /= a
                self.draw_two_sheets_hyperboloid(a=1.0,b=1.0,xmin=0.0,xmax=xmax,color=color,scale=[a,b,c],name=name,thickness=thickness,opacity=opacity)
        #
        #
        #
        def cone(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,half=False,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Cone&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws a cone
                Parameters:
                   o: center of the cone
                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
                   a2, b2, c2: squares of semi-axes of the cone. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = 0
                   half: if True draws half cone
                   principal: if True, the principal axis are drawn
                   canonica: if True, the canonical axis are drawn
                   color: color of the surface
                   name: name of the cone
                   xmax: maximum value of the x coordinate
                   cmax: the canonical axis are drawn between -cmax and cmax
                   pmax: the principal axis are drawn between -cmax and cmax
                   thickness: thickness of the cone
                   opacity: opacity of the cone
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                c = math.sqrt(c2)
                if xmax is None:
                        xmax = 10.0/a + 2
                xmax /= a
                self.draw_cone(a=1.0,xmin=0.0,xmax=xmax,steps=50,half=half,color=color,scale=[a,b,c],name=name,thickness=thickness,opacity=opacity)
        #
        #
        #
        def hyperbolic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicCylinder&#34;,xmax=None,zmax=20,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an hyperbolic cylinder
                Parameters:
                   o: center of the hyperbolic cylinder
                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
                   a2, b2: squares of semi-axes of the hyperbolic cylinder. The equation is x&#39;^2/a^2 - y&#39;^2/b^2 = 1
                   principal: if True, the principal axis are drawn
                   canonica: if True, the canonical axis are drawn
                   color: color of the surface
                   name: name of the hyperbolic cylinder
                   xmax: maximum value of the x coordinate
                   zmax: the hyperbolic cylinder is drawn between -zmax and zmax
                   cmax: the canonical axis are drawn between -cmax and cmax
                   pmax: the principal axis are drawn between -cmax and cmax
                   thickness: thickness of the hyperbolic cylinder
                   opacity: opacity of the hyperbolic cylinder
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                if xmax is None:
                        xmax = 5.0/a + 2
                xmax /= a
                obj = self.draw_hyperbolic_cylinder(a=1.0,b=1.0,xmin=1.0,xmax=xmax,length=zmax,steps=50,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)
        #
        #
        #
        def elliptic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;EllipticCylinder&#34;,zmax=20,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an elliptic cylinder
                Parameters:
                   o: center of the elliptic cylinder
                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
                   a2, b2: squares of semi-axes of the elliptic cylinder. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 = 1
                   principal: if True, the principal axis are drawn
                   canonica: if True, the canonical axis are drawn
                   color: color of the surface
                   name: name of the elliptic cylinder
                   zmax: the elliptic cylinder is drawn between -zmax and zmax
                   cmax: the canonical axis are drawn between -cmax and cmax
                   pmax: the principal axis are drawn between -cmax and cmax
                   thickness: thickness of the elliptic cylinder
                   opacity: opacity of the elliptic cylinder
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                self.draw_elliptic_cylinder(a=1.0,b=1.0,length=zmax,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)
        #
        #
        #
        def elliptic_paraboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;EllipticParaboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an elliptic paraboloid
                Parameters:
                   o: vertex of the elliptic paraboloid
                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
                   a2, b2: squares of semi-axes of the elliptic paraboloid. The equation is z = x&#39;^2/a^2 + y&#39;^2/b^2
                   principal: if True, the principal axis are drawn
                   canonica: if True, the canonical axis are drawn
                   color: color of the surface
                   name: name of the elliptic paraboloid
                   xmax: maximum value of the coordinate x
                   cmax: the canonical axis are drawn between -cmax and cmax
                   pmax: the principal axis are drawn between -cmax and cmax
                   thickness: thickness of the elliptic paraboloid
                   opacity: opacity of the elliptic paraboloid
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                if xmax is None:
                        xmax = 10.0/a
                xmax /= a
                self.draw_elliptic_paraboloid(a=1.0,xmin=0.0,xmax=xmax,steps=50,scale=[a,b,1],color=color,name=name,opacity=opacity,thickness=thickness)
        #
        #
        #
        def hyperbolic_paraboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicParaboloid&#34;,xmax=None,ymax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an hyperbolic paraboloid
                Parameters:
                   o: vertex of the hyperbolic paraboloid
                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
                   a2, b2: squares of semi-axes of the hyperbolic paraboloid. The equation is z = x&#39;^2/a^2 - y&#39;^2/b^2
                   principal: if True, the principal axis are drawn
                   canonica: if True, the canonical axis are drawn
                   color: color of the surface
                   name: name of the elliptic paraboloid
                   xmax: maximum value of the coordinate x
                   ymax: maximum value of the coordinate y
                   cmax: the canonical axis are drawn between -cmax and cmax
                   pmax: the principal axis are drawn between -cmax and cmax
                   thickness: thickness of the hyperbolic paraboloid
                   opacity: opacity of the hyperbolic paraboloid
                &#34;&#34;&#34;
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                if xmax is None:
                        xmax = 10.0/a + 2
                if ymax is None:
                        ymax = 10.0/b + 1
                xmax /= a
                ymax /= b
                obj = self.draw_hyperbolic_paraboloid(a=1.0,b=1.0,xmax=xmax,ymax=ymax,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)

                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                obj.location = o
        #
        #
        #
        def parabolic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;ParabolicCylinder&#34;,xmax=None,ymax=30,cmax=20,pmax=20,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an hyperbolic paraboloid
                Parameters:
                   o: vertex of the hyperbolic paraboloid
                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
                   a2, b2: squares of semi-axes of the hyperbolic paraboloid. The equation is z = x&#39;^2/a^2 - y&#39;^2/b^2
                   principal: if True, the principal axis are drawn
                   canonica: if True, the canonical axis are drawn
                   color: color of the surface
                   name: name of the elliptic paraboloid
                   xmax: maximum value of the coordinate x
                   ymax: maximum value of the coordinate y
                   cmax: the canonical axis are drawn between -cmax and cmax
                   pmax: the principal axis are drawn between -cmax and cmax
                   thickness: thickness of the hyperbolic paraboloid
                   opacity: opacity of the hyperbolic paraboloid
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                coef = 1.0
                if a &lt; 0:
                        coef = -1
                if xmax is None:
                        xmax = 5.0/a + 1.5
                xmax /= a
                self.draw_parabolic_cylinder(p=coef,xmin=0.0,xmax=xmax,length=ymax,color=color,name=name,scale=[a,1,1],thickness=thickness,opacity=opacity)
        #
        #
        #
        def draw_simple_curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.02,color=&#34;White&#34;,name=&#34;Curve&#34;):
                &#34;&#34;&#34;
                Draws a parametric curve
                Parameters:
                   fun: the parametric function
                   tmin: minimum value of the parameter
                   tmax: maximum value of the parameter
                   steps: number of steps
                   thickness: thickness of the curve
                   color: color of the curve
                   name: name of the curve
                &#34;&#34;&#34;
                if fun is None:
                        return None
                delta = (tmax - tmin) / steps
                t = tmin

                curve = bpy.data.curves.new(&#39;myCurve&#39;, type=&#39;CURVE&#39;)
                curve.dimensions = &#39;3D&#39;
                curve.resolution_u = 2

                line = curve.splines.new(&#39;POLY&#39;)
                line.points.add(steps)

                for i in range(steps+1):
                        p = fun(t)
                        p.append(1)
                        line.points[i].co = p
                        t += delta

                obj = bpy.data.objects.new(name, curve)
                curve.bevel_depth = thickness

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
                self.scene.collection.objects.link(obj)
                return obj
        #
        #
        #
        def draw_curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,axis=False,zaxis=True,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0])):
                &#34;&#34;&#34;
                Draws a curve in a reference R&#39; determined by the origin o and basis {v1, v2, v3} constructed from u1 and u2
                Parameters:
                   fun: the parametric function
                   tmin: minimum value of the parameter
                   tmax: maximum value of the parameter
                   steps: number of steps
                   thickness: thickness of the curve
                   name: name of the curve
                   color: color of the curve
                   axis: if True draws the axis of the reference R&#39;
                   zaxis: if True draws the z&#39; axis
                   o: origin of the reference R&#39;
                   u1, u2: vectors to construct the basis {v1, v2, v3}
                &#34;&#34;&#34;
                if fun is None:
                        return None
                qt = self.vectors_to_quaternion(u1,u2)
                delta = (tmax - tmin) / steps
                t = tmin
                bm = bmesh.new()
                verts = []

                pmax = 0
                for k in range(steps + 1):
                        p = fun(t)
                        m = max(map(abs,p))
                        if m &gt; pmax:
                                pmax = m
                        verts.append(bm.verts.new(p))
                        t += delta
                        if t &gt; tmax:
                                t = tmax

                for i in range(len(verts) - 1):
                        bm.edges.new([verts[i], verts[i+1]])

                me = self.meshes.new(&#39;placeholder_mesh&#39;)
                obj = self.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()

                modifier = obj.modifiers.new(type=&#39;SKIN&#39;,name = &#39;skin&#39;)
                for v in obj.data.skin_vertices[0].data:
                        v.radius = (thickness,thickness)

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
                self.set_origin(o)
                self.set_rotation(quaternion=qt)
                if self.rotation is not None:
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                if axis:
                        self.draw_base_axis(axis = pmax+3,positive=False,name=&#34;Referència escollida&#34;,zaxis=zaxis)
                self.scene.collection.objects.link(obj)
                bpy.ops.object.shade_smooth()
                obj.location = o
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,axis=False,zaxis=True,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),symmetry=None,change=False):
                &#34;&#34;&#34;
                Draws a curve in a reference R&#39; determined by the origin o and basis {v1, v2, v3} constructed from u1 and u2 and
                the symmetric curve or curves from the parameter &#39;symmetry&#39;
                Parameters:
                   fun: the parametric function
                   tmin: minimum value of the parameter
                   tmax: maximum value of the parameter
                   steps: number of steps
                   thickness: thickness of the curve
                   name: name of the curve
                   color: color of the curve
                   axis: if True draws the axis of the reference R&#39;
                   zaxis: if True draws the z&#39; axis
                   o: origin of the reference R&#39;
                   u1, u2: vectors to construct the basis {v1, v2, v3}
                   symmetry: list of values in (&#39;XY&#39;,&#39;XZ&#39;,&#39;YZ&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;,&#39;O&#39;). For every value S, draw the symmetric curve respect to S
                   change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                if fun is None:
                        return None
                obj = self.draw_curve(fun,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=name,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)

                if symmetry is None:
                        if change:
                                self.set_origin(o)
                                self.set_base([u1,u2],orthonormal=True)
                        return obj
                objs = [obj]
                if not isinstance(symmetry,list):
                        symmetry = [symmetry]
                for s in symmetry:
                        namem = name + s
                        if s == &#39;XY&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (p[0],p[1],-p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;XZ&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (p[0],-p[1],p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;YZ&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (-p[0],p[1],p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;X&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (p[0],-p[1],-p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;Y&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (-p[0],p[1],-p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;Z&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (-p[0],-p[1],p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;O&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (-p[0],-p[1],-p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                if change:
                        self.set_origin(o)
                        self.set_base([u1,u2],orthonormal=True)
                return self.join(objs)
        #
        #
        #
        def draw_circle(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),axis=False,zaxis=False,radius=1,steps=25,thickness=0.01,name=&#34;Circle&#34;,color=&#34;White&#34;,change=False):
                &#34;&#34;&#34;
                Draws a circle of center &#39;center&#39; and radius &#39;radius&#39; in the plane determined by vectors u1 and u2
                Parameters:
                   center: center of the circle
                   u1, u2: vectors to construct the basis {v1, v2, v3}
                   axis: if True draws the axis of the reference R&#39;
                   zaxis: if True draws the z&#39; axis
                   radius: radius of the circle
                   steps: number of steps
                   thickness: thickness of the curve
                   name: name of the curve
                   color: color of the curve
                   change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                if change:
                        self.set_origin(center)
                        self.set_base([u1,u2],orthonormal=True)
                return self.draw_curve(lambda t: (radius*math.cos(t),radius*math.sin(t),0),tmin=0.0,tmax=2*math.pi,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
        #
        #
        #
        def draw_ellipse(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,b=1,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Ellipse&#34;,color=&#34;White&#34;,change=False):
                &#34;&#34;&#34;
                Draws an ellipse of center &#39;center&#39; and semi-axes a and b in the plane determined by vectors u1 and u2
                Parameters:
                   center: center of the ellipse
                   u1, u2: vectors to construct the basis {v1, v2, v3}
                   a, b: semi-axes of the ellipse
                   axis: if True draws the axis of the reference R&#39;
                   zaxis: if True draws the z&#39; axis
                   steps: number of steps
                   thickness: thickness of the curve
                   name: name of the curve
                   color: color of the curve
                   change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                if change:
                        self.set_origin(center)
                        self.set_base([u1,u2],orthonormal=True)
                return self.draw_curve(lambda t: (a*math.cos(t),b*math.sin(t),0),tmin=0.0,tmax=2*math.pi,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
        #
        #
        #
        def draw_parabola(self,vertex=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,xmax=3.0,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Parabola&#34;,color=&#34;White&#34;,change=False):
                &#34;&#34;&#34;
                Draws a parabola of vertex &#39;vertex&#39; of equation y&#39;=ax&#39;^2 in the reference {vertex; v1, v2, v3} determined by vectors u1 and u2
                Parameters:
                   vertex: vertex of the parabola
                   u1, u2: vectors to construct the basis {v1, v2, v3}
                   a: coefficient of the parabola
                   xmax: maximum value of x&#39;
                   axis: if True draws the axis of the reference R&#39;
                   zaxis: if True draws the z&#39; axis
                   steps: number of steps
                   thickness: thickness of the curve
                   name: name of the curve
                   color: color of the curve
                   change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                if change:
                        self.set_origin(vertex)
                        self.set_base([u1,u2],orthonormal=True)
                return self.draw_curve(lambda t: (t,a*t**2,0),tmin=-xmax,tmax=xmax,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=vertex,u1=u1,u2=u2)
        #
        #
        #
        def draw_hyperbole(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,b=1,ymax=3.0,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Hyperbole&#34;,color=&#34;White&#34;,change=False):
                &#34;&#34;&#34;
                Draws an hyperbole of center &#39;center&#39; and semi-axes a and b in the plane determined by vectors u1 and u2
                Parameters:
                   center: center of the hyperbole
                   u1, u2: vectors to construct the basis {v1, v2, v3}
                   a, b: semi-axes of the hyperbole
                   ymax: maximum value of the y&#39;
                   axis: if True draws the axis of the reference R&#39;
                   zaxis: if True draws the z&#39; axis
                   steps: number of steps
                   thickness: thickness of the curve
                   name: name of the curve
                   color: color of the curve
                   change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                c1 = self.draw_curve(lambda t: (a*math.sqrt(1+t**2/b**2),t,0),tmin=-ymax,tmax=ymax,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
                c2 = self.draw_curve(lambda t: (-a*math.sqrt(1+t**2/b**2),t,0),tmin=-ymax,tmax=ymax,axis=False,zaxis=False,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
                self.join([c1,c2])
                if change:
                        self.set_origin(center)
                        self.set_base([u1,u2],orthonormal=True)
                return c1
        #
        #
        #
        def draw_surface(self,eq=None,umin=-1,umax=1,usteps=64,vmin=-1,vmax=1,vsteps=64,thickness=0.02,opacity=1.0,pmax=10,name=&#34;Surface&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),wrap_u=False,wrap_v=False,close_v=False):
                &#34;&#34;&#34;
                Draws a parametric surface in the reference R&#39;
                Parameters:
                   eq: parametric equacion f(u,v)
                   umin: minimum value of u
                   umax: maximum value of u
                   usteps: steps in the u direction
                   vmin: minimum value of v
                   vmax: maximum value of v
                   vsteps: steps in the v direction
                   thickness: thickness of the surface
                   opacity: opacity of the surface
                   color: color of the surface
                   pmax: the principal axis are drawn between -cmax and cmax
                   name: name of the surface
                   color: color of the surface
                   axis: if True draw the axis of the reference {o, v1, v2, v3}
                   o: origin of the reference R&#39;
                   u1, u2: vectors to construct the basis {v1, v2, v3}
                   scale: scale coefficients
                   wrap_u: wrap the u coordinate
                   wrap_v: wrap the u coordinate
                   close_v: close the v coordinate
                &#34;&#34;&#34;
                if eq is None:
                        return

                q = self.vectors_to_quaternion(u1,u2)
                draw_parametric_surface(eq=eq,range_u_min=umin,range_u_max=umax,range_u_step=usteps,range_v_min=vmin,range_v_max=vmax,range_v_step=vsteps,name=name,wrap_u=wrap_u,wrap_v=wrap_v,close_v=close_v)

                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)
                obj.show_wire = False

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if self.rotation is not None:
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                if axis:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència escollida&#34;)

                bpy.ops.object.shade_smooth()
                obj.location = o
                obj.select_set(False)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_function(self,f=None,xmin=-3,xmax=3,xsteps=64,ymin=-3,ymax=3,ysteps=64,thickness=0.02,opacity=1.0,pmax=10,name=&#34;Function&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0])):
                &#34;&#34;&#34;
                Draws a function of two variables f(x,y) i the reference R&#39; = {o, v1, v2, v3}
                Parameters:
                   f: the function of two variables f(x,y)
                   xmin: minimum value of x
                   xmax: maximum value of x
                   xsteps: steps in the x direction
                   ymin: minimum value of y
                   ymax: maximum value of y
                   ysteps: steps in the x direction
                   thickness: thickness of the surface
                   opacity: opacity of the surface
                   pmax: the axis are drawn between -pmax and pmax
                   name: name of the surface
                   color: color of the surface
                   axis: if True the axis of the reference R&#39; are drawn
                   o: origin of the reference R&#39;
                   u1, u2: vectors to construct the basis {v1, v2, v3}
                &#34;&#34;&#34;
                if f is None:
                        return None
                return self.draw_surface(eq=lambda x,y:(x,y,f(x,y)),umin=xmin,umax=xmax,usteps=xsteps,vmin=ymin,vmax=ymax,vsteps=ysteps,thickness=thickness,opacity=opacity,pmax=pmax,name=name,color=color,axis=axis,o=o,u1=u1,u2=u2,wrap_u=False,wrap_v=False,close_v=False)
        #
        #
        #
        def draw_vector_field(self,f=None,xmin=-3,xmax=3,xsteps=8,ymin=-3,ymax=3,ysteps=8,zmin=-3,zmax=3,zsteps=8,name=&#34;Vector Field&#34;,color=&#34;Red&#34;,scale=0.02,head_height=0.05):
                &#34;&#34;&#34;
                Draws a vector field
                Parameters:
                   f: the vector field
                   xmin: minimum value of x
                   xmax: maximum value of x
                   xsteps: steps in the x direction
                   ymin: minimum value of y
                   ymax: maximum value of y
                   ysteps: steps in the y direction
                   zmin: minimum value of z
                   zmax: maximum value of z
                   zsteps: steps in the z direction
                   name: name of the vector field
                   color: color of the vector field
                   scale: scale of the vectors
                   head_height: head height of the vectors
                &#34;&#34;&#34;
                if f is None:
                        return None
                xstep = (xmax - xmin)/xsteps
                ystep = (ymax - ymin)/ysteps
                zstep = (zmax - zmin)/zsteps
                if xstep == 0 or ystep == 0 or zstep == 0:
                        return None
                vectors = []
                count = 1
                x = xmin
                while x &lt;= xmax:
                        y = ymin
                        while y &lt;= ymax:
                                z = zmin
                                while z &lt;= zmax:
                                        o = Vector([x,y,z])
                                        v = f(x,y,z)
                                        if not isinstance(v,Vector):
                                                v = Vector(v)
                                        self.set_origin(o)
                                        vec = self.draw_vector(v,color=color,name=f&#34;Vector{count}&#34;,scale=scale,head_height=head_height)
                                        if vec is not None:
                                                vectors.append(vec)
                                        z += zstep
                                        count += 1
                                y += ystep
                        x += xstep
                v = self.join(vectors)
                bpy.context.object.name = name
                return v
        #
        #
        #
        def revolution_surface(self,fun=None,tmin=0.0,tmax=1.0,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),pmax=0,steps=256,thickness=0.025,axis=&#39;Z&#39;,name=&#34;Revolution surface&#34;,color=&#34;AzureBlueDark&#34;):
                &#34;&#34;&#34;
                Draws a revolution surface from a curve in the reference R&#39;
                Parameters:
                   fun: parametric equacion of the curve
                   steps: number of steps
                   axis: axis of revolution. It must be &#39;X&#39;, &#39;Y&#39; or &#39;Z&#39;
                   o: origin of the reference R&#39;
                   u1, u2: vectors to construct the basis {v1, v2, v3}
                   pmax: the principal axis are drawn between -pmax and pmax
                   color: color of the surface
                &#34;&#34;&#34;
                if fun is None:
                        return None
                q = self.vectors_to_quaternion(u1,u2)
                obj = self.simple_curve(fun,tmin=tmin,tmax=tmax,steps=steps,name=name)
                m = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                m.levels = 4
                m.subdivision_type = &#39;SIMPLE&#39;
                m = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                m.thickness = thickness
                m.offset = 1.0
                m = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                m.angle = 2*math.pi
                m.steps = steps
                m.axis =  axis
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
                bpy.context.scene.collection.objects.link(obj)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if self.rotation is not None:
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                if pmax &gt; 0.0:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència R&#39;&#34;)
                bpy.ops.object.shade_smooth()
                obj.location = o
                obj.select_set(False)
                bpy.context.view_layer.objects.active = None
        #
        #
        #
        def animate_revolution_surface(self,fun=None,tmin=0.0,tmax=1.0,steps=256,curvethicknes=0.025,thickness=0.025,frames=3,angle=3,radians=False,axis=&#39;Z&#39;,symmetry=None,name=&#34;Revolution surface&#34;,color=&#34;AzureBlueDark&#34;,point=None):
                &#34;&#34;&#34;
                Draws and animates a revolution surface from a curve
                Parameters:
                   fun: parametric equacion of the curve
                   steps: number of steps to graw the curve
                   curvethicknes: thickness of the curve
                   frames: number of frames at each step of revolution
                   angle: step angle of the revolution
                   radians: if True, angle must be in radians
                   axis: axis of revolution. It must be &#39;X&#39;, &#39;Y&#39; or &#39;Z&#39;
                   name: name of the surface
                   color: color of the surface
                   point: if not None draw three points and a cercle. Must be a float between tmax and tmin
                &#34;&#34;&#34;
                if radians:
                        angle *= 180/math.pi
                stepsr = int(360/angle) + 1
                angle = 360/stepsr
                if fun is None:
                        return None
                if axis == &#39;X&#39;:
                        r = Rotation(angle,Vector([1,0,0]))
                        d1 = Vector([0,1,0])
                        d2 = Vector([0,0,1])
                elif axis == &#39;Y&#39;:
                        r = Rotation(angle,Vector([0,1,0]))
                        d1 = Vector([0,0,1])
                        d2 = Vector([1,0,0])
                elif axis == &#39;Z&#39;:
                        r = Rotation(angle,Vector([0,0,1]))
                        d1 = Vector([1,0,0])
                        d2 = Vector([0,1,0])
                else:
                        return None

                if point is not None:
                        try:
                                tp = 1.0 * point
                        except:
                                pass
                        if not isinstance(tp,float):
                                return None
                        if tp &lt; tmin or tp &gt; tmax:
                                tp = random.uniform(tmin,tmax)
                        zp = Vector(fun(tp))
                        e = d1.cross(d2)
                        z0 = zp.project(e)

                p2 = self.curve(fun,tmin=tmin,tmax=tmax,steps=steps,thickness=curvethicknes,color=&#34;Red&#34;,name=name,symmetry=symmetry)
                p1 = self.curve(fun,tmin=tmin,tmax=tmax,steps=steps,thickness=1.05*curvethicknes,color=&#34;Blue&#34;,name=name,symmetry=symmetry)
                obj = self.simple_curve(fun,tmin=tmin,tmax=tmax,steps=steps,name=&#34;Surface of revolution&#34;,symmetry=symmetry)
                if point is not None:
                        m1 = self.draw_point(radius=0.1,location=zp,name=&#34;Punt p0&#34;,color=&#34;Red&#34;)
                        m2 = self.draw_point(radius=0.1,location=zp,name=&#34;Punt p1&#34;,color=&#34;Black&#34;)
                        m3 = self.draw_point(radius=0.1,location=z0,name=&#34;Punt p2&#34;,color=&#34;Blue&#34;)
                        l1 = self.draw_line(start=z0,end=zp,scale=0.04,name=&#34;Línia 1&#34;,color=&#34;Black&#34;)
                        l2 = self.draw_line(start=z0,end=zp,scale=0.03,name=&#34;Línia 2&#34;,color=&#34;Red&#34;)
                        self.draw_circle(center=z0,u1=d1,u2=d2,radius=(zp-z0).length,steps=128,thickness=0.005,name=&#34;Circle&#34;,color=&#34;Cyan&#34;)

                m = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                m.levels = 4
                m.subdivision_type = &#39;SIMPLE&#39;
                m = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                m.thickness = thickness
                m.offset = 1.0
                m = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                m.angle = 0.0
                m.steps = steps
                m.axis =  axis
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
                bpy.context.scene.collection.objects.link(obj)

                bpy.context.scene.frame_set(self.frame)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                obj.keyframe_insert(data_path=&#39;modifiers[&#34;Screw&#34;].angle&#39;,index=-1)
                p2.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if point is not None:
                        l1.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        m2.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn = frames + self.frame
                for i in range(0,stepsr):
                        bpy.context.scene.frame_set(fn)
                        p2.rotation_quaternion.rotate(r.quaternion)
                        p2.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        obj.modifiers[&#34;Screw&#34;].angle = 2 * (i+1) * math.pi / stepsr
                        obj.modifiers[&#34;Screw&#34;].steps = i+1
                        obj.keyframe_insert(data_path=&#39;modifiers[&#34;Screw&#34;].angle&#39;,index=-1)
                        if point is not None:
                                l1.rotation_quaternion.rotate(r.quaternion)
                                l1.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                                m2.location.rotate(r.quaternion)
                                m2.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames
                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()
        #
        #
        #
        def rotate_object(self,obj=None,axis=&#39;Z&#39;,frames=1,origin=Vector([0,0,0]),localaxis=None,localangle=None,helicoidal=0.0,rounds=1):
                &#34;&#34;&#34;
                Rotates an object around the axis
                Parameters:
                   obj: the object
                   axis: it must be &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39; or a Vector
                   local: if True the center of rotation is the location of the object
                &#34;&#34;&#34;
                if obj is None:
                        return None
                if isinstance(axis,str):
                        axis = axis.strip().upper()
                if axis == &#39;X&#39;:
                        u = Vector([1,0,0])
                elif axis == &#39;Y&#39;:
                        u = Vector([0,1,0])
                elif axis == &#39;Z&#39;:
                        u = Vector([0,0,1])
                elif isinstance(axis,Vector):
                        u = axis
                else:
                        u = Vector(axis)

                if not isinstance(origin,Vector):
                        origin = Vector(origin)

                line = None
                if localaxis is not None and localangle is not None:
                        old = self.origin
                        self.set_origin(obj.location)
                        l = obj.dimensions.length / 2
                        line = self.draw_vector(localaxis,axis=l,scale=0.1,arrow=False,positive=False,color=&#34;Orange&#34;,name=&#34;Eix rotació local&#34;)
                        line.select_set(True)
                        bpy.ops.object.origin_set(type=&#39;ORIGIN_CENTER_OF_MASS&#39;, center=&#39;MEDIAN&#39;)
                        line.select_set(False)
                        self.set_origin(old)
                        lr = Rotation(localangle,localaxis)

                r = Rotation(1/int(frames),u)
                axis, angle = r.to_axis_angle()
                t = helicoidal * axis
                bpy.context.scene.frame_set(self.frame)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn = self.frame + 1
                for i in range(int(frames) * int(rounds) * 360):
                        bpy.context.scene.frame_set(fn)
                        if line is None:
                                obj.rotation_quaternion.rotate(r.quaternion)
                        else:
                                obj.rotation_quaternion.rotate(lr.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        w = obj.location - origin
                        w.rotate(r.quaternion)
                        obj.location = origin + w + t
                        if line is not None:
                                line.location = origin + w + t
                                line.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += 1
                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()
        #
        #
        #
        def rotate_vector(self,vector=None,axis=&#39;Z&#39;):
                &#34;&#34;&#34;
                Rotates a vector around the axis
                Parameters:
                   vector: the vector
                   axis: it must be &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39; or a vector
                &#34;&#34;&#34;
                if vector is None:
                        return None
                if axis == &#39;X&#39;:
                        u = Vector([1,0,0])
                elif axis == &#39;Y&#39;:
                        u = Vector([0,1,0])
                elif axis == &#39;Z&#39;:
                        u = Vector([0,0,1])
                elif isinstance(axis,Vector):
                        u = axis
                else:
                        u = Vector(axis)

                self.draw_vector(vector,color=&#34;Black&#34;)
                obj = self.draw_vector(vector,color=&#34;Red&#34;)
                w1 = u.orthogonal().normalized()
                vec1 = vector.project(u)
                w3 = vec1.normalized()
                w2 = w3.cross(w1)
                a = vec1.length
                b = (vector-vec1).length
                p2 = b**2/a**2
                self.rotate_object(obj,u)
                self.draw_vector(u,axis=1.4*a,positive=False,color=&#34;White&#34;)
                self.cone(u1=w1,u2=w2,a2=p2,b2=p2,c2=1,half=True, principal=False,canonica=False,xmax=b,color=&#34;GrayLight&#34;,opacity=0.2)
        #
        #
        #
        def rotate_object_by_axis_angle(self,obj=None,axis=Vector([1,0,0]),angle=90,amax=15,frames=1,scaleaxis=0.075,local=False):
                &#34;&#34;&#34;
                Rotates an object around an angle &#39;angle&#39; around the axis
                Parameters:
                   obj: the object
                   axis: any non nul Vectors
                   angle: the angle of rotation in degrees
                   frames: increment of the frame set
                   scaleaxis: scale value for draw_base_axis
                   local: if True the center of rotation is the location of the object
                &#34;&#34;&#34;
                if obj is None:
                        return None
                if isinstance(axis,Vector):
                        u = axis
                else:
                        u = Vector(axis)
                if u.length == 0.0 or angle &lt;= 1:
                        return

                self.draw_base_axis(axis = amax,scale=scaleaxis,positive=False)
                self.draw_vector(u,scale=0.1,axis=amax,positive=False,color=&#34;Black&#34;,name=&#34;Eix rotació&#34;)

                num = int(angle)
                alfa = angle / num
                r = Rotation(alfa,u)
                bpy.context.scene.frame_set(self.frame)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if not local:
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn = frames + self.frame

                for i in range(num):
                        bpy.context.scene.frame_set(fn)
                        obj.rotation_quaternion.rotate(r.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if not local:
                                w = obj.location
                                w.rotate(r.quaternion)
                                obj.location = w
                                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames
                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()
        #
        #
        #
        def rotate_euler(self,obj=None,psi=0.0,theta=0.0,phi=0.0,frames=3,axis=&#39;ZXZ&#39;,amax=15,scaleaxis=0.075,reverse=False,local=False,radians=False,positive=True):
                &#34;&#34;&#34;
                Rotates an object by the Euler angles psi, theta and phi
                Parameters:
                   object: the object
                   psi, theta, phi: the Euler angles expressed in degrees
                   axis: it must be &#39;XYZ&#39;, &#39;XZY&#39;, &#39;YXZ&#39;, &#39;YZX&#39;, &#39;ZXY&#39;, &#39;ZYX&#39;, &#39;XYX&#39;, &#39;XZX&#39;, &#39;YXY&#39;, &#39;YZY&#39;, &#39;ZXZ&#39; or &#39;ZYZ&#39;
                   amax: axis valur for draw_base_axis
                   scaleaxis: scale value for draw_base_axis
                   local: if True the center of rotation is the location of the object
                   radians: if True, psi, theta and phi must be in radians
                   positive: if False and psi, theta or phi are greather than 180 degrees, they rae converted
                             to negative angles
                &#34;&#34;&#34;
                def vector_from_axis(axis):
                        if axis == &#39;X&#39;:
                                return Vector([1,0,0])
                        if axis == &#39;Y&#39;:
                                return Vector([0,1,0])
                        if axis == &#39;Z&#39;:
                                return Vector([0,0,1])
                        return None

                if obj is None or axis is None:
                        return None

                if not isinstance(axis,str):
                        return None

                axis = axis.upper()
                if axis not in (&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,&#39;XYX&#39;,&#39;XZX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;):
                        return None

                u1 = vector_from_axis(axis[0])
                u2 = vector_from_axis(axis[1])
                u3 = vector_from_axis(axis[2])

                if radians:
                        psi *= 180/math.pi
                        theta *= 180/math.pi
                        phi *= 180/math.pi
                if positive:
                        if psi &lt; 0.0:
                                psi += 360
                        if theta &lt; 0.0:
                                theta += 360
                        if phi &lt; 0.0:
                                phi += 360
                else:
                        if psi &gt; 180.0:
                                psi -= 360
                        if theta &gt; 180.0:
                                theta -= 360
                        if phi &gt; 180.0:
                                phi -= 360

                if reverse:
                        self.set_colors([&#34;OrangeRedDark&#34;,&#34;Yellow&#34;,&#34;Magenta&#34;])
                        axis = self.draw_base_axis(axis = amax,scale=scaleaxis,positive=False,name=&#34;Eixos fixes&#34;)
                        obj = self.join([obj,axis])
                        u1, u2, u3 = u3, u2, u1
                        psi, theta, phi = phi, theta, psi
                        s = Rotation(psi,u1)
                        u2 = s.apply(u2)
                        u3 = s.apply(u3)
                        s = Rotation(theta,u2)
                        u3 = s.apply(u3)
                else:
                        self.draw_base_axis(axis=amax,scale=scaleaxis,positive=False)

                bpy.context.scene.frame_set(self.frame)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if not local:
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn = frames + self.frame
                if psi &gt; 0:
                        num = int(psi)
                elif psi &lt; 0:
                        num = int(-psi)
                alfa = psi / num
                r = Rotation(alfa,u1)
                for i in range(num):
                        bpy.context.scene.frame_set(fn)
                        obj.rotation_quaternion.rotate(r.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if not local:
                                w = obj.location
                                w.rotate(r.quaternion)
                                obj.location = w
                                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames

                if theta &gt; 0:
                        num = int(theta)
                elif theta &lt; 0:
                        num = int(-theta)
                alfa = theta / num
                r = Rotation(alfa,u2)
                for i in range(num):
                        bpy.context.scene.frame_set(fn)
                        obj.rotation_quaternion.rotate(r.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if not local:
                                w = obj.location
                                w.rotate(r.quaternion)
                                obj.location = w
                                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames

                if phi &gt; 0:
                        num = int(phi)
                elif phi &lt; 0:
                        num = int(-phi)
                alfa = phi / num
                r = Rotation(alfa,u3)
                for i in range(num):
                        bpy.context.scene.frame_set(fn)
                        obj.rotation_quaternion.rotate(r.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if not local:
                                w = obj.location
                                w.rotate(r.quaternion)
                                obj.location = w
                                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames

                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()
        #
        #
        #
        def draw_frenet_curve(self,fun=None,var=None,tmin=0.0,tmax=1.0,radius=0.1,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,point=True,tangent=False,acceleration=False,normal=False,osculator=False,frenet=False,units=False,sizex=8,sizey=8):
                &#34;&#34;&#34;
                Draws a curve and diferents elements related to the curve
                Parameters:
                   fun: the parametric function
                   var = parameter variable of the function fun
                   tmin: minimum value of the parameter
                   tmax: maximum value of the parameter
                   radius: radius of the point
                   steps: number of steps
                   frames: increment of the frame set
                   thickness: thickness of the curve
                   name: name of the curve
                   color: color of the curve
                   point: if True draw a point along the curve
                   tangent: if True draw the tangent vector along the curve
                   acceleration: if True draw the acceleration vector along the curve
                   normal: if True draw the normal vector along the curve
                   osculator: if True draw the osculating plane along the curve
                   frenet: if True draw the Frenet trihedron along the curve
                   units: if True normalize the tangent and normal vectors
                   sizex, sizey: sizes of the osculating plane
                &#34;&#34;&#34;
                if fun is None:
                        return None

                def _fun_(x):
                        return [u.subs(var,x) for u in fun]

                def frenet_quaternion(tangent,normal):
                        v1 = tangent.normalized()
                        v2 = normal.normalized()
                        v3 = v1.cross(v2)
                        return Matrix([v1,v2,v3]).transposed().to_quaternion()

                frames = 1
                curve = self.draw_curve(_fun_,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,color=color,axis=False)
                if not point and not tangent and not osculator and not frenet:
                        return curve

                T = [diff(u,var) for u in fun]
                Tnorm = sqrt(sum([u**2 for u in T]))
                A = [diff(u,var) for u in T]
                p0 = Vector([u.subs(var,tmin) for u in fun])
                v0 = Vector([N(u.subs(var,tmin)) for u in T])
                a0 = Vector([N(u.subs(var,tmin)) for u in A])
                n0 = a0 - a0.project(v0)
                q0 = frenet_quaternion(v0,n0)
                f0 = [Vector([1,0,0]),Vector([0,1,0]),Vector([0,0,1])]

                if units:
                        v0.normalize()
                        n0.normalize()
                bpy.context.scene.frame_set(self.frame)

                if point:
                        p = self.draw_point(radius=radius,location=p0,name=&#34;Punt&#34;,color=&#34;Black&#34;)
                        p.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                self.set_origin(p0)
                if tangent:
                        l = v0.length
                        if not units:
                                vp = 5*v0.normalized()
                        else:
                                vp = v0
                        if not units:
                                v = self.draw_vector(vp,color=&#34;Red&#34;,scale=0.035,head_height=0.2)
                                v.scale.z *= l / 5.0
                        else:
                                v = self.draw_vector(vp,color=&#34;Red&#34;,scale=0.035,head_height=0.1)
                        v.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        v.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        v.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if acceleration:
                        l = a0.length
                        ap = 5*a0.normalized()
                        a = self.draw_vector(ap,color=&#34;Green&#34;,scale=0.035,head_height=0.2)
                        a.scale.z *= l / 5.0
                        a.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        a.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        a.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if normal:
                        l = n0.length
                        if not units:
                                np = 5*n0.normalized()
                        else:
                                np = n0
                        if not units:
                                n = self.draw_vector(np,color=&#34;Red&#34;,scale=0.035,head_height=0.2)
                                n.scale.z *= l / 5.0
                        else:
                                n = self.draw_vector(np,color=&#34;Red&#34;,scale=0.035,head_height=0.1)
                        n.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        n.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        n.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if osculator:
                        o = self.draw_plane_surface(base=[[1,0,0],[0,1,0]],color=&#34;GreenPaleDull&#34;,linecolor=&#34;GreenDarkDull&#34;,sizex=sizex,sizey=sizey,opacity=0.25)
                        o.rotation_quaternion = q0
                        o.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        o.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if frenet:
                        f = self.draw_vectors(f0,color=&#34;Red&#34;,scale=0.035,head_height=0.1)
                        f.rotation_quaternion = q0
                        f.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        f.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                self.set_origin()

                fn = frames + self.frame
                for i in range(steps):
                        bpy.context.scene.frame_set(fn)
                        x = tmin + (tmax - tmin)*i/steps
                        pos = Vector([u.subs(var,x) for u in fun])
                        v1 = Vector([N(u.subs(var,x)) for u in T])
                        a1 = Vector([N(u.subs(var,x)) for u in A])
                        n1 = a1 - a1.project(v1)
                        q1 = frenet_quaternion(v1,n1)
                        if point:
                                p.location = pos
                                p.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        if tangent:
                                if not units:
                                        r = v1.length / v0.length
                                        v.scale.z *= r
                                v.location = pos
                                v.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                v.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                                q = v0.rotation_difference(v1)
                                v.rotation_quaternion.rotate(q)
                                v.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if acceleration:
                                r = a1.length / a0.length
                                a.scale.z *= r
                                a.location = pos
                                a.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                a.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                                q = a0.rotation_difference(a1)
                                a.rotation_quaternion.rotate(q)
                                a.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if normal:
                                if not units:
                                        r = n1.length / n0.length
                                        n.scale.z *= r
                                n.location = pos
                                n.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                n.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                                q = n0.rotation_difference(n1)
                                n.rotation_quaternion.rotate(q)
                                n.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if osculator:
                                o.location = pos
                                o.rotation_quaternion = q1
                                o.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                o.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if frenet:
                                f.location = pos
                                f.rotation_quaternion = q1
                                f.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                f.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        v0 = v1.copy()
                        a0 = a1.copy()
                        n0 = n1.copy()
                        fn += frames
                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="LinearAlgebra.createFaces"><code class="name flex">
<span>def <span class="ident">createFaces</span></span>(<span>vertIdx1, vertIdx2, closed=False, flipped=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createFaces(vertIdx1,vertIdx2,closed=False,flipped=False):
        faces = []
        if not vertIdx1 or not vertIdx2:
                return None
        if len(vertIdx1) &lt; 2 and len(vertIdx2) &lt; 2:
                return None

        fan = False
        if (len(vertIdx1) != len(vertIdx2)):
                if (len(vertIdx1) == 1 and len(vertIdx2) &gt; 1):
                        fan = True
                else:
                        return None

        total = len(vertIdx2)
        if closed:
                if flipped:
                        face = [vertIdx1[0],vertIdx2[0],vertIdx2[total - 1]]
                        if not fan:
                                face.append(vertIdx1[total - 1])
                        faces.append(face)
                else:
                        face = [vertIdx2[0], vertIdx1[0]]
                        if not fan:
                                face.append(vertIdx1[total - 1])
                        face.append(vertIdx2[total - 1])
                        faces.append(face)
        for num in range(total - 1):
                if flipped:
                        if fan:
                                face = [vertIdx2[num], vertIdx1[0], vertIdx2[num + 1]]
                        else:
                                face = [vertIdx2[num], vertIdx1[num],vertIdx1[num + 1], vertIdx2[num + 1]]
                        faces.append(face)
                else:
                        if fan:
                                face = [vertIdx1[0], vertIdx2[num], vertIdx2[num + 1]]
                        else:
                                face = [vertIdx1[num], vertIdx2[num],vertIdx2[num + 1], vertIdx1[num + 1]]
                        faces.append(face)
        return faces</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.create_mesh_object"><code class="name flex">
<span>def <span class="ident">create_mesh_object</span></span>(<span>context, verts, edges, faces, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_mesh_object(context,verts,edges,faces,name):
        mesh = bpy.data.meshes.new(name)
        mesh.from_pydata(verts, edges, faces)
        mesh.update()
        return object_utils.object_data_add(context, mesh, operator=None)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.draw_parametric_surface"><code class="name flex">
<span>def <span class="ident">draw_parametric_surface</span></span>(<span>eq, range_u_min, range_u_max, range_u_step, range_v_min, range_v_max, range_v_step, name, wrap_u=False, wrap_v=False, close_v=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_parametric_surface(eq,range_u_min,range_u_max,range_u_step,range_v_min,range_v_max,range_v_step,name,wrap_u=False,wrap_v=False,close_v=False):
        verts = []
        faces = []
        if not callable(range_u_min) and not callable(range_u_max):
                uStep = (range_u_max - range_u_min) / range_u_step
        vStep = (range_v_max - range_v_min) / range_v_step
        uRange = range_u_step + 1
        vRange = range_v_step + 1

        if wrap_u:
                uRange = uRange - 1
        if wrap_v:
                vRange = vRange - 1

        for vN in range(vRange):
                v = range_v_min + (vN * vStep)
                if callable(range_u_min):
                        u_min = range_u_min(v)
                else:
                        u_min = range_u_min
                if callable(range_u_max):
                        u_max = range_u_max(v)
                else:
                        u_max = range_u_max
                uStep = (u_max - u_min) / range_u_step
                for uN in range(uRange):
                        u = u_min + (uN * uStep)
                        verts.append(eq(u,v))

        for vN in range(range_v_step):
                vNext = vN + 1
                if vNext &gt;= vRange:
                        vNext = 0
                for uN in range(range_u_step):
                        uNext = uN + 1
                        if uNext &gt;= uRange:
                                uNext = 0
                        faces.append([(vNext * uRange) + uNext,(vNext * uRange) + uN,(vN * uRange) + uN,(vN * uRange) + uNext])

        if close_v and wrap_u and (not wrap_v):
                for uN in range(1, range_u_step - 1):
                        faces.append([range_u_step - 1,range_u_step - 1 - uN,range_u_step - 2 - uN])
                        faces.append([range_v_step * uRange,range_v_step * uRange + uN,range_v_step * uRange + uN + 1])
        create_mesh_object(bpy.context,verts, [], faces, name)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="LinearAlgebra.Color"><code class="flex name class">
<span>class <span class="ident">Color</span></span>
<span>(</span><span>r, g, b, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Class that defines a color in RGB format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Color():
        &#34;&#34;&#34;
    Class that defines a color in RGB format
    &#34;&#34;&#34;
        def __init__(self,r,g,b,name):
                self.r = r
                self.g = g
                self.b = b
                self.name = name</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.Colors"><code class="flex name class">
<span>class <span class="ident">Colors</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class that defines a list of colors by name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Colors():
        &#34;&#34;&#34;
        Class that defines a list of colors by name
        &#34;&#34;&#34;
        colorsbyname = {
                &#39;Black&#39; : Color(0,0,0,&#39;Black&#39;),
                &#39;GrayObscure&#39; : Color(0.2,0.2,0.2,&#39;GrayObscure&#39;),
                &#39;GrayDark&#39; : Color(0.4,0.4,0.4,&#39;GrayDark&#39;),
                &#39;GrayLight&#39; : Color(0.6,0.6,0.6,&#39;GrayLight&#39;),
                &#39;GrayPale&#39; : Color(0.8,0.8,0.8,&#39;GrayPale&#39;),
                &#39;White&#39; : Color(1,1,1,&#39;White&#39;),
                &#39;Red&#39; : Color(1,0,0,&#39;Red&#39;),
                &#39;RedDarkHard&#39; : Color(0.8,0,0,&#39;RedDarkHard&#39;),
                &#39;RedLightHard&#39; : Color(1,0.2,0.2,&#39;RedLightHard&#39;),
                &#39;RedDarkFaded&#39; : Color(0.6,0,0,&#39;RedDarkFaded&#39;),
                &#39;RedMediumFaded&#39; : Color(0.8,0.2,0.2,&#39;RedMediumFaded&#39;),
                &#39;RedLightFaded&#39; : Color(1,0.4,0.4,&#39;RedLightFaded&#39;),
                &#39;RedObscureDull&#39; : Color(0.4,0,0,&#39;RedObscureDull&#39;),
                &#39;RedDarkDull&#39; : Color(0.6,0.2,0.2,&#39;RedDarkDull&#39;),
                &#39;RedLightDull&#39; : Color(0.8,0.4,0.4,&#39;RedLightDull&#39;),
                &#39;RedPaleDull&#39; : Color(1,0.6,0.6,&#39;RedPaleDull&#39;),
                &#39;RedObscureWeak&#39; : Color(0.2,0,0,&#39;RedObscureWeak&#39;),
                &#39;RedDarkWeak&#39; : Color(0.4,0.2,0.2,&#39;RedDarkWeak&#39;),
                &#39;RedMediumWeak&#39; : Color(0.6,0.4,0.4,&#39;RedMediumWeak&#39;),
                &#39;RedLightWeak&#39; : Color(0.8,0.6,0.6,&#39;RedLightWeak&#39;),
                &#39;RedPaleWeak&#39; : Color(1,0.8,0.8,&#39;RedPaleWeak&#39;),
                &#39;Orange&#39; : Color(1,0.37,0.12,&#39;Orange&#39;),
                &#39;OrangeRedDark&#39; : Color(0.6,0.2,0,&#39;OrangeRedDark&#39;),
                &#39;OrangeRedMedium&#39; : Color(0.8,0.4,0.2,&#39;OrangeRedMedium&#39;),
                &#39;OrangeRedLight&#39; : Color(1,0.6,0.4,&#39;OrangeRedLight&#39;),
                &#39;OrangeOrangeRed&#39; : Color(1,0.4,0,&#39;OrangeOrangeRed&#39;),
                &#39;RedOrangeDark&#39; : Color(0.8,0.2,0,&#39;RedOrangeDark&#39;),
                &#39;RedOrangeLight&#39; : Color(1,0.4,0.2,&#39;RedOrangeLight&#39;),
                &#39;RedRedOrange&#39; : Color(1,0.2,0,&#39;RedRedOrange&#39;),
                &#39;OrangeDarkHard&#39; : Color(0.8,0.4,0,&#39;OrangeDarkHard&#39;),
                &#39;OrangeLightHard&#39; : Color(1,0.6,0.2,&#39;OrangeLightHard&#39;),
                &#39;OrangeObscureDull&#39; : Color(0.4,0.2,0,&#39;OrangeObscureDull&#39;),
                &#39;OrangeDarkDull&#39; : Color(0.6,0.4,0.2,&#39;OrangeDarkDull&#39;),
                &#39;OrangeLightDull&#39; : Color(0.8,0.6,0.4,&#39;OrangeLightDull&#39;),
                &#39;OrangePaleDull&#39; : Color(1,0.8,0.6,&#39;OrangePaleDull&#39;),
                &#39;OrangeYellowDark&#39; : Color(0.6,0.4,0,&#39;OrangeYellowDark&#39;),
                &#39;OrangeYellowMedium&#39; : Color(0.8,0.6,0.2,&#39;OrangeYellowMedium&#39;),
                &#39;OrangeYellowLight&#39; : Color(1,0.8,0.4,&#39;OrangeYellowLight&#39;),
                &#39;OrangeOrangeYellow&#39; : Color(1,0.6,0,&#39;OrangeOrangeYellow&#39;),
                &#39;YellowOrangeDark&#39; : Color(0.8,0.6,0,&#39;YellowOrangeDark&#39;),
                &#39;YellowOrangeLight&#39; : Color(1,0.8,0.2,&#39;YellowOrangeLight&#39;),
                &#39;YellowYellowOrange&#39; : Color(1,0.8,0,&#39;YellowYellowOrange&#39;),
                &#39;Yellow&#39; : Color(1,1,0,&#39;Yellow&#39;),
                &#39;YellowDarkHard&#39; : Color(0.8,0.8,0,&#39;YellowDarkHard&#39;),
                &#39;YellowLightHard&#39; : Color(1,1,0.2,&#39;YellowLightHard&#39;),
                &#39;YellowDarkFaded&#39; : Color(0.6,0.6,0,&#39;YellowDarkFaded&#39;),
                &#39;YellowMediumFaded&#39; : Color(0.8,0.8,0.2,&#39;YellowMediumFaded&#39;),
                &#39;YellowLightFaded&#39; : Color(1,1,0.4,&#39;YellowLightFaded&#39;),
                &#39;YellowObscureDull&#39; : Color(0.4,0.4,0,&#39;YellowObscureDull&#39;),
                &#39;YellowDarkDull&#39; : Color(0.6,0.6,0.2,&#39;YellowDarkDull&#39;),
                &#39;YellowLightDull&#39; : Color(0.8,0.8,0.4,&#39;YellowLightDull&#39;),
                &#39;YellowPaleDull&#39; : Color(1,1,0.6,&#39;YellowPaleDull&#39;),
                &#39;YellowObscureWeak&#39; : Color(0.2,0.2,0,&#39;YellowObscureWeak&#39;),
                &#39;YellowDarkWeak&#39; : Color(0.4,0.4,0.2,&#39;YellowDarkWeak&#39;),
                &#39;YellowMediumWeak&#39; : Color(0.6,0.6,0.4,&#39;YellowMediumWeak&#39;),
                &#39;YellowLightWeak&#39; : Color(0.8,0.8,0.6,&#39;YellowLightWeak&#39;),
                &#39;YellowPaleWeak&#39; : Color(1,1,0.8,&#39;YellowPaleWeak&#39;),
                &#39;SpringYellowDark&#39; : Color(0.4,0.6,0,&#39;SpringYellowDark&#39;),
                &#39;SpringYellowMedium&#39; : Color(0.6,0.8,0.2,&#39;SpringYellowMedium&#39;),
                &#39;SpringYellowLight&#39; : Color(0.8,1,0.4,&#39;SpringYellowLight&#39;),
                &#39;SpringSpringYellow&#39; : Color(0.6,1,0,&#39;SpringSpringYellow&#39;),
                &#39;YellowSpringDark&#39; : Color(0.6,0.8,0,&#39;YellowSpringDark&#39;),
                &#39;YellowSpringLight&#39; : Color(0.8,1,0.2,&#39;YellowSpringLight&#39;),
                &#39;YellowYellowSpring&#39; : Color(0.8,1,0,&#39;YellowYellowSpring&#39;),
                &#39;SpringDarkHard&#39; : Color(0.4,0.8,0,&#39;SpringDarkHard&#39;),
                &#39;SpringLightHard&#39; : Color(0.6,1,0.2,&#39;SpringLightHard&#39;),
                &#39;SpringObscureDull&#39; : Color(0.2,0.4,0,&#39;SpringObscureDull&#39;),
                &#39;SpringDarkDull&#39; : Color(0.4,0.6,0.2,&#39;SpringDarkDull&#39;),
                &#39;SpringLightDull&#39; : Color(0.6,0.8,0.4,&#39;SpringLightDull&#39;),
                &#39;SpringPaleDull&#39; : Color(0.8,1,0.6,&#39;SpringPaleDull&#39;),
                &#39;SpringGreenDark&#39; : Color(0.2,0.6,0,&#39;SpringGreenDark&#39;),
                &#39;SpringGreenMedium&#39; : Color(0.4,0.8,0.2,&#39;SpringGreenMedium&#39;),
                &#39;SpringGreenLight&#39; : Color(0.6,1,0.4,&#39;SpringGreenLight&#39;),
                &#39;SpringSpringGreen&#39; : Color(0.4,1,0,&#39;SpringSpringGreen&#39;),
                &#39;GreenSpringDark&#39; : Color(0.2,0.8,0,&#39;GreenSpringDark&#39;),
                &#39;GreenSpringLight&#39; : Color(0.4,1,0.2,&#39;GreenSpringLight&#39;),
                &#39;GreenGreenSpring&#39; : Color(0.2,1,0,&#39;GreenGreenSpring&#39;),
                &#39;Green&#39; : Color(0,1,0,&#39;Green&#39;),
                &#39;GreenDarkHard&#39; : Color(0,0.8,0,&#39;GreenDarkHard&#39;),
                &#39;GreenLightHard&#39; : Color(0.2,1,0.2,&#39;GreenLightHard&#39;),
                &#39;GreenDarkFaded&#39; : Color(0,0.6,0,&#39;GreenDarkFaded&#39;),
                &#39;GreenMediumFaded&#39; : Color(0.2,0.8,0.2,&#39;GreenMediumFaded&#39;),
                &#39;GreenLightFaded&#39; : Color(0.4,1,0.4,&#39;GreenLightFaded&#39;),
                &#39;GreenObscureDull&#39; : Color(0,0.4,0,&#39;GreenObscureDull&#39;),
                &#39;GreenDarkDull&#39; : Color(0.2,0.6,0.2,&#39;GreenDarkDull&#39;),
                &#39;GreenLightDull&#39; : Color(0.4,0.8,0.4,&#39;GreenLightDull&#39;),
                &#39;GreenPaleDull&#39; : Color(0.6,1,0.6,&#39;GreenPaleDull&#39;),
                &#39;GreenObscureWeak&#39; : Color(0,0.2,0,&#39;GreenObscureWeak&#39;),
                &#39;GreenDarkWeak&#39; : Color(0.2,0.4,0.2,&#39;GreenDarkWeak&#39;),
                &#39;GreenMediumWeak&#39; : Color(0.4,0.6,0.4,&#39;GreenMediumWeak&#39;),
                &#39;GreenLightWeak&#39; : Color(0.6,0.8,0.6,&#39;GreenLightWeak&#39;),
                &#39;GreenPaleWeak&#39; : Color(0.8,1,0.8,&#39;GreenPaleWeak&#39;),
                &#39;TealGreenDark&#39; : Color(0,0.6,0.2,&#39;TealGreenDark&#39;),
                &#39;TealGreenMedium&#39; : Color(0.2,0.8,0.4,&#39;TealGreenMedium&#39;),
                &#39;TealGreenLight&#39; : Color(0.4,1,0.6,&#39;TealGreenLight&#39;),
                &#39;TealTealGreen&#39; : Color(0,1,0.4,&#39;TealTealGreen&#39;),
                &#39;GreenTealDark&#39; : Color(0,0.8,0.2,&#39;GreenTealDark&#39;),
                &#39;GreenTealLight&#39; : Color(0.2,1,0.4,&#39;GreenTealLight&#39;),
                &#39;GreenGreenTeal&#39; : Color(0,1,0.2,&#39;GreenGreenTeal&#39;),
                &#39;TealDarkHard&#39; : Color(0,0.8,0.4,&#39;TealDarkHard&#39;),
                &#39;TealLightHard&#39; : Color(0.2,1,0.6,&#39;TealLightHard&#39;),
                &#39;TealObscureDull&#39; : Color(0,0.4,0.2,&#39;TealObscureDull&#39;),
                &#39;TealDarkDull&#39; : Color(0.2,0.6,0.4,&#39;TealDarkDull&#39;),
                &#39;TealLightDull&#39; : Color(0.4,0.8,0.6,&#39;TealLightDull&#39;),
                &#39;TealPaleDull&#39; : Color(0.6,1,0.8,&#39;TealPaleDull&#39;),
                &#39;TealCyanDark&#39; : Color(0,0.6,0.4,&#39;TealCyanDark&#39;),
                &#39;TealCyanMedium&#39; : Color(0.2,0.8,0.6,&#39;TealCyanMedium&#39;),
                &#39;TealCyanLight&#39; : Color(0.4,1,0.8,&#39;TealCyanLight&#39;),
                &#39;TealTealCyan&#39; : Color(0,1,0.6,&#39;TealTealCyan&#39;),
                &#39;CyanTealDark&#39; : Color(0,0.8,0.6,&#39;CyanTealDark&#39;),
                &#39;CyanTealLight&#39; : Color(0.2,1,0.8,&#39;CyanTealLight&#39;),
                &#39;CyanCyanTeal&#39; : Color(0,1,0.8,&#39;CyanCyanTeal&#39;),
                &#39;Cyan&#39; : Color(0,1,1,&#39;Cyan&#39;),
                &#39;CyanDarkHard&#39; : Color(0,0.8,0.8,&#39;CyanDarkHard&#39;),
                &#39;CyanLightHard&#39; : Color(0.2,1,1,&#39;CyanLightHard&#39;),
                &#39;CyanDarkFaded&#39; : Color(0,0.6,0.6,&#39;CyanDarkFaded&#39;),
                &#39;CyanMediumFaded&#39; : Color(0.2,0.8,0.8,&#39;CyanMediumFaded&#39;),
                &#39;CyanLightFaded&#39; : Color(0.4,1,1,&#39;CyanLightFaded&#39;),
                &#39;CyanObscureDull&#39; : Color(0,0.4,0.4,&#39;CyanObscureDull&#39;),
                &#39;CyanDarkDull&#39; : Color(0.2,0.6,0.6,&#39;CyanDarkDull&#39;),
                &#39;CyanLightDull&#39; : Color(0.4,0.8,0.8,&#39;CyanLightDull&#39;),
                &#39;CyanPaleDull&#39; : Color(0.6,1,1,&#39;CyanPaleDull&#39;),
                &#39;CyanObscureWeak&#39; : Color(0,0.2,0.2,&#39;CyanObscureWeak&#39;),
                &#39;CyanDarkWeak&#39; : Color(0.2,0.4,0.4,&#39;CyanDarkWeak&#39;),
                &#39;CyanMediumWeak&#39; : Color(0.4,0.6,0.6,&#39;CyanMediumWeak&#39;),
                &#39;CyanLightWeak&#39; : Color(0.6,0.8,0.8,&#39;CyanLightWeak&#39;),
                &#39;CyanPaleWeak&#39; : Color(0.8,1,1,&#39;CyanPaleWeak&#39;),
                &#39;AzureCyanDark&#39; : Color(0,0.4,0.6,&#39;AzureCyanDark&#39;),
                &#39;AzureCyanMedium&#39; : Color(0.2,0.6,0.8,&#39;AzureCyanMedium&#39;),
                &#39;AzureCyanLight&#39; : Color(0.4,0.8,1,&#39;AzureCyanLight&#39;),
                &#39;AzureAzureCyan&#39; : Color(0,0.6,1,&#39;AzureAzureCyan&#39;),
                &#39;CyanAzureDark&#39; : Color(0,0.6,0.8,&#39;CyanAzureDark&#39;),
                &#39;CyanAzureLight&#39; : Color(0.2,0.8,1,&#39;CyanAzureLight&#39;),
                &#39;CyanCyanAzure&#39; : Color(0,0.8,1,&#39;CyanCyanAzure&#39;),
                &#39;AzureDarkHard&#39; : Color(0,0.4,0.8,&#39;AzureDarkHard&#39;),
                &#39;AzureLightHard&#39; : Color(0.2,0.6,1,&#39;AzureLightHard&#39;),
                &#39;AzureObscureDull&#39; : Color(0,0.2,0.4,&#39;AzureObscureDull&#39;),
                &#39;AzureDarkDull&#39; : Color(0.2,0.4,0.6,&#39;AzureDarkDull&#39;),
                &#39;AzureLightDull&#39; : Color(0.4,0.6,0.8,&#39;AzureLightDull&#39;),
                &#39;AzurePaleDull&#39; : Color(0.6,0.8,1,&#39;AzurePaleDull&#39;),
                &#39;AzureBlueDark&#39; : Color(0,0.2,0.6,&#39;AzureBlueDark&#39;),
                &#39;AzureBlueMedium&#39; : Color(0.2,0.4,0.8,&#39;AzureBlueMedium&#39;),
                &#39;AzureBlueLight&#39; : Color(0.4,0.6,1,&#39;AzureBlueLight&#39;),
                &#39;AzureAzureBlue&#39; : Color(0,0.4,1,&#39;AzureAzureBlue&#39;),
                &#39;BlueAzureDark&#39; : Color(0,0.2,0.8,&#39;BlueAzureDark&#39;),
                &#39;BlueAzureLight&#39; : Color(0.2,0.4,1,&#39;BlueAzureLight&#39;),
                &#39;BlueBlueAzure&#39; : Color(0,0.2,1,&#39;BlueBlueAzure&#39;),
                &#39;Blue&#39; : Color(0,0,1,&#39;Blue&#39;),
                &#39;BlueDarkHard&#39; : Color(0,0,0.8,&#39;BlueDarkHard&#39;),
                &#39;BlueLightHard&#39; : Color(0.2,0.2,1,&#39;BlueLightHard&#39;),
                &#39;BlueDarkFaded&#39; : Color(0,0,0.6,&#39;BlueDarkFaded&#39;),
                &#39;BlueMediumFaded&#39; : Color(0.2,0.2,0.8,&#39;BlueMediumFaded&#39;),
                &#39;BlueLightFaded&#39; : Color(0.4,0.4,1,&#39;BlueLightFaded&#39;),
                &#39;BlueObscureDull&#39; : Color(0,0,0.4,&#39;BlueObscureDull&#39;),
                &#39;BlueDarkDull&#39; : Color(0.2,0.2,0.6,&#39;BlueDarkDull&#39;),
                &#39;BlueLightDull&#39; : Color(0.4,0.4,0.8,&#39;BlueLightDull&#39;),
                &#39;BluePaleDull&#39; : Color(0.6,0.6,1,&#39;BluePaleDull&#39;),
                &#39;BlueObscureWeak&#39; : Color(0,0,0.2,&#39;BlueObscureWeak&#39;),
                &#39;BlueDarkWeak&#39; : Color(0.2,0.2,0.4,&#39;BlueDarkWeak&#39;),
                &#39;BlueMediumWeak&#39; : Color(0.4,0.4,0.6,&#39;BlueMediumWeak&#39;),
                &#39;BlueLightWeak&#39; : Color(0.6,0.6,0.8,&#39;BlueLightWeak&#39;),
                &#39;BluePaleWeak&#39; : Color(0.8,0.8,1,&#39;BluePaleWeak&#39;),
                &#39;VioletBlueDark&#39; : Color(0.2,0,0.6,&#39;VioletBlueDark&#39;),
                &#39;VioletBlueMedium&#39; : Color(0.4,0.2,0.8,&#39;VioletBlueMedium&#39;),
                &#39;VioletBlueLight&#39; : Color(0.6,0.4,1,&#39;VioletBlueLight&#39;),
                &#39;VioletVioletBlue&#39; : Color(0.4,0,1,&#39;VioletVioletBlue&#39;),
                &#39;BlueVioletDark&#39; : Color(0.2,0,0.8,&#39;BlueVioletDark&#39;),
                &#39;BlueVioletLight&#39; : Color(0.4,0.2,1,&#39;BlueVioletLight&#39;),
                &#39;BlueBlueViolet&#39; : Color(0.2,0,1,&#39;BlueBlueViolet&#39;),
                &#39;VioletDarkHard&#39; : Color(0.4,0,0.8,&#39;VioletDarkHard&#39;),
                &#39;VioletLightHard&#39; : Color(0.6,0.2,1,&#39;VioletLightHard&#39;),
                &#39;VioletObscureDull&#39; : Color(0.2,0,0.4,&#39;VioletObscureDull&#39;),
                &#39;VioletDarkDull&#39; : Color(0.4,0.2,0.6,&#39;VioletDarkDull&#39;),
                &#39;VioletLightDull&#39; : Color(0.6,0.4,0.8,&#39;VioletLightDull&#39;),
                &#39;VioletPaleDull&#39; : Color(0.8,0.6,1,&#39;VioletPaleDull&#39;),
                &#39;VioletMagentaDark&#39; : Color(0.4,0,0.6,&#39;VioletMagentaDark&#39;),
                &#39;VioletMagentaMedium&#39; : Color(0.6,0.2,0.8,&#39;VioletMagentaMedium&#39;),
                &#39;VioletMagentaLight&#39; : Color(0.8,0.4,1,&#39;VioletMagentaLight&#39;),
                &#39;VioletVioletMagenta&#39; : Color(0.6,0,1,&#39;VioletVioletMagenta&#39;),
                &#39;MagentaVioletDark&#39; : Color(0.6,0,0.8,&#39;MagentaVioletDark&#39;),
                &#39;MagentaVioletLight&#39; : Color(0.8,0.2,1,&#39;MagentaVioletLight&#39;),
                &#39;MagentaMagentaViolet&#39; : Color(0.8,0,1,&#39;MagentaMagentaViolet&#39;),
                &#39;Magenta&#39; : Color(1,0,1,&#39;Magenta&#39;),
                &#39;MagentaDarkHard&#39; : Color(0.8,0,0.8,&#39;MagentaDarkHard&#39;),
                &#39;MagentaLightHard&#39; : Color(1,0.2,1,&#39;MagentaLightHard&#39;),
                &#39;MagentaDarkFaded&#39; : Color(0.6,0,0.6,&#39;MagentaDarkFaded&#39;),
                &#39;MagentaMediumFaded&#39; : Color(0.8,0.2,0.8,&#39;MagentaMediumFaded&#39;),
                &#39;MagentaLightFaded&#39; : Color(1,0.4,1,&#39;MagentaLightFaded&#39;),
                &#39;MagentaObscureDull&#39; : Color(0.4,0,0.4,&#39;MagentaObscureDull&#39;),
                &#39;MagentaDarkDull&#39; : Color(0.6,0.2,0.6,&#39;MagentaDarkDull&#39;),
                &#39;MagentaLightDull&#39; : Color(0.8,0.4,0.8,&#39;MagentaLightDull&#39;),
                &#39;MagentaPaleDull&#39; : Color(1,0.6,1,&#39;MagentaPaleDull&#39;),
                &#39;MagentaObscureWeak&#39; : Color(0.2,0,0.2,&#39;MagentaObscureWeak&#39;),
                &#39;MagentaDarkWeak&#39; : Color(0.4,0.2,0.4,&#39;MagentaDarkWeak&#39;),
                &#39;MagentaMediumWeak&#39; : Color(0.6,0.4,0.6,&#39;MagentaMediumWeak&#39;),
                &#39;MagentaLightWeak&#39; : Color(0.8,0.6,0.8,&#39;MagentaLightWeak&#39;),
                &#39;MagentaPaleWeak&#39; : Color(1,0.8,1,&#39;MagentaPaleWeak&#39;),
                &#39;PinkMagentaDark&#39; : Color(0.6,0,0.4,&#39;PinkMagentaDark&#39;),
                &#39;PinkMagentaMedium&#39; : Color(0.8,0.2,0.6,&#39;PinkMagentaMedium&#39;),
                &#39;PinkMagentaLight&#39; : Color(1,0.4,0.8,&#39;PinkMagentaLight&#39;),
                &#39;PinkPinkMagenta&#39; : Color(1,0,0.6,&#39;PinkPinkMagenta&#39;),
                &#39;MagentaPinkDark&#39; : Color(0.8,0,0.6,&#39;MagentaPinkDark&#39;),
                &#39;MagentaPinkLight&#39; : Color(1,0.2,0.8,&#39;MagentaPinkLight&#39;),
                &#39;MagentaMagentaPink&#39; : Color(1,0,0.8,&#39;MagentaMagentaPink&#39;),
                &#39;PinkDarkHard&#39; : Color(0.8,0,0.4,&#39;PinkDarkHard&#39;),
                &#39;PinkLightHard&#39; : Color(1,0.2,0.6,&#39;PinkLightHard&#39;),
                &#39;PinkObscureDull&#39; : Color(0.4,0,0.2,&#39;PinkObscureDull&#39;),
                &#39;PinkDarkDull&#39; : Color(0.6,0.2,0.4,&#39;PinkDarkDull&#39;),
                &#39;PinkLightDull&#39; : Color(0.8,0.4,0.6,&#39;PinkLightDull&#39;),
                &#39;PinkPaleDull&#39; : Color(1,0.6,0.8,&#39;PinkPaleDull&#39;),
                &#39;PinkRedDark&#39; : Color(0.6,0,0.2,&#39;PinkRedDark&#39;),
                &#39;PinkRedMedium&#39; : Color(0.8,0.2,0.4,&#39;PinkRedMedium&#39;),
                &#39;PinkRedLight&#39; : Color(1,0.4,0.6,&#39;PinkRedLight&#39;),
                &#39;PinkPinkRed&#39; : Color(1,0,0.4,&#39;PinkPinkRed&#39;),
                &#39;RedPinkDark&#39; : Color(0.8,0,0.2,&#39;RedPinkDark&#39;),
                &#39;RedPinkLight&#39; : Color(1,0.2,0.4,&#39;RedPinkLight&#39;),
                &#39;RedRedPink&#39; : Color(1,0,0.2,&#39;RedRedPink&#39;)
        }
        #
        #
        #
        @classmethod
        def color(self,name):
                &#34;&#34;&#34;
                Function that returns a color from his name
                Parameters:
                   name: name of the color
                &#34;&#34;&#34;
                try:
                        color = self.colorsbyname[name]
                except:
                        return self.colorsbyname[&#34;Black&#34;]
                return color
        #
        #
        #
        @classmethod
        def colors(self,names):
                &#34;&#34;&#34;
                Return a list of colors fron their names
                Parameters:
                   names: list of names
                &#34;&#34;&#34;
                return [self.colorsbyname[x] for x in names]</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="LinearAlgebra.Colors.colorsbyname"><code class="name">var <span class="ident">colorsbyname</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="LinearAlgebra.Colors.color"><code class="name flex">
<span>def <span class="ident">color</span></span>(<span>name)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that returns a color from his name</p>
<h2 id="parameters">Parameters</h2>
<p>name: name of the color</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def color(self,name):
        &#34;&#34;&#34;
        Function that returns a color from his name
        Parameters:
           name: name of the color
        &#34;&#34;&#34;
        try:
                color = self.colorsbyname[name]
        except:
                return self.colorsbyname[&#34;Black&#34;]
        return color</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.Colors.colors"><code class="name flex">
<span>def <span class="ident">colors</span></span>(<span>names)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of colors fron their names</p>
<h2 id="parameters">Parameters</h2>
<p>names: list of names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def colors(self,names):
        &#34;&#34;&#34;
        Return a list of colors fron their names
        Parameters:
           names: list of names
        &#34;&#34;&#34;
        return [self.colorsbyname[x] for x in names]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="LinearAlgebra.LinearAlgebra"><code class="flex name class">
<span>class <span class="ident">LinearAlgebra</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class used to define all the functions in this module to work with graphics in Blender</p>
<p>Initializes the values for scene, objects, meshes, collection, etc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LinearAlgebra():
        &#34;&#34;&#34;
        Class used to define all the functions in this module to work with graphics in Blender
        &#34;&#34;&#34;
        def __init__(self):
                &#34;&#34;&#34;
        Initializes the values for scene, objects, meshes, collection, etc.
                &#34;&#34;&#34;
                self.scene = bpy.context.scene
                self.objects = bpy.data.objects
                self.meshes = bpy.data.meshes
                self.collection = bpy.context.collection
                self.ops = bpy.ops
                self.colors= Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                self.rotation = None
                self.origin = [0,0,0]
                self.base = [[1,0,0],[0,1,0],[0,0,1]]
                self.defaultcolor = None
                self.frame = 0
        #
        #
        #
        def base_cilinder(self):
                &#34;&#34;&#34;
                Draws a base cilinder with radius 1 and depth 1
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_cylinder_add(radius=1,depth=1,enter_editmode=False,location=(0, 0, 0))
                bpy.ops.transform.translate(value=(0, 0, 0.5), orient_type=&#39;GLOBAL&#39;,orient_matrix_type=&#39;GLOBAL&#39;,
                        constraint_axis=(False, False, True), mirror=True, use_proportional_edit=False,
                        proportional_edit_falloff=&#39;SMOOTH&#39;,proportional_size=1, use_proportional_connected=False, use_proportional_projected=False)
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                bpy.ops.object.shade_smooth()
                bpy.context.object.name = &#39;Arrow_stem&#39;
        #
        #
        #
        def base_cone(self):
                &#34;&#34;&#34;
                Draws a base cone with radius1=1.5, radius2=0, depth=2
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_cone_add(radius1=1.5, radius2=0, depth=2, enter_editmode=False, location=(0, 0, 0))
                bpy.ops.transform.translate(value=(0, 0, 1), orient_type=&#39;GLOBAL&#39;,orient_matrix_type=&#39;GLOBAL&#39;,
                        constraint_axis=(False, False, True), mirror=True, use_proportional_edit=False,
                        proportional_edit_falloff=&#39;SMOOTH&#39;, proportional_size=1, use_proportional_connected=False, use_proportional_projected=False)
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                bpy.ops.object.shade_smooth()
                bpy.context.object.name = &#39;Arrow_cone&#39;
        #
        #
        #
        def delete_base_cilinder(self):
                &#34;&#34;&#34;
                Removes the base cilinder
                &#34;&#34;&#34;
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.data.objects[&#39;Arrow_stem&#39;].select_set(True)
                bpy.ops.object.delete()
        #
        #
        #
        def delete_base_cone(self):
                &#34;&#34;&#34;
                Removes the base cone
                &#34;&#34;&#34;
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.data.objects[&#39;Arrow_cone&#39;].select_set(True)
                bpy.ops.object.delete()
        #
        #
        #
        def set_colors(self,names):
                &#34;&#34;&#34;
                Set self.colors to the list of colors with names &#39;names&#39;
                Parameters:
                   names: list of name colors
                &#34;&#34;&#34;
                self.colors = Colors.colors(names)
        #
        #
        #
        def reset_colors(self):
                &#34;&#34;&#34;
                Set self.colors to default colors
                &#34;&#34;&#34;
                self.colors= Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        #
        #
        #
        def set_default_color(self,name):
                &#34;&#34;&#34;
                Set self.defaultcolor to the color with name &#39;name&#39;
                Parameters:
                   name: name of a color
                &#34;&#34;&#34;
                self.defaultcolor = name
        #
        #
        #
        def reset_frames(self):
                &#34;&#34;&#34;
                Set self.frame to 0
                Parameters:
                   name: name of a color
                &#34;&#34;&#34;
                self.frame = 0
        #
        #
        #
        def reset(self):
                &#34;&#34;&#34;
                Resets origin, base, rotation, frames and colors
                &#34;&#34;&#34;
                self.reset_origin()
                self.reset_base()
                self.reset_rotation()
                self.reset_frames()
                self.reset_colors()
        #
        #
        #
        def set_rotation(self,angle=None,vector=None,quaternion=None):
                &#34;&#34;&#34;
                Sets self.rotation to the rotation defined by an angle and an axis or
                by a quaternion.
                Parameters:
                   angle: angle of rotation in degrees
                   vector: axis of rotation
                   quaternion: quaternion that defines a rotation
                The angle and vector takes precedence over the quaternion
                &#34;&#34;&#34;
                if angle is not None:
                        self.rotation = Rotation(angle,vector)
                elif quaternion is not None:
                        self.rotation = Rotation(quaternion=quaternion)
                else:
                        self.rotation = Rotation(0,[1,0,0])
        #
        #
        #
        def reset_rotation(self):
                &#34;&#34;&#34;
                Sets the rotation to identity, i.e., rotation of 0 degrees around the
                vector (1,0,0)
                &#34;&#34;&#34;
                self.set_rotation()
        #
        #
        #
        def set_origin(self,vector=[0,0,0]):
                &#34;&#34;&#34;
                Sets the origin of the reference coordinates used to display objects.
                Parameters:
                   vector: origin&#39;s position
                &#34;&#34;&#34;
                if isinstance(vector,Vector):
                        v1 = vector.copy()
                else:
                        v1 = Vector(vector)
                self.origin = v1
        #
        #
        #
        def reset_origin(self):
                &#34;&#34;&#34;
                Sets the origin to the point (0,0,0)
                &#34;&#34;&#34;
                self.origin = Vector([0,0,0])
        #
        #
        #
        def reset_base(self):
                &#34;&#34;&#34;
                Sets self.base to the canonical basis
                &#34;&#34;&#34;
                self.base = [[1,0,0],[0,1,0],[0,0,1]]
        #
        #
        #
        def set_base(self,base,orthonormal=False):
                &#34;&#34;&#34;
                Sets the self.base, i.e., the basis of the reference coordinates used to display
                objects
                Parameters:
                   base: list of three vectors
                   orthonormal: if True, the Gram-Schmidt method is applied and the vectors
                   are normalized.
                &#34;&#34;&#34;
                if orthonormal:
                        u1 = base[0]
                        u2 = base[1]
                        if isinstance(u1,Vector):
                                v1 = u1
                        else:
                                v1 = Vector(u1)
                        if isinstance(u2,Vector):
                                v2 = u2
                        else:
                                v2 = Vector(u2)
                        v2 = v2 - v2.project(v1)
                        v1.normalize()
                        v2.normalize()
                        v3 = v1.cross(v2)
                        self.base=[v1,v2,v3]
                else:
                        self.base = base
        #
        #
        #
        def base_is_canonica(self):
                &#34;&#34;&#34;
                Returns True if sel.base is the canonical basis
                &#34;&#34;&#34;
                return Matrix(self.base).is_identity
        #
        #
        #
        def add_material(self,obj,material_name,r,g,b,opacity=1.0):
                &#34;&#34;&#34;
                Adds a material and color to an object
                Parameters:
                   obj: object
                   material_name: material&#39;s name
                   r, g, b: RGB color values
                   opacity: the opacity
                &#34;&#34;&#34;
                material = bpy.data.materials.get(material_name)
                if material is None:
                        material = bpy.data.materials.new(material_name)
                material.use_nodes = True
                principled_bsdf = material.node_tree.nodes[&#39;Principled BSDF&#39;]
                if principled_bsdf is not None:
                        #for i, o in enumerate(principled_bsdf.inputs):
                        #       print(i, o.name)
                        principled_bsdf.inputs[&#39;Base Color&#39;].default_value = (r, g, b, 0.5)
                        principled_bsdf.inputs[&#39;IOR&#39;].default_value = 0.0
                        principled_bsdf.inputs[&#39;Specular&#39;].default_value = 1.0
                        principled_bsdf.inputs[&#39;Emission&#39;].default_value = (r, g, b, 0.5)
                        principled_bsdf.inputs[&#39;Emission Strength&#39;].default_value = 0.0
                        if opacity &lt; 1.0:
                                material.blend_method = &#39;BLEND&#39;
                                principled_bsdf.inputs[&#39;Alpha&#39;].default_value = opacity
                        else:
                                material.blend_method = &#39;OPAQUE&#39;
                                principled_bsdf.inputs[&#39;Alpha&#39;].default_value = 1.0
                obj.active_material = material
        #
        #
        #
        def add_ligth(self,location=[0,0,100],energy=3,direction=[0,0,-1]):
                &#34;&#34;&#34;
                Adds a ligth to the scene
                Parameters:
                   location: location point of the light
                   energy: energy of the ligth
                   direction: direction of the light
                &#34;&#34;&#34;
                l = bpy.data.lights.new(name=&#34;Light&#34;, type=&#39;SUN&#39;)
                l.energy = energy
                l.specular_factor = 4
                obj = self.objects.new(name=&#34;Light&#34;, object_data=l)
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.location = location
                n = Vector(direction)
                mat = Matrix(self.base)
                mat.transpose()
                n = mat @ n
                z = Vector([0,0,-1])
                quaternion = z.rotation_difference(n)
                obj.rotation_quaternion.rotate(quaternion)
                self.collection.objects.link(obj)
        #
        #
        #
        def add_ligths(self,energy=1):
                &#34;&#34;&#34;
                Adds diferent lights to the scene
                Parameters:
                   energy: energy of the lights
                &#34;&#34;&#34;
                self.add_ligth()
                self.add_ligth(location=[100,0,0],direction=[-1,0,0],energy=energy)
                self.add_ligth(location=[0,100,0],direction=[0,-1,0],energy=energy)
                self.add_ligth(location=[-100,0,0],direction=[1,0,0],energy=energy)
                self.add_ligth(location=[0,-100,0],direction=[0,1,0],energy=energy)
        #
        #
        #
        def new_components(self,vector=None):
                &#34;&#34;&#34;
                Returns the components of the vector &#39;vector&#39; in the basis determined by
                self.rotation ans the basis self.base
                Parameters:
                   vector: components of the vector in the canonical basis
                &#34;&#34;&#34;
                if vector is None:
                        return Vector([0,0,0])
                if isinstance(vector,Vector):
                        u = vector
                else:
                        u = Vector(vector)
                if self.rotation is not None:
                        mat = self.rotation.quaternion.to_matrix()
                        mat.invert()
                        u = mat @ u
                mat = Matrix(self.base)
                mat.transpose()
                mat.invert()
                u = mat @ u
                return u
        #
        #
        #
        def new_coordinates(self,point=None):
                &#34;&#34;&#34;
                Returns the coordinates of the point &#39;point&#39; in the reference determined by
                self.origin, self.rotation and the basis self.base
                Parameters:
                   point: coordinates of the point in the canonical reference
                &#34;&#34;&#34;
                if point is None:
                        return Vector([0,0,0])
                if isinstance(point,Vector):
                        u = point
                else:
                        u = Vector(point)
                if self.rotation is not None:
                        mat = self.rotation.quaternion.to_matrix()
                        mat.invert()
                        u = mat @ u
                mat = Matrix(self.base)
                mat.transpose()
                mat.invert()
                u = mat @ (u - Vector(self.origin))
                return u
        #
        #
        #
        def set_cursor(self,origin=[0,0,0],direction=[1,0,0],axis=&#39;x&#39;):
                &#34;&#34;&#34;
                Sets the cursor position and direction
                Parameters:
                  origin: position of the cursor
                  direction: vector that indicates the direction of the axis &#39;axis&#39;
                  axis: &#39;x&#39;, &#39;y&#39; or &#39;z&#39;
                &#34;&#34;&#34;
                axis = axis.lower()
                if axis not in [&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]:
                        return
                eixos = {&#39;x&#39; : Vector([1,0,0]),
                                 &#39;y&#39; : Vector([0,1,0]),
                                 &#39;z&#39; : Vector([0,0,1])
                }
                if isinstance(direction,Vector):
                        d = direction
                else:
                        d = Vector(direction)
                x = eixos[axis]
                quaternion = x.rotation_difference(d)
                self.scene.cursor.location = origin
                self.scene.cursor.rotation_mode = &#39;QUATERNION&#39;
                self.scene.cursor.rotation_quaternion = quaternion
        #
        #
        #
        def set_cursor_rotation(self,origin=[0,0,0],rotation=Matrix.Identity(3)):
                &#34;&#34;&#34;
                Sets the rotation of the cursor
                Parameters:
                   origin: position of the cursor
                   rotation: matrix of a rotation
                &#34;&#34;&#34;
                m = rotation.copy()
                det = m.determinant()
                if abs(- det - 1.0) &lt; 0.1:
                        m[2] = - m[2]
                quaternion = m.to_quaternion()
                self.scene.cursor.location = origin
                self.scene.cursor.rotation_mode = &#39;QUATERNION&#39;
                self.scene.cursor.rotation_quaternion = quaternion.conjugated()
        #
        #
        #
        def draw_base_axis(self,scale=0.05,head_height=0.15,axis=0,name=&#34;Axis&#34;,positive=True,zaxis=True):
                &#34;&#34;&#34;
                Draws a reference axis given by self.origin, self.rotation and the basis self.base
                Parameters:
                   scale: scale of the cylinder
                   head_height: height of the head of the vector from self.base
                   axis: length of the coordinate axis. If the length is 0, only the basis vectors are drawn
                   name: name of the result object
                   positive: if True, draw the positive part of the axis
                   zaxis: if True, draw the z axis
                &#34;&#34;&#34;
                self.base_cilinder()
                self.base_cone()
                o = Vector([0,0,0])
                op = Vector(self.origin)
                color = 0

                if axis != 0 and axis &lt; 8:
                        scale /= 3

                base = self.base
                if not zaxis:
                        base = self.base[0:2]
                for vec in base:
                        #
                        # Draw the stem
                        #
                        v = Vector(vec)
                        t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                        obj = t.copy()
                        obj.name = &#34;Axis%d&#34; % (color + 1)
                        obj.data = obj.data.copy()
                        obj.location = o
                        obj.scale = (scale,scale,(v - o).length - 2 * head_height)
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if self.colors is not None and len(self.colors) &gt; color:
                                c = self.colors[color]
                                self.add_material(obj,c.name,c.r,c.g,c.b)
                        if self.rotation is not None:
                                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location = op
                        self.scene.collection.objects.link(obj)
                        #
                        # Draw the arrow
                        #
                        t = bpy.data.objects.get(&#34;Arrow_cone&#34;)
                        obj2 = t.copy()
                        obj2.name = &#34;Arrow&#34;
                        obj2.data = obj2.data.copy()
                        obj2.location =  v - 2 * head_height * v / v.length
                        obj2.scale = (scale + 0.05,scale + 0.05,head_height)
                        obj2.rotation_mode = &#39;QUATERNION&#39;
                        obj2.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if self.colors is not None and len(self.colors) &gt; color:
                                c = self.colors[color]
                                self.add_material(obj2,c.name,c.r,c.g,c.b)
                        if self.rotation is not None:
                                obj2.rotation_quaternion.rotate(self.rotation.quaternion)
                                obj2.location.rotate(self.rotation.quaternion)
                        obj2.location = op + obj2.location
                        self.scene.collection.objects.link(obj2)
                        #
                        # Draw the line
                        #
                        obj3 = None
                        if axis != 0:
                                v = axis * Vector(vec)
                                t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                                obj3 = t.copy()
                                obj3.name = &#34;Line&#34;
                                obj3.data = obj3.data.copy()
                                obj3.location = op - v
                                obj3.scale = (scale / 2,scale / 2,(2 * v).length)
                                obj3.rotation_mode = &#39;QUATERNION&#39;
                                obj3.rotation_quaternion = v.to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                                if self.colors is not None and len(self.colors) &gt; color:
                                        c = self.colors[color]
                                        self.add_material(obj3,c.name,c.r,c.g,c.b)
                                if self.rotation is not None:
                                        obj3.rotation_quaternion.rotate(self.rotation.quaternion)
                                if positive:
                                        obj3.location = op
                                else:
                                        if self.rotation is not None:
                                                v.rotate(self.rotation.quaternion)
                                        obj3.location = op - v
                                self.scene.collection.objects.link(obj3)
                        #
                        # Joint the three objects
                        #
                        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                        bpy.context.view_layer.objects.active = obj
                        obj.select_set(True)
                        obj2.select_set(True)
                        if obj3 is not None:
                                obj3.select_set(True)
                        bpy.ops.object.join()
                        color += 1
                #
                # Join all the axis
                #
                t1 = bpy.data.objects.get(&#34;Axis1&#34;)
                t1.name = name
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.context.view_layer.objects.active = t1
                t1.select_set(True)
                t2 = bpy.data.objects.get(&#34;Axis2&#34;)
                t2.select_set(True)
                if zaxis:
                        t3 = bpy.data.objects.get(&#34;Axis3&#34;)
                        t3.select_set(True)
                bpy.ops.object.join()
                self.delete_base_cilinder()
                self.delete_base_cone()
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return t1
        #
        #
        #
        def draw_vector(self,vector=None,canonica=False,color=&#34;Black&#34;,scale=0.05,arrow=True,head_height=0.15,axis=0,name=&#34;Vector&#34;,positive=True):
                &#34;&#34;&#34;
                Draw the vector with components &#39;vector&#39;
                Parameters:
                   vector: components of the vector
                   canonica: if True, the components are in the canonical basis, else they are in the basis self.base. Finally,
                      self.rotation is applied
                   color: color of the vector
                   scale: scale of the cylinder
                   arrow: if True draws the vector itself
                   head_height: height of the head of the vector
                   axis: if not zero, draw also the line generated by the vector
                   positive: if axis is not zero and positive is True, draw only the positive part of the line
                      generated by the vector
                &#34;&#34;&#34;
                if vector is None:
                        return None
                if isinstance(vector,Vector):
                        vec = vector
                else:
                        vec = Vector(vector)
                if vec.length == 0:
                        return None
                self.base_cilinder()
                self.base_cone()
                o = Vector([0,0,0])
                op = Vector(self.origin)
                if color is not None:
                        color = Colors.color(color)
                v = vec
                if not canonica:
                        mat = Matrix(self.base)
                        mat.transpose()
                        v = mat @ vec

                if arrow:
                        t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                        obj = t.copy()
                        obj.name = name
                        obj.data = obj.data.copy()
                        obj.location = o
                        obj.scale = (scale,scale,(v - o).length - 2 * head_height)
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if color is not None:
                                self.add_material(obj,color.name,color.r,color.g,color.b)
                        if self.rotation is not None:
                                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location = op
                        self.scene.collection.objects.link(obj)

                        t = bpy.data.objects.get(&#34;Arrow_cone&#34;)
                        obj2 = t.copy()
                        obj2.data = obj2.data.copy()
                        obj2.name = &#34;Arrow&#34;
                        obj2.location =  v - 2 * head_height * v / v.length
                        obj2.scale = (scale + 0.01,scale + 0.01,head_height)
                        obj2.rotation_mode = &#39;QUATERNION&#39;
                        obj2.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if color is not None:
                                self.add_material(obj2,color.name,color.r,color.g,color.b)
                        if self.rotation is not None:
                                obj2.rotation_quaternion.rotate(self.rotation.quaternion)
                                obj2.location.rotate(self.rotation.quaternion)
                        obj2.location = op + obj2.location
                        self.scene.collection.objects.link(obj2)

                obj3 = None
                if axis != 0:
                        v = axis * v / v.length
                        t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                        obj3 = t.copy()
                        if not arrow:
                                obj3.name = &#34;Line&#34;
                        else:
                                obj3.name = &#34;Generated&#34;
                        obj3.data = obj3.data.copy()
                        obj3.scale = (scale / 2,scale / 2,(2 * v).length)
                        obj3.rotation_mode = &#39;QUATERNION&#39;
                        obj3.rotation_quaternion = v.to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if color is not None:
                                self.add_material(obj3,color.name,color.r,color.g,color.b)
                        if self.rotation is not None:
                                obj3.rotation_quaternion.rotate(self.rotation.quaternion)
                        if positive:
                                obj3.location = op
                        else:
                                obj3.location = op - v
                        self.scene.collection.objects.link(obj3)

                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                if arrow:
                        bpy.context.view_layer.objects.active = obj
                elif axis != 0:
                        bpy.context.view_layer.objects.active = obj3
                if arrow:
                        obj.select_set(True)
                        obj2.select_set(True)
                if obj3 is not None:
                        obj3.select_set(True)
                if arrow:
                        bpy.ops.object.join()
                bpy.ops.object.shade_smooth()
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                self.delete_base_cilinder()
                self.delete_base_cone()
                bpy.context.view_layer.objects.active = None
                if arrow:
                        return obj
                if axis != 0:
                        return obj3
                return None
        #
        #
        #
        def comp_times_vector(self,u,v):
                &#34;&#34;&#34;
                Computes the vectorial product u x v
                Parameters:
                   u, v: two Vectors
                &#34;&#34;&#34;
                return Vector([u.x * v.x,u.y * v.y,u.z * v.z])
        #
        #
        #
        def draw_line(self,start=[1,1,1],end=[10,10,10],scale=0.05,name=&#34;Line&#34;,color=&#34;Black&#34;):
                &#34;&#34;&#34;
                Draws a line from the point start to the point end. The reference given by self.origin,
                self.rotation and the basis self.base is used
                Parameters:
                   start: starting point of the line
                   end: ending point of the line
                   scale: scale of the cylinder
                   name: name of the object
                   color: color of the vector
                &#34;&#34;&#34;
                if start is None or end is None:
                        return
                self.base_cilinder()
                o = Vector([0,0,0])
                op = Vector(self.origin)
                if isinstance(start,Vector):
                        u = start
                else:
                        u = Vector(start)
                if isinstance(end,Vector):
                        v = end
                else:
                        v = Vector(end)
                mat = Matrix(self.base)
                mat.transpose()
                u = mat @ u
                v = mat @ v
                l = (v - u).length
                t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                obj = t.copy()
                obj.name = name
                obj.location = u
                obj.scale = (scale / 2,scale / 2,l)
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.rotation_quaternion = (v - u).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                if color is not None:
                        c = Colors.color(color)
                        self.add_material(obj,c.name,c.r,c.g,c.b)
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                obj.location = obj.location + op
                self.scene.collection.objects.link(obj)
                bpy.ops.object.shade_flat()
                self.delete_base_cilinder()
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_components(self,vector=None,color=&#34;Cyan&#34;,name=&#34;Components&#34;,scale=0.005):
                &#34;&#34;&#34;
                Draws the components of the the vector &#39;vector&#39; in the reference given by self.origin,
                self.rotation and the basis self.base
                Parameters:
                   vector: the vector
                   color: color of the lines of components
                   name: name of the object
                   scale: scale of the lines
                &#34;&#34;&#34;
                if vector is None:
                        return
                if isinstance(vector,Vector):
                        v = vector
                else:
                        v = Vector(vector)
                mat = Matrix(self.base)
                mat.transpose()
                list = [[0,0,0],[1,0,0],[1,1,0],[0,1,0],[0,0,1],[1,0,1],[1,1,1],[0,1,1]]
                lines = [[0,1],[1,2],[2,3],[0,3],[0,4],[1,5],[2,6],[3,7],[4,5],[5,6],[6,7],[4,7]]
                vecs = [self.comp_times_vector(v,Vector(x)) for x in list]
                count = 0
                for first, last in lines:
                        if count == 0:
                                this = name
                        else:
                                this = f&#34;Line{count}&#34;
                        count += 1
                        self.draw_line(start=vecs[first],end=vecs[last],scale=scale,name=this,color=color)
                t = bpy.data.objects.get(name)
                list = [t]
                for count in range(1,12):
                        obj = bpy.data.objects.get(f&#34;Line{count}&#34;)
                        if obj is not None:
                                list.append(obj)
                t = self.join(list)
                bpy.context.view_layer.objects.active = None
                return t
        #
        #
        #
        def draw_vectors(self,vectors=[],canonica=False,color=&#34;Black&#34;,scale=0.05,head_height=0.2,name=&#34;Vectors&#34;,axis=0):
                &#34;&#34;&#34;
                Draws a list of vectors.
                Parameters:
                   vectors: list of vectors
                   canonica: if True, the the vectors are expressed in the canonical basis.
                   color: color of the vectors
                   scale: scale of the cylinder
                   head_height: height of the head of the vector
                   axis: if not zero, draw also the line generated by every vector
                &#34;&#34;&#34;
                if len(vectors) == 0:
                        return
                count = 0
                for v in vectors:
                        if count == 0:
                                this = name
                        else:
                                this = f&#34;Vector{count}&#34;
                        count += 1
                        t = self.draw_vector(v,canonica,color,scale,head_height,axis,this)
                t = bpy.data.objects.get(name)
                list = [t]
                for count in range(1,len(vectors)+1):
                        obj = bpy.data.objects.get(f&#34;Vector{count}&#34;)
                        if obj is not None:
                                list.append(obj)
                t = self.join(list)
                return t
        #
        #
        #
        def draw_plane(self,normal=None,base=None,sizex=10,sizey=10,color=&#34;AzureBlueDark&#34;,name=&#39;Plane&#39;,opacity=1.0,thickness=0.01):
                &#34;&#34;&#34;
                Draws a plane with normal vector or base vectors. It passes through the point self.origin.
                Only normal or base can be not None
                Parameters:
                   normal: normal vector to the plane
                   base: list of two independent vectors
                   sizex: x-size of the plane
                   sizey: y-size of the plane
                   color: color of the plane
                   name: name of the plane
                   opacity: opacity of the plane
                   thickness: thickness of the plane
                &#34;&#34;&#34;
                if sizex == 0.0:
                        return
                bpy.ops.mesh.primitive_plane_add(size=sizex,enter_editmode=True,location=(0, 0, 0))
                bpy.context.object.name = name
                ##### bpy.ops.mesh.subdivide(number_cuts=6,quadcorner=&#39;INNERVERT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj = bpy.data.objects.get(name)
                if sizey is not None and sizey != 0.0:
                        t = sizey / sizex
                        obj.scale = [1,t,1]
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                if normal is not None and base is not None:
                        return
                if base is not None:
                        if len(base) != 2:
                                return
                        if isinstance(base[0],Vector):
                                v1 = base[0]
                        else:
                                v1 = Vector(base[0])
                        if isinstance(base[1],Vector):
                                v2 = base[1]
                        else:
                                v2 = Vector(base[1])

                        if self.base is None:
                                normal = v1.cross(v2)
                        else:
                                u1 = v1[0]*self.base[0] + v1[1]*self.base[1] + v1[2]*self.base[2]
                                u2 = v2[0]*self.base[0] + v2[1]*self.base[1] + v2[2]*self.base[2]
                                normal = u1.cross(u2)
                if normal is not None and normal != Vector([0,0,0]):
                        z = Vector([0,0,1])
                        quaternion = z.rotation_difference(normal)
                        obj.rotation_quaternion.rotate(quaternion)
                        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def simple_curve(self,f=None,tmin=0.0,tmax=1.0,steps=25,name=&#34;Simple curve&#34;,symmetry=None,draw=False):
                &#34;&#34;&#34;
                Return a curve defined by the parametrization f
                Parameters:
                   f: Parametrization of the curve
                   tmin: minimum value of the parameter
                   tmax: maximum value of the parameter
                   steps: number of steps
                   name: name of the curve
                   symmetry: None or a value in the list (&#39;XY&#39;,&#39;XZ&#39;,&#39;YZ&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;,&#39;O&#39;). Symmetry of the curve
                   draw: if True, the curve is drawn
                &#34;&#34;&#34;
                if f is None:
                        return None

                delta = (tmax - tmin)/steps
                t = tmin
                bm = bmesh.new()
                verts = []
                verts2 = []

                for k in range(steps + 1):
                        p = f(t)
                        q = None
                        verts.append(bm.verts.new(p))
                        if symmetry == &#39;XY&#39;:
                                q = (p[0],p[1],-p[2])
                        elif symmetry == &#39;XZ&#39;:
                                q = (p[0],-p[1],p[2])
                        elif symmetry == &#39;YZ&#39;:
                                q = (-p[0],p[1],p[2])
                        elif symmetry == &#39;X&#39;:
                                q = (p[0],-p[1],-p[2])
                        elif symmetry == &#39;Y&#39;:
                                q = (-p[0],p[1],-p[2])
                        elif symmetry == &#39;Z&#39;:
                                q = (-p[0],-p[1],p[2])
                        elif symmetry == &#39;O&#39;:
                                q = (-p[0],-p[1],-p[2])

                        if q is not None:
                                verts2.append(bm.verts.new(q))
                        t += delta
                        if t &gt; tmax:
                                t = tmax

                for i in range(len(verts) - 1):
                        bm.edges.new([verts[i], verts[i+1]])
                        if len(verts2) &gt; 0:
                                bm.edges.new([verts2[i], verts2[i+1]])

                me = bpy.data.meshes.new(&#39;placeholder_mesh&#39;)
                obj = bpy.data.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()

                if draw:
                        self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_elliptic_paraboloid(self,a=0.5,xmin=0.0,xmax=3.0,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;EllipticParaboloid&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws an elliptic paraboloid from the parabola z=a*t^2
                Parameters:
                   a: coefficient of the parabola
                   xmin: minimum value of x
                   xmax: maximum value of x
                   steps: numbers of steps to draw the parabola
                   scale: scaling factors in the X, Y and Z directions
                   color: color of the surface
                   name: name of the surface
                   opacity: opacity of the surface
                   thickness: thickness of the surface
                &#34;&#34;&#34;
                obj = self.simple_curve(f=lambda t:(t,0,a*t**2),tmin=xmin,tmax=xmax,steps=steps,name=name)
                modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                modifier.angle = 2 * math.pi
                modifier.steps = 128
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                self.scene.collection.objects.link(obj)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_one_sheet_hyperboloid(self,a=2.0,b=2.0,xmin=math.sqrt(2),xmax=5.0,steps=256,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperboloidOneSheet&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws a one sheet hyperboloid from the hyperbole z = \pm a*sqrt(x^2-b) in the XZ plane
                Parameters:
                   a, b: coefficients of the hyperbole
                   xmin: minimum value of x
                   xmax: maximum value of x
                   steps: numbers of steps to draw the parabola
                   scale: scaling factors in the X, Y and Z directions
                   color: color of the surface
                   name: name of the surface
                   opacity: opacity of the surface
                   thickness: thickness of the surface
                &#34;&#34;&#34;
                if xmin &lt; math.sqrt(b):
                        xmin = math.sqrt(b)
                delta = (xmax - xmin) / steps
                x = xmax
                bm = bmesh.new()
                verts = []

                for k in range(steps + 1):
                        if x &lt; math.sqrt(b):
                                z = 0.0
                        else:
                                z = - a * math.sqrt(x**2 - b)
                        verts.append(bm.verts.new((x,0,z)))
                        x -= delta
                x = math.sqrt(b)
                for k in range(steps):
                        x += delta
                        if x**2 &lt; b:
                                z = 0.0
                        else:
                                z = a * math.sqrt(x**2 - b)
                        verts.append(bm.verts.new((x,0,z)))

                for i in range(len(verts) - 1):
                        bm.edges.new([verts[i], verts[i+1]])

                me = self.meshes.new(&#39;placeholder_mesh&#39;)
                obj = self.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()
                modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                modifier.angle = 2 * math.pi
                modifier.steps = 128
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_two_sheets_hyperboloid(self,a=2.0,b=1.0,xmin=0.0,xmax=5.0,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperboloidTwoSheets&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws a two sheet hyperboloid from the hyperbole z = \pm a * math.sqrt(x**2+b) in the XZ plane
                Parameters:
                   a, b: coefficients of the hyperbole
                   xmin: minimum value of x
                   xmax: maximum value of x
                   steps: numbers of steps to draw the parabola
                   scale: scaling factors in the X, Y and Z directions
                   color: color of the surface
                   name: name of the surface
                   opacity: opacity of the surface
                   thickness: thickness of the surface
                &#34;&#34;&#34;
                delta = (xmax - xmin) / steps
                x = xmax
                bm = bmesh.new()
                verts = []
                count = 2 * steps + 2
                sign = 1
                for k in range(count):
                        if k == steps + 1:
                                sign = -1
                        z = sign * a * math.sqrt(x**2+b)
                        verts.append(bm.verts.new((x,0,z)))
                        if k == steps and xmin &gt; 0:
                                x = xmin
                        else:
                                x = x - sign * delta
                        if k == 0 or k == steps + 1:
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;placeholder_mesh&#39;)
                obj = self.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()

                modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                modifier.angle = 2 * math.pi
                modifier.steps = 128
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_cone(self,a=1.0,xmin=0.0,xmax=5.0,steps=50,scale=[1,1,1],half=False,color=&#34;AzureBlueDark&#34;,name=&#34;Cone&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws a cone from the line z = a*x in the XZ plane
                Parameters:
                   a: slope of the line
                   xmin: minimum value of x
                   xmax: maximum value of x
                   steps: numbers of steps to draw the parabola
                   scale: scaling factors in the X, Y and Z directions
                   half: if True, draws half cone
                   color: color of the surface
                   name: name of the surface
                   opacity: opacity of the surface
                   thickness: thickness of the surface
                &#34;&#34;&#34;
                delta = (xmax - xmin) / steps
                x = xmax
                bm = bmesh.new()
                verts = []
                count = 2 * steps + 2
                if xmin == 0.0:
                        count = 2 * steps + 1
                if half:
                        count = steps + 1
                for k in range(count):
                        z = a * x
                        verts.append(bm.verts.new((x,0,z)))
                        if k == steps and xmin &gt; 0:
                                x = - xmin
                        else:
                                x -= delta
                        if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;placeholder_mesh&#39;)
                obj = self.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()

                modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                modifier.angle = 2 * math.pi
                modifier.steps = 128
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_parabolic_cylinder(self,p=0.25,xmin=0.0,xmax=6.0,length=20,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;ParabolicCylinder&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws a parabolic cylinder from the parabola z=p*x^2 in the XZ plane
                Parameters:
                   p: coefficients of the parabola
                   xmin: minimum value of x
                   xmax: maximum value of x
                   length: length in the Y direction
                   steps: numbers of steps to draw the parabola
                   scale: scaling factors in the X, Y and Z directions
                   color: color of the surface
                   name: name of the surface
                   opacity: opacity of the surface
                   thickness: thickness of the surface
                &#34;&#34;&#34;
                delta = (xmax - xmin) / steps
                x = xmax
                bm = bmesh.new()
                verts = []
                count = 2 * steps + 2
                if xmin == 0.0:
                        count = 2 * steps + 1
                for k in range(count):
                        z = p * x**2
                        verts.append(bm.verts.new((x,0,z)))
                        if k == steps and xmin &gt; 0:
                                x = - xmin
                        else:
                                x -= delta
                        if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;ParabolicCylinderMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()

                bpy.context.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = obj
                bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
                bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
                bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
                bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0, length, 0),&#34;constraint_axis&#34;:(False, True, False),&#34;use_accurate&#34;:True})
                bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj.select_set(True)
                bpy.ops.transform.translate(value=(0, -length/2, 0),constraint_axis=(False, True, False))
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                obj.select_set(False)

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_hyperbolic_cylinder(self,a=1.0,b=4.0,xmin=2.0,xmax=6.0,length=20,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicCylinder&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws an hyperbolic cylinder from the hyperbole y = a * sqrt(x**2 - b) in the XY plane
                Parameters:
                   a, b: coefficients of the hyperbole
                   xmin: minimum value of x
                   xmax: maximum value of x
                   length: length in the Z direction
                   steps: numbers of steps to draw the parabola
                   scale: scaling factors in the X, Y and Z directions
                   color: color of the surface
                   name: name of the surface
                   opacity: opacity of the surface
                   thickness: thickness of the surface
                &#34;&#34;&#34;
                if xmin &lt; math.sqrt(b):
                        xmin = math.sqrt(b)
                delta = (xmax-xmin)/steps
                bm = bmesh.new()
                verts = []
                count = 2 * steps + 2
                if xmin == 0.0:
                        count = 2 * steps + 1
                for q, d in [[1,0],[-1,count]]:
                        x = xmax
                        sign = 1
                        for k in range(count):
                                if k == steps + 1:
                                        sign = -1
                                if x &lt; math.sqrt(b):
                                        x = math.sqrt(b)
                                y = sign * a * math.sqrt(x**2 - b)
                                verts.append(bm.verts.new((q * x,y,0)))
                                if k == steps and xmin &gt; math.sqrt(b):
                                        x = xmin
                                else:
                                        x = x - sign * delta
                                if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                                        continue
                                bm.edges.new([verts[d + k-1], verts[d + k]])

                me = self.meshes.new(&#39;HyperboliclinderMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()

                self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = obj
                bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
                bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
                bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
                bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0,0,length),&#34;constraint_axis&#34;:(False,False,True),&#34;use_accurate&#34;:True})
                bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj.select_set(True)
                bpy.ops.transform.translate(value=(0,0,-length/2),constraint_axis=(False,False,True))
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                obj.select_set(False)

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_elliptic_cylinder(self,a=8.0,b=5.0,amin=0.0,amax=2*math.pi,length=20,steps=200,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;EllipticCylinder&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws an eliptic cylinder from the ellipse
                  x = a*cos(t)
                  y = b*sin(t)
                in the XY plane
                Parameters:
                   a, b: coefficients of the ellipsw
                   amin: minimum value of the angle t
                   amax: maximum value of the angle t
                   length: length in the Z direction
                   steps: numbers of steps to draw the parabola
                   scale: scaling factors in the X, Y and Z directions
                   color: color of the surface
                   name: name of the surface
                   opacity: opacity of the surface
                   thickness: thickness of the surface
                &#34;&#34;&#34;
                if amin &lt; 0.0:
                        amin = 0.0
                if amax &gt; 2 * math.pi:
                        amax = 2 * math.pi
                delta = (amax-amin)/steps
                bm = bmesh.new()
                verts = []
                t = amin
                for k in range(steps + 1):
                        x = a * math.cos(t)
                        y = b * math.sin(t)
                        verts.append(bm.verts.new((x,y,0)))
                        t += delta
                        if k == 0:
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;EllipticCylinderMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()
                self.scene.collection.objects.link(obj)

                bpy.context.view_layer.objects.active = obj
                bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
                bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
                bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
                bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0,0,length),&#34;constraint_axis&#34;:(False,False,True),&#34;use_accurate&#34;:True})
                bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj.select_set(True)
                bpy.ops.transform.translate(value=(0,0,-length/2),constraint_axis=(False,False,True))
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                obj.select_set(False)

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_hyperbolic_paraboloid(self,a=0.2,b=0.4,xmax=10.0,ymax=10.0,steps=64,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicParaboloid&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws an hyperbolic paraboloid with equation z = a*x^2 - b*y^2
                Parameters:
                   a, b: coefficients of the parabolic hyperboloid
                   xmax: maximum  value of x
                   ymax: maxim value y
                   steps: numbers of steps to draw the parabola
                   scale: scaling factors in the X, Y and Z directions
                   color: color of the surface
                   name: name of the surface
                   opacity: opacity of the surface
                   thickness: thickness of the surface
                &#34;&#34;&#34;
                equ = lambda x,y: (x,y,a*x**2-b*y**2)
                obj = self.draw_surface(eq=equ,umin=-xmax,umax=xmax,usteps=steps,vmin=-ymax,vmax=ymax,vsteps=steps,thickness=thickness,opacity=opacity,pmax=0,name=&#34;Hyperbolic paraboloid&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),wrap_u=False,wrap_v=False,close_v=False)
                obj.scale = scale
                return obj
        #
        #
        #
        def draw_ellipsoid(self,radius=5.0,scale=[1.2,1.8,0.8],color=&#34;AzureBlueDark&#34;,name=&#34;Ellipsoid&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws en ellipsoid
                Parameters:
                   radius: radius of the sphere
                   scale: scaling factors in the X, Y and Z directions
                   color: color of the surface
                   name: name of the surface
                   opacity: opacity of the surface
                   thickness: thickness of the surface
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_uv_sphere_add(segments=128, ring_count=128, radius=radius, enter_editmode=False, location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                obj.select_set(False)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_plane_surface(self,origin=None,normal=None,base=None,sizex=10,sizey=10,vectors=False,scalelines=0.05,scalevector=0.01,
                                                color=&#34;AzureBlueDark&#34;,linecolor=&#34;BlueDarkDull&#34;,vectorcolor=&#34;Black&#34;,name=&#34;Plane&#34;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a plane with normal vector or base vectors. It passes through the point origin.
                Only normal or base can be not None
                Parameters:
                   origin: a point in the plane
                   normal: normal vector to the plane
                   base: list of two independent vectors
                   sizex: x-size of the plane
                   sizey: y-size of the plane
                   vectors: if True, draw the generators of the plane
                   scalelines: scale of the lines limiting the plane
                   scalevector: scale of the generators
                   color: color of the plane
                   linecolor: color of the lines limiting the plane
                   vectorcolor: color of the generators
                   name: name of the plane
                   opacity: opacity of the plane
                   thickness: thickness of the plane
                &#34;&#34;&#34;
                if normal is not None and base is not None:
                        return
                if normal is None and base is None:
                        return
                mat = Matrix(self.base)
                mat.transpose()
                if normal is not None:
                        if not isinstance(normal,Vector):
                                normal= Vector(normal)
                        normal = mat @ normal
                if base is not None:
                        if len(base) != 2:
                                return
                        if isinstance(base[0],Vector):
                                v1 = base[0]
                        else:
                                v1 = Vector(base[0])
                        if isinstance(base[1],Vector):
                                v2 = base[1]
                        else:
                                v2 = Vector(base[1])
                        v1 = mat @ v1
                        v2 = mat @ v2
                        normal = v1.cross(v2)

                if normal == Vector([0,0,0]):
                        return

                steps = 4
                delta = sizex / steps
                x = - sizex / 2
                bm = bmesh.new()
                verts = []
                for k in range(steps + 1):
                        verts.append(bm.verts.new((x,0,0)))
                        x += delta
                        if k == 0:
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;PlaneSurfaceMesh&#39;)
                obj = self.objects.new(&#39;PlaneSurface&#39;, me)
                bm.to_mesh(me)
                bm.free()

                bpy.context.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = obj
                bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
                bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
                bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
                bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0, sizey, 0),&#34;constraint_axis&#34;:(False, True, False),&#34;use_accurate&#34;:True})
                bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj.select_set(True)
                bpy.ops.transform.translate(value=(0, -sizey/2, 0),constraint_axis=(False, True, False))
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                obj.select_set(False)

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                if origin is not None:
                        if isinstance(origin,Vector):
                                op = op + origin
                        else:
                                op = op + Vector(origin)
                obj.location = o
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                lines = None
                vecs = None
                s = 0.0
                nodes = [[1,1,0],[-1,1,0],[-1,-1,0],[1,-1,0]]
                nodes = [self.comp_times_vector(Vector([sizex / 2,sizey / 2,0]),Vector(x)) for x in nodes]
                edges = [[0,1],[1,2],[2,3],[3,0]]

                if scalelines &gt; 0.0:
                        aux = self.origin
                        self.origin = Vector([0,0,0])
                        objects = []
                        aux2 = self.base
                        self.reset_base()
                        for edge in edges:
                                l = self.draw_line(start=nodes[edge[0]],end=nodes[edge[1]],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)
                        self.set_origin(aux)
                        self.set_base(aux2)


                if lines is not None:
                        obj = self.join([obj,lines])

                if vectors:
                        vecs = self.draw_vectors(nodes,True,color=vectorcolor,scale=scalevector,head_height=0.2,name=&#34;Vectors&#34;,axis=0)
                if vecs is not None:
                        obj = self.join([obj,vecs])
                obj.name = name

                if isinstance(normal,Vector):
                        n = normal
                else:
                        n = Vector(normal)
                z = Vector([0,0,1])
                quaternion = z.rotation_difference(n)
                tmp = obj.rotation_quaternion
                quaternion = tmp @ quaternion
                obj.rotation_quaternion = quaternion
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_point(self,radius=0.2,location=(0,0,0),name=&#34;Point&#34;,color=&#34;Black&#34;,opacity=1.0):
                &#34;&#34;&#34;
                Draws a point (in the reference self.origin, self.base)
                Parameters:
                   radius: radius of the point
                   location: location of the point
                   name: name of the point
                   color: color of the point
                   opacity: opacity of the point
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_uv_sphere_add(segments=16, ring_count=16, radius=radius, enter_editmode=False, location=location)
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                if not isinstance(location,Vector):
                        location = Vector(location)
                mat = Matrix(self.base)
                mat.transpose()
                location = mat @ location

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = 0.1
                modifier.offset = 0.0
                c = Colors.color(color)
                op = Vector(self.origin)
                obj.location = op + location
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                bpy.ops.object.shade_smooth()
                obj.select_set(False)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_cube(self,origin=None,scale=[1,1,1],scalelines=0.05,vectors=False,color=&#34;Blue&#34;,linecolor=&#34;Red&#34;,vectorcolor=&#34;Black&#34;,name=&#39;Parallelepiped&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a rectangular parallelepiped
                Parameters:
                   origin: center of the parallelepiped
                   scale: scale of the sides of the parallelepiped
                   scalelines: scale of the edges of the parallelepiped
                   vectors: if True, draws vectors from the origin to the vertices
                   color: color of the parallelepiped
                   linecolor: color of the edges
                   vectorcolor: color of the vectors
                   name: name of the parallelepiped
                   opacity: opacity of the parallelepiped
                   thickness: thickness of the parallelepiped
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_cube_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                if origin is not None:
                        if isinstance(origin,Vector):
                                op = op + origin
                        else:
                                op = op + Vector(origin)
                obj.location = o
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                vecs = None
                s = 0.0
                nodes = [[1+s,1+s,1+s],[-1-s,1+s,1+s],[-1-s,-1-s,1+s],[1+s,-1-s,1+s],
                                [1+s,1+s,-1-s],[-1-s,1+s,-1-s],[-1-s,-1-s,-1-s],[1+s,-1-s,-1-s]]
                nodes = [self.comp_times_vector(Vector(scale),Vector(x)) for x in nodes]
                edges =[[0,1],[1,2],[2,3],[3,0],[0,4],[1,5],[2,6],[3,7],[4,5],[5,6],[6,7],[7,4]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=op+nodes[edge[0]],end=op+nodes[edge[1]],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                if vectors:
                        vecs = self.draw_vectors(nodes,color=vectorcolor,scale=0.05,head_height=0.2,name=&#34;Vectors&#34;,axis=0)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.scale = scale

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                if lines is not None:
                        obj = self.join([obj,lines])

                if vecs is not None:
                        obj = self.join([obj,vecs])
                return obj
        #
        #
        #
        def draw_parallelepiped(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],u3=[0,0,1],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Parallelepiped&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a parallelepiped
                Parameters:
                   origin: base vertex of the parallelepiped
                   u1, u2, u3: vectors that gives the edges
                   scalelines: scale of the edges of the parallelepiped
                   color: color of the parallelepiped
                   linecolor: color of the edges
                   name: name of the parallelepiped
                   opacity: opacity of the parallelepiped
                   thickness: thickness of the parallelepiped
                &#34;&#34;&#34;
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                if not isinstance(u3,Vector):
                        u3 = Vector(u3)

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2
                u3 = mat @ u3

                bpy.ops.mesh.primitive_cube_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                verts = obj.data.vertices
                verts[0].co = op
                verts[1].co = op + u3
                verts[2].co = op + u2
                verts[3].co = op + u2 + u3
                verts[4].co = op + u1
                verts[5].co = op + u1 + u3
                verts[6].co = op + u1 + u2
                verts[7].co = op + u1 + u2 + u3

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                s = 0.0
                edges =[[0,1],[0,2],[0,4],[1,3],[1,5],[2,3],[2,6],[3,7],[4,5],[4,6],[5,7],[6,7]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj
        #
        #
        #
        def draw_tetrahedron(self,origin=[0,0,0],u1=[2,0,0],u2=[2*math.cos(math.pi/3),2*math.sin(math.pi/3),0],u3=[(2+2*math.cos(math.pi/3))/3,2*math.sin(math.pi/3)/3,2],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Tetrahedron&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a tetrahedron
                Parameters:
                   origin: base vertex of the tetrahedron
                   u1, u2, u3: vectors that gives the edges
                   scalelines: scale of the edges of the tetrahedron
                   color: color of the tetrahedron
                   linecolor: color of the edges
                   name: name of the tetrahedron
                   opacity: opacity of the tetrahedron
                   thickness: thickness of the tetrahedron
                &#34;&#34;&#34;
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                if not isinstance(u3,Vector):
                        u3 = Vector(u3)

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2
                u3 = mat @ u3

                bpy.ops.mesh.primitive_solid_add()
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                verts = obj.data.vertices
                verts[0].co = op + u3
                verts[1].co = op
                verts[2].co = op + u1
                verts[3].co = op + u2

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                s = 0.0
                edges =[[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj
        #
        #
        #
        def draw_pyramid(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],u3=[0.5,0.5,1],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Pyramid&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a pyramid
                Parameters:
                   origin: base vertex of the pyramid
                   u1, u2, u3: vectors that gives the edges
                   scalelines: scale of the edges of the pyramid
                   color: color of the pyramid
                   linecolor: color of the edges
                   name: name of the pyramid
                   opacity: opacity of the pyramid
                   thickness: thickness of the pyramid
                &#34;&#34;&#34;
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                if not isinstance(u3,Vector):
                        u3 = Vector(u3)

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2
                u3 = mat @ u3

                bpy.ops.mesh.primitive_cone_add(radius1=1, radius2=0, depth=2, enter_editmode=False, align=&#39;WORLD&#39;,vertices=4)
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                verts = obj.data.vertices
                verts[0].co = op
                verts[1].co = op + u1
                verts[2].co = op + u1 + u2
                verts[3].co = op + u2
                verts[4].co = op + u3

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                s = 0.0
                edges =[[0,1],[0,3],[0,4],[1,2],[1,4],[2,3],[2,4],[3,4]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj
        #
        #
        #
        def draw_parallelogram(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Parallelogram&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a parallelogram
                Parameters:
                   origin: base vertex of the parallelogram
                   u1, u2: vectors that gives the edges
                   scalelines: scale of the edges of the parallelogram
                   color: color of the parallelogram
                   linecolor: color of the edges
                   name: name of the parallelogram
                   opacity: opacity of the parallelogram
                   thickness: thickness of the parallelogram
                &#34;&#34;&#34;
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2

                bpy.ops.mesh.primitive_plane_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                verts = obj.data.vertices
                verts[0].co = op
                verts[1].co = op + u1
                verts[2].co = op + u2
                verts[3].co = op + u1 + u2

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                s = 0.0
                edges =[[0,1],[0,2],[1,3],[2,3]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj
        #
        #
        #
        def draw_polygon(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],points=[[0,0],[1,0],[0,1]],scalelines=0.075,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Polygon&#39;,opacity=1.0,thickness=0.0,vectors=None,scalevectors=0.01):
                &#34;&#34;&#34;
                Draws a polygon
                Parameters:
                   origin: base vertex of the polygon
                   u1, u2: base vectors for the polygon
                   points: list of coordinates of points. The coordinates are taken in the reference {origin; u1, u2}
                   scalelines: scale of the edges of the polygon
                   color: color of the polygon
                   linecolor: color of the edges
                   name: name of the polygon
                   opacity: opacity of the polygon
                   thickness: thickness of the polygon
                &#34;&#34;&#34;
                if len(points) &lt; 3:
                        return
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                for i in range(len(points)):
                        if not isinstance(points[i],Vector):
                                points[i] = Vector(points[i])

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2



                bpy.ops.curve.simple(Simple_Type=&#39;Polygon&#39;,Simple_sides=len(points),align=&#39;WORLD&#39;,location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)

                baricentre = Vector([0,0,0])
                verts = obj.data.splines[0].bezier_points
                for i in range(len(verts)):
                        verts[i].co = op + points[i][0] * u1 + points[i][1] * u2
                        baricentre += verts[i].co
                baricentre /= len(verts)

                for i in range(len(verts)):
                        verts[i].co -= baricentre
                obj.location = baricentre

                obj.select_set(True)
                bpy.ops.object.convert(target=&#39;MESH&#39;)

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                ps = [op + points[i][0] * u1 + points[i][1] * u2 for i in range(len(points))]
                lines = None
                if scalelines &gt; 0.0:
                        objects = []
                        for i in range(len(points)):
                                l = self.draw_line(start=ps[i],end=ps[(i + 1) % len(points)],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                if vectors is not None:
                        old = self.origin
                        self.set_origin(op)
                        ps = [points[i][0] * u1 + points[i][1] * u2 for i in range(len(points))]
                        vecs = self.draw_vectors(ps,color=vectors,scale=scalevectors)
                        self.set_origin(old)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])
                if vectors is not None:
                        obj = self.join([obj,vecs])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj

        #
        #
        #
        def draw_regular_polygon(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],vertexs=5,radius=1,scalelines=0.075,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;RegularPolygon&#39;,opacity=1.0,thickness=0.0,vectors=None):
                &#34;&#34;&#34;
                Draws a regular polygon
                Parameters:
                   origin: base vertex of the polygon
                   u1, u2: base vectors for the polygon
                   vertexs: number of vertices of the polygon
                   radius: radius of the polygon
                   scalelines: scale of the edges of the polygon
                   color: color of the polygon
                   linecolor: color of the edges
                   name: name of the polygon
                   opacity: opacity of the polygon
                   thickness: thickness of the polygon
                &#34;&#34;&#34;
                angle = 2*math.pi/vertexs
                points = [[radius*math.cos(i*angle),radius*math.sin(i*angle)] for i in range(vertexs)]
                return self.draw_polygon(origin=origin,u1=u1,u2=u2,points=points,scalelines=scalelines,color=color,linecolor=linecolor,name=name,opacity=opacity,thickness=thickness,vectors=vectors,scalevectors=radius/400)
        #
        #
        #
        def draw_triangle(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],points=[[0,0],[1,0],[0,1]],scalelines=0.075,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#34;Triangle&#34;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a triangle. It&#39;s a polygon with three vertices
                Parameters:
                   origin: base vertex of the triangle
                   u1, u2: base vectors for the triangle
                   points: list of coordinates of points. The coordinates are taken in the reference {origin; u1, u2}
                   scalelines: scale of the edges of the triangle
                   color: color of the triangle
                   linecolor: color of the edges
                   name: name of the triangle
                   opacity: opacity of the triangle
                   thickness: thickness of the triangle
                &#34;&#34;&#34;
                if len(points) != 3:
                        return
                self.draw_polygon(origin=origin,u1=u1,u2=u2,points=points,scalelines=scalelines,color=color,linecolor=linecolor,name=name,opacity=opacity,thickness=thickness)

        #
        #
        #
        def draw_points(self,points=[],name=&#39;Points&#39;,color=&#34;Blue&#34;,opacity=1):
                &#34;&#34;&#34;
                Draws a list of points
                Parameters:
                   origin:
                   points: list of points
                   name: name of the list of points
                   color: color of the points
                   opacity: opacity of the points
                &#34;&#34;&#34;
                bm = bmesh.new()
                verts = []
                for p in points:
                        verts.append(bm.verts.new(p))

                me = self.meshes.new(&#39;PointsMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()
                self.scene.collection.objects.link(obj)
                return obj
        #
        #
        #
        def draw_mesh(self,mesh=None,name=&#39;Mesh&#39;,color=&#34;Blue&#34;,opacity=1):
                &#34;&#34;&#34;
                Draws a mesh. This function is used by other functions
                Parameters:
                   mesh: the mesh to be drawn
                   name: name of the mesh
                   color: color of the mesh
                   opacity: opacity of the mesh
                &#34;&#34;&#34;
                bm = bmesh.new()
                verts = []
                for p in mesh.points:
                        verts.append(bm.verts.new(p))
                edges = [[0,1],[1,2],[2,3],[3,0]]
                for s in mesh.simplices:
                        for e in edges:
                                v = Vector(mesh.points[s[e[0]]]) - Vector(mesh.points[s[e[1]]])
                                edge = [verts[s[e[0]]],verts[s[e[1]]]]
                                try:
                                        bm.edges.new(edge)
                                except:
                                        pass
                me = self.meshes.new(&#39;PointsMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()
                self.scene.collection.objects.link(obj)
                return obj
        #
        #
        #
        def join(self,list):
                &#34;&#34;&#34;
                Joins a list of objects
                Parameters:
                   list: list of objects
                &#34;&#34;&#34;
                if len(list) &lt;= 1:
                        return
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.context.view_layer.objects.active = list[0]
                for obj in list:
                        obj.select_set(True)
                bpy.ops.object.join()
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                return list[0]
        #
        #
        #
        def vectors_to_quaternion(self,u1=Vector([1,0,0]),u2=Vector([0,1,0])):
                &#34;&#34;&#34;
                Returns the quaternion correspondint to the base {v1,v2,v3}
                u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
                       v1 = u1
                           v2 = u2 - u2.project(v1)
                           v1.normalize()
                           v2.normalize()
                           v3 = v1.cross(v2)
                &#34;&#34;&#34;
                if isinstance(u1,Vector):
                        v1 = u1
                else:
                        v1 = Vector(u1)
                if isinstance(u2,Vector):
                        v2 = u2
                else:
                        v2 = Vector(u2)
                v2 = v2 - v2.project(v1)
                v1.normalize()
                v2.normalize()
                v3 = v1.cross(v2)
                mat = Matrix([v1,v2,v3])
                mat.transpose()
                return mat.to_quaternion()
        #
        #
        #
        def ellipsoid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Ellipsoid&#34;,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an ellipsoid
                Parameters:
                   o: center of the ellipsoid
                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
                       v1 = u1
                           v2 = u2 - u2.project(v1)
                           v1.normalize()
                           v2.normalize()
                           v3 = v1.cross(v2)
                   a2, b2, c2: squares of semi-axes of the ellipsoid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 + z&#39;^2/c^2 = 1
                   principal: if True, the principal axis are drawn
                   canonica: if True, the canonical axis are drawn
                   color: color of the surface
                   name: name of the ellipsoid
                   cmax: the canonical axis are drawn between -cmax and cmax
                   pmax: the principal axis are drawn between -pmax and pmax
                   thickness: thickness of the ellipsoid
                   opacity: opaccity of the ellipsoid
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                c = math.sqrt(c2)
                self.draw_ellipsoid(radius=1,scale=[a,b,c],color=color,name=name,thickness=thickness,opacity=opacity)
        #
        #
        #
        def sphere(self,o=[0,0,0],r2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Sphere&#34;,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws a sphere of center &#39;o&#39; and radius squared equal to &#39;r2&#39;
                Parameters:
                   o: center of the sphere
                   r2: radius squared
                   principal: if True, the principal axis are drawn
                   canonica: if True, the canonical axis are drawn
                   color: color of the surface
                   name: name of the sphere
                   cmax: the canonical axis are drawn between -cmax and cmax
                   pmax: the principal axis are drawn between -cmax and cmax
                   thickness: thickness of the sphere
                   opacity: opacity of the sphere
                &#34;&#34;&#34;
                u1 = Vector([1,0,0])
                u2 = Vector([0,1,0])
                return self.ellipsoid(o=o,u1=u1,u2=u2,a2=r2,b2=r2,c2=r2,principal=principal,canonica=canonica,color=color,name=name,cmax=cmax,pmax=pmax,thickness=thickness,opacity=opacity)
        #
        #
        #
        def one_sheet_hyperboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;OneSheetHyperboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an one sheet hyperboloid
                Parameters:
                   o: center of the hyperboloid
                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
                   a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = 1
                   principal: if True, the principal axis are drawn
                   canonica: if True, the canonical axis are drawn
                   color: color of the surface
                   name: name of the hyperboloid
                   xmax: maximum value of the x coordinate
                   cmax: the canonical axis are drawn between -cmax and cmax
                   pmax: the principal axis are drawn between -cmax and cmax
                   thickness: thickness of the hyperboloid
                   opacity: opacity of the hyperboloid
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                c = math.sqrt(c2)
                if xmax is None:
                        xmax=5.0/a + 2
                xmax /= a
                self.draw_one_sheet_hyperboloid(a=1.0,b=1.0,xmin=1.0,xmax=xmax,scale=[a,b,c],color=color,name=name,thickness=thickness,opacity=opacity)
        #
        #
        #
        def two_sheets_hyperboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;TwoSheetParaboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws a two sheets hyperboloid
                Parameters:
                   o: center of the hyperboloid
                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
                   a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = -1
                   principal: if True, the principal axis are drawn
                   canonica: if True, the canonical axis are drawn
                   color: color of the surface
                   name: name of the hyperboloid
                   xmax: maximum value of the x coordinate
                   cmax: the canonical axis are drawn between -cmax and cmax
                   pmax: the principal axis are drawn between -cmax and cmax
                   thickness: thickness of the hyperboloid
                   opacity: opacity of the hyperboloid
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                c = math.sqrt(c2)
                if xmax is None:
                        xmax = 5.0/a + 2
                xmax /= a
                self.draw_two_sheets_hyperboloid(a=1.0,b=1.0,xmin=0.0,xmax=xmax,color=color,scale=[a,b,c],name=name,thickness=thickness,opacity=opacity)
        #
        #
        #
        def cone(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,half=False,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Cone&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws a cone
                Parameters:
                   o: center of the cone
                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
                   a2, b2, c2: squares of semi-axes of the cone. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = 0
                   half: if True draws half cone
                   principal: if True, the principal axis are drawn
                   canonica: if True, the canonical axis are drawn
                   color: color of the surface
                   name: name of the cone
                   xmax: maximum value of the x coordinate
                   cmax: the canonical axis are drawn between -cmax and cmax
                   pmax: the principal axis are drawn between -cmax and cmax
                   thickness: thickness of the cone
                   opacity: opacity of the cone
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                c = math.sqrt(c2)
                if xmax is None:
                        xmax = 10.0/a + 2
                xmax /= a
                self.draw_cone(a=1.0,xmin=0.0,xmax=xmax,steps=50,half=half,color=color,scale=[a,b,c],name=name,thickness=thickness,opacity=opacity)
        #
        #
        #
        def hyperbolic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicCylinder&#34;,xmax=None,zmax=20,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an hyperbolic cylinder
                Parameters:
                   o: center of the hyperbolic cylinder
                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
                   a2, b2: squares of semi-axes of the hyperbolic cylinder. The equation is x&#39;^2/a^2 - y&#39;^2/b^2 = 1
                   principal: if True, the principal axis are drawn
                   canonica: if True, the canonical axis are drawn
                   color: color of the surface
                   name: name of the hyperbolic cylinder
                   xmax: maximum value of the x coordinate
                   zmax: the hyperbolic cylinder is drawn between -zmax and zmax
                   cmax: the canonical axis are drawn between -cmax and cmax
                   pmax: the principal axis are drawn between -cmax and cmax
                   thickness: thickness of the hyperbolic cylinder
                   opacity: opacity of the hyperbolic cylinder
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                if xmax is None:
                        xmax = 5.0/a + 2
                xmax /= a
                obj = self.draw_hyperbolic_cylinder(a=1.0,b=1.0,xmin=1.0,xmax=xmax,length=zmax,steps=50,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)
        #
        #
        #
        def elliptic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;EllipticCylinder&#34;,zmax=20,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an elliptic cylinder
                Parameters:
                   o: center of the elliptic cylinder
                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
                   a2, b2: squares of semi-axes of the elliptic cylinder. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 = 1
                   principal: if True, the principal axis are drawn
                   canonica: if True, the canonical axis are drawn
                   color: color of the surface
                   name: name of the elliptic cylinder
                   zmax: the elliptic cylinder is drawn between -zmax and zmax
                   cmax: the canonical axis are drawn between -cmax and cmax
                   pmax: the principal axis are drawn between -cmax and cmax
                   thickness: thickness of the elliptic cylinder
                   opacity: opacity of the elliptic cylinder
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                self.draw_elliptic_cylinder(a=1.0,b=1.0,length=zmax,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)
        #
        #
        #
        def elliptic_paraboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;EllipticParaboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an elliptic paraboloid
                Parameters:
                   o: vertex of the elliptic paraboloid
                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
                   a2, b2: squares of semi-axes of the elliptic paraboloid. The equation is z = x&#39;^2/a^2 + y&#39;^2/b^2
                   principal: if True, the principal axis are drawn
                   canonica: if True, the canonical axis are drawn
                   color: color of the surface
                   name: name of the elliptic paraboloid
                   xmax: maximum value of the coordinate x
                   cmax: the canonical axis are drawn between -cmax and cmax
                   pmax: the principal axis are drawn between -cmax and cmax
                   thickness: thickness of the elliptic paraboloid
                   opacity: opacity of the elliptic paraboloid
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                if xmax is None:
                        xmax = 10.0/a
                xmax /= a
                self.draw_elliptic_paraboloid(a=1.0,xmin=0.0,xmax=xmax,steps=50,scale=[a,b,1],color=color,name=name,opacity=opacity,thickness=thickness)
        #
        #
        #
        def hyperbolic_paraboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicParaboloid&#34;,xmax=None,ymax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an hyperbolic paraboloid
                Parameters:
                   o: vertex of the hyperbolic paraboloid
                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
                   a2, b2: squares of semi-axes of the hyperbolic paraboloid. The equation is z = x&#39;^2/a^2 - y&#39;^2/b^2
                   principal: if True, the principal axis are drawn
                   canonica: if True, the canonical axis are drawn
                   color: color of the surface
                   name: name of the elliptic paraboloid
                   xmax: maximum value of the coordinate x
                   ymax: maximum value of the coordinate y
                   cmax: the canonical axis are drawn between -cmax and cmax
                   pmax: the principal axis are drawn between -cmax and cmax
                   thickness: thickness of the hyperbolic paraboloid
                   opacity: opacity of the hyperbolic paraboloid
                &#34;&#34;&#34;
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                if xmax is None:
                        xmax = 10.0/a + 2
                if ymax is None:
                        ymax = 10.0/b + 1
                xmax /= a
                ymax /= b
                obj = self.draw_hyperbolic_paraboloid(a=1.0,b=1.0,xmax=xmax,ymax=ymax,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)

                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                obj.location = o
        #
        #
        #
        def parabolic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;ParabolicCylinder&#34;,xmax=None,ymax=30,cmax=20,pmax=20,thickness=0.02,opacity=1.0):
                &#34;&#34;&#34;
                Draws an hyperbolic paraboloid
                Parameters:
                   o: vertex of the hyperbolic paraboloid
                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
                   a2, b2: squares of semi-axes of the hyperbolic paraboloid. The equation is z = x&#39;^2/a^2 - y&#39;^2/b^2
                   principal: if True, the principal axis are drawn
                   canonica: if True, the canonical axis are drawn
                   color: color of the surface
                   name: name of the elliptic paraboloid
                   xmax: maximum value of the coordinate x
                   ymax: maximum value of the coordinate y
                   cmax: the canonical axis are drawn between -cmax and cmax
                   pmax: the principal axis are drawn between -cmax and cmax
                   thickness: thickness of the hyperbolic paraboloid
                   opacity: opacity of the hyperbolic paraboloid
                &#34;&#34;&#34;
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                coef = 1.0
                if a &lt; 0:
                        coef = -1
                if xmax is None:
                        xmax = 5.0/a + 1.5
                xmax /= a
                self.draw_parabolic_cylinder(p=coef,xmin=0.0,xmax=xmax,length=ymax,color=color,name=name,scale=[a,1,1],thickness=thickness,opacity=opacity)
        #
        #
        #
        def draw_simple_curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.02,color=&#34;White&#34;,name=&#34;Curve&#34;):
                &#34;&#34;&#34;
                Draws a parametric curve
                Parameters:
                   fun: the parametric function
                   tmin: minimum value of the parameter
                   tmax: maximum value of the parameter
                   steps: number of steps
                   thickness: thickness of the curve
                   color: color of the curve
                   name: name of the curve
                &#34;&#34;&#34;
                if fun is None:
                        return None
                delta = (tmax - tmin) / steps
                t = tmin

                curve = bpy.data.curves.new(&#39;myCurve&#39;, type=&#39;CURVE&#39;)
                curve.dimensions = &#39;3D&#39;
                curve.resolution_u = 2

                line = curve.splines.new(&#39;POLY&#39;)
                line.points.add(steps)

                for i in range(steps+1):
                        p = fun(t)
                        p.append(1)
                        line.points[i].co = p
                        t += delta

                obj = bpy.data.objects.new(name, curve)
                curve.bevel_depth = thickness

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
                self.scene.collection.objects.link(obj)
                return obj
        #
        #
        #
        def draw_curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,axis=False,zaxis=True,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0])):
                &#34;&#34;&#34;
                Draws a curve in a reference R&#39; determined by the origin o and basis {v1, v2, v3} constructed from u1 and u2
                Parameters:
                   fun: the parametric function
                   tmin: minimum value of the parameter
                   tmax: maximum value of the parameter
                   steps: number of steps
                   thickness: thickness of the curve
                   name: name of the curve
                   color: color of the curve
                   axis: if True draws the axis of the reference R&#39;
                   zaxis: if True draws the z&#39; axis
                   o: origin of the reference R&#39;
                   u1, u2: vectors to construct the basis {v1, v2, v3}
                &#34;&#34;&#34;
                if fun is None:
                        return None
                qt = self.vectors_to_quaternion(u1,u2)
                delta = (tmax - tmin) / steps
                t = tmin
                bm = bmesh.new()
                verts = []

                pmax = 0
                for k in range(steps + 1):
                        p = fun(t)
                        m = max(map(abs,p))
                        if m &gt; pmax:
                                pmax = m
                        verts.append(bm.verts.new(p))
                        t += delta
                        if t &gt; tmax:
                                t = tmax

                for i in range(len(verts) - 1):
                        bm.edges.new([verts[i], verts[i+1]])

                me = self.meshes.new(&#39;placeholder_mesh&#39;)
                obj = self.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()

                modifier = obj.modifiers.new(type=&#39;SKIN&#39;,name = &#39;skin&#39;)
                for v in obj.data.skin_vertices[0].data:
                        v.radius = (thickness,thickness)

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
                self.set_origin(o)
                self.set_rotation(quaternion=qt)
                if self.rotation is not None:
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                if axis:
                        self.draw_base_axis(axis = pmax+3,positive=False,name=&#34;Referència escollida&#34;,zaxis=zaxis)
                self.scene.collection.objects.link(obj)
                bpy.ops.object.shade_smooth()
                obj.location = o
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,axis=False,zaxis=True,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),symmetry=None,change=False):
                &#34;&#34;&#34;
                Draws a curve in a reference R&#39; determined by the origin o and basis {v1, v2, v3} constructed from u1 and u2 and
                the symmetric curve or curves from the parameter &#39;symmetry&#39;
                Parameters:
                   fun: the parametric function
                   tmin: minimum value of the parameter
                   tmax: maximum value of the parameter
                   steps: number of steps
                   thickness: thickness of the curve
                   name: name of the curve
                   color: color of the curve
                   axis: if True draws the axis of the reference R&#39;
                   zaxis: if True draws the z&#39; axis
                   o: origin of the reference R&#39;
                   u1, u2: vectors to construct the basis {v1, v2, v3}
                   symmetry: list of values in (&#39;XY&#39;,&#39;XZ&#39;,&#39;YZ&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;,&#39;O&#39;). For every value S, draw the symmetric curve respect to S
                   change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                if fun is None:
                        return None
                obj = self.draw_curve(fun,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=name,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)

                if symmetry is None:
                        if change:
                                self.set_origin(o)
                                self.set_base([u1,u2],orthonormal=True)
                        return obj
                objs = [obj]
                if not isinstance(symmetry,list):
                        symmetry = [symmetry]
                for s in symmetry:
                        namem = name + s
                        if s == &#39;XY&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (p[0],p[1],-p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;XZ&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (p[0],-p[1],p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;YZ&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (-p[0],p[1],p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;X&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (p[0],-p[1],-p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;Y&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (-p[0],p[1],-p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;Z&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (-p[0],-p[1],p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;O&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (-p[0],-p[1],-p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                if change:
                        self.set_origin(o)
                        self.set_base([u1,u2],orthonormal=True)
                return self.join(objs)
        #
        #
        #
        def draw_circle(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),axis=False,zaxis=False,radius=1,steps=25,thickness=0.01,name=&#34;Circle&#34;,color=&#34;White&#34;,change=False):
                &#34;&#34;&#34;
                Draws a circle of center &#39;center&#39; and radius &#39;radius&#39; in the plane determined by vectors u1 and u2
                Parameters:
                   center: center of the circle
                   u1, u2: vectors to construct the basis {v1, v2, v3}
                   axis: if True draws the axis of the reference R&#39;
                   zaxis: if True draws the z&#39; axis
                   radius: radius of the circle
                   steps: number of steps
                   thickness: thickness of the curve
                   name: name of the curve
                   color: color of the curve
                   change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                if change:
                        self.set_origin(center)
                        self.set_base([u1,u2],orthonormal=True)
                return self.draw_curve(lambda t: (radius*math.cos(t),radius*math.sin(t),0),tmin=0.0,tmax=2*math.pi,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
        #
        #
        #
        def draw_ellipse(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,b=1,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Ellipse&#34;,color=&#34;White&#34;,change=False):
                &#34;&#34;&#34;
                Draws an ellipse of center &#39;center&#39; and semi-axes a and b in the plane determined by vectors u1 and u2
                Parameters:
                   center: center of the ellipse
                   u1, u2: vectors to construct the basis {v1, v2, v3}
                   a, b: semi-axes of the ellipse
                   axis: if True draws the axis of the reference R&#39;
                   zaxis: if True draws the z&#39; axis
                   steps: number of steps
                   thickness: thickness of the curve
                   name: name of the curve
                   color: color of the curve
                   change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                if change:
                        self.set_origin(center)
                        self.set_base([u1,u2],orthonormal=True)
                return self.draw_curve(lambda t: (a*math.cos(t),b*math.sin(t),0),tmin=0.0,tmax=2*math.pi,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
        #
        #
        #
        def draw_parabola(self,vertex=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,xmax=3.0,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Parabola&#34;,color=&#34;White&#34;,change=False):
                &#34;&#34;&#34;
                Draws a parabola of vertex &#39;vertex&#39; of equation y&#39;=ax&#39;^2 in the reference {vertex; v1, v2, v3} determined by vectors u1 and u2
                Parameters:
                   vertex: vertex of the parabola
                   u1, u2: vectors to construct the basis {v1, v2, v3}
                   a: coefficient of the parabola
                   xmax: maximum value of x&#39;
                   axis: if True draws the axis of the reference R&#39;
                   zaxis: if True draws the z&#39; axis
                   steps: number of steps
                   thickness: thickness of the curve
                   name: name of the curve
                   color: color of the curve
                   change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                if change:
                        self.set_origin(vertex)
                        self.set_base([u1,u2],orthonormal=True)
                return self.draw_curve(lambda t: (t,a*t**2,0),tmin=-xmax,tmax=xmax,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=vertex,u1=u1,u2=u2)
        #
        #
        #
        def draw_hyperbole(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,b=1,ymax=3.0,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Hyperbole&#34;,color=&#34;White&#34;,change=False):
                &#34;&#34;&#34;
                Draws an hyperbole of center &#39;center&#39; and semi-axes a and b in the plane determined by vectors u1 and u2
                Parameters:
                   center: center of the hyperbole
                   u1, u2: vectors to construct the basis {v1, v2, v3}
                   a, b: semi-axes of the hyperbole
                   ymax: maximum value of the y&#39;
                   axis: if True draws the axis of the reference R&#39;
                   zaxis: if True draws the z&#39; axis
                   steps: number of steps
                   thickness: thickness of the curve
                   name: name of the curve
                   color: color of the curve
                   change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                c1 = self.draw_curve(lambda t: (a*math.sqrt(1+t**2/b**2),t,0),tmin=-ymax,tmax=ymax,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
                c2 = self.draw_curve(lambda t: (-a*math.sqrt(1+t**2/b**2),t,0),tmin=-ymax,tmax=ymax,axis=False,zaxis=False,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
                self.join([c1,c2])
                if change:
                        self.set_origin(center)
                        self.set_base([u1,u2],orthonormal=True)
                return c1
        #
        #
        #
        def draw_surface(self,eq=None,umin=-1,umax=1,usteps=64,vmin=-1,vmax=1,vsteps=64,thickness=0.02,opacity=1.0,pmax=10,name=&#34;Surface&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),wrap_u=False,wrap_v=False,close_v=False):
                &#34;&#34;&#34;
                Draws a parametric surface in the reference R&#39;
                Parameters:
                   eq: parametric equacion f(u,v)
                   umin: minimum value of u
                   umax: maximum value of u
                   usteps: steps in the u direction
                   vmin: minimum value of v
                   vmax: maximum value of v
                   vsteps: steps in the v direction
                   thickness: thickness of the surface
                   opacity: opacity of the surface
                   color: color of the surface
                   pmax: the principal axis are drawn between -cmax and cmax
                   name: name of the surface
                   color: color of the surface
                   axis: if True draw the axis of the reference {o, v1, v2, v3}
                   o: origin of the reference R&#39;
                   u1, u2: vectors to construct the basis {v1, v2, v3}
                   scale: scale coefficients
                   wrap_u: wrap the u coordinate
                   wrap_v: wrap the u coordinate
                   close_v: close the v coordinate
                &#34;&#34;&#34;
                if eq is None:
                        return

                q = self.vectors_to_quaternion(u1,u2)
                draw_parametric_surface(eq=eq,range_u_min=umin,range_u_max=umax,range_u_step=usteps,range_v_min=vmin,range_v_max=vmax,range_v_step=vsteps,name=name,wrap_u=wrap_u,wrap_v=wrap_v,close_v=close_v)

                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)
                obj.show_wire = False

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if self.rotation is not None:
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                if axis:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència escollida&#34;)

                bpy.ops.object.shade_smooth()
                obj.location = o
                obj.select_set(False)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_function(self,f=None,xmin=-3,xmax=3,xsteps=64,ymin=-3,ymax=3,ysteps=64,thickness=0.02,opacity=1.0,pmax=10,name=&#34;Function&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0])):
                &#34;&#34;&#34;
                Draws a function of two variables f(x,y) i the reference R&#39; = {o, v1, v2, v3}
                Parameters:
                   f: the function of two variables f(x,y)
                   xmin: minimum value of x
                   xmax: maximum value of x
                   xsteps: steps in the x direction
                   ymin: minimum value of y
                   ymax: maximum value of y
                   ysteps: steps in the x direction
                   thickness: thickness of the surface
                   opacity: opacity of the surface
                   pmax: the axis are drawn between -pmax and pmax
                   name: name of the surface
                   color: color of the surface
                   axis: if True the axis of the reference R&#39; are drawn
                   o: origin of the reference R&#39;
                   u1, u2: vectors to construct the basis {v1, v2, v3}
                &#34;&#34;&#34;
                if f is None:
                        return None
                return self.draw_surface(eq=lambda x,y:(x,y,f(x,y)),umin=xmin,umax=xmax,usteps=xsteps,vmin=ymin,vmax=ymax,vsteps=ysteps,thickness=thickness,opacity=opacity,pmax=pmax,name=name,color=color,axis=axis,o=o,u1=u1,u2=u2,wrap_u=False,wrap_v=False,close_v=False)
        #
        #
        #
        def draw_vector_field(self,f=None,xmin=-3,xmax=3,xsteps=8,ymin=-3,ymax=3,ysteps=8,zmin=-3,zmax=3,zsteps=8,name=&#34;Vector Field&#34;,color=&#34;Red&#34;,scale=0.02,head_height=0.05):
                &#34;&#34;&#34;
                Draws a vector field
                Parameters:
                   f: the vector field
                   xmin: minimum value of x
                   xmax: maximum value of x
                   xsteps: steps in the x direction
                   ymin: minimum value of y
                   ymax: maximum value of y
                   ysteps: steps in the y direction
                   zmin: minimum value of z
                   zmax: maximum value of z
                   zsteps: steps in the z direction
                   name: name of the vector field
                   color: color of the vector field
                   scale: scale of the vectors
                   head_height: head height of the vectors
                &#34;&#34;&#34;
                if f is None:
                        return None
                xstep = (xmax - xmin)/xsteps
                ystep = (ymax - ymin)/ysteps
                zstep = (zmax - zmin)/zsteps
                if xstep == 0 or ystep == 0 or zstep == 0:
                        return None
                vectors = []
                count = 1
                x = xmin
                while x &lt;= xmax:
                        y = ymin
                        while y &lt;= ymax:
                                z = zmin
                                while z &lt;= zmax:
                                        o = Vector([x,y,z])
                                        v = f(x,y,z)
                                        if not isinstance(v,Vector):
                                                v = Vector(v)
                                        self.set_origin(o)
                                        vec = self.draw_vector(v,color=color,name=f&#34;Vector{count}&#34;,scale=scale,head_height=head_height)
                                        if vec is not None:
                                                vectors.append(vec)
                                        z += zstep
                                        count += 1
                                y += ystep
                        x += xstep
                v = self.join(vectors)
                bpy.context.object.name = name
                return v
        #
        #
        #
        def revolution_surface(self,fun=None,tmin=0.0,tmax=1.0,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),pmax=0,steps=256,thickness=0.025,axis=&#39;Z&#39;,name=&#34;Revolution surface&#34;,color=&#34;AzureBlueDark&#34;):
                &#34;&#34;&#34;
                Draws a revolution surface from a curve in the reference R&#39;
                Parameters:
                   fun: parametric equacion of the curve
                   steps: number of steps
                   axis: axis of revolution. It must be &#39;X&#39;, &#39;Y&#39; or &#39;Z&#39;
                   o: origin of the reference R&#39;
                   u1, u2: vectors to construct the basis {v1, v2, v3}
                   pmax: the principal axis are drawn between -pmax and pmax
                   color: color of the surface
                &#34;&#34;&#34;
                if fun is None:
                        return None
                q = self.vectors_to_quaternion(u1,u2)
                obj = self.simple_curve(fun,tmin=tmin,tmax=tmax,steps=steps,name=name)
                m = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                m.levels = 4
                m.subdivision_type = &#39;SIMPLE&#39;
                m = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                m.thickness = thickness
                m.offset = 1.0
                m = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                m.angle = 2*math.pi
                m.steps = steps
                m.axis =  axis
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
                bpy.context.scene.collection.objects.link(obj)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if self.rotation is not None:
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                if pmax &gt; 0.0:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència R&#39;&#34;)
                bpy.ops.object.shade_smooth()
                obj.location = o
                obj.select_set(False)
                bpy.context.view_layer.objects.active = None
        #
        #
        #
        def animate_revolution_surface(self,fun=None,tmin=0.0,tmax=1.0,steps=256,curvethicknes=0.025,thickness=0.025,frames=3,angle=3,radians=False,axis=&#39;Z&#39;,symmetry=None,name=&#34;Revolution surface&#34;,color=&#34;AzureBlueDark&#34;,point=None):
                &#34;&#34;&#34;
                Draws and animates a revolution surface from a curve
                Parameters:
                   fun: parametric equacion of the curve
                   steps: number of steps to graw the curve
                   curvethicknes: thickness of the curve
                   frames: number of frames at each step of revolution
                   angle: step angle of the revolution
                   radians: if True, angle must be in radians
                   axis: axis of revolution. It must be &#39;X&#39;, &#39;Y&#39; or &#39;Z&#39;
                   name: name of the surface
                   color: color of the surface
                   point: if not None draw three points and a cercle. Must be a float between tmax and tmin
                &#34;&#34;&#34;
                if radians:
                        angle *= 180/math.pi
                stepsr = int(360/angle) + 1
                angle = 360/stepsr
                if fun is None:
                        return None
                if axis == &#39;X&#39;:
                        r = Rotation(angle,Vector([1,0,0]))
                        d1 = Vector([0,1,0])
                        d2 = Vector([0,0,1])
                elif axis == &#39;Y&#39;:
                        r = Rotation(angle,Vector([0,1,0]))
                        d1 = Vector([0,0,1])
                        d2 = Vector([1,0,0])
                elif axis == &#39;Z&#39;:
                        r = Rotation(angle,Vector([0,0,1]))
                        d1 = Vector([1,0,0])
                        d2 = Vector([0,1,0])
                else:
                        return None

                if point is not None:
                        try:
                                tp = 1.0 * point
                        except:
                                pass
                        if not isinstance(tp,float):
                                return None
                        if tp &lt; tmin or tp &gt; tmax:
                                tp = random.uniform(tmin,tmax)
                        zp = Vector(fun(tp))
                        e = d1.cross(d2)
                        z0 = zp.project(e)

                p2 = self.curve(fun,tmin=tmin,tmax=tmax,steps=steps,thickness=curvethicknes,color=&#34;Red&#34;,name=name,symmetry=symmetry)
                p1 = self.curve(fun,tmin=tmin,tmax=tmax,steps=steps,thickness=1.05*curvethicknes,color=&#34;Blue&#34;,name=name,symmetry=symmetry)
                obj = self.simple_curve(fun,tmin=tmin,tmax=tmax,steps=steps,name=&#34;Surface of revolution&#34;,symmetry=symmetry)
                if point is not None:
                        m1 = self.draw_point(radius=0.1,location=zp,name=&#34;Punt p0&#34;,color=&#34;Red&#34;)
                        m2 = self.draw_point(radius=0.1,location=zp,name=&#34;Punt p1&#34;,color=&#34;Black&#34;)
                        m3 = self.draw_point(radius=0.1,location=z0,name=&#34;Punt p2&#34;,color=&#34;Blue&#34;)
                        l1 = self.draw_line(start=z0,end=zp,scale=0.04,name=&#34;Línia 1&#34;,color=&#34;Black&#34;)
                        l2 = self.draw_line(start=z0,end=zp,scale=0.03,name=&#34;Línia 2&#34;,color=&#34;Red&#34;)
                        self.draw_circle(center=z0,u1=d1,u2=d2,radius=(zp-z0).length,steps=128,thickness=0.005,name=&#34;Circle&#34;,color=&#34;Cyan&#34;)

                m = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                m.levels = 4
                m.subdivision_type = &#39;SIMPLE&#39;
                m = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                m.thickness = thickness
                m.offset = 1.0
                m = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                m.angle = 0.0
                m.steps = steps
                m.axis =  axis
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
                bpy.context.scene.collection.objects.link(obj)

                bpy.context.scene.frame_set(self.frame)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                obj.keyframe_insert(data_path=&#39;modifiers[&#34;Screw&#34;].angle&#39;,index=-1)
                p2.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if point is not None:
                        l1.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        m2.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn = frames + self.frame
                for i in range(0,stepsr):
                        bpy.context.scene.frame_set(fn)
                        p2.rotation_quaternion.rotate(r.quaternion)
                        p2.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        obj.modifiers[&#34;Screw&#34;].angle = 2 * (i+1) * math.pi / stepsr
                        obj.modifiers[&#34;Screw&#34;].steps = i+1
                        obj.keyframe_insert(data_path=&#39;modifiers[&#34;Screw&#34;].angle&#39;,index=-1)
                        if point is not None:
                                l1.rotation_quaternion.rotate(r.quaternion)
                                l1.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                                m2.location.rotate(r.quaternion)
                                m2.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames
                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()
        #
        #
        #
        def rotate_object(self,obj=None,axis=&#39;Z&#39;,frames=1,origin=Vector([0,0,0]),localaxis=None,localangle=None,helicoidal=0.0,rounds=1):
                &#34;&#34;&#34;
                Rotates an object around the axis
                Parameters:
                   obj: the object
                   axis: it must be &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39; or a Vector
                   local: if True the center of rotation is the location of the object
                &#34;&#34;&#34;
                if obj is None:
                        return None
                if isinstance(axis,str):
                        axis = axis.strip().upper()
                if axis == &#39;X&#39;:
                        u = Vector([1,0,0])
                elif axis == &#39;Y&#39;:
                        u = Vector([0,1,0])
                elif axis == &#39;Z&#39;:
                        u = Vector([0,0,1])
                elif isinstance(axis,Vector):
                        u = axis
                else:
                        u = Vector(axis)

                if not isinstance(origin,Vector):
                        origin = Vector(origin)

                line = None
                if localaxis is not None and localangle is not None:
                        old = self.origin
                        self.set_origin(obj.location)
                        l = obj.dimensions.length / 2
                        line = self.draw_vector(localaxis,axis=l,scale=0.1,arrow=False,positive=False,color=&#34;Orange&#34;,name=&#34;Eix rotació local&#34;)
                        line.select_set(True)
                        bpy.ops.object.origin_set(type=&#39;ORIGIN_CENTER_OF_MASS&#39;, center=&#39;MEDIAN&#39;)
                        line.select_set(False)
                        self.set_origin(old)
                        lr = Rotation(localangle,localaxis)

                r = Rotation(1/int(frames),u)
                axis, angle = r.to_axis_angle()
                t = helicoidal * axis
                bpy.context.scene.frame_set(self.frame)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn = self.frame + 1
                for i in range(int(frames) * int(rounds) * 360):
                        bpy.context.scene.frame_set(fn)
                        if line is None:
                                obj.rotation_quaternion.rotate(r.quaternion)
                        else:
                                obj.rotation_quaternion.rotate(lr.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        w = obj.location - origin
                        w.rotate(r.quaternion)
                        obj.location = origin + w + t
                        if line is not None:
                                line.location = origin + w + t
                                line.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += 1
                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()
        #
        #
        #
        def rotate_vector(self,vector=None,axis=&#39;Z&#39;):
                &#34;&#34;&#34;
                Rotates a vector around the axis
                Parameters:
                   vector: the vector
                   axis: it must be &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39; or a vector
                &#34;&#34;&#34;
                if vector is None:
                        return None
                if axis == &#39;X&#39;:
                        u = Vector([1,0,0])
                elif axis == &#39;Y&#39;:
                        u = Vector([0,1,0])
                elif axis == &#39;Z&#39;:
                        u = Vector([0,0,1])
                elif isinstance(axis,Vector):
                        u = axis
                else:
                        u = Vector(axis)

                self.draw_vector(vector,color=&#34;Black&#34;)
                obj = self.draw_vector(vector,color=&#34;Red&#34;)
                w1 = u.orthogonal().normalized()
                vec1 = vector.project(u)
                w3 = vec1.normalized()
                w2 = w3.cross(w1)
                a = vec1.length
                b = (vector-vec1).length
                p2 = b**2/a**2
                self.rotate_object(obj,u)
                self.draw_vector(u,axis=1.4*a,positive=False,color=&#34;White&#34;)
                self.cone(u1=w1,u2=w2,a2=p2,b2=p2,c2=1,half=True, principal=False,canonica=False,xmax=b,color=&#34;GrayLight&#34;,opacity=0.2)
        #
        #
        #
        def rotate_object_by_axis_angle(self,obj=None,axis=Vector([1,0,0]),angle=90,amax=15,frames=1,scaleaxis=0.075,local=False):
                &#34;&#34;&#34;
                Rotates an object around an angle &#39;angle&#39; around the axis
                Parameters:
                   obj: the object
                   axis: any non nul Vectors
                   angle: the angle of rotation in degrees
                   frames: increment of the frame set
                   scaleaxis: scale value for draw_base_axis
                   local: if True the center of rotation is the location of the object
                &#34;&#34;&#34;
                if obj is None:
                        return None
                if isinstance(axis,Vector):
                        u = axis
                else:
                        u = Vector(axis)
                if u.length == 0.0 or angle &lt;= 1:
                        return

                self.draw_base_axis(axis = amax,scale=scaleaxis,positive=False)
                self.draw_vector(u,scale=0.1,axis=amax,positive=False,color=&#34;Black&#34;,name=&#34;Eix rotació&#34;)

                num = int(angle)
                alfa = angle / num
                r = Rotation(alfa,u)
                bpy.context.scene.frame_set(self.frame)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if not local:
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn = frames + self.frame

                for i in range(num):
                        bpy.context.scene.frame_set(fn)
                        obj.rotation_quaternion.rotate(r.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if not local:
                                w = obj.location
                                w.rotate(r.quaternion)
                                obj.location = w
                                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames
                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()
        #
        #
        #
        def rotate_euler(self,obj=None,psi=0.0,theta=0.0,phi=0.0,frames=3,axis=&#39;ZXZ&#39;,amax=15,scaleaxis=0.075,reverse=False,local=False,radians=False,positive=True):
                &#34;&#34;&#34;
                Rotates an object by the Euler angles psi, theta and phi
                Parameters:
                   object: the object
                   psi, theta, phi: the Euler angles expressed in degrees
                   axis: it must be &#39;XYZ&#39;, &#39;XZY&#39;, &#39;YXZ&#39;, &#39;YZX&#39;, &#39;ZXY&#39;, &#39;ZYX&#39;, &#39;XYX&#39;, &#39;XZX&#39;, &#39;YXY&#39;, &#39;YZY&#39;, &#39;ZXZ&#39; or &#39;ZYZ&#39;
                   amax: axis valur for draw_base_axis
                   scaleaxis: scale value for draw_base_axis
                   local: if True the center of rotation is the location of the object
                   radians: if True, psi, theta and phi must be in radians
                   positive: if False and psi, theta or phi are greather than 180 degrees, they rae converted
                             to negative angles
                &#34;&#34;&#34;
                def vector_from_axis(axis):
                        if axis == &#39;X&#39;:
                                return Vector([1,0,0])
                        if axis == &#39;Y&#39;:
                                return Vector([0,1,0])
                        if axis == &#39;Z&#39;:
                                return Vector([0,0,1])
                        return None

                if obj is None or axis is None:
                        return None

                if not isinstance(axis,str):
                        return None

                axis = axis.upper()
                if axis not in (&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,&#39;XYX&#39;,&#39;XZX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;):
                        return None

                u1 = vector_from_axis(axis[0])
                u2 = vector_from_axis(axis[1])
                u3 = vector_from_axis(axis[2])

                if radians:
                        psi *= 180/math.pi
                        theta *= 180/math.pi
                        phi *= 180/math.pi
                if positive:
                        if psi &lt; 0.0:
                                psi += 360
                        if theta &lt; 0.0:
                                theta += 360
                        if phi &lt; 0.0:
                                phi += 360
                else:
                        if psi &gt; 180.0:
                                psi -= 360
                        if theta &gt; 180.0:
                                theta -= 360
                        if phi &gt; 180.0:
                                phi -= 360

                if reverse:
                        self.set_colors([&#34;OrangeRedDark&#34;,&#34;Yellow&#34;,&#34;Magenta&#34;])
                        axis = self.draw_base_axis(axis = amax,scale=scaleaxis,positive=False,name=&#34;Eixos fixes&#34;)
                        obj = self.join([obj,axis])
                        u1, u2, u3 = u3, u2, u1
                        psi, theta, phi = phi, theta, psi
                        s = Rotation(psi,u1)
                        u2 = s.apply(u2)
                        u3 = s.apply(u3)
                        s = Rotation(theta,u2)
                        u3 = s.apply(u3)
                else:
                        self.draw_base_axis(axis=amax,scale=scaleaxis,positive=False)

                bpy.context.scene.frame_set(self.frame)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if not local:
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn = frames + self.frame
                if psi &gt; 0:
                        num = int(psi)
                elif psi &lt; 0:
                        num = int(-psi)
                alfa = psi / num
                r = Rotation(alfa,u1)
                for i in range(num):
                        bpy.context.scene.frame_set(fn)
                        obj.rotation_quaternion.rotate(r.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if not local:
                                w = obj.location
                                w.rotate(r.quaternion)
                                obj.location = w
                                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames

                if theta &gt; 0:
                        num = int(theta)
                elif theta &lt; 0:
                        num = int(-theta)
                alfa = theta / num
                r = Rotation(alfa,u2)
                for i in range(num):
                        bpy.context.scene.frame_set(fn)
                        obj.rotation_quaternion.rotate(r.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if not local:
                                w = obj.location
                                w.rotate(r.quaternion)
                                obj.location = w
                                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames

                if phi &gt; 0:
                        num = int(phi)
                elif phi &lt; 0:
                        num = int(-phi)
                alfa = phi / num
                r = Rotation(alfa,u3)
                for i in range(num):
                        bpy.context.scene.frame_set(fn)
                        obj.rotation_quaternion.rotate(r.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if not local:
                                w = obj.location
                                w.rotate(r.quaternion)
                                obj.location = w
                                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames

                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()
        #
        #
        #
        def draw_frenet_curve(self,fun=None,var=None,tmin=0.0,tmax=1.0,radius=0.1,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,point=True,tangent=False,acceleration=False,normal=False,osculator=False,frenet=False,units=False,sizex=8,sizey=8):
                &#34;&#34;&#34;
                Draws a curve and diferents elements related to the curve
                Parameters:
                   fun: the parametric function
                   var = parameter variable of the function fun
                   tmin: minimum value of the parameter
                   tmax: maximum value of the parameter
                   radius: radius of the point
                   steps: number of steps
                   frames: increment of the frame set
                   thickness: thickness of the curve
                   name: name of the curve
                   color: color of the curve
                   point: if True draw a point along the curve
                   tangent: if True draw the tangent vector along the curve
                   acceleration: if True draw the acceleration vector along the curve
                   normal: if True draw the normal vector along the curve
                   osculator: if True draw the osculating plane along the curve
                   frenet: if True draw the Frenet trihedron along the curve
                   units: if True normalize the tangent and normal vectors
                   sizex, sizey: sizes of the osculating plane
                &#34;&#34;&#34;
                if fun is None:
                        return None

                def _fun_(x):
                        return [u.subs(var,x) for u in fun]

                def frenet_quaternion(tangent,normal):
                        v1 = tangent.normalized()
                        v2 = normal.normalized()
                        v3 = v1.cross(v2)
                        return Matrix([v1,v2,v3]).transposed().to_quaternion()

                frames = 1
                curve = self.draw_curve(_fun_,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,color=color,axis=False)
                if not point and not tangent and not osculator and not frenet:
                        return curve

                T = [diff(u,var) for u in fun]
                Tnorm = sqrt(sum([u**2 for u in T]))
                A = [diff(u,var) for u in T]
                p0 = Vector([u.subs(var,tmin) for u in fun])
                v0 = Vector([N(u.subs(var,tmin)) for u in T])
                a0 = Vector([N(u.subs(var,tmin)) for u in A])
                n0 = a0 - a0.project(v0)
                q0 = frenet_quaternion(v0,n0)
                f0 = [Vector([1,0,0]),Vector([0,1,0]),Vector([0,0,1])]

                if units:
                        v0.normalize()
                        n0.normalize()
                bpy.context.scene.frame_set(self.frame)

                if point:
                        p = self.draw_point(radius=radius,location=p0,name=&#34;Punt&#34;,color=&#34;Black&#34;)
                        p.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                self.set_origin(p0)
                if tangent:
                        l = v0.length
                        if not units:
                                vp = 5*v0.normalized()
                        else:
                                vp = v0
                        if not units:
                                v = self.draw_vector(vp,color=&#34;Red&#34;,scale=0.035,head_height=0.2)
                                v.scale.z *= l / 5.0
                        else:
                                v = self.draw_vector(vp,color=&#34;Red&#34;,scale=0.035,head_height=0.1)
                        v.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        v.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        v.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if acceleration:
                        l = a0.length
                        ap = 5*a0.normalized()
                        a = self.draw_vector(ap,color=&#34;Green&#34;,scale=0.035,head_height=0.2)
                        a.scale.z *= l / 5.0
                        a.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        a.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        a.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if normal:
                        l = n0.length
                        if not units:
                                np = 5*n0.normalized()
                        else:
                                np = n0
                        if not units:
                                n = self.draw_vector(np,color=&#34;Red&#34;,scale=0.035,head_height=0.2)
                                n.scale.z *= l / 5.0
                        else:
                                n = self.draw_vector(np,color=&#34;Red&#34;,scale=0.035,head_height=0.1)
                        n.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        n.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        n.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if osculator:
                        o = self.draw_plane_surface(base=[[1,0,0],[0,1,0]],color=&#34;GreenPaleDull&#34;,linecolor=&#34;GreenDarkDull&#34;,sizex=sizex,sizey=sizey,opacity=0.25)
                        o.rotation_quaternion = q0
                        o.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        o.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if frenet:
                        f = self.draw_vectors(f0,color=&#34;Red&#34;,scale=0.035,head_height=0.1)
                        f.rotation_quaternion = q0
                        f.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        f.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                self.set_origin()

                fn = frames + self.frame
                for i in range(steps):
                        bpy.context.scene.frame_set(fn)
                        x = tmin + (tmax - tmin)*i/steps
                        pos = Vector([u.subs(var,x) for u in fun])
                        v1 = Vector([N(u.subs(var,x)) for u in T])
                        a1 = Vector([N(u.subs(var,x)) for u in A])
                        n1 = a1 - a1.project(v1)
                        q1 = frenet_quaternion(v1,n1)
                        if point:
                                p.location = pos
                                p.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        if tangent:
                                if not units:
                                        r = v1.length / v0.length
                                        v.scale.z *= r
                                v.location = pos
                                v.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                v.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                                q = v0.rotation_difference(v1)
                                v.rotation_quaternion.rotate(q)
                                v.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if acceleration:
                                r = a1.length / a0.length
                                a.scale.z *= r
                                a.location = pos
                                a.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                a.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                                q = a0.rotation_difference(a1)
                                a.rotation_quaternion.rotate(q)
                                a.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if normal:
                                if not units:
                                        r = n1.length / n0.length
                                        n.scale.z *= r
                                n.location = pos
                                n.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                n.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                                q = n0.rotation_difference(n1)
                                n.rotation_quaternion.rotate(q)
                                n.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if osculator:
                                o.location = pos
                                o.rotation_quaternion = q1
                                o.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                o.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if frenet:
                                f.location = pos
                                f.rotation_quaternion = q1
                                f.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                f.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        v0 = v1.copy()
                        a0 = a1.copy()
                        n0 = n1.copy()
                        fn += frames
                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="LinearAlgebra.LinearAlgebra.add_ligth"><code class="name flex">
<span>def <span class="ident">add_ligth</span></span>(<span>self, location=[0, 0, 100], energy=3, direction=[0, 0, -1])</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a ligth to the scene</p>
<h2 id="parameters">Parameters</h2>
<p>location: location point of the light
energy: energy of the ligth
direction: direction of the light</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_ligth(self,location=[0,0,100],energy=3,direction=[0,0,-1]):
        &#34;&#34;&#34;
        Adds a ligth to the scene
        Parameters:
           location: location point of the light
           energy: energy of the ligth
           direction: direction of the light
        &#34;&#34;&#34;
        l = bpy.data.lights.new(name=&#34;Light&#34;, type=&#39;SUN&#39;)
        l.energy = energy
        l.specular_factor = 4
        obj = self.objects.new(name=&#34;Light&#34;, object_data=l)
        obj.rotation_mode = &#39;QUATERNION&#39;
        obj.location = location
        n = Vector(direction)
        mat = Matrix(self.base)
        mat.transpose()
        n = mat @ n
        z = Vector([0,0,-1])
        quaternion = z.rotation_difference(n)
        obj.rotation_quaternion.rotate(quaternion)
        self.collection.objects.link(obj)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.add_ligths"><code class="name flex">
<span>def <span class="ident">add_ligths</span></span>(<span>self, energy=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds diferent lights to the scene</p>
<h2 id="parameters">Parameters</h2>
<p>energy: energy of the lights</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_ligths(self,energy=1):
        &#34;&#34;&#34;
        Adds diferent lights to the scene
        Parameters:
           energy: energy of the lights
        &#34;&#34;&#34;
        self.add_ligth()
        self.add_ligth(location=[100,0,0],direction=[-1,0,0],energy=energy)
        self.add_ligth(location=[0,100,0],direction=[0,-1,0],energy=energy)
        self.add_ligth(location=[-100,0,0],direction=[1,0,0],energy=energy)
        self.add_ligth(location=[0,-100,0],direction=[0,1,0],energy=energy)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.add_material"><code class="name flex">
<span>def <span class="ident">add_material</span></span>(<span>self, obj, material_name, r, g, b, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a material and color to an object</p>
<h2 id="parameters">Parameters</h2>
<p>obj: object
material_name: material's name
r, g, b: RGB color values
opacity: the opacity</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_material(self,obj,material_name,r,g,b,opacity=1.0):
        &#34;&#34;&#34;
        Adds a material and color to an object
        Parameters:
           obj: object
           material_name: material&#39;s name
           r, g, b: RGB color values
           opacity: the opacity
        &#34;&#34;&#34;
        material = bpy.data.materials.get(material_name)
        if material is None:
                material = bpy.data.materials.new(material_name)
        material.use_nodes = True
        principled_bsdf = material.node_tree.nodes[&#39;Principled BSDF&#39;]
        if principled_bsdf is not None:
                #for i, o in enumerate(principled_bsdf.inputs):
                #       print(i, o.name)
                principled_bsdf.inputs[&#39;Base Color&#39;].default_value = (r, g, b, 0.5)
                principled_bsdf.inputs[&#39;IOR&#39;].default_value = 0.0
                principled_bsdf.inputs[&#39;Specular&#39;].default_value = 1.0
                principled_bsdf.inputs[&#39;Emission&#39;].default_value = (r, g, b, 0.5)
                principled_bsdf.inputs[&#39;Emission Strength&#39;].default_value = 0.0
                if opacity &lt; 1.0:
                        material.blend_method = &#39;BLEND&#39;
                        principled_bsdf.inputs[&#39;Alpha&#39;].default_value = opacity
                else:
                        material.blend_method = &#39;OPAQUE&#39;
                        principled_bsdf.inputs[&#39;Alpha&#39;].default_value = 1.0
        obj.active_material = material</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.animate_revolution_surface"><code class="name flex">
<span>def <span class="ident">animate_revolution_surface</span></span>(<span>self, fun=None, tmin=0.0, tmax=1.0, steps=256, curvethicknes=0.025, thickness=0.025, frames=3, angle=3, radians=False, axis='Z', symmetry=None, name='Revolution surface', color='AzureBlueDark', point=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws and animates a revolution surface from a curve</p>
<h2 id="parameters">Parameters</h2>
<p>fun: parametric equacion of the curve
steps: number of steps to graw the curve
curvethicknes: thickness of the curve
frames: number of frames at each step of revolution
angle: step angle of the revolution
radians: if True, angle must be in radians
axis: axis of revolution. It must be 'X', 'Y' or 'Z'
name: name of the surface
color: color of the surface
point: if not None draw three points and a cercle. Must be a float between tmax and tmin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def animate_revolution_surface(self,fun=None,tmin=0.0,tmax=1.0,steps=256,curvethicknes=0.025,thickness=0.025,frames=3,angle=3,radians=False,axis=&#39;Z&#39;,symmetry=None,name=&#34;Revolution surface&#34;,color=&#34;AzureBlueDark&#34;,point=None):
        &#34;&#34;&#34;
        Draws and animates a revolution surface from a curve
        Parameters:
           fun: parametric equacion of the curve
           steps: number of steps to graw the curve
           curvethicknes: thickness of the curve
           frames: number of frames at each step of revolution
           angle: step angle of the revolution
           radians: if True, angle must be in radians
           axis: axis of revolution. It must be &#39;X&#39;, &#39;Y&#39; or &#39;Z&#39;
           name: name of the surface
           color: color of the surface
           point: if not None draw three points and a cercle. Must be a float between tmax and tmin
        &#34;&#34;&#34;
        if radians:
                angle *= 180/math.pi
        stepsr = int(360/angle) + 1
        angle = 360/stepsr
        if fun is None:
                return None
        if axis == &#39;X&#39;:
                r = Rotation(angle,Vector([1,0,0]))
                d1 = Vector([0,1,0])
                d2 = Vector([0,0,1])
        elif axis == &#39;Y&#39;:
                r = Rotation(angle,Vector([0,1,0]))
                d1 = Vector([0,0,1])
                d2 = Vector([1,0,0])
        elif axis == &#39;Z&#39;:
                r = Rotation(angle,Vector([0,0,1]))
                d1 = Vector([1,0,0])
                d2 = Vector([0,1,0])
        else:
                return None

        if point is not None:
                try:
                        tp = 1.0 * point
                except:
                        pass
                if not isinstance(tp,float):
                        return None
                if tp &lt; tmin or tp &gt; tmax:
                        tp = random.uniform(tmin,tmax)
                zp = Vector(fun(tp))
                e = d1.cross(d2)
                z0 = zp.project(e)

        p2 = self.curve(fun,tmin=tmin,tmax=tmax,steps=steps,thickness=curvethicknes,color=&#34;Red&#34;,name=name,symmetry=symmetry)
        p1 = self.curve(fun,tmin=tmin,tmax=tmax,steps=steps,thickness=1.05*curvethicknes,color=&#34;Blue&#34;,name=name,symmetry=symmetry)
        obj = self.simple_curve(fun,tmin=tmin,tmax=tmax,steps=steps,name=&#34;Surface of revolution&#34;,symmetry=symmetry)
        if point is not None:
                m1 = self.draw_point(radius=0.1,location=zp,name=&#34;Punt p0&#34;,color=&#34;Red&#34;)
                m2 = self.draw_point(radius=0.1,location=zp,name=&#34;Punt p1&#34;,color=&#34;Black&#34;)
                m3 = self.draw_point(radius=0.1,location=z0,name=&#34;Punt p2&#34;,color=&#34;Blue&#34;)
                l1 = self.draw_line(start=z0,end=zp,scale=0.04,name=&#34;Línia 1&#34;,color=&#34;Black&#34;)
                l2 = self.draw_line(start=z0,end=zp,scale=0.03,name=&#34;Línia 2&#34;,color=&#34;Red&#34;)
                self.draw_circle(center=z0,u1=d1,u2=d2,radius=(zp-z0).length,steps=128,thickness=0.005,name=&#34;Circle&#34;,color=&#34;Cyan&#34;)

        m = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        m.levels = 4
        m.subdivision_type = &#39;SIMPLE&#39;
        m = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
        m.thickness = thickness
        m.offset = 1.0
        m = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
        m.angle = 0.0
        m.steps = steps
        m.axis =  axis
        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
        bpy.context.scene.collection.objects.link(obj)

        bpy.context.scene.frame_set(self.frame)
        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        obj.keyframe_insert(data_path=&#39;modifiers[&#34;Screw&#34;].angle&#39;,index=-1)
        p2.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        if point is not None:
                l1.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                m2.keyframe_insert(data_path=&#34;location&#34;,index=-1)
        fn = frames + self.frame
        for i in range(0,stepsr):
                bpy.context.scene.frame_set(fn)
                p2.rotation_quaternion.rotate(r.quaternion)
                p2.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                obj.modifiers[&#34;Screw&#34;].angle = 2 * (i+1) * math.pi / stepsr
                obj.modifiers[&#34;Screw&#34;].steps = i+1
                obj.keyframe_insert(data_path=&#39;modifiers[&#34;Screw&#34;].angle&#39;,index=-1)
                if point is not None:
                        l1.rotation_quaternion.rotate(r.quaternion)
                        l1.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        m2.location.rotate(r.quaternion)
                        m2.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn += frames
        self.frame = fn - frames
        bpy.context.scene.frame_end = self.frame
        bpy.context.scene.frame_set(0)
        bpy.context.view_layer.update()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.base_cilinder"><code class="name flex">
<span>def <span class="ident">base_cilinder</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a base cilinder with radius 1 and depth 1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_cilinder(self):
        &#34;&#34;&#34;
        Draws a base cilinder with radius 1 and depth 1
        &#34;&#34;&#34;
        bpy.ops.mesh.primitive_cylinder_add(radius=1,depth=1,enter_editmode=False,location=(0, 0, 0))
        bpy.ops.transform.translate(value=(0, 0, 0.5), orient_type=&#39;GLOBAL&#39;,orient_matrix_type=&#39;GLOBAL&#39;,
                constraint_axis=(False, False, True), mirror=True, use_proportional_edit=False,
                proportional_edit_falloff=&#39;SMOOTH&#39;,proportional_size=1, use_proportional_connected=False, use_proportional_projected=False)
        bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
        bpy.ops.object.shade_smooth()
        bpy.context.object.name = &#39;Arrow_stem&#39;</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.base_cone"><code class="name flex">
<span>def <span class="ident">base_cone</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a base cone with radius1=1.5, radius2=0, depth=2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_cone(self):
        &#34;&#34;&#34;
        Draws a base cone with radius1=1.5, radius2=0, depth=2
        &#34;&#34;&#34;
        bpy.ops.mesh.primitive_cone_add(radius1=1.5, radius2=0, depth=2, enter_editmode=False, location=(0, 0, 0))
        bpy.ops.transform.translate(value=(0, 0, 1), orient_type=&#39;GLOBAL&#39;,orient_matrix_type=&#39;GLOBAL&#39;,
                constraint_axis=(False, False, True), mirror=True, use_proportional_edit=False,
                proportional_edit_falloff=&#39;SMOOTH&#39;, proportional_size=1, use_proportional_connected=False, use_proportional_projected=False)
        bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
        bpy.ops.object.shade_smooth()
        bpy.context.object.name = &#39;Arrow_cone&#39;</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.base_is_canonica"><code class="name flex">
<span>def <span class="ident">base_is_canonica</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if sel.base is the canonical basis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_is_canonica(self):
        &#34;&#34;&#34;
        Returns True if sel.base is the canonical basis
        &#34;&#34;&#34;
        return Matrix(self.base).is_identity</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.comp_times_vector"><code class="name flex">
<span>def <span class="ident">comp_times_vector</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the vectorial product u x v</p>
<h2 id="parameters">Parameters</h2>
<p>u, v: two Vectors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comp_times_vector(self,u,v):
        &#34;&#34;&#34;
        Computes the vectorial product u x v
        Parameters:
           u, v: two Vectors
        &#34;&#34;&#34;
        return Vector([u.x * v.x,u.y * v.y,u.z * v.z])</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.cone"><code class="name flex">
<span>def <span class="ident">cone</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, c2=1, half=False, principal=True, canonica=True, color='AzureBlueDark', name='Cone', xmax=None, cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a cone</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the cone
u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
a2, b2, c2: squares of semi-axes of the cone. The equation is x'^2/a^2 + y'^2/b^2 - z'^2/c^2 = 0
half: if True draws half cone
principal: if True, the principal axis are drawn
canonica: if True, the canonical axis are drawn
color: color of the surface
name: name of the cone
xmax: maximum value of the x coordinate
cmax: the canonical axis are drawn between -cmax and cmax
pmax: the principal axis are drawn between -cmax and cmax
thickness: thickness of the cone
opacity: opacity of the cone</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cone(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,half=False,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Cone&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws a cone
        Parameters:
           o: center of the cone
           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
           a2, b2, c2: squares of semi-axes of the cone. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = 0
           half: if True draws half cone
           principal: if True, the principal axis are drawn
           canonica: if True, the canonical axis are drawn
           color: color of the surface
           name: name of the cone
           xmax: maximum value of the x coordinate
           cmax: the canonical axis are drawn between -cmax and cmax
           pmax: the principal axis are drawn between -cmax and cmax
           thickness: thickness of the cone
           opacity: opacity of the cone
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        c = math.sqrt(c2)
        if xmax is None:
                xmax = 10.0/a + 2
        xmax /= a
        self.draw_cone(a=1.0,xmin=0.0,xmax=xmax,steps=50,half=half,color=color,scale=[a,b,c],name=name,thickness=thickness,opacity=opacity)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.curve"><code class="name flex">
<span>def <span class="ident">curve</span></span>(<span>self, fun=None, tmin=0.0, tmax=1.0, steps=25, thickness=0.01, name='Curve', color='White', axis=False, zaxis=True, o=Vector((0.0, 0.0, 0.0)), u1=Vector((1.0, 0.0, 0.0)), u2=Vector((0.0, 1.0, 0.0)), symmetry=None, change=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a curve in a reference R' determined by the origin o and basis {v1, v2, v3} constructed from u1 and u2 and
the symmetric curve or curves from the parameter 'symmetry'</p>
<h2 id="parameters">Parameters</h2>
<p>fun: the parametric function
tmin: minimum value of the parameter
tmax: maximum value of the parameter
steps: number of steps
thickness: thickness of the curve
name: name of the curve
color: color of the curve
axis: if True draws the axis of the reference R'
zaxis: if True draws the z' axis
o: origin of the reference R'
u1, u2: vectors to construct the basis {v1, v2, v3}
symmetry: list of values in ('XY','XZ','YZ','X','Y','Z','O'). For every value S, draw the symmetric curve respect to S
change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,axis=False,zaxis=True,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),symmetry=None,change=False):
        &#34;&#34;&#34;
        Draws a curve in a reference R&#39; determined by the origin o and basis {v1, v2, v3} constructed from u1 and u2 and
        the symmetric curve or curves from the parameter &#39;symmetry&#39;
        Parameters:
           fun: the parametric function
           tmin: minimum value of the parameter
           tmax: maximum value of the parameter
           steps: number of steps
           thickness: thickness of the curve
           name: name of the curve
           color: color of the curve
           axis: if True draws the axis of the reference R&#39;
           zaxis: if True draws the z&#39; axis
           o: origin of the reference R&#39;
           u1, u2: vectors to construct the basis {v1, v2, v3}
           symmetry: list of values in (&#39;XY&#39;,&#39;XZ&#39;,&#39;YZ&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;,&#39;O&#39;). For every value S, draw the symmetric curve respect to S
           change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
        &#34;&#34;&#34;
        if fun is None:
                return None
        obj = self.draw_curve(fun,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=name,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)

        if symmetry is None:
                if change:
                        self.set_origin(o)
                        self.set_base([u1,u2],orthonormal=True)
                return obj
        objs = [obj]
        if not isinstance(symmetry,list):
                symmetry = [symmetry]
        for s in symmetry:
                namem = name + s
                if s == &#39;XY&#39;:
                        def f(t):
                                p = fun(t)
                                return (p[0],p[1],-p[2])
                        obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                        objs.append(obj2)
                if s == &#39;XZ&#39;:
                        def f(t):
                                p = fun(t)
                                return (p[0],-p[1],p[2])
                        obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                        objs.append(obj2)
                if s == &#39;YZ&#39;:
                        def f(t):
                                p = fun(t)
                                return (-p[0],p[1],p[2])
                        obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                        objs.append(obj2)
                if s == &#39;X&#39;:
                        def f(t):
                                p = fun(t)
                                return (p[0],-p[1],-p[2])
                        obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                        objs.append(obj2)
                if s == &#39;Y&#39;:
                        def f(t):
                                p = fun(t)
                                return (-p[0],p[1],-p[2])
                        obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                        objs.append(obj2)
                if s == &#39;Z&#39;:
                        def f(t):
                                p = fun(t)
                                return (-p[0],-p[1],p[2])
                        obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                        objs.append(obj2)
                if s == &#39;O&#39;:
                        def f(t):
                                p = fun(t)
                                return (-p[0],-p[1],-p[2])
                        obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                        objs.append(obj2)
        if change:
                self.set_origin(o)
                self.set_base([u1,u2],orthonormal=True)
        return self.join(objs)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.delete_base_cilinder"><code class="name flex">
<span>def <span class="ident">delete_base_cilinder</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the base cilinder</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_base_cilinder(self):
        &#34;&#34;&#34;
        Removes the base cilinder
        &#34;&#34;&#34;
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        bpy.data.objects[&#39;Arrow_stem&#39;].select_set(True)
        bpy.ops.object.delete()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.delete_base_cone"><code class="name flex">
<span>def <span class="ident">delete_base_cone</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the base cone</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_base_cone(self):
        &#34;&#34;&#34;
        Removes the base cone
        &#34;&#34;&#34;
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        bpy.data.objects[&#39;Arrow_cone&#39;].select_set(True)
        bpy.ops.object.delete()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_base_axis"><code class="name flex">
<span>def <span class="ident">draw_base_axis</span></span>(<span>self, scale=0.05, head_height=0.15, axis=0, name='Axis', positive=True, zaxis=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a reference axis given by self.origin, self.rotation and the basis self.base</p>
<h2 id="parameters">Parameters</h2>
<p>scale: scale of the cylinder
head_height: height of the head of the vector from self.base
axis: length of the coordinate axis. If the length is 0, only the basis vectors are drawn
name: name of the result object
positive: if True, draw the positive part of the axis
zaxis: if True, draw the z axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_base_axis(self,scale=0.05,head_height=0.15,axis=0,name=&#34;Axis&#34;,positive=True,zaxis=True):
        &#34;&#34;&#34;
        Draws a reference axis given by self.origin, self.rotation and the basis self.base
        Parameters:
           scale: scale of the cylinder
           head_height: height of the head of the vector from self.base
           axis: length of the coordinate axis. If the length is 0, only the basis vectors are drawn
           name: name of the result object
           positive: if True, draw the positive part of the axis
           zaxis: if True, draw the z axis
        &#34;&#34;&#34;
        self.base_cilinder()
        self.base_cone()
        o = Vector([0,0,0])
        op = Vector(self.origin)
        color = 0

        if axis != 0 and axis &lt; 8:
                scale /= 3

        base = self.base
        if not zaxis:
                base = self.base[0:2]
        for vec in base:
                #
                # Draw the stem
                #
                v = Vector(vec)
                t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                obj = t.copy()
                obj.name = &#34;Axis%d&#34; % (color + 1)
                obj.data = obj.data.copy()
                obj.location = o
                obj.scale = (scale,scale,(v - o).length - 2 * head_height)
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                if self.colors is not None and len(self.colors) &gt; color:
                        c = self.colors[color]
                        self.add_material(obj,c.name,c.r,c.g,c.b)
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location = op
                self.scene.collection.objects.link(obj)
                #
                # Draw the arrow
                #
                t = bpy.data.objects.get(&#34;Arrow_cone&#34;)
                obj2 = t.copy()
                obj2.name = &#34;Arrow&#34;
                obj2.data = obj2.data.copy()
                obj2.location =  v - 2 * head_height * v / v.length
                obj2.scale = (scale + 0.05,scale + 0.05,head_height)
                obj2.rotation_mode = &#39;QUATERNION&#39;
                obj2.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                if self.colors is not None and len(self.colors) &gt; color:
                        c = self.colors[color]
                        self.add_material(obj2,c.name,c.r,c.g,c.b)
                if self.rotation is not None:
                        obj2.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj2.location.rotate(self.rotation.quaternion)
                obj2.location = op + obj2.location
                self.scene.collection.objects.link(obj2)
                #
                # Draw the line
                #
                obj3 = None
                if axis != 0:
                        v = axis * Vector(vec)
                        t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                        obj3 = t.copy()
                        obj3.name = &#34;Line&#34;
                        obj3.data = obj3.data.copy()
                        obj3.location = op - v
                        obj3.scale = (scale / 2,scale / 2,(2 * v).length)
                        obj3.rotation_mode = &#39;QUATERNION&#39;
                        obj3.rotation_quaternion = v.to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if self.colors is not None and len(self.colors) &gt; color:
                                c = self.colors[color]
                                self.add_material(obj3,c.name,c.r,c.g,c.b)
                        if self.rotation is not None:
                                obj3.rotation_quaternion.rotate(self.rotation.quaternion)
                        if positive:
                                obj3.location = op
                        else:
                                if self.rotation is not None:
                                        v.rotate(self.rotation.quaternion)
                                obj3.location = op - v
                        self.scene.collection.objects.link(obj3)
                #
                # Joint the three objects
                #
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.context.view_layer.objects.active = obj
                obj.select_set(True)
                obj2.select_set(True)
                if obj3 is not None:
                        obj3.select_set(True)
                bpy.ops.object.join()
                color += 1
        #
        # Join all the axis
        #
        t1 = bpy.data.objects.get(&#34;Axis1&#34;)
        t1.name = name
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        bpy.context.view_layer.objects.active = t1
        t1.select_set(True)
        t2 = bpy.data.objects.get(&#34;Axis2&#34;)
        t2.select_set(True)
        if zaxis:
                t3 = bpy.data.objects.get(&#34;Axis3&#34;)
                t3.select_set(True)
        bpy.ops.object.join()
        self.delete_base_cilinder()
        self.delete_base_cone()
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return t1</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_circle"><code class="name flex">
<span>def <span class="ident">draw_circle</span></span>(<span>self, center=[0, 0, 0], u1=Vector((1.0, 0.0, 0.0)), u2=Vector((0.0, 1.0, 0.0)), axis=False, zaxis=False, radius=1, steps=25, thickness=0.01, name='Circle', color='White', change=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a circle of center 'center' and radius 'radius' in the plane determined by vectors u1 and u2</p>
<h2 id="parameters">Parameters</h2>
<p>center: center of the circle
u1, u2: vectors to construct the basis {v1, v2, v3}
axis: if True draws the axis of the reference R'
zaxis: if True draws the z' axis
radius: radius of the circle
steps: number of steps
thickness: thickness of the curve
name: name of the curve
color: color of the curve
change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_circle(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),axis=False,zaxis=False,radius=1,steps=25,thickness=0.01,name=&#34;Circle&#34;,color=&#34;White&#34;,change=False):
        &#34;&#34;&#34;
        Draws a circle of center &#39;center&#39; and radius &#39;radius&#39; in the plane determined by vectors u1 and u2
        Parameters:
           center: center of the circle
           u1, u2: vectors to construct the basis {v1, v2, v3}
           axis: if True draws the axis of the reference R&#39;
           zaxis: if True draws the z&#39; axis
           radius: radius of the circle
           steps: number of steps
           thickness: thickness of the curve
           name: name of the curve
           color: color of the curve
           change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
        &#34;&#34;&#34;
        if change:
                self.set_origin(center)
                self.set_base([u1,u2],orthonormal=True)
        return self.draw_curve(lambda t: (radius*math.cos(t),radius*math.sin(t),0),tmin=0.0,tmax=2*math.pi,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_components"><code class="name flex">
<span>def <span class="ident">draw_components</span></span>(<span>self, vector=None, color='Cyan', name='Components', scale=0.005)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the components of the the vector 'vector' in the reference given by self.origin,
self.rotation and the basis self.base</p>
<h2 id="parameters">Parameters</h2>
<p>vector: the vector
color: color of the lines of components
name: name of the object
scale: scale of the lines</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_components(self,vector=None,color=&#34;Cyan&#34;,name=&#34;Components&#34;,scale=0.005):
        &#34;&#34;&#34;
        Draws the components of the the vector &#39;vector&#39; in the reference given by self.origin,
        self.rotation and the basis self.base
        Parameters:
           vector: the vector
           color: color of the lines of components
           name: name of the object
           scale: scale of the lines
        &#34;&#34;&#34;
        if vector is None:
                return
        if isinstance(vector,Vector):
                v = vector
        else:
                v = Vector(vector)
        mat = Matrix(self.base)
        mat.transpose()
        list = [[0,0,0],[1,0,0],[1,1,0],[0,1,0],[0,0,1],[1,0,1],[1,1,1],[0,1,1]]
        lines = [[0,1],[1,2],[2,3],[0,3],[0,4],[1,5],[2,6],[3,7],[4,5],[5,6],[6,7],[4,7]]
        vecs = [self.comp_times_vector(v,Vector(x)) for x in list]
        count = 0
        for first, last in lines:
                if count == 0:
                        this = name
                else:
                        this = f&#34;Line{count}&#34;
                count += 1
                self.draw_line(start=vecs[first],end=vecs[last],scale=scale,name=this,color=color)
        t = bpy.data.objects.get(name)
        list = [t]
        for count in range(1,12):
                obj = bpy.data.objects.get(f&#34;Line{count}&#34;)
                if obj is not None:
                        list.append(obj)
        t = self.join(list)
        bpy.context.view_layer.objects.active = None
        return t</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_cone"><code class="name flex">
<span>def <span class="ident">draw_cone</span></span>(<span>self, a=1.0, xmin=0.0, xmax=5.0, steps=50, scale=[1, 1, 1], half=False, color='AzureBlueDark', name='Cone', opacity=1.0, thickness=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a cone from the line z = a*x in the XZ plane</p>
<h2 id="parameters">Parameters</h2>
<p>a: slope of the line
xmin: minimum value of x
xmax: maximum value of x
steps: numbers of steps to draw the parabola
scale: scaling factors in the X, Y and Z directions
half: if True, draws half cone
color: color of the surface
name: name of the surface
opacity: opacity of the surface
thickness: thickness of the surface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_cone(self,a=1.0,xmin=0.0,xmax=5.0,steps=50,scale=[1,1,1],half=False,color=&#34;AzureBlueDark&#34;,name=&#34;Cone&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws a cone from the line z = a*x in the XZ plane
        Parameters:
           a: slope of the line
           xmin: minimum value of x
           xmax: maximum value of x
           steps: numbers of steps to draw the parabola
           scale: scaling factors in the X, Y and Z directions
           half: if True, draws half cone
           color: color of the surface
           name: name of the surface
           opacity: opacity of the surface
           thickness: thickness of the surface
        &#34;&#34;&#34;
        delta = (xmax - xmin) / steps
        x = xmax
        bm = bmesh.new()
        verts = []
        count = 2 * steps + 2
        if xmin == 0.0:
                count = 2 * steps + 1
        if half:
                count = steps + 1
        for k in range(count):
                z = a * x
                verts.append(bm.verts.new((x,0,z)))
                if k == steps and xmin &gt; 0:
                        x = - xmin
                else:
                        x -= delta
                if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                        continue
                bm.edges.new([verts[k-1], verts[k]])

        me = self.meshes.new(&#39;placeholder_mesh&#39;)
        obj = self.objects.new(name,me)
        bm.to_mesh(me)
        bm.free()

        modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
        modifier.angle = 2 * math.pi
        modifier.steps = 128
        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        self.scene.collection.objects.link(obj)
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_cube"><code class="name flex">
<span>def <span class="ident">draw_cube</span></span>(<span>self, origin=None, scale=[1, 1, 1], scalelines=0.05, vectors=False, color='Blue', linecolor='Red', vectorcolor='Black', name='Parallelepiped', opacity=1.0, thickness=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a rectangular parallelepiped</p>
<h2 id="parameters">Parameters</h2>
<p>origin: center of the parallelepiped
scale: scale of the sides of the parallelepiped
scalelines: scale of the edges of the parallelepiped
vectors: if True, draws vectors from the origin to the vertices
color: color of the parallelepiped
linecolor: color of the edges
vectorcolor: color of the vectors
name: name of the parallelepiped
opacity: opacity of the parallelepiped
thickness: thickness of the parallelepiped</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_cube(self,origin=None,scale=[1,1,1],scalelines=0.05,vectors=False,color=&#34;Blue&#34;,linecolor=&#34;Red&#34;,vectorcolor=&#34;Black&#34;,name=&#39;Parallelepiped&#39;,opacity=1.0,thickness=0.0):
        &#34;&#34;&#34;
        Draws a rectangular parallelepiped
        Parameters:
           origin: center of the parallelepiped
           scale: scale of the sides of the parallelepiped
           scalelines: scale of the edges of the parallelepiped
           vectors: if True, draws vectors from the origin to the vertices
           color: color of the parallelepiped
           linecolor: color of the edges
           vectorcolor: color of the vectors
           name: name of the parallelepiped
           opacity: opacity of the parallelepiped
           thickness: thickness of the parallelepiped
        &#34;&#34;&#34;
        bpy.ops.mesh.primitive_cube_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        if origin is not None:
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
        obj.location = o
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 0.0

        lines = None
        vecs = None
        s = 0.0
        nodes = [[1+s,1+s,1+s],[-1-s,1+s,1+s],[-1-s,-1-s,1+s],[1+s,-1-s,1+s],
                        [1+s,1+s,-1-s],[-1-s,1+s,-1-s],[-1-s,-1-s,-1-s],[1+s,-1-s,-1-s]]
        nodes = [self.comp_times_vector(Vector(scale),Vector(x)) for x in nodes]
        edges =[[0,1],[1,2],[2,3],[3,0],[0,4],[1,5],[2,6],[3,7],[4,5],[5,6],[6,7],[7,4]]
        if scalelines &gt; 0.0:
                objects = []
                for edge in edges:
                        l = self.draw_line(start=op+nodes[edge[0]],end=op+nodes[edge[1]],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                        objects.append(l)
                lines = self.join(objects)

        if vectors:
                vecs = self.draw_vectors(nodes,color=vectorcolor,scale=0.05,head_height=0.2,name=&#34;Vectors&#34;,axis=0)

        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.scale = scale

        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        obj.location = op
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        if lines is not None:
                obj = self.join([obj,lines])

        if vecs is not None:
                obj = self.join([obj,vecs])
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_curve"><code class="name flex">
<span>def <span class="ident">draw_curve</span></span>(<span>self, fun=None, tmin=0.0, tmax=1.0, steps=25, thickness=0.01, name='Curve', color='White', axis=False, zaxis=True, o=Vector((0.0, 0.0, 0.0)), u1=Vector((1.0, 0.0, 0.0)), u2=Vector((0.0, 1.0, 0.0)))</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a curve in a reference R' determined by the origin o and basis {v1, v2, v3} constructed from u1 and u2</p>
<h2 id="parameters">Parameters</h2>
<p>fun: the parametric function
tmin: minimum value of the parameter
tmax: maximum value of the parameter
steps: number of steps
thickness: thickness of the curve
name: name of the curve
color: color of the curve
axis: if True draws the axis of the reference R'
zaxis: if True draws the z' axis
o: origin of the reference R'
u1, u2: vectors to construct the basis {v1, v2, v3}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,axis=False,zaxis=True,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0])):
        &#34;&#34;&#34;
        Draws a curve in a reference R&#39; determined by the origin o and basis {v1, v2, v3} constructed from u1 and u2
        Parameters:
           fun: the parametric function
           tmin: minimum value of the parameter
           tmax: maximum value of the parameter
           steps: number of steps
           thickness: thickness of the curve
           name: name of the curve
           color: color of the curve
           axis: if True draws the axis of the reference R&#39;
           zaxis: if True draws the z&#39; axis
           o: origin of the reference R&#39;
           u1, u2: vectors to construct the basis {v1, v2, v3}
        &#34;&#34;&#34;
        if fun is None:
                return None
        qt = self.vectors_to_quaternion(u1,u2)
        delta = (tmax - tmin) / steps
        t = tmin
        bm = bmesh.new()
        verts = []

        pmax = 0
        for k in range(steps + 1):
                p = fun(t)
                m = max(map(abs,p))
                if m &gt; pmax:
                        pmax = m
                verts.append(bm.verts.new(p))
                t += delta
                if t &gt; tmax:
                        t = tmax

        for i in range(len(verts) - 1):
                bm.edges.new([verts[i], verts[i+1]])

        me = self.meshes.new(&#39;placeholder_mesh&#39;)
        obj = self.objects.new(name,me)
        bm.to_mesh(me)
        bm.free()

        modifier = obj.modifiers.new(type=&#39;SKIN&#39;,name = &#39;skin&#39;)
        for v in obj.data.skin_vertices[0].data:
                v.radius = (thickness,thickness)

        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
        self.set_origin(o)
        self.set_rotation(quaternion=qt)
        if self.rotation is not None:
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        if axis:
                self.draw_base_axis(axis = pmax+3,positive=False,name=&#34;Referència escollida&#34;,zaxis=zaxis)
        self.scene.collection.objects.link(obj)
        bpy.ops.object.shade_smooth()
        obj.location = o
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_ellipse"><code class="name flex">
<span>def <span class="ident">draw_ellipse</span></span>(<span>self, center=[0, 0, 0], u1=Vector((1.0, 0.0, 0.0)), u2=Vector((0.0, 1.0, 0.0)), a=1, b=1, axis=False, zaxis=False, steps=25, thickness=0.01, name='Ellipse', color='White', change=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an ellipse of center 'center' and semi-axes a and b in the plane determined by vectors u1 and u2</p>
<h2 id="parameters">Parameters</h2>
<p>center: center of the ellipse
u1, u2: vectors to construct the basis {v1, v2, v3}
a, b: semi-axes of the ellipse
axis: if True draws the axis of the reference R'
zaxis: if True draws the z' axis
steps: number of steps
thickness: thickness of the curve
name: name of the curve
color: color of the curve
change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_ellipse(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,b=1,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Ellipse&#34;,color=&#34;White&#34;,change=False):
        &#34;&#34;&#34;
        Draws an ellipse of center &#39;center&#39; and semi-axes a and b in the plane determined by vectors u1 and u2
        Parameters:
           center: center of the ellipse
           u1, u2: vectors to construct the basis {v1, v2, v3}
           a, b: semi-axes of the ellipse
           axis: if True draws the axis of the reference R&#39;
           zaxis: if True draws the z&#39; axis
           steps: number of steps
           thickness: thickness of the curve
           name: name of the curve
           color: color of the curve
           change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
        &#34;&#34;&#34;
        if change:
                self.set_origin(center)
                self.set_base([u1,u2],orthonormal=True)
        return self.draw_curve(lambda t: (a*math.cos(t),b*math.sin(t),0),tmin=0.0,tmax=2*math.pi,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_ellipsoid"><code class="name flex">
<span>def <span class="ident">draw_ellipsoid</span></span>(<span>self, radius=5.0, scale=[1.2, 1.8, 0.8], color='AzureBlueDark', name='Ellipsoid', opacity=1.0, thickness=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws en ellipsoid</p>
<h2 id="parameters">Parameters</h2>
<p>radius: radius of the sphere
scale: scaling factors in the X, Y and Z directions
color: color of the surface
name: name of the surface
opacity: opacity of the surface
thickness: thickness of the surface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_ellipsoid(self,radius=5.0,scale=[1.2,1.8,0.8],color=&#34;AzureBlueDark&#34;,name=&#34;Ellipsoid&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws en ellipsoid
        Parameters:
           radius: radius of the sphere
           scale: scaling factors in the X, Y and Z directions
           color: color of the surface
           name: name of the surface
           opacity: opacity of the surface
           thickness: thickness of the surface
        &#34;&#34;&#34;
        bpy.ops.mesh.primitive_uv_sphere_add(segments=128, ring_count=128, radius=radius, enter_editmode=False, location=(0, 0, 0))
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)

        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        obj.select_set(False)
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_elliptic_cylinder"><code class="name flex">
<span>def <span class="ident">draw_elliptic_cylinder</span></span>(<span>self, a=8.0, b=5.0, amin=0.0, amax=6.283185307179586, length=20, steps=200, scale=[1, 1, 1], color='AzureBlueDark', name='EllipticCylinder', opacity=1.0, thickness=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an eliptic cylinder from the ellipse
x = a<em>cos(t)
y = b</em>sin(t)
in the XY plane</p>
<h2 id="parameters">Parameters</h2>
<p>a, b: coefficients of the ellipsw
amin: minimum value of the angle t
amax: maximum value of the angle t
length: length in the Z direction
steps: numbers of steps to draw the parabola
scale: scaling factors in the X, Y and Z directions
color: color of the surface
name: name of the surface
opacity: opacity of the surface
thickness: thickness of the surface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_elliptic_cylinder(self,a=8.0,b=5.0,amin=0.0,amax=2*math.pi,length=20,steps=200,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;EllipticCylinder&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws an eliptic cylinder from the ellipse
          x = a*cos(t)
          y = b*sin(t)
        in the XY plane
        Parameters:
           a, b: coefficients of the ellipsw
           amin: minimum value of the angle t
           amax: maximum value of the angle t
           length: length in the Z direction
           steps: numbers of steps to draw the parabola
           scale: scaling factors in the X, Y and Z directions
           color: color of the surface
           name: name of the surface
           opacity: opacity of the surface
           thickness: thickness of the surface
        &#34;&#34;&#34;
        if amin &lt; 0.0:
                amin = 0.0
        if amax &gt; 2 * math.pi:
                amax = 2 * math.pi
        delta = (amax-amin)/steps
        bm = bmesh.new()
        verts = []
        t = amin
        for k in range(steps + 1):
                x = a * math.cos(t)
                y = b * math.sin(t)
                verts.append(bm.verts.new((x,y,0)))
                t += delta
                if k == 0:
                        continue
                bm.edges.new([verts[k-1], verts[k]])

        me = self.meshes.new(&#39;EllipticCylinderMesh&#39;)
        obj = self.objects.new(name, me)
        bm.to_mesh(me)
        bm.free()
        self.scene.collection.objects.link(obj)

        bpy.context.view_layer.objects.active = obj
        bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
        bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
        bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
        bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0,0,length),&#34;constraint_axis&#34;:(False,False,True),&#34;use_accurate&#34;:True})
        bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
        bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
        obj.select_set(True)
        bpy.ops.transform.translate(value=(0,0,-length/2),constraint_axis=(False,False,True))
        bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
        obj.select_set(False)

        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_elliptic_paraboloid"><code class="name flex">
<span>def <span class="ident">draw_elliptic_paraboloid</span></span>(<span>self, a=0.5, xmin=0.0, xmax=3.0, steps=50, scale=[1, 1, 1], color='AzureBlueDark', name='EllipticParaboloid', opacity=1.0, thickness=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an elliptic paraboloid from the parabola z=a*t^2</p>
<h2 id="parameters">Parameters</h2>
<p>a: coefficient of the parabola
xmin: minimum value of x
xmax: maximum value of x
steps: numbers of steps to draw the parabola
scale: scaling factors in the X, Y and Z directions
color: color of the surface
name: name of the surface
opacity: opacity of the surface
thickness: thickness of the surface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_elliptic_paraboloid(self,a=0.5,xmin=0.0,xmax=3.0,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;EllipticParaboloid&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws an elliptic paraboloid from the parabola z=a*t^2
        Parameters:
           a: coefficient of the parabola
           xmin: minimum value of x
           xmax: maximum value of x
           steps: numbers of steps to draw the parabola
           scale: scaling factors in the X, Y and Z directions
           color: color of the surface
           name: name of the surface
           opacity: opacity of the surface
           thickness: thickness of the surface
        &#34;&#34;&#34;
        obj = self.simple_curve(f=lambda t:(t,0,a*t**2),tmin=xmin,tmax=xmax,steps=steps,name=name)
        modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
        modifier.angle = 2 * math.pi
        modifier.steps = 128
        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        self.scene.collection.objects.link(obj)
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_frenet_curve"><code class="name flex">
<span>def <span class="ident">draw_frenet_curve</span></span>(<span>self, fun=None, var=None, tmin=0.0, tmax=1.0, radius=0.1, steps=25, thickness=0.01, name='Curve', color='White', point=True, tangent=False, acceleration=False, normal=False, osculator=False, frenet=False, units=False, sizex=8, sizey=8)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a curve and diferents elements related to the curve</p>
<h2 id="parameters">Parameters</h2>
<p>fun: the parametric function
var = parameter variable of the function fun
tmin: minimum value of the parameter
tmax: maximum value of the parameter
radius: radius of the point
steps: number of steps
frames: increment of the frame set
thickness: thickness of the curve
name: name of the curve
color: color of the curve
point: if True draw a point along the curve
tangent: if True draw the tangent vector along the curve
acceleration: if True draw the acceleration vector along the curve
normal: if True draw the normal vector along the curve
osculator: if True draw the osculating plane along the curve
frenet: if True draw the Frenet trihedron along the curve
units: if True normalize the tangent and normal vectors
sizex, sizey: sizes of the osculating plane</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_frenet_curve(self,fun=None,var=None,tmin=0.0,tmax=1.0,radius=0.1,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,point=True,tangent=False,acceleration=False,normal=False,osculator=False,frenet=False,units=False,sizex=8,sizey=8):
        &#34;&#34;&#34;
        Draws a curve and diferents elements related to the curve
        Parameters:
           fun: the parametric function
           var = parameter variable of the function fun
           tmin: minimum value of the parameter
           tmax: maximum value of the parameter
           radius: radius of the point
           steps: number of steps
           frames: increment of the frame set
           thickness: thickness of the curve
           name: name of the curve
           color: color of the curve
           point: if True draw a point along the curve
           tangent: if True draw the tangent vector along the curve
           acceleration: if True draw the acceleration vector along the curve
           normal: if True draw the normal vector along the curve
           osculator: if True draw the osculating plane along the curve
           frenet: if True draw the Frenet trihedron along the curve
           units: if True normalize the tangent and normal vectors
           sizex, sizey: sizes of the osculating plane
        &#34;&#34;&#34;
        if fun is None:
                return None

        def _fun_(x):
                return [u.subs(var,x) for u in fun]

        def frenet_quaternion(tangent,normal):
                v1 = tangent.normalized()
                v2 = normal.normalized()
                v3 = v1.cross(v2)
                return Matrix([v1,v2,v3]).transposed().to_quaternion()

        frames = 1
        curve = self.draw_curve(_fun_,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,color=color,axis=False)
        if not point and not tangent and not osculator and not frenet:
                return curve

        T = [diff(u,var) for u in fun]
        Tnorm = sqrt(sum([u**2 for u in T]))
        A = [diff(u,var) for u in T]
        p0 = Vector([u.subs(var,tmin) for u in fun])
        v0 = Vector([N(u.subs(var,tmin)) for u in T])
        a0 = Vector([N(u.subs(var,tmin)) for u in A])
        n0 = a0 - a0.project(v0)
        q0 = frenet_quaternion(v0,n0)
        f0 = [Vector([1,0,0]),Vector([0,1,0]),Vector([0,0,1])]

        if units:
                v0.normalize()
                n0.normalize()
        bpy.context.scene.frame_set(self.frame)

        if point:
                p = self.draw_point(radius=radius,location=p0,name=&#34;Punt&#34;,color=&#34;Black&#34;)
                p.keyframe_insert(data_path=&#34;location&#34;,index=-1)
        self.set_origin(p0)
        if tangent:
                l = v0.length
                if not units:
                        vp = 5*v0.normalized()
                else:
                        vp = v0
                if not units:
                        v = self.draw_vector(vp,color=&#34;Red&#34;,scale=0.035,head_height=0.2)
                        v.scale.z *= l / 5.0
                else:
                        v = self.draw_vector(vp,color=&#34;Red&#34;,scale=0.035,head_height=0.1)
                v.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                v.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                v.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        if acceleration:
                l = a0.length
                ap = 5*a0.normalized()
                a = self.draw_vector(ap,color=&#34;Green&#34;,scale=0.035,head_height=0.2)
                a.scale.z *= l / 5.0
                a.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                a.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                a.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        if normal:
                l = n0.length
                if not units:
                        np = 5*n0.normalized()
                else:
                        np = n0
                if not units:
                        n = self.draw_vector(np,color=&#34;Red&#34;,scale=0.035,head_height=0.2)
                        n.scale.z *= l / 5.0
                else:
                        n = self.draw_vector(np,color=&#34;Red&#34;,scale=0.035,head_height=0.1)
                n.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                n.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                n.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        if osculator:
                o = self.draw_plane_surface(base=[[1,0,0],[0,1,0]],color=&#34;GreenPaleDull&#34;,linecolor=&#34;GreenDarkDull&#34;,sizex=sizex,sizey=sizey,opacity=0.25)
                o.rotation_quaternion = q0
                o.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                o.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        if frenet:
                f = self.draw_vectors(f0,color=&#34;Red&#34;,scale=0.035,head_height=0.1)
                f.rotation_quaternion = q0
                f.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                f.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        self.set_origin()

        fn = frames + self.frame
        for i in range(steps):
                bpy.context.scene.frame_set(fn)
                x = tmin + (tmax - tmin)*i/steps
                pos = Vector([u.subs(var,x) for u in fun])
                v1 = Vector([N(u.subs(var,x)) for u in T])
                a1 = Vector([N(u.subs(var,x)) for u in A])
                n1 = a1 - a1.project(v1)
                q1 = frenet_quaternion(v1,n1)
                if point:
                        p.location = pos
                        p.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                if tangent:
                        if not units:
                                r = v1.length / v0.length
                                v.scale.z *= r
                        v.location = pos
                        v.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        v.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        q = v0.rotation_difference(v1)
                        v.rotation_quaternion.rotate(q)
                        v.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if acceleration:
                        r = a1.length / a0.length
                        a.scale.z *= r
                        a.location = pos
                        a.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        a.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        q = a0.rotation_difference(a1)
                        a.rotation_quaternion.rotate(q)
                        a.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if normal:
                        if not units:
                                r = n1.length / n0.length
                                n.scale.z *= r
                        n.location = pos
                        n.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        n.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        q = n0.rotation_difference(n1)
                        n.rotation_quaternion.rotate(q)
                        n.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if osculator:
                        o.location = pos
                        o.rotation_quaternion = q1
                        o.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        o.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if frenet:
                        f.location = pos
                        f.rotation_quaternion = q1
                        f.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        f.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                v0 = v1.copy()
                a0 = a1.copy()
                n0 = n1.copy()
                fn += frames
        self.frame = fn - frames
        bpy.context.scene.frame_end = self.frame
        bpy.context.scene.frame_set(0)
        bpy.context.view_layer.update()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_function"><code class="name flex">
<span>def <span class="ident">draw_function</span></span>(<span>self, f=None, xmin=-3, xmax=3, xsteps=64, ymin=-3, ymax=3, ysteps=64, thickness=0.02, opacity=1.0, pmax=10, name='Function', color='AzureBlueDark', axis=False, o=Vector((0.0, 0.0, 0.0)), u1=Vector((1.0, 0.0, 0.0)), u2=Vector((0.0, 1.0, 0.0)))</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a function of two variables f(x,y) i the reference R' = {o, v1, v2, v3}</p>
<h2 id="parameters">Parameters</h2>
<p>f: the function of two variables f(x,y)
xmin: minimum value of x
xmax: maximum value of x
xsteps: steps in the x direction
ymin: minimum value of y
ymax: maximum value of y
ysteps: steps in the x direction
thickness: thickness of the surface
opacity: opacity of the surface
pmax: the axis are drawn between -pmax and pmax
name: name of the surface
color: color of the surface
axis: if True the axis of the reference R' are drawn
o: origin of the reference R'
u1, u2: vectors to construct the basis {v1, v2, v3}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_function(self,f=None,xmin=-3,xmax=3,xsteps=64,ymin=-3,ymax=3,ysteps=64,thickness=0.02,opacity=1.0,pmax=10,name=&#34;Function&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0])):
        &#34;&#34;&#34;
        Draws a function of two variables f(x,y) i the reference R&#39; = {o, v1, v2, v3}
        Parameters:
           f: the function of two variables f(x,y)
           xmin: minimum value of x
           xmax: maximum value of x
           xsteps: steps in the x direction
           ymin: minimum value of y
           ymax: maximum value of y
           ysteps: steps in the x direction
           thickness: thickness of the surface
           opacity: opacity of the surface
           pmax: the axis are drawn between -pmax and pmax
           name: name of the surface
           color: color of the surface
           axis: if True the axis of the reference R&#39; are drawn
           o: origin of the reference R&#39;
           u1, u2: vectors to construct the basis {v1, v2, v3}
        &#34;&#34;&#34;
        if f is None:
                return None
        return self.draw_surface(eq=lambda x,y:(x,y,f(x,y)),umin=xmin,umax=xmax,usteps=xsteps,vmin=ymin,vmax=ymax,vsteps=ysteps,thickness=thickness,opacity=opacity,pmax=pmax,name=name,color=color,axis=axis,o=o,u1=u1,u2=u2,wrap_u=False,wrap_v=False,close_v=False)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_hyperbole"><code class="name flex">
<span>def <span class="ident">draw_hyperbole</span></span>(<span>self, center=[0, 0, 0], u1=Vector((1.0, 0.0, 0.0)), u2=Vector((0.0, 1.0, 0.0)), a=1, b=1, ymax=3.0, axis=False, zaxis=False, steps=25, thickness=0.01, name='Hyperbole', color='White', change=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an hyperbole of center 'center' and semi-axes a and b in the plane determined by vectors u1 and u2</p>
<h2 id="parameters">Parameters</h2>
<p>center: center of the hyperbole
u1, u2: vectors to construct the basis {v1, v2, v3}
a, b: semi-axes of the hyperbole
ymax: maximum value of the y'
axis: if True draws the axis of the reference R'
zaxis: if True draws the z' axis
steps: number of steps
thickness: thickness of the curve
name: name of the curve
color: color of the curve
change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_hyperbole(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,b=1,ymax=3.0,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Hyperbole&#34;,color=&#34;White&#34;,change=False):
        &#34;&#34;&#34;
        Draws an hyperbole of center &#39;center&#39; and semi-axes a and b in the plane determined by vectors u1 and u2
        Parameters:
           center: center of the hyperbole
           u1, u2: vectors to construct the basis {v1, v2, v3}
           a, b: semi-axes of the hyperbole
           ymax: maximum value of the y&#39;
           axis: if True draws the axis of the reference R&#39;
           zaxis: if True draws the z&#39; axis
           steps: number of steps
           thickness: thickness of the curve
           name: name of the curve
           color: color of the curve
           change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
        &#34;&#34;&#34;
        c1 = self.draw_curve(lambda t: (a*math.sqrt(1+t**2/b**2),t,0),tmin=-ymax,tmax=ymax,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
        c2 = self.draw_curve(lambda t: (-a*math.sqrt(1+t**2/b**2),t,0),tmin=-ymax,tmax=ymax,axis=False,zaxis=False,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
        self.join([c1,c2])
        if change:
                self.set_origin(center)
                self.set_base([u1,u2],orthonormal=True)
        return c1</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_hyperbolic_cylinder"><code class="name flex">
<span>def <span class="ident">draw_hyperbolic_cylinder</span></span>(<span>self, a=1.0, b=4.0, xmin=2.0, xmax=6.0, length=20, steps=50, scale=[1, 1, 1], color='AzureBlueDark', name='HyperbolicCylinder', opacity=1.0, thickness=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an hyperbolic cylinder from the hyperbole y = a * sqrt(x**2 - b) in the XY plane</p>
<h2 id="parameters">Parameters</h2>
<p>a, b: coefficients of the hyperbole
xmin: minimum value of x
xmax: maximum value of x
length: length in the Z direction
steps: numbers of steps to draw the parabola
scale: scaling factors in the X, Y and Z directions
color: color of the surface
name: name of the surface
opacity: opacity of the surface
thickness: thickness of the surface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_hyperbolic_cylinder(self,a=1.0,b=4.0,xmin=2.0,xmax=6.0,length=20,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicCylinder&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws an hyperbolic cylinder from the hyperbole y = a * sqrt(x**2 - b) in the XY plane
        Parameters:
           a, b: coefficients of the hyperbole
           xmin: minimum value of x
           xmax: maximum value of x
           length: length in the Z direction
           steps: numbers of steps to draw the parabola
           scale: scaling factors in the X, Y and Z directions
           color: color of the surface
           name: name of the surface
           opacity: opacity of the surface
           thickness: thickness of the surface
        &#34;&#34;&#34;
        if xmin &lt; math.sqrt(b):
                xmin = math.sqrt(b)
        delta = (xmax-xmin)/steps
        bm = bmesh.new()
        verts = []
        count = 2 * steps + 2
        if xmin == 0.0:
                count = 2 * steps + 1
        for q, d in [[1,0],[-1,count]]:
                x = xmax
                sign = 1
                for k in range(count):
                        if k == steps + 1:
                                sign = -1
                        if x &lt; math.sqrt(b):
                                x = math.sqrt(b)
                        y = sign * a * math.sqrt(x**2 - b)
                        verts.append(bm.verts.new((q * x,y,0)))
                        if k == steps and xmin &gt; math.sqrt(b):
                                x = xmin
                        else:
                                x = x - sign * delta
                        if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                                continue
                        bm.edges.new([verts[d + k-1], verts[d + k]])

        me = self.meshes.new(&#39;HyperboliclinderMesh&#39;)
        obj = self.objects.new(name, me)
        bm.to_mesh(me)
        bm.free()

        self.scene.collection.objects.link(obj)
        bpy.context.view_layer.objects.active = obj
        bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
        bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
        bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
        bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0,0,length),&#34;constraint_axis&#34;:(False,False,True),&#34;use_accurate&#34;:True})
        bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
        bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
        obj.select_set(True)
        bpy.ops.transform.translate(value=(0,0,-length/2),constraint_axis=(False,False,True))
        bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
        obj.select_set(False)

        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_hyperbolic_paraboloid"><code class="name flex">
<span>def <span class="ident">draw_hyperbolic_paraboloid</span></span>(<span>self, a=0.2, b=0.4, xmax=10.0, ymax=10.0, steps=64, scale=[1, 1, 1], color='AzureBlueDark', name='HyperbolicParaboloid', opacity=1.0, thickness=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an hyperbolic paraboloid with equation z = a<em>x^2 - b</em>y^2</p>
<h2 id="parameters">Parameters</h2>
<p>a, b: coefficients of the parabolic hyperboloid
xmax: maximum
value of x
ymax: maxim value y
steps: numbers of steps to draw the parabola
scale: scaling factors in the X, Y and Z directions
color: color of the surface
name: name of the surface
opacity: opacity of the surface
thickness: thickness of the surface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_hyperbolic_paraboloid(self,a=0.2,b=0.4,xmax=10.0,ymax=10.0,steps=64,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicParaboloid&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws an hyperbolic paraboloid with equation z = a*x^2 - b*y^2
        Parameters:
           a, b: coefficients of the parabolic hyperboloid
           xmax: maximum  value of x
           ymax: maxim value y
           steps: numbers of steps to draw the parabola
           scale: scaling factors in the X, Y and Z directions
           color: color of the surface
           name: name of the surface
           opacity: opacity of the surface
           thickness: thickness of the surface
        &#34;&#34;&#34;
        equ = lambda x,y: (x,y,a*x**2-b*y**2)
        obj = self.draw_surface(eq=equ,umin=-xmax,umax=xmax,usteps=steps,vmin=-ymax,vmax=ymax,vsteps=steps,thickness=thickness,opacity=opacity,pmax=0,name=&#34;Hyperbolic paraboloid&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),wrap_u=False,wrap_v=False,close_v=False)
        obj.scale = scale
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_line"><code class="name flex">
<span>def <span class="ident">draw_line</span></span>(<span>self, start=[1, 1, 1], end=[10, 10, 10], scale=0.05, name='Line', color='Black')</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a line from the point start to the point end. The reference given by self.origin,
self.rotation and the basis self.base is used</p>
<h2 id="parameters">Parameters</h2>
<p>start: starting point of the line
end: ending point of the line
scale: scale of the cylinder
name: name of the object
color: color of the vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_line(self,start=[1,1,1],end=[10,10,10],scale=0.05,name=&#34;Line&#34;,color=&#34;Black&#34;):
        &#34;&#34;&#34;
        Draws a line from the point start to the point end. The reference given by self.origin,
        self.rotation and the basis self.base is used
        Parameters:
           start: starting point of the line
           end: ending point of the line
           scale: scale of the cylinder
           name: name of the object
           color: color of the vector
        &#34;&#34;&#34;
        if start is None or end is None:
                return
        self.base_cilinder()
        o = Vector([0,0,0])
        op = Vector(self.origin)
        if isinstance(start,Vector):
                u = start
        else:
                u = Vector(start)
        if isinstance(end,Vector):
                v = end
        else:
                v = Vector(end)
        mat = Matrix(self.base)
        mat.transpose()
        u = mat @ u
        v = mat @ v
        l = (v - u).length
        t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
        obj = t.copy()
        obj.name = name
        obj.location = u
        obj.scale = (scale / 2,scale / 2,l)
        obj.rotation_mode = &#39;QUATERNION&#39;
        obj.rotation_quaternion = (v - u).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
        if color is not None:
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b)
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        obj.location = obj.location + op
        self.scene.collection.objects.link(obj)
        bpy.ops.object.shade_flat()
        self.delete_base_cilinder()
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_mesh"><code class="name flex">
<span>def <span class="ident">draw_mesh</span></span>(<span>self, mesh=None, name='Mesh', color='Blue', opacity=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a mesh. This function is used by other functions</p>
<h2 id="parameters">Parameters</h2>
<p>mesh: the mesh to be drawn
name: name of the mesh
color: color of the mesh
opacity: opacity of the mesh</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_mesh(self,mesh=None,name=&#39;Mesh&#39;,color=&#34;Blue&#34;,opacity=1):
        &#34;&#34;&#34;
        Draws a mesh. This function is used by other functions
        Parameters:
           mesh: the mesh to be drawn
           name: name of the mesh
           color: color of the mesh
           opacity: opacity of the mesh
        &#34;&#34;&#34;
        bm = bmesh.new()
        verts = []
        for p in mesh.points:
                verts.append(bm.verts.new(p))
        edges = [[0,1],[1,2],[2,3],[3,0]]
        for s in mesh.simplices:
                for e in edges:
                        v = Vector(mesh.points[s[e[0]]]) - Vector(mesh.points[s[e[1]]])
                        edge = [verts[s[e[0]]],verts[s[e[1]]]]
                        try:
                                bm.edges.new(edge)
                        except:
                                pass
        me = self.meshes.new(&#39;PointsMesh&#39;)
        obj = self.objects.new(name, me)
        bm.to_mesh(me)
        bm.free()
        self.scene.collection.objects.link(obj)
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_one_sheet_hyperboloid"><code class="name flex">
<span>def <span class="ident">draw_one_sheet_hyperboloid</span></span>(<span>self, a=2.0, b=2.0, xmin=1.4142135623730951, xmax=5.0, steps=256, scale=[1, 1, 1], color='AzureBlueDark', name='HyperboloidOneSheet', opacity=1.0, thickness=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a one sheet hyperboloid from the hyperbole z = \pm a*sqrt(x^2-b) in the XZ plane</p>
<h2 id="parameters">Parameters</h2>
<p>a, b: coefficients of the hyperbole
xmin: minimum value of x
xmax: maximum value of x
steps: numbers of steps to draw the parabola
scale: scaling factors in the X, Y and Z directions
color: color of the surface
name: name of the surface
opacity: opacity of the surface
thickness: thickness of the surface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_one_sheet_hyperboloid(self,a=2.0,b=2.0,xmin=math.sqrt(2),xmax=5.0,steps=256,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperboloidOneSheet&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws a one sheet hyperboloid from the hyperbole z = \pm a*sqrt(x^2-b) in the XZ plane
        Parameters:
           a, b: coefficients of the hyperbole
           xmin: minimum value of x
           xmax: maximum value of x
           steps: numbers of steps to draw the parabola
           scale: scaling factors in the X, Y and Z directions
           color: color of the surface
           name: name of the surface
           opacity: opacity of the surface
           thickness: thickness of the surface
        &#34;&#34;&#34;
        if xmin &lt; math.sqrt(b):
                xmin = math.sqrt(b)
        delta = (xmax - xmin) / steps
        x = xmax
        bm = bmesh.new()
        verts = []

        for k in range(steps + 1):
                if x &lt; math.sqrt(b):
                        z = 0.0
                else:
                        z = - a * math.sqrt(x**2 - b)
                verts.append(bm.verts.new((x,0,z)))
                x -= delta
        x = math.sqrt(b)
        for k in range(steps):
                x += delta
                if x**2 &lt; b:
                        z = 0.0
                else:
                        z = a * math.sqrt(x**2 - b)
                verts.append(bm.verts.new((x,0,z)))

        for i in range(len(verts) - 1):
                bm.edges.new([verts[i], verts[i+1]])

        me = self.meshes.new(&#39;placeholder_mesh&#39;)
        obj = self.objects.new(name,me)
        bm.to_mesh(me)
        bm.free()
        modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
        modifier.angle = 2 * math.pi
        modifier.steps = 128
        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        self.scene.collection.objects.link(obj)
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_parabola"><code class="name flex">
<span>def <span class="ident">draw_parabola</span></span>(<span>self, vertex=[0, 0, 0], u1=Vector((1.0, 0.0, 0.0)), u2=Vector((0.0, 1.0, 0.0)), a=1, xmax=3.0, axis=False, zaxis=False, steps=25, thickness=0.01, name='Parabola', color='White', change=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a parabola of vertex 'vertex' of equation y'=ax'^2 in the reference {vertex; v1, v2, v3} determined by vectors u1 and u2</p>
<h2 id="parameters">Parameters</h2>
<p>vertex: vertex of the parabola
u1, u2: vectors to construct the basis {v1, v2, v3}
a: coefficient of the parabola
xmax: maximum value of x'
axis: if True draws the axis of the reference R'
zaxis: if True draws the z' axis
steps: number of steps
thickness: thickness of the curve
name: name of the curve
color: color of the curve
change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_parabola(self,vertex=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,xmax=3.0,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Parabola&#34;,color=&#34;White&#34;,change=False):
        &#34;&#34;&#34;
        Draws a parabola of vertex &#39;vertex&#39; of equation y&#39;=ax&#39;^2 in the reference {vertex; v1, v2, v3} determined by vectors u1 and u2
        Parameters:
           vertex: vertex of the parabola
           u1, u2: vectors to construct the basis {v1, v2, v3}
           a: coefficient of the parabola
           xmax: maximum value of x&#39;
           axis: if True draws the axis of the reference R&#39;
           zaxis: if True draws the z&#39; axis
           steps: number of steps
           thickness: thickness of the curve
           name: name of the curve
           color: color of the curve
           change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
        &#34;&#34;&#34;
        if change:
                self.set_origin(vertex)
                self.set_base([u1,u2],orthonormal=True)
        return self.draw_curve(lambda t: (t,a*t**2,0),tmin=-xmax,tmax=xmax,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=vertex,u1=u1,u2=u2)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_parabolic_cylinder"><code class="name flex">
<span>def <span class="ident">draw_parabolic_cylinder</span></span>(<span>self, p=0.25, xmin=0.0, xmax=6.0, length=20, steps=50, scale=[1, 1, 1], color='AzureBlueDark', name='ParabolicCylinder', opacity=1.0, thickness=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a parabolic cylinder from the parabola z=p*x^2 in the XZ plane</p>
<h2 id="parameters">Parameters</h2>
<p>p: coefficients of the parabola
xmin: minimum value of x
xmax: maximum value of x
length: length in the Y direction
steps: numbers of steps to draw the parabola
scale: scaling factors in the X, Y and Z directions
color: color of the surface
name: name of the surface
opacity: opacity of the surface
thickness: thickness of the surface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_parabolic_cylinder(self,p=0.25,xmin=0.0,xmax=6.0,length=20,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;ParabolicCylinder&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws a parabolic cylinder from the parabola z=p*x^2 in the XZ plane
        Parameters:
           p: coefficients of the parabola
           xmin: minimum value of x
           xmax: maximum value of x
           length: length in the Y direction
           steps: numbers of steps to draw the parabola
           scale: scaling factors in the X, Y and Z directions
           color: color of the surface
           name: name of the surface
           opacity: opacity of the surface
           thickness: thickness of the surface
        &#34;&#34;&#34;
        delta = (xmax - xmin) / steps
        x = xmax
        bm = bmesh.new()
        verts = []
        count = 2 * steps + 2
        if xmin == 0.0:
                count = 2 * steps + 1
        for k in range(count):
                z = p * x**2
                verts.append(bm.verts.new((x,0,z)))
                if k == steps and xmin &gt; 0:
                        x = - xmin
                else:
                        x -= delta
                if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                        continue
                bm.edges.new([verts[k-1], verts[k]])

        me = self.meshes.new(&#39;ParabolicCylinderMesh&#39;)
        obj = self.objects.new(name, me)
        bm.to_mesh(me)
        bm.free()

        bpy.context.scene.collection.objects.link(obj)
        bpy.context.view_layer.objects.active = obj
        bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
        bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
        bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
        bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0, length, 0),&#34;constraint_axis&#34;:(False, True, False),&#34;use_accurate&#34;:True})
        bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
        bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
        obj.select_set(True)
        bpy.ops.transform.translate(value=(0, -length/2, 0),constraint_axis=(False, True, False))
        bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
        obj.select_set(False)

        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_parallelepiped"><code class="name flex">
<span>def <span class="ident">draw_parallelepiped</span></span>(<span>self, origin=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], u3=[0, 0, 1], scalelines=0.025, color='AzureBlueDark', linecolor='OrangeObscureDull', name='Parallelepiped', opacity=1.0, thickness=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a parallelepiped</p>
<h2 id="parameters">Parameters</h2>
<p>origin: base vertex of the parallelepiped
u1, u2, u3: vectors that gives the edges
scalelines: scale of the edges of the parallelepiped
color: color of the parallelepiped
linecolor: color of the edges
name: name of the parallelepiped
opacity: opacity of the parallelepiped
thickness: thickness of the parallelepiped</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_parallelepiped(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],u3=[0,0,1],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Parallelepiped&#39;,opacity=1.0,thickness=0.0):
        &#34;&#34;&#34;
        Draws a parallelepiped
        Parameters:
           origin: base vertex of the parallelepiped
           u1, u2, u3: vectors that gives the edges
           scalelines: scale of the edges of the parallelepiped
           color: color of the parallelepiped
           linecolor: color of the edges
           name: name of the parallelepiped
           opacity: opacity of the parallelepiped
           thickness: thickness of the parallelepiped
        &#34;&#34;&#34;
        op = Vector(self.origin)
        if isinstance(origin,Vector):
                op = op + origin
        else:
                op = op + Vector(origin)
        if not isinstance(u1,Vector):
                u1 = Vector(u1)
        if not isinstance(u2,Vector):
                u2 = Vector(u2)
        if not isinstance(u3,Vector):
                u3 = Vector(u3)

        mat = Matrix(self.base)
        mat.transpose()
        u1 = mat @ u1
        u2 = mat @ u2
        u3 = mat @ u3

        bpy.ops.mesh.primitive_cube_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)

        verts = obj.data.vertices
        verts[0].co = op
        verts[1].co = op + u3
        verts[2].co = op + u2
        verts[3].co = op + u2 + u3
        verts[4].co = op + u1
        verts[5].co = op + u1 + u3
        verts[6].co = op + u1 + u2
        verts[7].co = op + u1 + u2 + u3

        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 0.0

        lines = None
        s = 0.0
        edges =[[0,1],[0,2],[0,4],[1,3],[1,5],[2,3],[2,6],[3,7],[4,5],[4,6],[5,7],[6,7]]
        if scalelines &gt; 0.0:
                objects = []
                for edge in edges:
                        l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                        objects.append(l)
                lines = self.join(objects)

        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

        if lines is not None:
                obj = self.join([obj,lines])

        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None

        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_parallelogram"><code class="name flex">
<span>def <span class="ident">draw_parallelogram</span></span>(<span>self, origin=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], scalelines=0.025, color='AzureBlueDark', linecolor='OrangeObscureDull', name='Parallelogram', opacity=1.0, thickness=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a parallelogram</p>
<h2 id="parameters">Parameters</h2>
<p>origin: base vertex of the parallelogram
u1, u2: vectors that gives the edges
scalelines: scale of the edges of the parallelogram
color: color of the parallelogram
linecolor: color of the edges
name: name of the parallelogram
opacity: opacity of the parallelogram
thickness: thickness of the parallelogram</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_parallelogram(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Parallelogram&#39;,opacity=1.0,thickness=0.0):
        &#34;&#34;&#34;
        Draws a parallelogram
        Parameters:
           origin: base vertex of the parallelogram
           u1, u2: vectors that gives the edges
           scalelines: scale of the edges of the parallelogram
           color: color of the parallelogram
           linecolor: color of the edges
           name: name of the parallelogram
           opacity: opacity of the parallelogram
           thickness: thickness of the parallelogram
        &#34;&#34;&#34;
        op = Vector(self.origin)
        if isinstance(origin,Vector):
                op = op + origin
        else:
                op = op + Vector(origin)
        if not isinstance(u1,Vector):
                u1 = Vector(u1)
        if not isinstance(u2,Vector):
                u2 = Vector(u2)

        mat = Matrix(self.base)
        mat.transpose()
        u1 = mat @ u1
        u2 = mat @ u2

        bpy.ops.mesh.primitive_plane_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)

        verts = obj.data.vertices
        verts[0].co = op
        verts[1].co = op + u1
        verts[2].co = op + u2
        verts[3].co = op + u1 + u2

        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 0.0

        lines = None
        s = 0.0
        edges =[[0,1],[0,2],[1,3],[2,3]]
        if scalelines &gt; 0.0:
                objects = []
                for edge in edges:
                        l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                        objects.append(l)
                lines = self.join(objects)

        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

        if lines is not None:
                obj = self.join([obj,lines])

        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None

        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_plane"><code class="name flex">
<span>def <span class="ident">draw_plane</span></span>(<span>self, normal=None, base=None, sizex=10, sizey=10, color='AzureBlueDark', name='Plane', opacity=1.0, thickness=0.01)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a plane with normal vector or base vectors. It passes through the point self.origin.
Only normal or base can be not None</p>
<h2 id="parameters">Parameters</h2>
<p>normal: normal vector to the plane
base: list of two independent vectors
sizex: x-size of the plane
sizey: y-size of the plane
color: color of the plane
name: name of the plane
opacity: opacity of the plane
thickness: thickness of the plane</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_plane(self,normal=None,base=None,sizex=10,sizey=10,color=&#34;AzureBlueDark&#34;,name=&#39;Plane&#39;,opacity=1.0,thickness=0.01):
        &#34;&#34;&#34;
        Draws a plane with normal vector or base vectors. It passes through the point self.origin.
        Only normal or base can be not None
        Parameters:
           normal: normal vector to the plane
           base: list of two independent vectors
           sizex: x-size of the plane
           sizey: y-size of the plane
           color: color of the plane
           name: name of the plane
           opacity: opacity of the plane
           thickness: thickness of the plane
        &#34;&#34;&#34;
        if sizex == 0.0:
                return
        bpy.ops.mesh.primitive_plane_add(size=sizex,enter_editmode=True,location=(0, 0, 0))
        bpy.context.object.name = name
        ##### bpy.ops.mesh.subdivide(number_cuts=6,quadcorner=&#39;INNERVERT&#39;)
        bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
        obj = bpy.data.objects.get(name)
        if sizey is not None and sizey != 0.0:
                t = sizey / sizex
                obj.scale = [1,t,1]
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        if normal is not None and base is not None:
                return
        if base is not None:
                if len(base) != 2:
                        return
                if isinstance(base[0],Vector):
                        v1 = base[0]
                else:
                        v1 = Vector(base[0])
                if isinstance(base[1],Vector):
                        v2 = base[1]
                else:
                        v2 = Vector(base[1])

                if self.base is None:
                        normal = v1.cross(v2)
                else:
                        u1 = v1[0]*self.base[0] + v1[1]*self.base[1] + v1[2]*self.base[2]
                        u2 = v2[0]*self.base[0] + v2[1]*self.base[1] + v2[2]*self.base[2]
                        normal = u1.cross(u2)
        if normal is not None and normal != Vector([0,0,0]):
                z = Vector([0,0,1])
                quaternion = z.rotation_difference(normal)
                obj.rotation_quaternion.rotate(quaternion)
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        obj.location = op
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_plane_surface"><code class="name flex">
<span>def <span class="ident">draw_plane_surface</span></span>(<span>self, origin=None, normal=None, base=None, sizex=10, sizey=10, vectors=False, scalelines=0.05, scalevector=0.01, color='AzureBlueDark', linecolor='BlueDarkDull', vectorcolor='Black', name='Plane', opacity=1.0, thickness=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a plane with normal vector or base vectors. It passes through the point origin.
Only normal or base can be not None</p>
<h2 id="parameters">Parameters</h2>
<p>origin: a point in the plane
normal: normal vector to the plane
base: list of two independent vectors
sizex: x-size of the plane
sizey: y-size of the plane
vectors: if True, draw the generators of the plane
scalelines: scale of the lines limiting the plane
scalevector: scale of the generators
color: color of the plane
linecolor: color of the lines limiting the plane
vectorcolor: color of the generators
name: name of the plane
opacity: opacity of the plane
thickness: thickness of the plane</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_plane_surface(self,origin=None,normal=None,base=None,sizex=10,sizey=10,vectors=False,scalelines=0.05,scalevector=0.01,
                                        color=&#34;AzureBlueDark&#34;,linecolor=&#34;BlueDarkDull&#34;,vectorcolor=&#34;Black&#34;,name=&#34;Plane&#34;,opacity=1.0,thickness=0.0):
        &#34;&#34;&#34;
        Draws a plane with normal vector or base vectors. It passes through the point origin.
        Only normal or base can be not None
        Parameters:
           origin: a point in the plane
           normal: normal vector to the plane
           base: list of two independent vectors
           sizex: x-size of the plane
           sizey: y-size of the plane
           vectors: if True, draw the generators of the plane
           scalelines: scale of the lines limiting the plane
           scalevector: scale of the generators
           color: color of the plane
           linecolor: color of the lines limiting the plane
           vectorcolor: color of the generators
           name: name of the plane
           opacity: opacity of the plane
           thickness: thickness of the plane
        &#34;&#34;&#34;
        if normal is not None and base is not None:
                return
        if normal is None and base is None:
                return
        mat = Matrix(self.base)
        mat.transpose()
        if normal is not None:
                if not isinstance(normal,Vector):
                        normal= Vector(normal)
                normal = mat @ normal
        if base is not None:
                if len(base) != 2:
                        return
                if isinstance(base[0],Vector):
                        v1 = base[0]
                else:
                        v1 = Vector(base[0])
                if isinstance(base[1],Vector):
                        v2 = base[1]
                else:
                        v2 = Vector(base[1])
                v1 = mat @ v1
                v2 = mat @ v2
                normal = v1.cross(v2)

        if normal == Vector([0,0,0]):
                return

        steps = 4
        delta = sizex / steps
        x = - sizex / 2
        bm = bmesh.new()
        verts = []
        for k in range(steps + 1):
                verts.append(bm.verts.new((x,0,0)))
                x += delta
                if k == 0:
                        continue
                bm.edges.new([verts[k-1], verts[k]])

        me = self.meshes.new(&#39;PlaneSurfaceMesh&#39;)
        obj = self.objects.new(&#39;PlaneSurface&#39;, me)
        bm.to_mesh(me)
        bm.free()

        bpy.context.scene.collection.objects.link(obj)
        bpy.context.view_layer.objects.active = obj
        bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
        bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
        bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
        bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0, sizey, 0),&#34;constraint_axis&#34;:(False, True, False),&#34;use_accurate&#34;:True})
        bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
        bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
        obj.select_set(True)
        bpy.ops.transform.translate(value=(0, -sizey/2, 0),constraint_axis=(False, True, False))
        bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
        obj.select_set(False)

        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        if origin is not None:
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
        obj.location = o
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

        lines = None
        vecs = None
        s = 0.0
        nodes = [[1,1,0],[-1,1,0],[-1,-1,0],[1,-1,0]]
        nodes = [self.comp_times_vector(Vector([sizex / 2,sizey / 2,0]),Vector(x)) for x in nodes]
        edges = [[0,1],[1,2],[2,3],[3,0]]

        if scalelines &gt; 0.0:
                aux = self.origin
                self.origin = Vector([0,0,0])
                objects = []
                aux2 = self.base
                self.reset_base()
                for edge in edges:
                        l = self.draw_line(start=nodes[edge[0]],end=nodes[edge[1]],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                        objects.append(l)
                lines = self.join(objects)
                self.set_origin(aux)
                self.set_base(aux2)


        if lines is not None:
                obj = self.join([obj,lines])

        if vectors:
                vecs = self.draw_vectors(nodes,True,color=vectorcolor,scale=scalevector,head_height=0.2,name=&#34;Vectors&#34;,axis=0)
        if vecs is not None:
                obj = self.join([obj,vecs])
        obj.name = name

        if isinstance(normal,Vector):
                n = normal
        else:
                n = Vector(normal)
        z = Vector([0,0,1])
        quaternion = z.rotation_difference(n)
        tmp = obj.rotation_quaternion
        quaternion = tmp @ quaternion
        obj.rotation_quaternion = quaternion
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        obj.location = op
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_point"><code class="name flex">
<span>def <span class="ident">draw_point</span></span>(<span>self, radius=0.2, location=(0, 0, 0), name='Point', color='Black', opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a point (in the reference self.origin, self.base)</p>
<h2 id="parameters">Parameters</h2>
<p>radius: radius of the point
location: location of the point
name: name of the point
color: color of the point
opacity: opacity of the point</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_point(self,radius=0.2,location=(0,0,0),name=&#34;Point&#34;,color=&#34;Black&#34;,opacity=1.0):
        &#34;&#34;&#34;
        Draws a point (in the reference self.origin, self.base)
        Parameters:
           radius: radius of the point
           location: location of the point
           name: name of the point
           color: color of the point
           opacity: opacity of the point
        &#34;&#34;&#34;
        bpy.ops.mesh.primitive_uv_sphere_add(segments=16, ring_count=16, radius=radius, enter_editmode=False, location=location)
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)

        if not isinstance(location,Vector):
                location = Vector(location)
        mat = Matrix(self.base)
        mat.transpose()
        location = mat @ location

        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
        modifier.thickness = 0.1
        modifier.offset = 0.0
        c = Colors.color(color)
        op = Vector(self.origin)
        obj.location = op + location
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        bpy.ops.object.shade_smooth()
        obj.select_set(False)
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_points"><code class="name flex">
<span>def <span class="ident">draw_points</span></span>(<span>self, points=[], name='Points', color='Blue', opacity=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a list of points</p>
<h2 id="parameters">Parameters</h2>
<p>origin:
points: list of points
name: name of the list of points
color: color of the points
opacity: opacity of the points</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_points(self,points=[],name=&#39;Points&#39;,color=&#34;Blue&#34;,opacity=1):
        &#34;&#34;&#34;
        Draws a list of points
        Parameters:
           origin:
           points: list of points
           name: name of the list of points
           color: color of the points
           opacity: opacity of the points
        &#34;&#34;&#34;
        bm = bmesh.new()
        verts = []
        for p in points:
                verts.append(bm.verts.new(p))

        me = self.meshes.new(&#39;PointsMesh&#39;)
        obj = self.objects.new(name, me)
        bm.to_mesh(me)
        bm.free()
        self.scene.collection.objects.link(obj)
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_polygon"><code class="name flex">
<span>def <span class="ident">draw_polygon</span></span>(<span>self, origin=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], points=[[0, 0], [1, 0], [0, 1]], scalelines=0.075, color='AzureBlueDark', linecolor='OrangeObscureDull', name='Polygon', opacity=1.0, thickness=0.0, vectors=None, scalevectors=0.01)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a polygon</p>
<h2 id="parameters">Parameters</h2>
<p>origin: base vertex of the polygon
u1, u2: base vectors for the polygon
points: list of coordinates of points. The coordinates are taken in the reference {origin; u1, u2}
scalelines: scale of the edges of the polygon
color: color of the polygon
linecolor: color of the edges
name: name of the polygon
opacity: opacity of the polygon
thickness: thickness of the polygon</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_polygon(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],points=[[0,0],[1,0],[0,1]],scalelines=0.075,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Polygon&#39;,opacity=1.0,thickness=0.0,vectors=None,scalevectors=0.01):
        &#34;&#34;&#34;
        Draws a polygon
        Parameters:
           origin: base vertex of the polygon
           u1, u2: base vectors for the polygon
           points: list of coordinates of points. The coordinates are taken in the reference {origin; u1, u2}
           scalelines: scale of the edges of the polygon
           color: color of the polygon
           linecolor: color of the edges
           name: name of the polygon
           opacity: opacity of the polygon
           thickness: thickness of the polygon
        &#34;&#34;&#34;
        if len(points) &lt; 3:
                return
        op = Vector(self.origin)
        if isinstance(origin,Vector):
                op = op + origin
        else:
                op = op + Vector(origin)
        if not isinstance(u1,Vector):
                u1 = Vector(u1)
        if not isinstance(u2,Vector):
                u2 = Vector(u2)
        for i in range(len(points)):
                if not isinstance(points[i],Vector):
                        points[i] = Vector(points[i])

        mat = Matrix(self.base)
        mat.transpose()
        u1 = mat @ u1
        u2 = mat @ u2



        bpy.ops.curve.simple(Simple_Type=&#39;Polygon&#39;,Simple_sides=len(points),align=&#39;WORLD&#39;,location=(0, 0, 0))
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)
        bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)

        baricentre = Vector([0,0,0])
        verts = obj.data.splines[0].bezier_points
        for i in range(len(verts)):
                verts[i].co = op + points[i][0] * u1 + points[i][1] * u2
                baricentre += verts[i].co
        baricentre /= len(verts)

        for i in range(len(verts)):
                verts[i].co -= baricentre
        obj.location = baricentre

        obj.select_set(True)
        bpy.ops.object.convert(target=&#39;MESH&#39;)

        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 0.0

        ps = [op + points[i][0] * u1 + points[i][1] * u2 for i in range(len(points))]
        lines = None
        if scalelines &gt; 0.0:
                objects = []
                for i in range(len(points)):
                        l = self.draw_line(start=ps[i],end=ps[(i + 1) % len(points)],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                        objects.append(l)
                lines = self.join(objects)

        if vectors is not None:
                old = self.origin
                self.set_origin(op)
                ps = [points[i][0] * u1 + points[i][1] * u2 for i in range(len(points))]
                vecs = self.draw_vectors(ps,color=vectors,scale=scalevectors)
                self.set_origin(old)

        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

        if lines is not None:
                obj = self.join([obj,lines])
        if vectors is not None:
                obj = self.join([obj,vecs])

        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None

        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_pyramid"><code class="name flex">
<span>def <span class="ident">draw_pyramid</span></span>(<span>self, origin=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], u3=[0.5, 0.5, 1], scalelines=0.025, color='AzureBlueDark', linecolor='OrangeObscureDull', name='Pyramid', opacity=1.0, thickness=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a pyramid</p>
<h2 id="parameters">Parameters</h2>
<p>origin: base vertex of the pyramid
u1, u2, u3: vectors that gives the edges
scalelines: scale of the edges of the pyramid
color: color of the pyramid
linecolor: color of the edges
name: name of the pyramid
opacity: opacity of the pyramid
thickness: thickness of the pyramid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_pyramid(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],u3=[0.5,0.5,1],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Pyramid&#39;,opacity=1.0,thickness=0.0):
        &#34;&#34;&#34;
        Draws a pyramid
        Parameters:
           origin: base vertex of the pyramid
           u1, u2, u3: vectors that gives the edges
           scalelines: scale of the edges of the pyramid
           color: color of the pyramid
           linecolor: color of the edges
           name: name of the pyramid
           opacity: opacity of the pyramid
           thickness: thickness of the pyramid
        &#34;&#34;&#34;
        op = Vector(self.origin)
        if isinstance(origin,Vector):
                op = op + origin
        else:
                op = op + Vector(origin)
        if not isinstance(u1,Vector):
                u1 = Vector(u1)
        if not isinstance(u2,Vector):
                u2 = Vector(u2)
        if not isinstance(u3,Vector):
                u3 = Vector(u3)

        mat = Matrix(self.base)
        mat.transpose()
        u1 = mat @ u1
        u2 = mat @ u2
        u3 = mat @ u3

        bpy.ops.mesh.primitive_cone_add(radius1=1, radius2=0, depth=2, enter_editmode=False, align=&#39;WORLD&#39;,vertices=4)
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)

        verts = obj.data.vertices
        verts[0].co = op
        verts[1].co = op + u1
        verts[2].co = op + u1 + u2
        verts[3].co = op + u2
        verts[4].co = op + u3

        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 0.0

        lines = None
        s = 0.0
        edges =[[0,1],[0,3],[0,4],[1,2],[1,4],[2,3],[2,4],[3,4]]
        if scalelines &gt; 0.0:
                objects = []
                for edge in edges:
                        l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                        objects.append(l)
                lines = self.join(objects)

        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

        if lines is not None:
                obj = self.join([obj,lines])

        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None

        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_regular_polygon"><code class="name flex">
<span>def <span class="ident">draw_regular_polygon</span></span>(<span>self, origin=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], vertexs=5, radius=1, scalelines=0.075, color='AzureBlueDark', linecolor='OrangeObscureDull', name='RegularPolygon', opacity=1.0, thickness=0.0, vectors=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a regular polygon</p>
<h2 id="parameters">Parameters</h2>
<p>origin: base vertex of the polygon
u1, u2: base vectors for the polygon
vertexs: number of vertices of the polygon
radius: radius of the polygon
scalelines: scale of the edges of the polygon
color: color of the polygon
linecolor: color of the edges
name: name of the polygon
opacity: opacity of the polygon
thickness: thickness of the polygon</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_regular_polygon(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],vertexs=5,radius=1,scalelines=0.075,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;RegularPolygon&#39;,opacity=1.0,thickness=0.0,vectors=None):
        &#34;&#34;&#34;
        Draws a regular polygon
        Parameters:
           origin: base vertex of the polygon
           u1, u2: base vectors for the polygon
           vertexs: number of vertices of the polygon
           radius: radius of the polygon
           scalelines: scale of the edges of the polygon
           color: color of the polygon
           linecolor: color of the edges
           name: name of the polygon
           opacity: opacity of the polygon
           thickness: thickness of the polygon
        &#34;&#34;&#34;
        angle = 2*math.pi/vertexs
        points = [[radius*math.cos(i*angle),radius*math.sin(i*angle)] for i in range(vertexs)]
        return self.draw_polygon(origin=origin,u1=u1,u2=u2,points=points,scalelines=scalelines,color=color,linecolor=linecolor,name=name,opacity=opacity,thickness=thickness,vectors=vectors,scalevectors=radius/400)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_simple_curve"><code class="name flex">
<span>def <span class="ident">draw_simple_curve</span></span>(<span>self, fun=None, tmin=0.0, tmax=1.0, steps=25, thickness=0.02, color='White', name='Curve')</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a parametric curve</p>
<h2 id="parameters">Parameters</h2>
<p>fun: the parametric function
tmin: minimum value of the parameter
tmax: maximum value of the parameter
steps: number of steps
thickness: thickness of the curve
color: color of the curve
name: name of the curve</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_simple_curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.02,color=&#34;White&#34;,name=&#34;Curve&#34;):
        &#34;&#34;&#34;
        Draws a parametric curve
        Parameters:
           fun: the parametric function
           tmin: minimum value of the parameter
           tmax: maximum value of the parameter
           steps: number of steps
           thickness: thickness of the curve
           color: color of the curve
           name: name of the curve
        &#34;&#34;&#34;
        if fun is None:
                return None
        delta = (tmax - tmin) / steps
        t = tmin

        curve = bpy.data.curves.new(&#39;myCurve&#39;, type=&#39;CURVE&#39;)
        curve.dimensions = &#39;3D&#39;
        curve.resolution_u = 2

        line = curve.splines.new(&#39;POLY&#39;)
        line.points.add(steps)

        for i in range(steps+1):
                p = fun(t)
                p.append(1)
                line.points[i].co = p
                t += delta

        obj = bpy.data.objects.new(name, curve)
        curve.bevel_depth = thickness

        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
        self.scene.collection.objects.link(obj)
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_surface"><code class="name flex">
<span>def <span class="ident">draw_surface</span></span>(<span>self, eq=None, umin=-1, umax=1, usteps=64, vmin=-1, vmax=1, vsteps=64, thickness=0.02, opacity=1.0, pmax=10, name='Surface', color='AzureBlueDark', axis=False, o=Vector((0.0, 0.0, 0.0)), u1=Vector((1.0, 0.0, 0.0)), u2=Vector((0.0, 1.0, 0.0)), wrap_u=False, wrap_v=False, close_v=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a parametric surface in the reference R'</p>
<h2 id="parameters">Parameters</h2>
<p>eq: parametric equacion f(u,v)
umin: minimum value of u
umax: maximum value of u
usteps: steps in the u direction
vmin: minimum value of v
vmax: maximum value of v
vsteps: steps in the v direction
thickness: thickness of the surface
opacity: opacity of the surface
color: color of the surface
pmax: the principal axis are drawn between -cmax and cmax
name: name of the surface
color: color of the surface
axis: if True draw the axis of the reference {o, v1, v2, v3}
o: origin of the reference R'
u1, u2: vectors to construct the basis {v1, v2, v3}
scale: scale coefficients
wrap_u: wrap the u coordinate
wrap_v: wrap the u coordinate
close_v: close the v coordinate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_surface(self,eq=None,umin=-1,umax=1,usteps=64,vmin=-1,vmax=1,vsteps=64,thickness=0.02,opacity=1.0,pmax=10,name=&#34;Surface&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),wrap_u=False,wrap_v=False,close_v=False):
        &#34;&#34;&#34;
        Draws a parametric surface in the reference R&#39;
        Parameters:
           eq: parametric equacion f(u,v)
           umin: minimum value of u
           umax: maximum value of u
           usteps: steps in the u direction
           vmin: minimum value of v
           vmax: maximum value of v
           vsteps: steps in the v direction
           thickness: thickness of the surface
           opacity: opacity of the surface
           color: color of the surface
           pmax: the principal axis are drawn between -cmax and cmax
           name: name of the surface
           color: color of the surface
           axis: if True draw the axis of the reference {o, v1, v2, v3}
           o: origin of the reference R&#39;
           u1, u2: vectors to construct the basis {v1, v2, v3}
           scale: scale coefficients
           wrap_u: wrap the u coordinate
           wrap_v: wrap the u coordinate
           close_v: close the v coordinate
        &#34;&#34;&#34;
        if eq is None:
                return

        q = self.vectors_to_quaternion(u1,u2)
        draw_parametric_surface(eq=eq,range_u_min=umin,range_u_max=umax,range_u_step=usteps,range_v_min=vmin,range_v_max=vmax,range_v_step=vsteps,name=name,wrap_u=wrap_u,wrap_v=wrap_v,close_v=close_v)

        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)
        obj.show_wire = False

        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if self.rotation is not None:
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        if axis:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència escollida&#34;)

        bpy.ops.object.shade_smooth()
        obj.location = o
        obj.select_set(False)
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_tetrahedron"><code class="name flex">
<span>def <span class="ident">draw_tetrahedron</span></span>(<span>self, origin=[0, 0, 0], u1=[2, 0, 0], u2=[1.0000000000000002, 1.7320508075688772, 0], u3=[1.0, 0.5773502691896257, 2], scalelines=0.025, color='AzureBlueDark', linecolor='OrangeObscureDull', name='Tetrahedron', opacity=1.0, thickness=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a tetrahedron</p>
<h2 id="parameters">Parameters</h2>
<p>origin: base vertex of the tetrahedron
u1, u2, u3: vectors that gives the edges
scalelines: scale of the edges of the tetrahedron
color: color of the tetrahedron
linecolor: color of the edges
name: name of the tetrahedron
opacity: opacity of the tetrahedron
thickness: thickness of the tetrahedron</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_tetrahedron(self,origin=[0,0,0],u1=[2,0,0],u2=[2*math.cos(math.pi/3),2*math.sin(math.pi/3),0],u3=[(2+2*math.cos(math.pi/3))/3,2*math.sin(math.pi/3)/3,2],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Tetrahedron&#39;,opacity=1.0,thickness=0.0):
        &#34;&#34;&#34;
        Draws a tetrahedron
        Parameters:
           origin: base vertex of the tetrahedron
           u1, u2, u3: vectors that gives the edges
           scalelines: scale of the edges of the tetrahedron
           color: color of the tetrahedron
           linecolor: color of the edges
           name: name of the tetrahedron
           opacity: opacity of the tetrahedron
           thickness: thickness of the tetrahedron
        &#34;&#34;&#34;
        op = Vector(self.origin)
        if isinstance(origin,Vector):
                op = op + origin
        else:
                op = op + Vector(origin)
        if not isinstance(u1,Vector):
                u1 = Vector(u1)
        if not isinstance(u2,Vector):
                u2 = Vector(u2)
        if not isinstance(u3,Vector):
                u3 = Vector(u3)

        mat = Matrix(self.base)
        mat.transpose()
        u1 = mat @ u1
        u2 = mat @ u2
        u3 = mat @ u3

        bpy.ops.mesh.primitive_solid_add()
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)

        verts = obj.data.vertices
        verts[0].co = op + u3
        verts[1].co = op
        verts[2].co = op + u1
        verts[3].co = op + u2

        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 0.0

        lines = None
        s = 0.0
        edges =[[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]]
        if scalelines &gt; 0.0:
                objects = []
                for edge in edges:
                        l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                        objects.append(l)
                lines = self.join(objects)

        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

        if lines is not None:
                obj = self.join([obj,lines])

        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None

        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_triangle"><code class="name flex">
<span>def <span class="ident">draw_triangle</span></span>(<span>self, origin=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], points=[[0, 0], [1, 0], [0, 1]], scalelines=0.075, color='AzureBlueDark', linecolor='OrangeObscureDull', name='Triangle', opacity=1.0, thickness=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a triangle. It's a polygon with three vertices</p>
<h2 id="parameters">Parameters</h2>
<p>origin: base vertex of the triangle
u1, u2: base vectors for the triangle
points: list of coordinates of points. The coordinates are taken in the reference {origin; u1, u2}
scalelines: scale of the edges of the triangle
color: color of the triangle
linecolor: color of the edges
name: name of the triangle
opacity: opacity of the triangle
thickness: thickness of the triangle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_triangle(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],points=[[0,0],[1,0],[0,1]],scalelines=0.075,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#34;Triangle&#34;,opacity=1.0,thickness=0.0):
        &#34;&#34;&#34;
        Draws a triangle. It&#39;s a polygon with three vertices
        Parameters:
           origin: base vertex of the triangle
           u1, u2: base vectors for the triangle
           points: list of coordinates of points. The coordinates are taken in the reference {origin; u1, u2}
           scalelines: scale of the edges of the triangle
           color: color of the triangle
           linecolor: color of the edges
           name: name of the triangle
           opacity: opacity of the triangle
           thickness: thickness of the triangle
        &#34;&#34;&#34;
        if len(points) != 3:
                return
        self.draw_polygon(origin=origin,u1=u1,u2=u2,points=points,scalelines=scalelines,color=color,linecolor=linecolor,name=name,opacity=opacity,thickness=thickness)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_two_sheets_hyperboloid"><code class="name flex">
<span>def <span class="ident">draw_two_sheets_hyperboloid</span></span>(<span>self, a=2.0, b=1.0, xmin=0.0, xmax=5.0, steps=50, scale=[1, 1, 1], color='AzureBlueDark', name='HyperboloidTwoSheets', opacity=1.0, thickness=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a two sheet hyperboloid from the hyperbole z = \pm a * math.sqrt(x**2+b) in the XZ plane</p>
<h2 id="parameters">Parameters</h2>
<p>a, b: coefficients of the hyperbole
xmin: minimum value of x
xmax: maximum value of x
steps: numbers of steps to draw the parabola
scale: scaling factors in the X, Y and Z directions
color: color of the surface
name: name of the surface
opacity: opacity of the surface
thickness: thickness of the surface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_two_sheets_hyperboloid(self,a=2.0,b=1.0,xmin=0.0,xmax=5.0,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperboloidTwoSheets&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws a two sheet hyperboloid from the hyperbole z = \pm a * math.sqrt(x**2+b) in the XZ plane
        Parameters:
           a, b: coefficients of the hyperbole
           xmin: minimum value of x
           xmax: maximum value of x
           steps: numbers of steps to draw the parabola
           scale: scaling factors in the X, Y and Z directions
           color: color of the surface
           name: name of the surface
           opacity: opacity of the surface
           thickness: thickness of the surface
        &#34;&#34;&#34;
        delta = (xmax - xmin) / steps
        x = xmax
        bm = bmesh.new()
        verts = []
        count = 2 * steps + 2
        sign = 1
        for k in range(count):
                if k == steps + 1:
                        sign = -1
                z = sign * a * math.sqrt(x**2+b)
                verts.append(bm.verts.new((x,0,z)))
                if k == steps and xmin &gt; 0:
                        x = xmin
                else:
                        x = x - sign * delta
                if k == 0 or k == steps + 1:
                        continue
                bm.edges.new([verts[k-1], verts[k]])

        me = self.meshes.new(&#39;placeholder_mesh&#39;)
        obj = self.objects.new(name,me)
        bm.to_mesh(me)
        bm.free()

        modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
        modifier.angle = 2 * math.pi
        modifier.steps = 128
        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        self.scene.collection.objects.link(obj)
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_vector"><code class="name flex">
<span>def <span class="ident">draw_vector</span></span>(<span>self, vector=None, canonica=False, color='Black', scale=0.05, arrow=True, head_height=0.15, axis=0, name='Vector', positive=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw the vector with components 'vector'</p>
<h2 id="parameters">Parameters</h2>
<p>vector: components of the vector
canonica: if True, the components are in the canonical basis, else they are in the basis self.base. Finally,
self.rotation is applied
color: color of the vector
scale: scale of the cylinder
arrow: if True draws the vector itself
head_height: height of the head of the vector
axis: if not zero, draw also the line generated by the vector
positive: if axis is not zero and positive is True, draw only the positive part of the line
generated by the vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_vector(self,vector=None,canonica=False,color=&#34;Black&#34;,scale=0.05,arrow=True,head_height=0.15,axis=0,name=&#34;Vector&#34;,positive=True):
        &#34;&#34;&#34;
        Draw the vector with components &#39;vector&#39;
        Parameters:
           vector: components of the vector
           canonica: if True, the components are in the canonical basis, else they are in the basis self.base. Finally,
              self.rotation is applied
           color: color of the vector
           scale: scale of the cylinder
           arrow: if True draws the vector itself
           head_height: height of the head of the vector
           axis: if not zero, draw also the line generated by the vector
           positive: if axis is not zero and positive is True, draw only the positive part of the line
              generated by the vector
        &#34;&#34;&#34;
        if vector is None:
                return None
        if isinstance(vector,Vector):
                vec = vector
        else:
                vec = Vector(vector)
        if vec.length == 0:
                return None
        self.base_cilinder()
        self.base_cone()
        o = Vector([0,0,0])
        op = Vector(self.origin)
        if color is not None:
                color = Colors.color(color)
        v = vec
        if not canonica:
                mat = Matrix(self.base)
                mat.transpose()
                v = mat @ vec

        if arrow:
                t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                obj = t.copy()
                obj.name = name
                obj.data = obj.data.copy()
                obj.location = o
                obj.scale = (scale,scale,(v - o).length - 2 * head_height)
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                if color is not None:
                        self.add_material(obj,color.name,color.r,color.g,color.b)
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location = op
                self.scene.collection.objects.link(obj)

                t = bpy.data.objects.get(&#34;Arrow_cone&#34;)
                obj2 = t.copy()
                obj2.data = obj2.data.copy()
                obj2.name = &#34;Arrow&#34;
                obj2.location =  v - 2 * head_height * v / v.length
                obj2.scale = (scale + 0.01,scale + 0.01,head_height)
                obj2.rotation_mode = &#39;QUATERNION&#39;
                obj2.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                if color is not None:
                        self.add_material(obj2,color.name,color.r,color.g,color.b)
                if self.rotation is not None:
                        obj2.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj2.location.rotate(self.rotation.quaternion)
                obj2.location = op + obj2.location
                self.scene.collection.objects.link(obj2)

        obj3 = None
        if axis != 0:
                v = axis * v / v.length
                t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                obj3 = t.copy()
                if not arrow:
                        obj3.name = &#34;Line&#34;
                else:
                        obj3.name = &#34;Generated&#34;
                obj3.data = obj3.data.copy()
                obj3.scale = (scale / 2,scale / 2,(2 * v).length)
                obj3.rotation_mode = &#39;QUATERNION&#39;
                obj3.rotation_quaternion = v.to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                if color is not None:
                        self.add_material(obj3,color.name,color.r,color.g,color.b)
                if self.rotation is not None:
                        obj3.rotation_quaternion.rotate(self.rotation.quaternion)
                if positive:
                        obj3.location = op
                else:
                        obj3.location = op - v
                self.scene.collection.objects.link(obj3)

        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        if arrow:
                bpy.context.view_layer.objects.active = obj
        elif axis != 0:
                bpy.context.view_layer.objects.active = obj3
        if arrow:
                obj.select_set(True)
                obj2.select_set(True)
        if obj3 is not None:
                obj3.select_set(True)
        if arrow:
                bpy.ops.object.join()
        bpy.ops.object.shade_smooth()
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        self.delete_base_cilinder()
        self.delete_base_cone()
        bpy.context.view_layer.objects.active = None
        if arrow:
                return obj
        if axis != 0:
                return obj3
        return None</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_vector_field"><code class="name flex">
<span>def <span class="ident">draw_vector_field</span></span>(<span>self, f=None, xmin=-3, xmax=3, xsteps=8, ymin=-3, ymax=3, ysteps=8, zmin=-3, zmax=3, zsteps=8, name='Vector Field', color='Red', scale=0.02, head_height=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a vector field</p>
<h2 id="parameters">Parameters</h2>
<p>f: the vector field
xmin: minimum value of x
xmax: maximum value of x
xsteps: steps in the x direction
ymin: minimum value of y
ymax: maximum value of y
ysteps: steps in the y direction
zmin: minimum value of z
zmax: maximum value of z
zsteps: steps in the z direction
name: name of the vector field
color: color of the vector field
scale: scale of the vectors
head_height: head height of the vectors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_vector_field(self,f=None,xmin=-3,xmax=3,xsteps=8,ymin=-3,ymax=3,ysteps=8,zmin=-3,zmax=3,zsteps=8,name=&#34;Vector Field&#34;,color=&#34;Red&#34;,scale=0.02,head_height=0.05):
        &#34;&#34;&#34;
        Draws a vector field
        Parameters:
           f: the vector field
           xmin: minimum value of x
           xmax: maximum value of x
           xsteps: steps in the x direction
           ymin: minimum value of y
           ymax: maximum value of y
           ysteps: steps in the y direction
           zmin: minimum value of z
           zmax: maximum value of z
           zsteps: steps in the z direction
           name: name of the vector field
           color: color of the vector field
           scale: scale of the vectors
           head_height: head height of the vectors
        &#34;&#34;&#34;
        if f is None:
                return None
        xstep = (xmax - xmin)/xsteps
        ystep = (ymax - ymin)/ysteps
        zstep = (zmax - zmin)/zsteps
        if xstep == 0 or ystep == 0 or zstep == 0:
                return None
        vectors = []
        count = 1
        x = xmin
        while x &lt;= xmax:
                y = ymin
                while y &lt;= ymax:
                        z = zmin
                        while z &lt;= zmax:
                                o = Vector([x,y,z])
                                v = f(x,y,z)
                                if not isinstance(v,Vector):
                                        v = Vector(v)
                                self.set_origin(o)
                                vec = self.draw_vector(v,color=color,name=f&#34;Vector{count}&#34;,scale=scale,head_height=head_height)
                                if vec is not None:
                                        vectors.append(vec)
                                z += zstep
                                count += 1
                        y += ystep
                x += xstep
        v = self.join(vectors)
        bpy.context.object.name = name
        return v</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_vectors"><code class="name flex">
<span>def <span class="ident">draw_vectors</span></span>(<span>self, vectors=[], canonica=False, color='Black', scale=0.05, head_height=0.2, name='Vectors', axis=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a list of vectors.</p>
<h2 id="parameters">Parameters</h2>
<p>vectors: list of vectors
canonica: if True, the the vectors are expressed in the canonical basis.
color: color of the vectors
scale: scale of the cylinder
head_height: height of the head of the vector
axis: if not zero, draw also the line generated by every vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_vectors(self,vectors=[],canonica=False,color=&#34;Black&#34;,scale=0.05,head_height=0.2,name=&#34;Vectors&#34;,axis=0):
        &#34;&#34;&#34;
        Draws a list of vectors.
        Parameters:
           vectors: list of vectors
           canonica: if True, the the vectors are expressed in the canonical basis.
           color: color of the vectors
           scale: scale of the cylinder
           head_height: height of the head of the vector
           axis: if not zero, draw also the line generated by every vector
        &#34;&#34;&#34;
        if len(vectors) == 0:
                return
        count = 0
        for v in vectors:
                if count == 0:
                        this = name
                else:
                        this = f&#34;Vector{count}&#34;
                count += 1
                t = self.draw_vector(v,canonica,color,scale,head_height,axis,this)
        t = bpy.data.objects.get(name)
        list = [t]
        for count in range(1,len(vectors)+1):
                obj = bpy.data.objects.get(f&#34;Vector{count}&#34;)
                if obj is not None:
                        list.append(obj)
        t = self.join(list)
        return t</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.ellipsoid"><code class="name flex">
<span>def <span class="ident">ellipsoid</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, c2=1, principal=True, canonica=True, color='AzureBlueDark', name='Ellipsoid', cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an ellipsoid</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the ellipsoid
u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
v1 = u1
v2 = u2 - u2.project(v1)
v1.normalize()
v2.normalize()
v3 = v1.cross(v2)
a2, b2, c2: squares of semi-axes of the ellipsoid. The equation is x'^2/a^2 + y'^2/b^2 + z'^2/c^2 = 1
principal: if True, the principal axis are drawn
canonica: if True, the canonical axis are drawn
color: color of the surface
name: name of the ellipsoid
cmax: the canonical axis are drawn between -cmax and cmax
pmax: the principal axis are drawn between -pmax and pmax
thickness: thickness of the ellipsoid
opacity: opaccity of the ellipsoid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ellipsoid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Ellipsoid&#34;,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws an ellipsoid
        Parameters:
           o: center of the ellipsoid
           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
               v1 = u1
                   v2 = u2 - u2.project(v1)
                   v1.normalize()
                   v2.normalize()
                   v3 = v1.cross(v2)
           a2, b2, c2: squares of semi-axes of the ellipsoid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 + z&#39;^2/c^2 = 1
           principal: if True, the principal axis are drawn
           canonica: if True, the canonical axis are drawn
           color: color of the surface
           name: name of the ellipsoid
           cmax: the canonical axis are drawn between -cmax and cmax
           pmax: the principal axis are drawn between -pmax and pmax
           thickness: thickness of the ellipsoid
           opacity: opaccity of the ellipsoid
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        c = math.sqrt(c2)
        self.draw_ellipsoid(radius=1,scale=[a,b,c],color=color,name=name,thickness=thickness,opacity=opacity)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.elliptic_cylinder"><code class="name flex">
<span>def <span class="ident">elliptic_cylinder</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, principal=True, canonica=True, color='AzureBlueDark', name='EllipticCylinder', zmax=20, cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an elliptic cylinder</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the elliptic cylinder
u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
a2, b2: squares of semi-axes of the elliptic cylinder. The equation is x'^2/a^2 + y'^2/b^2 = 1
principal: if True, the principal axis are drawn
canonica: if True, the canonical axis are drawn
color: color of the surface
name: name of the elliptic cylinder
zmax: the elliptic cylinder is drawn between -zmax and zmax
cmax: the canonical axis are drawn between -cmax and cmax
pmax: the principal axis are drawn between -cmax and cmax
thickness: thickness of the elliptic cylinder
opacity: opacity of the elliptic cylinder</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def elliptic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;EllipticCylinder&#34;,zmax=20,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws an elliptic cylinder
        Parameters:
           o: center of the elliptic cylinder
           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
           a2, b2: squares of semi-axes of the elliptic cylinder. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 = 1
           principal: if True, the principal axis are drawn
           canonica: if True, the canonical axis are drawn
           color: color of the surface
           name: name of the elliptic cylinder
           zmax: the elliptic cylinder is drawn between -zmax and zmax
           cmax: the canonical axis are drawn between -cmax and cmax
           pmax: the principal axis are drawn between -cmax and cmax
           thickness: thickness of the elliptic cylinder
           opacity: opacity of the elliptic cylinder
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        self.draw_elliptic_cylinder(a=1.0,b=1.0,length=zmax,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.elliptic_paraboloid"><code class="name flex">
<span>def <span class="ident">elliptic_paraboloid</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, principal=True, canonica=True, color='AzureBlueDark', name='EllipticParaboloid', xmax=None, cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an elliptic paraboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: vertex of the elliptic paraboloid
u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
a2, b2: squares of semi-axes of the elliptic paraboloid. The equation is z = x'^2/a^2 + y'^2/b^2
principal: if True, the principal axis are drawn
canonica: if True, the canonical axis are drawn
color: color of the surface
name: name of the elliptic paraboloid
xmax: maximum value of the coordinate x
cmax: the canonical axis are drawn between -cmax and cmax
pmax: the principal axis are drawn between -cmax and cmax
thickness: thickness of the elliptic paraboloid
opacity: opacity of the elliptic paraboloid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def elliptic_paraboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;EllipticParaboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws an elliptic paraboloid
        Parameters:
           o: vertex of the elliptic paraboloid
           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
           a2, b2: squares of semi-axes of the elliptic paraboloid. The equation is z = x&#39;^2/a^2 + y&#39;^2/b^2
           principal: if True, the principal axis are drawn
           canonica: if True, the canonical axis are drawn
           color: color of the surface
           name: name of the elliptic paraboloid
           xmax: maximum value of the coordinate x
           cmax: the canonical axis are drawn between -cmax and cmax
           pmax: the principal axis are drawn between -cmax and cmax
           thickness: thickness of the elliptic paraboloid
           opacity: opacity of the elliptic paraboloid
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        if xmax is None:
                xmax = 10.0/a
        xmax /= a
        self.draw_elliptic_paraboloid(a=1.0,xmin=0.0,xmax=xmax,steps=50,scale=[a,b,1],color=color,name=name,opacity=opacity,thickness=thickness)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.hyperbolic_cylinder"><code class="name flex">
<span>def <span class="ident">hyperbolic_cylinder</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, principal=True, canonica=True, color='AzureBlueDark', name='HyperbolicCylinder', xmax=None, zmax=20, cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an hyperbolic cylinder</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the hyperbolic cylinder
u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
a2, b2: squares of semi-axes of the hyperbolic cylinder. The equation is x'^2/a^2 - y'^2/b^2 = 1
principal: if True, the principal axis are drawn
canonica: if True, the canonical axis are drawn
color: color of the surface
name: name of the hyperbolic cylinder
xmax: maximum value of the x coordinate
zmax: the hyperbolic cylinder is drawn between -zmax and zmax
cmax: the canonical axis are drawn between -cmax and cmax
pmax: the principal axis are drawn between -cmax and cmax
thickness: thickness of the hyperbolic cylinder
opacity: opacity of the hyperbolic cylinder</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hyperbolic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicCylinder&#34;,xmax=None,zmax=20,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws an hyperbolic cylinder
        Parameters:
           o: center of the hyperbolic cylinder
           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
           a2, b2: squares of semi-axes of the hyperbolic cylinder. The equation is x&#39;^2/a^2 - y&#39;^2/b^2 = 1
           principal: if True, the principal axis are drawn
           canonica: if True, the canonical axis are drawn
           color: color of the surface
           name: name of the hyperbolic cylinder
           xmax: maximum value of the x coordinate
           zmax: the hyperbolic cylinder is drawn between -zmax and zmax
           cmax: the canonical axis are drawn between -cmax and cmax
           pmax: the principal axis are drawn between -cmax and cmax
           thickness: thickness of the hyperbolic cylinder
           opacity: opacity of the hyperbolic cylinder
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        if xmax is None:
                xmax = 5.0/a + 2
        xmax /= a
        obj = self.draw_hyperbolic_cylinder(a=1.0,b=1.0,xmin=1.0,xmax=xmax,length=zmax,steps=50,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.hyperbolic_paraboloid"><code class="name flex">
<span>def <span class="ident">hyperbolic_paraboloid</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, principal=True, canonica=True, color='AzureBlueDark', name='HyperbolicParaboloid', xmax=None, ymax=None, cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an hyperbolic paraboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: vertex of the hyperbolic paraboloid
u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
a2, b2: squares of semi-axes of the hyperbolic paraboloid. The equation is z = x'^2/a^2 - y'^2/b^2
principal: if True, the principal axis are drawn
canonica: if True, the canonical axis are drawn
color: color of the surface
name: name of the elliptic paraboloid
xmax: maximum value of the coordinate x
ymax: maximum value of the coordinate y
cmax: the canonical axis are drawn between -cmax and cmax
pmax: the principal axis are drawn between -cmax and cmax
thickness: thickness of the hyperbolic paraboloid
opacity: opacity of the hyperbolic paraboloid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hyperbolic_paraboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicParaboloid&#34;,xmax=None,ymax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws an hyperbolic paraboloid
        Parameters:
           o: vertex of the hyperbolic paraboloid
           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
           a2, b2: squares of semi-axes of the hyperbolic paraboloid. The equation is z = x&#39;^2/a^2 - y&#39;^2/b^2
           principal: if True, the principal axis are drawn
           canonica: if True, the canonical axis are drawn
           color: color of the surface
           name: name of the elliptic paraboloid
           xmax: maximum value of the coordinate x
           ymax: maximum value of the coordinate y
           cmax: the canonical axis are drawn between -cmax and cmax
           pmax: the principal axis are drawn between -cmax and cmax
           thickness: thickness of the hyperbolic paraboloid
           opacity: opacity of the hyperbolic paraboloid
        &#34;&#34;&#34;
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        if xmax is None:
                xmax = 10.0/a + 2
        if ymax is None:
                ymax = 10.0/b + 1
        xmax /= a
        ymax /= b
        obj = self.draw_hyperbolic_paraboloid(a=1.0,b=1.0,xmax=xmax,ymax=ymax,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)

        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        obj.location = o</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>self, list)</span>
</code></dt>
<dd>
<div class="desc"><p>Joins a list of objects</p>
<h2 id="parameters">Parameters</h2>
<p>list: list of objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join(self,list):
        &#34;&#34;&#34;
        Joins a list of objects
        Parameters:
           list: list of objects
        &#34;&#34;&#34;
        if len(list) &lt;= 1:
                return
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        bpy.context.view_layer.objects.active = list[0]
        for obj in list:
                obj.select_set(True)
        bpy.ops.object.join()
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        return list[0]</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.new_components"><code class="name flex">
<span>def <span class="ident">new_components</span></span>(<span>self, vector=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the components of the vector 'vector' in the basis determined by
self.rotation ans the basis self.base</p>
<h2 id="parameters">Parameters</h2>
<p>vector: components of the vector in the canonical basis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_components(self,vector=None):
        &#34;&#34;&#34;
        Returns the components of the vector &#39;vector&#39; in the basis determined by
        self.rotation ans the basis self.base
        Parameters:
           vector: components of the vector in the canonical basis
        &#34;&#34;&#34;
        if vector is None:
                return Vector([0,0,0])
        if isinstance(vector,Vector):
                u = vector
        else:
                u = Vector(vector)
        if self.rotation is not None:
                mat = self.rotation.quaternion.to_matrix()
                mat.invert()
                u = mat @ u
        mat = Matrix(self.base)
        mat.transpose()
        mat.invert()
        u = mat @ u
        return u</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.new_coordinates"><code class="name flex">
<span>def <span class="ident">new_coordinates</span></span>(<span>self, point=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the coordinates of the point 'point' in the reference determined by
self.origin, self.rotation and the basis self.base</p>
<h2 id="parameters">Parameters</h2>
<p>point: coordinates of the point in the canonical reference</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_coordinates(self,point=None):
        &#34;&#34;&#34;
        Returns the coordinates of the point &#39;point&#39; in the reference determined by
        self.origin, self.rotation and the basis self.base
        Parameters:
           point: coordinates of the point in the canonical reference
        &#34;&#34;&#34;
        if point is None:
                return Vector([0,0,0])
        if isinstance(point,Vector):
                u = point
        else:
                u = Vector(point)
        if self.rotation is not None:
                mat = self.rotation.quaternion.to_matrix()
                mat.invert()
                u = mat @ u
        mat = Matrix(self.base)
        mat.transpose()
        mat.invert()
        u = mat @ (u - Vector(self.origin))
        return u</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.one_sheet_hyperboloid"><code class="name flex">
<span>def <span class="ident">one_sheet_hyperboloid</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, c2=1, principal=True, canonica=True, color='AzureBlueDark', name='OneSheetHyperboloid', xmax=None, cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an one sheet hyperboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the hyperboloid
u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x'^2/a^2 + y'^2/b^2 - z'^2/c^2 = 1
principal: if True, the principal axis are drawn
canonica: if True, the canonical axis are drawn
color: color of the surface
name: name of the hyperboloid
xmax: maximum value of the x coordinate
cmax: the canonical axis are drawn between -cmax and cmax
pmax: the principal axis are drawn between -cmax and cmax
thickness: thickness of the hyperboloid
opacity: opacity of the hyperboloid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def one_sheet_hyperboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;OneSheetHyperboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws an one sheet hyperboloid
        Parameters:
           o: center of the hyperboloid
           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
           a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = 1
           principal: if True, the principal axis are drawn
           canonica: if True, the canonical axis are drawn
           color: color of the surface
           name: name of the hyperboloid
           xmax: maximum value of the x coordinate
           cmax: the canonical axis are drawn between -cmax and cmax
           pmax: the principal axis are drawn between -cmax and cmax
           thickness: thickness of the hyperboloid
           opacity: opacity of the hyperboloid
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        c = math.sqrt(c2)
        if xmax is None:
                xmax=5.0/a + 2
        xmax /= a
        self.draw_one_sheet_hyperboloid(a=1.0,b=1.0,xmin=1.0,xmax=xmax,scale=[a,b,c],color=color,name=name,thickness=thickness,opacity=opacity)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.parabolic_cylinder"><code class="name flex">
<span>def <span class="ident">parabolic_cylinder</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a=1, principal=True, canonica=True, color='AzureBlueDark', name='ParabolicCylinder', xmax=None, ymax=30, cmax=20, pmax=20, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws an hyperbolic paraboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: vertex of the hyperbolic paraboloid
u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
a2, b2: squares of semi-axes of the hyperbolic paraboloid. The equation is z = x'^2/a^2 - y'^2/b^2
principal: if True, the principal axis are drawn
canonica: if True, the canonical axis are drawn
color: color of the surface
name: name of the elliptic paraboloid
xmax: maximum value of the coordinate x
ymax: maximum value of the coordinate y
cmax: the canonical axis are drawn between -cmax and cmax
pmax: the principal axis are drawn between -cmax and cmax
thickness: thickness of the hyperbolic paraboloid
opacity: opacity of the hyperbolic paraboloid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parabolic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;ParabolicCylinder&#34;,xmax=None,ymax=30,cmax=20,pmax=20,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws an hyperbolic paraboloid
        Parameters:
           o: vertex of the hyperbolic paraboloid
           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
           a2, b2: squares of semi-axes of the hyperbolic paraboloid. The equation is z = x&#39;^2/a^2 - y&#39;^2/b^2
           principal: if True, the principal axis are drawn
           canonica: if True, the canonical axis are drawn
           color: color of the surface
           name: name of the elliptic paraboloid
           xmax: maximum value of the coordinate x
           ymax: maximum value of the coordinate y
           cmax: the canonical axis are drawn between -cmax and cmax
           pmax: the principal axis are drawn between -cmax and cmax
           thickness: thickness of the hyperbolic paraboloid
           opacity: opacity of the hyperbolic paraboloid
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        coef = 1.0
        if a &lt; 0:
                coef = -1
        if xmax is None:
                xmax = 5.0/a + 1.5
        xmax /= a
        self.draw_parabolic_cylinder(p=coef,xmin=0.0,xmax=xmax,length=ymax,color=color,name=name,scale=[a,1,1],thickness=thickness,opacity=opacity)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets origin, base, rotation, frames and colors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
        &#34;&#34;&#34;
        Resets origin, base, rotation, frames and colors
        &#34;&#34;&#34;
        self.reset_origin()
        self.reset_base()
        self.reset_rotation()
        self.reset_frames()
        self.reset_colors()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.reset_base"><code class="name flex">
<span>def <span class="ident">reset_base</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets self.base to the canonical basis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_base(self):
        &#34;&#34;&#34;
        Sets self.base to the canonical basis
        &#34;&#34;&#34;
        self.base = [[1,0,0],[0,1,0],[0,0,1]]</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.reset_colors"><code class="name flex">
<span>def <span class="ident">reset_colors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set self.colors to default colors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_colors(self):
        &#34;&#34;&#34;
        Set self.colors to default colors
        &#34;&#34;&#34;
        self.colors= Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.reset_frames"><code class="name flex">
<span>def <span class="ident">reset_frames</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set self.frame to 0</p>
<h2 id="parameters">Parameters</h2>
<p>name: name of a color</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_frames(self):
        &#34;&#34;&#34;
        Set self.frame to 0
        Parameters:
           name: name of a color
        &#34;&#34;&#34;
        self.frame = 0</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.reset_origin"><code class="name flex">
<span>def <span class="ident">reset_origin</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the origin to the point (0,0,0)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_origin(self):
        &#34;&#34;&#34;
        Sets the origin to the point (0,0,0)
        &#34;&#34;&#34;
        self.origin = Vector([0,0,0])</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.reset_rotation"><code class="name flex">
<span>def <span class="ident">reset_rotation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the rotation to identity, i.e., rotation of 0 degrees around the
vector (1,0,0)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_rotation(self):
        &#34;&#34;&#34;
        Sets the rotation to identity, i.e., rotation of 0 degrees around the
        vector (1,0,0)
        &#34;&#34;&#34;
        self.set_rotation()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.revolution_surface"><code class="name flex">
<span>def <span class="ident">revolution_surface</span></span>(<span>self, fun=None, tmin=0.0, tmax=1.0, o=Vector((0.0, 0.0, 0.0)), u1=Vector((1.0, 0.0, 0.0)), u2=Vector((0.0, 1.0, 0.0)), pmax=0, steps=256, thickness=0.025, axis='Z', name='Revolution surface', color='AzureBlueDark')</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a revolution surface from a curve in the reference R'</p>
<h2 id="parameters">Parameters</h2>
<p>fun: parametric equacion of the curve
steps: number of steps
axis: axis of revolution. It must be 'X', 'Y' or 'Z'
o: origin of the reference R'
u1, u2: vectors to construct the basis {v1, v2, v3}
pmax: the principal axis are drawn between -pmax and pmax
color: color of the surface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def revolution_surface(self,fun=None,tmin=0.0,tmax=1.0,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),pmax=0,steps=256,thickness=0.025,axis=&#39;Z&#39;,name=&#34;Revolution surface&#34;,color=&#34;AzureBlueDark&#34;):
        &#34;&#34;&#34;
        Draws a revolution surface from a curve in the reference R&#39;
        Parameters:
           fun: parametric equacion of the curve
           steps: number of steps
           axis: axis of revolution. It must be &#39;X&#39;, &#39;Y&#39; or &#39;Z&#39;
           o: origin of the reference R&#39;
           u1, u2: vectors to construct the basis {v1, v2, v3}
           pmax: the principal axis are drawn between -pmax and pmax
           color: color of the surface
        &#34;&#34;&#34;
        if fun is None:
                return None
        q = self.vectors_to_quaternion(u1,u2)
        obj = self.simple_curve(fun,tmin=tmin,tmax=tmax,steps=steps,name=name)
        m = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        m.levels = 4
        m.subdivision_type = &#39;SIMPLE&#39;
        m = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
        m.thickness = thickness
        m.offset = 1.0
        m = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
        m.angle = 2*math.pi
        m.steps = steps
        m.axis =  axis
        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
        bpy.context.scene.collection.objects.link(obj)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if self.rotation is not None:
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        if pmax &gt; 0.0:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència R&#39;&#34;)
        bpy.ops.object.shade_smooth()
        obj.location = o
        obj.select_set(False)
        bpy.context.view_layer.objects.active = None</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rotate_euler"><code class="name flex">
<span>def <span class="ident">rotate_euler</span></span>(<span>self, obj=None, psi=0.0, theta=0.0, phi=0.0, frames=3, axis='ZXZ', amax=15, scaleaxis=0.075, reverse=False, local=False, radians=False, positive=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotates an object by the Euler angles psi, theta and phi</p>
<h2 id="parameters">Parameters</h2>
<p>object: the object
psi, theta, phi: the Euler angles expressed in degrees
axis: it must be 'XYZ', 'XZY', 'YXZ', 'YZX', 'ZXY', 'ZYX', 'XYX', 'XZX', 'YXY', 'YZY', 'ZXZ' or 'ZYZ'
amax: axis valur for draw_base_axis
scaleaxis: scale value for draw_base_axis
local: if True the center of rotation is the location of the object
radians: if True, psi, theta and phi must be in radians
positive: if False and psi, theta or phi are greather than 180 degrees, they rae converted
to negative angles</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_euler(self,obj=None,psi=0.0,theta=0.0,phi=0.0,frames=3,axis=&#39;ZXZ&#39;,amax=15,scaleaxis=0.075,reverse=False,local=False,radians=False,positive=True):
        &#34;&#34;&#34;
        Rotates an object by the Euler angles psi, theta and phi
        Parameters:
           object: the object
           psi, theta, phi: the Euler angles expressed in degrees
           axis: it must be &#39;XYZ&#39;, &#39;XZY&#39;, &#39;YXZ&#39;, &#39;YZX&#39;, &#39;ZXY&#39;, &#39;ZYX&#39;, &#39;XYX&#39;, &#39;XZX&#39;, &#39;YXY&#39;, &#39;YZY&#39;, &#39;ZXZ&#39; or &#39;ZYZ&#39;
           amax: axis valur for draw_base_axis
           scaleaxis: scale value for draw_base_axis
           local: if True the center of rotation is the location of the object
           radians: if True, psi, theta and phi must be in radians
           positive: if False and psi, theta or phi are greather than 180 degrees, they rae converted
                     to negative angles
        &#34;&#34;&#34;
        def vector_from_axis(axis):
                if axis == &#39;X&#39;:
                        return Vector([1,0,0])
                if axis == &#39;Y&#39;:
                        return Vector([0,1,0])
                if axis == &#39;Z&#39;:
                        return Vector([0,0,1])
                return None

        if obj is None or axis is None:
                return None

        if not isinstance(axis,str):
                return None

        axis = axis.upper()
        if axis not in (&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,&#39;XYX&#39;,&#39;XZX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;):
                return None

        u1 = vector_from_axis(axis[0])
        u2 = vector_from_axis(axis[1])
        u3 = vector_from_axis(axis[2])

        if radians:
                psi *= 180/math.pi
                theta *= 180/math.pi
                phi *= 180/math.pi
        if positive:
                if psi &lt; 0.0:
                        psi += 360
                if theta &lt; 0.0:
                        theta += 360
                if phi &lt; 0.0:
                        phi += 360
        else:
                if psi &gt; 180.0:
                        psi -= 360
                if theta &gt; 180.0:
                        theta -= 360
                if phi &gt; 180.0:
                        phi -= 360

        if reverse:
                self.set_colors([&#34;OrangeRedDark&#34;,&#34;Yellow&#34;,&#34;Magenta&#34;])
                axis = self.draw_base_axis(axis = amax,scale=scaleaxis,positive=False,name=&#34;Eixos fixes&#34;)
                obj = self.join([obj,axis])
                u1, u2, u3 = u3, u2, u1
                psi, theta, phi = phi, theta, psi
                s = Rotation(psi,u1)
                u2 = s.apply(u2)
                u3 = s.apply(u3)
                s = Rotation(theta,u2)
                u3 = s.apply(u3)
        else:
                self.draw_base_axis(axis=amax,scale=scaleaxis,positive=False)

        bpy.context.scene.frame_set(self.frame)
        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        if not local:
                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
        fn = frames + self.frame
        if psi &gt; 0:
                num = int(psi)
        elif psi &lt; 0:
                num = int(-psi)
        alfa = psi / num
        r = Rotation(alfa,u1)
        for i in range(num):
                bpy.context.scene.frame_set(fn)
                obj.rotation_quaternion.rotate(r.quaternion)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if not local:
                        w = obj.location
                        w.rotate(r.quaternion)
                        obj.location = w
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn += frames

        if theta &gt; 0:
                num = int(theta)
        elif theta &lt; 0:
                num = int(-theta)
        alfa = theta / num
        r = Rotation(alfa,u2)
        for i in range(num):
                bpy.context.scene.frame_set(fn)
                obj.rotation_quaternion.rotate(r.quaternion)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if not local:
                        w = obj.location
                        w.rotate(r.quaternion)
                        obj.location = w
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn += frames

        if phi &gt; 0:
                num = int(phi)
        elif phi &lt; 0:
                num = int(-phi)
        alfa = phi / num
        r = Rotation(alfa,u3)
        for i in range(num):
                bpy.context.scene.frame_set(fn)
                obj.rotation_quaternion.rotate(r.quaternion)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if not local:
                        w = obj.location
                        w.rotate(r.quaternion)
                        obj.location = w
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn += frames

        self.frame = fn - frames
        bpy.context.scene.frame_end = self.frame
        bpy.context.scene.frame_set(0)
        bpy.context.view_layer.update()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rotate_object"><code class="name flex">
<span>def <span class="ident">rotate_object</span></span>(<span>self, obj=None, axis='Z', frames=1, origin=Vector((0.0, 0.0, 0.0)), localaxis=None, localangle=None, helicoidal=0.0, rounds=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotates an object around the axis</p>
<h2 id="parameters">Parameters</h2>
<p>obj: the object
axis: it must be 'X', 'Y', 'Z' or a Vector
local: if True the center of rotation is the location of the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_object(self,obj=None,axis=&#39;Z&#39;,frames=1,origin=Vector([0,0,0]),localaxis=None,localangle=None,helicoidal=0.0,rounds=1):
        &#34;&#34;&#34;
        Rotates an object around the axis
        Parameters:
           obj: the object
           axis: it must be &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39; or a Vector
           local: if True the center of rotation is the location of the object
        &#34;&#34;&#34;
        if obj is None:
                return None
        if isinstance(axis,str):
                axis = axis.strip().upper()
        if axis == &#39;X&#39;:
                u = Vector([1,0,0])
        elif axis == &#39;Y&#39;:
                u = Vector([0,1,0])
        elif axis == &#39;Z&#39;:
                u = Vector([0,0,1])
        elif isinstance(axis,Vector):
                u = axis
        else:
                u = Vector(axis)

        if not isinstance(origin,Vector):
                origin = Vector(origin)

        line = None
        if localaxis is not None and localangle is not None:
                old = self.origin
                self.set_origin(obj.location)
                l = obj.dimensions.length / 2
                line = self.draw_vector(localaxis,axis=l,scale=0.1,arrow=False,positive=False,color=&#34;Orange&#34;,name=&#34;Eix rotació local&#34;)
                line.select_set(True)
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CENTER_OF_MASS&#39;, center=&#39;MEDIAN&#39;)
                line.select_set(False)
                self.set_origin(old)
                lr = Rotation(localangle,localaxis)

        r = Rotation(1/int(frames),u)
        axis, angle = r.to_axis_angle()
        t = helicoidal * axis
        bpy.context.scene.frame_set(self.frame)
        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
        fn = self.frame + 1
        for i in range(int(frames) * int(rounds) * 360):
                bpy.context.scene.frame_set(fn)
                if line is None:
                        obj.rotation_quaternion.rotate(r.quaternion)
                else:
                        obj.rotation_quaternion.rotate(lr.quaternion)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                w = obj.location - origin
                w.rotate(r.quaternion)
                obj.location = origin + w + t
                if line is not None:
                        line.location = origin + w + t
                        line.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn += 1
        self.frame = fn - frames
        bpy.context.scene.frame_end = self.frame
        bpy.context.scene.frame_set(0)
        bpy.context.view_layer.update()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rotate_object_by_axis_angle"><code class="name flex">
<span>def <span class="ident">rotate_object_by_axis_angle</span></span>(<span>self, obj=None, axis=Vector((1.0, 0.0, 0.0)), angle=90, amax=15, frames=1, scaleaxis=0.075, local=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotates an object around an angle 'angle' around the axis</p>
<h2 id="parameters">Parameters</h2>
<p>obj: the object
axis: any non nul Vectors
angle: the angle of rotation in degrees
frames: increment of the frame set
scaleaxis: scale value for draw_base_axis
local: if True the center of rotation is the location of the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_object_by_axis_angle(self,obj=None,axis=Vector([1,0,0]),angle=90,amax=15,frames=1,scaleaxis=0.075,local=False):
        &#34;&#34;&#34;
        Rotates an object around an angle &#39;angle&#39; around the axis
        Parameters:
           obj: the object
           axis: any non nul Vectors
           angle: the angle of rotation in degrees
           frames: increment of the frame set
           scaleaxis: scale value for draw_base_axis
           local: if True the center of rotation is the location of the object
        &#34;&#34;&#34;
        if obj is None:
                return None
        if isinstance(axis,Vector):
                u = axis
        else:
                u = Vector(axis)
        if u.length == 0.0 or angle &lt;= 1:
                return

        self.draw_base_axis(axis = amax,scale=scaleaxis,positive=False)
        self.draw_vector(u,scale=0.1,axis=amax,positive=False,color=&#34;Black&#34;,name=&#34;Eix rotació&#34;)

        num = int(angle)
        alfa = angle / num
        r = Rotation(alfa,u)
        bpy.context.scene.frame_set(self.frame)
        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        if not local:
                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
        fn = frames + self.frame

        for i in range(num):
                bpy.context.scene.frame_set(fn)
                obj.rotation_quaternion.rotate(r.quaternion)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if not local:
                        w = obj.location
                        w.rotate(r.quaternion)
                        obj.location = w
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn += frames
        self.frame = fn - frames
        bpy.context.scene.frame_end = self.frame
        bpy.context.scene.frame_set(0)
        bpy.context.view_layer.update()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rotate_vector"><code class="name flex">
<span>def <span class="ident">rotate_vector</span></span>(<span>self, vector=None, axis='Z')</span>
</code></dt>
<dd>
<div class="desc"><p>Rotates a vector around the axis</p>
<h2 id="parameters">Parameters</h2>
<p>vector: the vector
axis: it must be 'X', 'Y', 'Z' or a vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_vector(self,vector=None,axis=&#39;Z&#39;):
        &#34;&#34;&#34;
        Rotates a vector around the axis
        Parameters:
           vector: the vector
           axis: it must be &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39; or a vector
        &#34;&#34;&#34;
        if vector is None:
                return None
        if axis == &#39;X&#39;:
                u = Vector([1,0,0])
        elif axis == &#39;Y&#39;:
                u = Vector([0,1,0])
        elif axis == &#39;Z&#39;:
                u = Vector([0,0,1])
        elif isinstance(axis,Vector):
                u = axis
        else:
                u = Vector(axis)

        self.draw_vector(vector,color=&#34;Black&#34;)
        obj = self.draw_vector(vector,color=&#34;Red&#34;)
        w1 = u.orthogonal().normalized()
        vec1 = vector.project(u)
        w3 = vec1.normalized()
        w2 = w3.cross(w1)
        a = vec1.length
        b = (vector-vec1).length
        p2 = b**2/a**2
        self.rotate_object(obj,u)
        self.draw_vector(u,axis=1.4*a,positive=False,color=&#34;White&#34;)
        self.cone(u1=w1,u2=w2,a2=p2,b2=p2,c2=1,half=True, principal=False,canonica=False,xmax=b,color=&#34;GrayLight&#34;,opacity=0.2)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.set_base"><code class="name flex">
<span>def <span class="ident">set_base</span></span>(<span>self, base, orthonormal=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the self.base, i.e., the basis of the reference coordinates used to display
objects</p>
<h2 id="parameters">Parameters</h2>
<p>base: list of three vectors
orthonormal: if True, the Gram-Schmidt method is applied and the vectors
are normalized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_base(self,base,orthonormal=False):
        &#34;&#34;&#34;
        Sets the self.base, i.e., the basis of the reference coordinates used to display
        objects
        Parameters:
           base: list of three vectors
           orthonormal: if True, the Gram-Schmidt method is applied and the vectors
           are normalized.
        &#34;&#34;&#34;
        if orthonormal:
                u1 = base[0]
                u2 = base[1]
                if isinstance(u1,Vector):
                        v1 = u1
                else:
                        v1 = Vector(u1)
                if isinstance(u2,Vector):
                        v2 = u2
                else:
                        v2 = Vector(u2)
                v2 = v2 - v2.project(v1)
                v1.normalize()
                v2.normalize()
                v3 = v1.cross(v2)
                self.base=[v1,v2,v3]
        else:
                self.base = base</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.set_colors"><code class="name flex">
<span>def <span class="ident">set_colors</span></span>(<span>self, names)</span>
</code></dt>
<dd>
<div class="desc"><p>Set self.colors to the list of colors with names 'names'</p>
<h2 id="parameters">Parameters</h2>
<p>names: list of name colors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_colors(self,names):
        &#34;&#34;&#34;
        Set self.colors to the list of colors with names &#39;names&#39;
        Parameters:
           names: list of name colors
        &#34;&#34;&#34;
        self.colors = Colors.colors(names)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.set_cursor"><code class="name flex">
<span>def <span class="ident">set_cursor</span></span>(<span>self, origin=[0, 0, 0], direction=[1, 0, 0], axis='x')</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the cursor position and direction</p>
<h2 id="parameters">Parameters</h2>
<p>origin: position of the cursor
direction: vector that indicates the direction of the axis 'axis'
axis: 'x', 'y' or 'z'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cursor(self,origin=[0,0,0],direction=[1,0,0],axis=&#39;x&#39;):
        &#34;&#34;&#34;
        Sets the cursor position and direction
        Parameters:
          origin: position of the cursor
          direction: vector that indicates the direction of the axis &#39;axis&#39;
          axis: &#39;x&#39;, &#39;y&#39; or &#39;z&#39;
        &#34;&#34;&#34;
        axis = axis.lower()
        if axis not in [&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]:
                return
        eixos = {&#39;x&#39; : Vector([1,0,0]),
                         &#39;y&#39; : Vector([0,1,0]),
                         &#39;z&#39; : Vector([0,0,1])
        }
        if isinstance(direction,Vector):
                d = direction
        else:
                d = Vector(direction)
        x = eixos[axis]
        quaternion = x.rotation_difference(d)
        self.scene.cursor.location = origin
        self.scene.cursor.rotation_mode = &#39;QUATERNION&#39;
        self.scene.cursor.rotation_quaternion = quaternion</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.set_cursor_rotation"><code class="name flex">
<span>def <span class="ident">set_cursor_rotation</span></span>(<span>self, origin=[0, 0, 0], rotation=Matrix(((1.0, 0.0, 0.0),
(0.0, 1.0, 0.0),
(0.0, 0.0, 1.0))))</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the rotation of the cursor</p>
<h2 id="parameters">Parameters</h2>
<p>origin: position of the cursor
rotation: matrix of a rotation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cursor_rotation(self,origin=[0,0,0],rotation=Matrix.Identity(3)):
        &#34;&#34;&#34;
        Sets the rotation of the cursor
        Parameters:
           origin: position of the cursor
           rotation: matrix of a rotation
        &#34;&#34;&#34;
        m = rotation.copy()
        det = m.determinant()
        if abs(- det - 1.0) &lt; 0.1:
                m[2] = - m[2]
        quaternion = m.to_quaternion()
        self.scene.cursor.location = origin
        self.scene.cursor.rotation_mode = &#39;QUATERNION&#39;
        self.scene.cursor.rotation_quaternion = quaternion.conjugated()</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.set_default_color"><code class="name flex">
<span>def <span class="ident">set_default_color</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Set self.defaultcolor to the color with name 'name'</p>
<h2 id="parameters">Parameters</h2>
<p>name: name of a color</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_default_color(self,name):
        &#34;&#34;&#34;
        Set self.defaultcolor to the color with name &#39;name&#39;
        Parameters:
           name: name of a color
        &#34;&#34;&#34;
        self.defaultcolor = name</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.set_origin"><code class="name flex">
<span>def <span class="ident">set_origin</span></span>(<span>self, vector=[0, 0, 0])</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the origin of the reference coordinates used to display objects.</p>
<h2 id="parameters">Parameters</h2>
<p>vector: origin's position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_origin(self,vector=[0,0,0]):
        &#34;&#34;&#34;
        Sets the origin of the reference coordinates used to display objects.
        Parameters:
           vector: origin&#39;s position
        &#34;&#34;&#34;
        if isinstance(vector,Vector):
                v1 = vector.copy()
        else:
                v1 = Vector(vector)
        self.origin = v1</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.set_rotation"><code class="name flex">
<span>def <span class="ident">set_rotation</span></span>(<span>self, angle=None, vector=None, quaternion=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets self.rotation to the rotation defined by an angle and an axis or
by a quaternion.</p>
<h2 id="parameters">Parameters</h2>
<p>angle: angle of rotation in degrees
vector: axis of rotation
quaternion: quaternion that defines a rotation
The angle and vector takes precedence over the quaternion</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_rotation(self,angle=None,vector=None,quaternion=None):
        &#34;&#34;&#34;
        Sets self.rotation to the rotation defined by an angle and an axis or
        by a quaternion.
        Parameters:
           angle: angle of rotation in degrees
           vector: axis of rotation
           quaternion: quaternion that defines a rotation
        The angle and vector takes precedence over the quaternion
        &#34;&#34;&#34;
        if angle is not None:
                self.rotation = Rotation(angle,vector)
        elif quaternion is not None:
                self.rotation = Rotation(quaternion=quaternion)
        else:
                self.rotation = Rotation(0,[1,0,0])</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.simple_curve"><code class="name flex">
<span>def <span class="ident">simple_curve</span></span>(<span>self, f=None, tmin=0.0, tmax=1.0, steps=25, name='Simple curve', symmetry=None, draw=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a curve defined by the parametrization f</p>
<h2 id="parameters">Parameters</h2>
<p>f: Parametrization of the curve
tmin: minimum value of the parameter
tmax: maximum value of the parameter
steps: number of steps
name: name of the curve
symmetry: None or a value in the list ('XY','XZ','YZ','X','Y','Z','O'). Symmetry of the curve
draw: if True, the curve is drawn</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simple_curve(self,f=None,tmin=0.0,tmax=1.0,steps=25,name=&#34;Simple curve&#34;,symmetry=None,draw=False):
        &#34;&#34;&#34;
        Return a curve defined by the parametrization f
        Parameters:
           f: Parametrization of the curve
           tmin: minimum value of the parameter
           tmax: maximum value of the parameter
           steps: number of steps
           name: name of the curve
           symmetry: None or a value in the list (&#39;XY&#39;,&#39;XZ&#39;,&#39;YZ&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;,&#39;O&#39;). Symmetry of the curve
           draw: if True, the curve is drawn
        &#34;&#34;&#34;
        if f is None:
                return None

        delta = (tmax - tmin)/steps
        t = tmin
        bm = bmesh.new()
        verts = []
        verts2 = []

        for k in range(steps + 1):
                p = f(t)
                q = None
                verts.append(bm.verts.new(p))
                if symmetry == &#39;XY&#39;:
                        q = (p[0],p[1],-p[2])
                elif symmetry == &#39;XZ&#39;:
                        q = (p[0],-p[1],p[2])
                elif symmetry == &#39;YZ&#39;:
                        q = (-p[0],p[1],p[2])
                elif symmetry == &#39;X&#39;:
                        q = (p[0],-p[1],-p[2])
                elif symmetry == &#39;Y&#39;:
                        q = (-p[0],p[1],-p[2])
                elif symmetry == &#39;Z&#39;:
                        q = (-p[0],-p[1],p[2])
                elif symmetry == &#39;O&#39;:
                        q = (-p[0],-p[1],-p[2])

                if q is not None:
                        verts2.append(bm.verts.new(q))
                t += delta
                if t &gt; tmax:
                        t = tmax

        for i in range(len(verts) - 1):
                bm.edges.new([verts[i], verts[i+1]])
                if len(verts2) &gt; 0:
                        bm.edges.new([verts2[i], verts2[i+1]])

        me = bpy.data.meshes.new(&#39;placeholder_mesh&#39;)
        obj = bpy.data.objects.new(name,me)
        bm.to_mesh(me)
        bm.free()

        if draw:
                self.scene.collection.objects.link(obj)
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.sphere"><code class="name flex">
<span>def <span class="ident">sphere</span></span>(<span>self, o=[0, 0, 0], r2=1, principal=True, canonica=True, color='AzureBlueDark', name='Sphere', cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a sphere of center 'o' and radius squared equal to 'r2'</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the sphere
r2: radius squared
principal: if True, the principal axis are drawn
canonica: if True, the canonical axis are drawn
color: color of the surface
name: name of the sphere
cmax: the canonical axis are drawn between -cmax and cmax
pmax: the principal axis are drawn between -cmax and cmax
thickness: thickness of the sphere
opacity: opacity of the sphere</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sphere(self,o=[0,0,0],r2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Sphere&#34;,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws a sphere of center &#39;o&#39; and radius squared equal to &#39;r2&#39;
        Parameters:
           o: center of the sphere
           r2: radius squared
           principal: if True, the principal axis are drawn
           canonica: if True, the canonical axis are drawn
           color: color of the surface
           name: name of the sphere
           cmax: the canonical axis are drawn between -cmax and cmax
           pmax: the principal axis are drawn between -cmax and cmax
           thickness: thickness of the sphere
           opacity: opacity of the sphere
        &#34;&#34;&#34;
        u1 = Vector([1,0,0])
        u2 = Vector([0,1,0])
        return self.ellipsoid(o=o,u1=u1,u2=u2,a2=r2,b2=r2,c2=r2,principal=principal,canonica=canonica,color=color,name=name,cmax=cmax,pmax=pmax,thickness=thickness,opacity=opacity)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.two_sheets_hyperboloid"><code class="name flex">
<span>def <span class="ident">two_sheets_hyperboloid</span></span>(<span>self, o=[0, 0, 0], u1=[1, 0, 0], u2=[0, 1, 0], a2=1, b2=1, c2=1, principal=True, canonica=True, color='AzureBlueDark', name='TwoSheetParaboloid', xmax=None, cmax=15, pmax=15, thickness=0.02, opacity=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a two sheets hyperboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the hyperboloid
u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x'^2/a^2 + y'^2/b^2 - z'^2/c^2 = -1
principal: if True, the principal axis are drawn
canonica: if True, the canonical axis are drawn
color: color of the surface
name: name of the hyperboloid
xmax: maximum value of the x coordinate
cmax: the canonical axis are drawn between -cmax and cmax
pmax: the principal axis are drawn between -cmax and cmax
thickness: thickness of the hyperboloid
opacity: opacity of the hyperboloid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def two_sheets_hyperboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;TwoSheetParaboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0):
        &#34;&#34;&#34;
        Draws a two sheets hyperboloid
        Parameters:
           o: center of the hyperboloid
           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors
           a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = -1
           principal: if True, the principal axis are drawn
           canonica: if True, the canonical axis are drawn
           color: color of the surface
           name: name of the hyperboloid
           xmax: maximum value of the x coordinate
           cmax: the canonical axis are drawn between -cmax and cmax
           pmax: the principal axis are drawn between -cmax and cmax
           thickness: thickness of the hyperboloid
           opacity: opacity of the hyperboloid
        &#34;&#34;&#34;
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        c = math.sqrt(c2)
        if xmax is None:
                xmax = 5.0/a + 2
        xmax /= a
        self.draw_two_sheets_hyperboloid(a=1.0,b=1.0,xmin=0.0,xmax=xmax,color=color,scale=[a,b,c],name=name,thickness=thickness,opacity=opacity)</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.vectors_to_quaternion"><code class="name flex">
<span>def <span class="ident">vectors_to_quaternion</span></span>(<span>self, u1=Vector((1.0, 0.0, 0.0)), u2=Vector((0.0, 1.0, 0.0)))</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the quaternion correspondint to the base {v1,v2,v3}
u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
v1 = u1
v2 = u2 - u2.project(v1)
v1.normalize()
v2.normalize()
v3 = v1.cross(v2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vectors_to_quaternion(self,u1=Vector([1,0,0]),u2=Vector([0,1,0])):
        &#34;&#34;&#34;
        Returns the quaternion correspondint to the base {v1,v2,v3}
        u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
               v1 = u1
                   v2 = u2 - u2.project(v1)
                   v1.normalize()
                   v2.normalize()
                   v3 = v1.cross(v2)
        &#34;&#34;&#34;
        if isinstance(u1,Vector):
                v1 = u1
        else:
                v1 = Vector(u1)
        if isinstance(u2,Vector):
                v2 = u2
        else:
                v2 = Vector(u2)
        v2 = v2 - v2.project(v1)
        v1.normalize()
        v2.normalize()
        v3 = v1.cross(v2)
        mat = Matrix([v1,v2,v3])
        mat.transpose()
        return mat.to_quaternion()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="LinearAlgebra.Rotation"><code class="flex name class">
<span>class <span class="ident">Rotation</span></span>
<span>(</span><span>angle=None, vector=None, axis=None, quaternion=None, radians=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class used for work with rotations. The stored value in the class is a quaternion</p>
<p>Initializes the value for a rotation</p>
<h2 id="parameters">Parameters</h2>
<p>angle: angle of rotation
vector: axis of rotation
quaternion: The quaternion itself
radians: must be True if the angle is entered in radians and False if the
is entered in degrees.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rotation():
        &#34;&#34;&#34;
    Class used for work with rotations. The stored value in the class is a quaternion
        &#34;&#34;&#34;
        def __init__(self,angle=None,vector=None,axis=None,quaternion=None,radians=False):
                &#34;&#34;&#34;
                Initializes the value for a rotation
                Parameters:
                   angle: angle of rotation
                   vector: axis of rotation
                   quaternion: The quaternion itself
                   radians: must be True if the angle is entered in radians and False if the
                            is entered in degrees.
                &#34;&#34;&#34;
                if vector is not None and axis is not None:
                        return
                if axis is not None:
                        if axis in (&#39;X&#39;,&#39;x&#39;):
                                vector = Vector([1,0,0])
                        elif axis in (&#39;Y&#39;,&#39;y&#39;):
                                vector = Vector([0,1,0])
                        elif axis in (&#39;Z&#39;,&#39;z&#39;):
                                vector = Vector([0,0,1])
                        else:
                                return

                if angle is not None:
                        if not radians:
                                angle = math.radians(angle)
                        if not isinstance(vector,Vector):
                                vector = Vector(vector)
                        self.quaternion = Quaternion(vector,angle)
                elif quaternion is not None:
                        self.quaternion = quaternion
                else:
                        self.quaternion = (1,0,0,0)
        #
        #
        #
        @classmethod
        def from_euler_angles(self,psi,theta,phi,axis=&#39;ZXZ&#39;,radians=False):
                &#34;&#34;&#34;
                Initializes a rotation from its Euler angles in the order ZXZ
                Parameters:
                   phi, theta, psi: Euler angles
                   axis: it must be &#39;XYZ&#39;, &#39;XZY&#39;, &#39;YXZ&#39;, &#39;YZX&#39;, &#39;ZXY&#39;, &#39;ZYX&#39;, &#39;XYX&#39;, &#39;XZX&#39;, &#39;YXY&#39;, &#39;YZY&#39;, &#39;ZXZ&#39; or &#39;ZYZ&#39;
                   radians: if radians, psi, theta and must be in radians
                &#34;&#34;&#34;
                if not radians:
                        phi = math.radians(phi)
                        theta = math.radians(theta)
                        psi = math.radians(psi)

                if axis is None:
                        return None
                if not isinstance(axis,str):
                        return None
                axis = axis.upper()
                if axis not in (&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,&#39;XYX&#39;,&#39;XZX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;):
                        return None

                r1 = Matrix.Rotation(psi,3,axis[0])
                r2 = Matrix.Rotation(theta,3,axis[1])
                r3 = Matrix.Rotation(phi,3,axis[2])
                m = r3 @ r2 @ r1
                q = m.to_quaternion()
                return self(quaternion=q)
        #
        #
        #
        def apply(self,v):
                &#34;&#34;&#34;
        Applies the rotation to an object v
                Parameters:
                   v: any object that can be transformed by a rotation
                &#34;&#34;&#34;
                return self.quaternion @ v
        #
        #
        #
        def to_axis_angle(self,radians=False):
                &#34;&#34;&#34;
                Returns the axis and angle of the rotation
                Parameters:
                   radians: if True, the angle returned is in radians, if not, is
                            returned in degrees
                &#34;&#34;&#34;
                v, alpha = self.quaternion.to_axis_angle()
                if radians:
                        return v, alpha
                return v, 180*alpha/math.pi
        #
        #
        #
        def to_euler_angles(self,axis=&#39;ZXZ&#39;,randomize=False,radians=False):
                &#34;&#34;&#34;
                Returns the Euler angles according to axis &#39;axis&#39;
                Parameters:
                   axis: it must be &#39;XYZ&#39;, &#39;XZY&#39;, &#39;YXZ&#39;, &#39;YZX&#39;, &#39;ZXY&#39;, &#39;ZYX&#39;, &#39;XYX&#39;, &#39;XZX&#39;, &#39;YXY&#39;, &#39;YZY&#39;, &#39;ZXZ&#39; or &#39;ZYZ&#39;
                   radians: if True, the angle returned is in radians, if not, is
                            returned in degrees
                &#34;&#34;&#34;
                def ACOS(x):
                        if x &gt; 1.0:
                                x = 1.0
                        if x &lt; -1.0:
                                x = -1.0
                        return math.acos(x)

                def ASIN(x):
                        if x &gt; 1.0:
                                x = 1.0
                        if x &lt; -1.0:
                                x = -1.0
                        return math.asin(x)

                axis = axis.upper()
                if axis not in (&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,&#39;XYX&#39;,&#39;XZX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;):
                        return None
                rndm = 0
                A = self.quaternion.to_matrix()
                if axis == &#39;ZXZ&#39;:
                        theta = ACOS(A[2][2])
                        if abs(A[2][2]) != 1:
                                psi = math.atan2(A[2][0],A[2][1])
                                phi = math.atan2(A[0][2],-A[1][2])
                        else:
                                rndm = A[2][2]
                                phi = 0
                                psi = math.atan2(A[1][0],A[0][0])
                if axis == &#39;XZX&#39;:
                        theta = ACOS(A[0][0])
                        if abs(A[0][0]) != 1:
                                psi = math.atan2(A[0][2],-A[0][1])
                                phi = math.atan2(A[2][0],A[1][0])
                        else:
                                rndm = A[0][0]
                                phi = 0
                                psi = math.atan2(-A[1][2],A[2][2])
                if axis == &#39;ZYZ&#39;:
                        theta = ACOS(A[2][2])
                        if abs(A[2][2]) != 1:
                                psi = math.atan2(A[2][1],-A[2][0])
                                phi = math.atan2(A[1][2],A[0][2])
                        else:
                                rndm = A[2][2]
                                phi = 0
                                psi = math.atan2(-A[0][1],A[1][1])
                if axis == &#39;YZY&#39;:
                        theta = ACOS(A[1][1])
                        if abs(A[1][1]) != 1:
                                psi = math.atan2(A[1][2],A[1][0])
                                phi = math.atan2(A[2][1],-A[0][1])
                        else:
                                rndm = A[1][1]
                                phi = 0
                                psi = math.atan2(A[0][2],A[2][2])
                if axis == &#39;XYX&#39;:
                        theta = ACOS(A[0][0])
                        if abs(A[0][0]) != 1:
                                psi = math.atan2(A[0][1],A[0][2])
                                phi = math.atan2(A[1][0],-A[2][0])
                        else:
                                rndm = A[0][0]
                                phi = 0
                                psi = math.atan2(A[2][1],A[1][1])
                if axis == &#39;YXY&#39;:
                        theta = ACOS(A[1][1])
                        if abs(A[1][1]) != 1:
                                psi = math.atan2(A[1][0],-A[1][2])
                                phi = math.atan2(A[0][1],A[2][1])
                        else:
                                rndm = A[1][1]
                                phi = 0
                                psi = math.atan2(-A[2][0],A[0][0])
                if axis == &#39;XYZ&#39;:
                        theta = ASIN(-A[2][0])
                        if abs(A[2][0]) != 1:
                                psi = math.atan2(A[2][1],A[2][2])
                                phi = math.atan2(A[1][0],A[0][0])
                        else:
                                rndm = A[2][0]
                                phi = 0
                                psi = math.atan2(-A[0][1],A[1][1])
                if axis == &#39;XZY&#39;:
                        theta = ASIN(A[1][0])
                        if abs(A[1][0]) != 1:
                                psi = math.atan2(-A[1][2],A[1][1])
                                phi = math.atan2(-A[2][0],A[0][0])
                        else:
                                rndm = A[1][0]
                                phi = 0
                                psi = math.atan2(A[0][2],A[2][2])
                if axis == &#39;YXZ&#39;:
                        theta = ASIN(A[2][1])
                        if abs(A[2][1]) != 1:
                                psi = math.atan2(-A[2][0],A[2][2])
                                phi = math.atan2(-A[0][1],A[1][1])
                        else:
                                rndm = A[2][1]
                                phi = 0
                                psi = math.atan2(A[1][0],A[0][0])
                if axis == &#39;YZX&#39;:
                        theta = ASIN(-A[0][1])
                        if abs(A[0][1]) != 1:
                                psi = math.atan2(A[0][2],A[0][0])
                                phi = math.atan2(A[2][1],A[1][1])
                        else:
                                rndm = A[0][1]
                                phi = 0
                                psi = math.atan2(-A[1][2],A[2][2])
                if axis == &#39;ZXY&#39;:
                        theta = ASIN(-A[1][2])
                        if abs(A[1][2]) != 1:
                                psi = math.atan2(A[1][0],A[1][1])
                                phi = math.atan2(A[0][2],A[2][2])
                        else:
                                rndm = A[1][2]
                                phi = 0
                                psi = math.atan2(-A[0][2],A[0][0])
                if axis == &#39;ZYX&#39;:
                        theta = ASIN(A[0][2])
                        if abs(A[0][2]) != 1:
                                psi = math.atan2(-A[0][1],A[0][0])
                                phi = math.atan2(-A[1][2],A[2][2])
                        else:
                                rndm = A[0][2]
                                phi = 0
                                psi = math.atan2(A[2][1],A[1][1])

                if psi &lt; 0:
                        psi += 2*math.pi
                if theta &lt; 0:
                        theta += 2*math.pi
                if phi &lt; 0:
                        phi += 2*math.pi

                if rndm != 0 and randomize:
                        phi = random.uniform(0.0,psi)
                        psi = rndm * (psi - phi)
                        if psi &lt; 0:
                                psi += 2*math.pi

                if not radians:
                        psi, theta, phi = 180.0/math.pi * psi, 180.0/math.pi * theta, 180.0/math.pi * phi
                        T = 359.9
                else:
                        T = 359.9 * math.pi / 180.0
                if psi &gt; T:
                        psi = 0.0
                if theta &gt; T:
                        theta = 0.0
                if phi &gt; T:
                        phi = 0.0
                return psi, theta, phi</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="LinearAlgebra.Rotation.from_euler_angles"><code class="name flex">
<span>def <span class="ident">from_euler_angles</span></span>(<span>psi, theta, phi, axis='ZXZ', radians=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a rotation from its Euler angles in the order ZXZ</p>
<h2 id="parameters">Parameters</h2>
<p>phi, theta, psi: Euler angles
axis: it must be 'XYZ', 'XZY', 'YXZ', 'YZX', 'ZXY', 'ZYX', 'XYX', 'XZX', 'YXY', 'YZY', 'ZXZ' or 'ZYZ'
radians: if radians, psi, theta and must be in radians</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_euler_angles(self,psi,theta,phi,axis=&#39;ZXZ&#39;,radians=False):
        &#34;&#34;&#34;
        Initializes a rotation from its Euler angles in the order ZXZ
        Parameters:
           phi, theta, psi: Euler angles
           axis: it must be &#39;XYZ&#39;, &#39;XZY&#39;, &#39;YXZ&#39;, &#39;YZX&#39;, &#39;ZXY&#39;, &#39;ZYX&#39;, &#39;XYX&#39;, &#39;XZX&#39;, &#39;YXY&#39;, &#39;YZY&#39;, &#39;ZXZ&#39; or &#39;ZYZ&#39;
           radians: if radians, psi, theta and must be in radians
        &#34;&#34;&#34;
        if not radians:
                phi = math.radians(phi)
                theta = math.radians(theta)
                psi = math.radians(psi)

        if axis is None:
                return None
        if not isinstance(axis,str):
                return None
        axis = axis.upper()
        if axis not in (&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,&#39;XYX&#39;,&#39;XZX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;):
                return None

        r1 = Matrix.Rotation(psi,3,axis[0])
        r2 = Matrix.Rotation(theta,3,axis[1])
        r3 = Matrix.Rotation(phi,3,axis[2])
        m = r3 @ r2 @ r1
        q = m.to_quaternion()
        return self(quaternion=q)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="LinearAlgebra.Rotation.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, v)</span>
</code></dt>
<dd>
<div class="desc"><p>Applies the rotation to an object v
Parameters:
v: any object that can be transformed by a rotation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self,v):
        &#34;&#34;&#34;
Applies the rotation to an object v
        Parameters:
           v: any object that can be transformed by a rotation
        &#34;&#34;&#34;
        return self.quaternion @ v</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.Rotation.to_axis_angle"><code class="name flex">
<span>def <span class="ident">to_axis_angle</span></span>(<span>self, radians=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the axis and angle of the rotation</p>
<h2 id="parameters">Parameters</h2>
<p>radians: if True, the angle returned is in radians, if not, is
returned in degrees</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_axis_angle(self,radians=False):
        &#34;&#34;&#34;
        Returns the axis and angle of the rotation
        Parameters:
           radians: if True, the angle returned is in radians, if not, is
                    returned in degrees
        &#34;&#34;&#34;
        v, alpha = self.quaternion.to_axis_angle()
        if radians:
                return v, alpha
        return v, 180*alpha/math.pi</code></pre>
</details>
</dd>
<dt id="LinearAlgebra.Rotation.to_euler_angles"><code class="name flex">
<span>def <span class="ident">to_euler_angles</span></span>(<span>self, axis='ZXZ', randomize=False, radians=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the Euler angles according to axis 'axis'</p>
<h2 id="parameters">Parameters</h2>
<p>axis: it must be 'XYZ', 'XZY', 'YXZ', 'YZX', 'ZXY', 'ZYX', 'XYX', 'XZX', 'YXY', 'YZY', 'ZXZ' or 'ZYZ'
radians: if True, the angle returned is in radians, if not, is
returned in degrees</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_euler_angles(self,axis=&#39;ZXZ&#39;,randomize=False,radians=False):
        &#34;&#34;&#34;
        Returns the Euler angles according to axis &#39;axis&#39;
        Parameters:
           axis: it must be &#39;XYZ&#39;, &#39;XZY&#39;, &#39;YXZ&#39;, &#39;YZX&#39;, &#39;ZXY&#39;, &#39;ZYX&#39;, &#39;XYX&#39;, &#39;XZX&#39;, &#39;YXY&#39;, &#39;YZY&#39;, &#39;ZXZ&#39; or &#39;ZYZ&#39;
           radians: if True, the angle returned is in radians, if not, is
                    returned in degrees
        &#34;&#34;&#34;
        def ACOS(x):
                if x &gt; 1.0:
                        x = 1.0
                if x &lt; -1.0:
                        x = -1.0
                return math.acos(x)

        def ASIN(x):
                if x &gt; 1.0:
                        x = 1.0
                if x &lt; -1.0:
                        x = -1.0
                return math.asin(x)

        axis = axis.upper()
        if axis not in (&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,&#39;XYX&#39;,&#39;XZX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;):
                return None
        rndm = 0
        A = self.quaternion.to_matrix()
        if axis == &#39;ZXZ&#39;:
                theta = ACOS(A[2][2])
                if abs(A[2][2]) != 1:
                        psi = math.atan2(A[2][0],A[2][1])
                        phi = math.atan2(A[0][2],-A[1][2])
                else:
                        rndm = A[2][2]
                        phi = 0
                        psi = math.atan2(A[1][0],A[0][0])
        if axis == &#39;XZX&#39;:
                theta = ACOS(A[0][0])
                if abs(A[0][0]) != 1:
                        psi = math.atan2(A[0][2],-A[0][1])
                        phi = math.atan2(A[2][0],A[1][0])
                else:
                        rndm = A[0][0]
                        phi = 0
                        psi = math.atan2(-A[1][2],A[2][2])
        if axis == &#39;ZYZ&#39;:
                theta = ACOS(A[2][2])
                if abs(A[2][2]) != 1:
                        psi = math.atan2(A[2][1],-A[2][0])
                        phi = math.atan2(A[1][2],A[0][2])
                else:
                        rndm = A[2][2]
                        phi = 0
                        psi = math.atan2(-A[0][1],A[1][1])
        if axis == &#39;YZY&#39;:
                theta = ACOS(A[1][1])
                if abs(A[1][1]) != 1:
                        psi = math.atan2(A[1][2],A[1][0])
                        phi = math.atan2(A[2][1],-A[0][1])
                else:
                        rndm = A[1][1]
                        phi = 0
                        psi = math.atan2(A[0][2],A[2][2])
        if axis == &#39;XYX&#39;:
                theta = ACOS(A[0][0])
                if abs(A[0][0]) != 1:
                        psi = math.atan2(A[0][1],A[0][2])
                        phi = math.atan2(A[1][0],-A[2][0])
                else:
                        rndm = A[0][0]
                        phi = 0
                        psi = math.atan2(A[2][1],A[1][1])
        if axis == &#39;YXY&#39;:
                theta = ACOS(A[1][1])
                if abs(A[1][1]) != 1:
                        psi = math.atan2(A[1][0],-A[1][2])
                        phi = math.atan2(A[0][1],A[2][1])
                else:
                        rndm = A[1][1]
                        phi = 0
                        psi = math.atan2(-A[2][0],A[0][0])
        if axis == &#39;XYZ&#39;:
                theta = ASIN(-A[2][0])
                if abs(A[2][0]) != 1:
                        psi = math.atan2(A[2][1],A[2][2])
                        phi = math.atan2(A[1][0],A[0][0])
                else:
                        rndm = A[2][0]
                        phi = 0
                        psi = math.atan2(-A[0][1],A[1][1])
        if axis == &#39;XZY&#39;:
                theta = ASIN(A[1][0])
                if abs(A[1][0]) != 1:
                        psi = math.atan2(-A[1][2],A[1][1])
                        phi = math.atan2(-A[2][0],A[0][0])
                else:
                        rndm = A[1][0]
                        phi = 0
                        psi = math.atan2(A[0][2],A[2][2])
        if axis == &#39;YXZ&#39;:
                theta = ASIN(A[2][1])
                if abs(A[2][1]) != 1:
                        psi = math.atan2(-A[2][0],A[2][2])
                        phi = math.atan2(-A[0][1],A[1][1])
                else:
                        rndm = A[2][1]
                        phi = 0
                        psi = math.atan2(A[1][0],A[0][0])
        if axis == &#39;YZX&#39;:
                theta = ASIN(-A[0][1])
                if abs(A[0][1]) != 1:
                        psi = math.atan2(A[0][2],A[0][0])
                        phi = math.atan2(A[2][1],A[1][1])
                else:
                        rndm = A[0][1]
                        phi = 0
                        psi = math.atan2(-A[1][2],A[2][2])
        if axis == &#39;ZXY&#39;:
                theta = ASIN(-A[1][2])
                if abs(A[1][2]) != 1:
                        psi = math.atan2(A[1][0],A[1][1])
                        phi = math.atan2(A[0][2],A[2][2])
                else:
                        rndm = A[1][2]
                        phi = 0
                        psi = math.atan2(-A[0][2],A[0][0])
        if axis == &#39;ZYX&#39;:
                theta = ASIN(A[0][2])
                if abs(A[0][2]) != 1:
                        psi = math.atan2(-A[0][1],A[0][0])
                        phi = math.atan2(-A[1][2],A[2][2])
                else:
                        rndm = A[0][2]
                        phi = 0
                        psi = math.atan2(A[2][1],A[1][1])

        if psi &lt; 0:
                psi += 2*math.pi
        if theta &lt; 0:
                theta += 2*math.pi
        if phi &lt; 0:
                phi += 2*math.pi

        if rndm != 0 and randomize:
                phi = random.uniform(0.0,psi)
                psi = rndm * (psi - phi)
                if psi &lt; 0:
                        psi += 2*math.pi

        if not radians:
                psi, theta, phi = 180.0/math.pi * psi, 180.0/math.pi * theta, 180.0/math.pi * phi
                T = 359.9
        else:
                T = 359.9 * math.pi / 180.0
        if psi &gt; T:
                psi = 0.0
        if theta &gt; T:
                theta = 0.0
        if phi &gt; T:
                phi = 0.0
        return psi, theta, phi</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="LinearAlgebra.createFaces" href="#LinearAlgebra.createFaces">createFaces</a></code></li>
<li><code><a title="LinearAlgebra.create_mesh_object" href="#LinearAlgebra.create_mesh_object">create_mesh_object</a></code></li>
<li><code><a title="LinearAlgebra.draw_parametric_surface" href="#LinearAlgebra.draw_parametric_surface">draw_parametric_surface</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="LinearAlgebra.Color" href="#LinearAlgebra.Color">Color</a></code></h4>
</li>
<li>
<h4><code><a title="LinearAlgebra.Colors" href="#LinearAlgebra.Colors">Colors</a></code></h4>
<ul class="">
<li><code><a title="LinearAlgebra.Colors.color" href="#LinearAlgebra.Colors.color">color</a></code></li>
<li><code><a title="LinearAlgebra.Colors.colors" href="#LinearAlgebra.Colors.colors">colors</a></code></li>
<li><code><a title="LinearAlgebra.Colors.colorsbyname" href="#LinearAlgebra.Colors.colorsbyname">colorsbyname</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="LinearAlgebra.LinearAlgebra" href="#LinearAlgebra.LinearAlgebra">LinearAlgebra</a></code></h4>
<ul class="">
<li><code><a title="LinearAlgebra.LinearAlgebra.add_ligth" href="#LinearAlgebra.LinearAlgebra.add_ligth">add_ligth</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.add_ligths" href="#LinearAlgebra.LinearAlgebra.add_ligths">add_ligths</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.add_material" href="#LinearAlgebra.LinearAlgebra.add_material">add_material</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.animate_revolution_surface" href="#LinearAlgebra.LinearAlgebra.animate_revolution_surface">animate_revolution_surface</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.base_cilinder" href="#LinearAlgebra.LinearAlgebra.base_cilinder">base_cilinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.base_cone" href="#LinearAlgebra.LinearAlgebra.base_cone">base_cone</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.base_is_canonica" href="#LinearAlgebra.LinearAlgebra.base_is_canonica">base_is_canonica</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.comp_times_vector" href="#LinearAlgebra.LinearAlgebra.comp_times_vector">comp_times_vector</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.cone" href="#LinearAlgebra.LinearAlgebra.cone">cone</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.curve" href="#LinearAlgebra.LinearAlgebra.curve">curve</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.delete_base_cilinder" href="#LinearAlgebra.LinearAlgebra.delete_base_cilinder">delete_base_cilinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.delete_base_cone" href="#LinearAlgebra.LinearAlgebra.delete_base_cone">delete_base_cone</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_base_axis" href="#LinearAlgebra.LinearAlgebra.draw_base_axis">draw_base_axis</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_circle" href="#LinearAlgebra.LinearAlgebra.draw_circle">draw_circle</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_components" href="#LinearAlgebra.LinearAlgebra.draw_components">draw_components</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_cone" href="#LinearAlgebra.LinearAlgebra.draw_cone">draw_cone</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_cube" href="#LinearAlgebra.LinearAlgebra.draw_cube">draw_cube</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_curve" href="#LinearAlgebra.LinearAlgebra.draw_curve">draw_curve</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_ellipse" href="#LinearAlgebra.LinearAlgebra.draw_ellipse">draw_ellipse</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_ellipsoid" href="#LinearAlgebra.LinearAlgebra.draw_ellipsoid">draw_ellipsoid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_elliptic_cylinder" href="#LinearAlgebra.LinearAlgebra.draw_elliptic_cylinder">draw_elliptic_cylinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_elliptic_paraboloid" href="#LinearAlgebra.LinearAlgebra.draw_elliptic_paraboloid">draw_elliptic_paraboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_frenet_curve" href="#LinearAlgebra.LinearAlgebra.draw_frenet_curve">draw_frenet_curve</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_function" href="#LinearAlgebra.LinearAlgebra.draw_function">draw_function</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_hyperbole" href="#LinearAlgebra.LinearAlgebra.draw_hyperbole">draw_hyperbole</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_hyperbolic_cylinder" href="#LinearAlgebra.LinearAlgebra.draw_hyperbolic_cylinder">draw_hyperbolic_cylinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_hyperbolic_paraboloid" href="#LinearAlgebra.LinearAlgebra.draw_hyperbolic_paraboloid">draw_hyperbolic_paraboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_line" href="#LinearAlgebra.LinearAlgebra.draw_line">draw_line</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_mesh" href="#LinearAlgebra.LinearAlgebra.draw_mesh">draw_mesh</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_one_sheet_hyperboloid" href="#LinearAlgebra.LinearAlgebra.draw_one_sheet_hyperboloid">draw_one_sheet_hyperboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_parabola" href="#LinearAlgebra.LinearAlgebra.draw_parabola">draw_parabola</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_parabolic_cylinder" href="#LinearAlgebra.LinearAlgebra.draw_parabolic_cylinder">draw_parabolic_cylinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_parallelepiped" href="#LinearAlgebra.LinearAlgebra.draw_parallelepiped">draw_parallelepiped</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_parallelogram" href="#LinearAlgebra.LinearAlgebra.draw_parallelogram">draw_parallelogram</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_plane" href="#LinearAlgebra.LinearAlgebra.draw_plane">draw_plane</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_plane_surface" href="#LinearAlgebra.LinearAlgebra.draw_plane_surface">draw_plane_surface</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_point" href="#LinearAlgebra.LinearAlgebra.draw_point">draw_point</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_points" href="#LinearAlgebra.LinearAlgebra.draw_points">draw_points</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_polygon" href="#LinearAlgebra.LinearAlgebra.draw_polygon">draw_polygon</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_pyramid" href="#LinearAlgebra.LinearAlgebra.draw_pyramid">draw_pyramid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_regular_polygon" href="#LinearAlgebra.LinearAlgebra.draw_regular_polygon">draw_regular_polygon</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_simple_curve" href="#LinearAlgebra.LinearAlgebra.draw_simple_curve">draw_simple_curve</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_surface" href="#LinearAlgebra.LinearAlgebra.draw_surface">draw_surface</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_tetrahedron" href="#LinearAlgebra.LinearAlgebra.draw_tetrahedron">draw_tetrahedron</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_triangle" href="#LinearAlgebra.LinearAlgebra.draw_triangle">draw_triangle</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_two_sheets_hyperboloid" href="#LinearAlgebra.LinearAlgebra.draw_two_sheets_hyperboloid">draw_two_sheets_hyperboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_vector" href="#LinearAlgebra.LinearAlgebra.draw_vector">draw_vector</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_vector_field" href="#LinearAlgebra.LinearAlgebra.draw_vector_field">draw_vector_field</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_vectors" href="#LinearAlgebra.LinearAlgebra.draw_vectors">draw_vectors</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.ellipsoid" href="#LinearAlgebra.LinearAlgebra.ellipsoid">ellipsoid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.elliptic_cylinder" href="#LinearAlgebra.LinearAlgebra.elliptic_cylinder">elliptic_cylinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.elliptic_paraboloid" href="#LinearAlgebra.LinearAlgebra.elliptic_paraboloid">elliptic_paraboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.hyperbolic_cylinder" href="#LinearAlgebra.LinearAlgebra.hyperbolic_cylinder">hyperbolic_cylinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.hyperbolic_paraboloid" href="#LinearAlgebra.LinearAlgebra.hyperbolic_paraboloid">hyperbolic_paraboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.join" href="#LinearAlgebra.LinearAlgebra.join">join</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.new_components" href="#LinearAlgebra.LinearAlgebra.new_components">new_components</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.new_coordinates" href="#LinearAlgebra.LinearAlgebra.new_coordinates">new_coordinates</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.one_sheet_hyperboloid" href="#LinearAlgebra.LinearAlgebra.one_sheet_hyperboloid">one_sheet_hyperboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.parabolic_cylinder" href="#LinearAlgebra.LinearAlgebra.parabolic_cylinder">parabolic_cylinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.reset" href="#LinearAlgebra.LinearAlgebra.reset">reset</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.reset_base" href="#LinearAlgebra.LinearAlgebra.reset_base">reset_base</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.reset_colors" href="#LinearAlgebra.LinearAlgebra.reset_colors">reset_colors</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.reset_frames" href="#LinearAlgebra.LinearAlgebra.reset_frames">reset_frames</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.reset_origin" href="#LinearAlgebra.LinearAlgebra.reset_origin">reset_origin</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.reset_rotation" href="#LinearAlgebra.LinearAlgebra.reset_rotation">reset_rotation</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.revolution_surface" href="#LinearAlgebra.LinearAlgebra.revolution_surface">revolution_surface</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rotate_euler" href="#LinearAlgebra.LinearAlgebra.rotate_euler">rotate_euler</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rotate_object" href="#LinearAlgebra.LinearAlgebra.rotate_object">rotate_object</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rotate_object_by_axis_angle" href="#LinearAlgebra.LinearAlgebra.rotate_object_by_axis_angle">rotate_object_by_axis_angle</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rotate_vector" href="#LinearAlgebra.LinearAlgebra.rotate_vector">rotate_vector</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.set_base" href="#LinearAlgebra.LinearAlgebra.set_base">set_base</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.set_colors" href="#LinearAlgebra.LinearAlgebra.set_colors">set_colors</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.set_cursor" href="#LinearAlgebra.LinearAlgebra.set_cursor">set_cursor</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.set_cursor_rotation" href="#LinearAlgebra.LinearAlgebra.set_cursor_rotation">set_cursor_rotation</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.set_default_color" href="#LinearAlgebra.LinearAlgebra.set_default_color">set_default_color</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.set_origin" href="#LinearAlgebra.LinearAlgebra.set_origin">set_origin</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.set_rotation" href="#LinearAlgebra.LinearAlgebra.set_rotation">set_rotation</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.simple_curve" href="#LinearAlgebra.LinearAlgebra.simple_curve">simple_curve</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.sphere" href="#LinearAlgebra.LinearAlgebra.sphere">sphere</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.two_sheets_hyperboloid" href="#LinearAlgebra.LinearAlgebra.two_sheets_hyperboloid">two_sheets_hyperboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.vectors_to_quaternion" href="#LinearAlgebra.LinearAlgebra.vectors_to_quaternion">vectors_to_quaternion</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="LinearAlgebra.Rotation" href="#LinearAlgebra.Rotation">Rotation</a></code></h4>
<ul class="">
<li><code><a title="LinearAlgebra.Rotation.apply" href="#LinearAlgebra.Rotation.apply">apply</a></code></li>
<li><code><a title="LinearAlgebra.Rotation.from_euler_angles" href="#LinearAlgebra.Rotation.from_euler_angles">from_euler_angles</a></code></li>
<li><code><a title="LinearAlgebra.Rotation.to_axis_angle" href="#LinearAlgebra.Rotation.to_axis_angle">to_axis_angle</a></code></li>
<li><code><a title="LinearAlgebra.Rotation.to_euler_angles" href="#LinearAlgebra.Rotation.to_euler_angles">to_euler_angles</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>