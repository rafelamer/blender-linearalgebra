<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>LinearAlgebra API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>LinearAlgebra</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="LinearAlgebra.add_object_align_init"><code class="name flex">
<span>def <span class="ident">add_object_align_init</span></span>(<span>context, operator)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_object_align_init(context, operator):
    properties = operator.properties if operator is not None else None

    space_data = context.space_data
    if space_data and space_data.type != &#39;VIEW_3D&#39;:
        space_data = None

    # location
    if operator and properties.is_property_set(&#34;location&#34;):
        location = Matrix.Translation(Vector(properties.location))
    else:
        location = Matrix.Translation(context.scene.cursor.location)

        if operator:
            properties.location = location.to_translation()

    # rotation
    add_align_preference = context.preferences.edit.object_align
    if operator:
        if not properties.is_property_set(&#34;rotation&#34;):
            # So one of &#34;align&#34; and &#34;rotation&#34; will be set
            properties.align = add_align_preference

        if properties.align == &#39;WORLD&#39;:
            rotation = properties.rotation.to_matrix().to_4x4()
        elif properties.align == &#39;VIEW&#39;:
            rotation = space_data.region_3d.view_matrix.to_3x3().inverted()
            rotation.resize_4x4()
            properties.rotation = rotation.to_euler()
        elif properties.align == &#39;CURSOR&#39;:
            rotation = context.scene.cursor.matrix
            rotation.col[3][0:3] = 0.0, 0.0, 0.0
            properties.rotation = rotation.to_euler()
        else:
            rotation = properties.rotation.to_matrix().to_4x4()
    else:
        if (add_align_preference == &#39;VIEW&#39;) and space_data:
            rotation = space_data.region_3d.view_matrix.to_3x3().inverted()
            rotation.resize_4x4()
        elif add_align_preference == &#39;CURSOR&#39;:
            rotation = context.scene.cursor.rotation_euler.to_matrix().to_4x4()
        else:
            rotation = Matrix()

    return location @ rotation</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="LinearAlgebra.createFaces"><code class="name flex">
<span>def <span class="ident">createFaces</span></span>(<span>vertIdx1, vertIdx2, closed=False, flipped=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createFaces(vertIdx1,vertIdx2,closed=False,flipped=False):
        faces = []
        if not vertIdx1 or not vertIdx2:
                return None
        if len(vertIdx1) &lt; 2 and len(vertIdx2) &lt; 2:
                return None

        fan = False
        if (len(vertIdx1) != len(vertIdx2)):
                if (len(vertIdx1) == 1 and len(vertIdx2) &gt; 1):
                        fan = True
                else:
                        return None

        total = len(vertIdx2)
        if closed:
                if flipped:
                        face = [vertIdx1[0],vertIdx2[0],vertIdx2[total - 1]]
                        if not fan:
                                face.append(vertIdx1[total - 1])
                        faces.append(face)
                else:
                        face = [vertIdx2[0], vertIdx1[0]]
                        if not fan:
                                face.append(vertIdx1[total - 1])
                        face.append(vertIdx2[total - 1])
                        faces.append(face)
        for num in range(total - 1):
                if flipped:
                        if fan:
                                face = [vertIdx2[num], vertIdx1[0], vertIdx2[num + 1]]
                        else:
                                face = [vertIdx2[num], vertIdx1[num],vertIdx1[num + 1], vertIdx2[num + 1]]
                        faces.append(face)
                else:
                        if fan:
                                face = [vertIdx1[0], vertIdx2[num], vertIdx2[num + 1]]
                        else:
                                face = [vertIdx1[num], vertIdx2[num],vertIdx2[num + 1], vertIdx1[num + 1]]
                        faces.append(face)
        return faces</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="LinearAlgebra.create_mesh_object"><code class="name flex">
<span>def <span class="ident">create_mesh_object</span></span>(<span>context, verts, edges, faces, name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_mesh_object(context,verts,edges,faces,name):
        mesh = bpy.data.meshes.new(name)
        mesh.from_pydata(verts, edges, faces)
        mesh.update()
        return object_data_add(context, mesh, operator=None)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="LinearAlgebra.draw_parametric_surface"><code class="name flex">
<span>def <span class="ident">draw_parametric_surface</span></span>(<span>eq,<br>range_u_min,<br>range_u_max,<br>range_u_step,<br>range_v_min,<br>range_v_max,<br>range_v_step,<br>name,<br>wrap_u=False,<br>wrap_v=False,<br>close_v=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_parametric_surface(eq,range_u_min,range_u_max,range_u_step,range_v_min,range_v_max,range_v_step,name,wrap_u=False,wrap_v=False,close_v=False):
        verts = []
        faces = []
        if not callable(range_u_min) and not callable(range_u_max):
                uStep = (range_u_max - range_u_min) / range_u_step
        vStep = (range_v_max - range_v_min) / range_v_step
        uRange = range_u_step + 1
        vRange = range_v_step + 1

        if wrap_u:
                uRange = uRange - 1
        if wrap_v:
                vRange = vRange - 1

        for vN in range(vRange):
                v = range_v_min + (vN * vStep)
                if callable(range_u_min):
                        u_min = range_u_min(v)
                else:
                        u_min = range_u_min
                if callable(range_u_max):
                        u_max = range_u_max(v)
                else:
                        u_max = range_u_max
                uStep = (u_max - u_min) / range_u_step
                for uN in range(uRange):
                        u = u_min + (uN * uStep)
                        verts.append(eq(u,v))

        for vN in range(range_v_step):
                vNext = vN + 1
                if vNext &gt;= vRange:
                        vNext = 0
                for uN in range(range_u_step):
                        uNext = uN + 1
                        if uNext &gt;= uRange:
                                uNext = 0
                        faces.append([(vNext * uRange) + uNext,(vNext * uRange) + uN,(vN * uRange) + uN,(vN * uRange) + uNext])

        if close_v and wrap_u and (not wrap_v):
                for uN in range(1, range_u_step - 1):
                        faces.append([range_u_step - 1,range_u_step - 1 - uN,range_u_step - 2 - uN])
                        faces.append([range_v_step * uRange,range_v_step * uRange + uN,range_v_step * uRange + uN + 1])
        create_mesh_object(bpy.context,verts, [], faces, name)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="LinearAlgebra.object_data_add"><code class="name flex">
<span>def <span class="ident">object_data_add</span></span>(<span>context, obdata, operator=None, name=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_data_add(context, obdata, operator=None, name=None):
    layer = context.view_layer
    layer_collection = context.layer_collection or layer.active_layer_collection
    scene_collection = layer_collection.collection

    for ob in layer.objects:
        if ob is not None:
            ob.select_set(False)

    if name is None:
        name = &#34;Object&#34; if obdata is None else obdata.name

    obj_act = layer.objects.active
    obj_new = bpy.data.objects.new(name, obdata)
    scene_collection.objects.link(obj_new)
    obj_new.select_set(True)
    obj_new.matrix_world = add_object_align_init(context, operator)

    space_data = context.space_data
    if space_data and space_data.type != &#39;VIEW_3D&#39;:
        space_data = None

    if space_data:
        if space_data.local_view:
            obj_new.local_view_set(space_data, True)

    if obj_act and obj_act.mode == &#39;EDIT&#39; and obj_act.type == obj_new.type:
        bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
        obj_act.select_set(True)
        bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)

        obj_act.select_set(True)
        layer.update()  # apply location
        # layer.objects.active = obj_new

        # Match up UV layers, this is needed so adding an object with UVs
        # doesn&#39;t create new layers when there happens to be a naming mismatch.
        uv_new = obdata.uv_layers.active
        if uv_new is not None:
            uv_act = obj_act.data.uv_layers.active
            if uv_act is not None:
                uv_new.name = uv_act.name

        bpy.ops.object.join()  # join into the active.
        if obdata:
            bpy.data.meshes.remove(obdata)

        bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
    else:
        layer.objects.active = obj_new
        if context.preferences.edit.use_enter_edit_mode:
            if obdata and obdata.library is None:
                obtype = obj_new.type
                mode = None
                if obtype in {&#39;ARMATURE&#39;, &#39;CURVE&#39;, &#39;CURVES&#39;, &#39;FONT&#39;, &#39;LATTICE&#39;, &#39;MESH&#39;, &#39;META&#39;, &#39;SURFACE&#39;}:
                    mode = &#39;EDIT&#39;
                elif obtype == &#39;GPENCIL&#39;:
                    mode = &#39;EDIT_GPENCIL&#39;

                if mode is not None:
                    bpy.ops.object.mode_set(mode=mode)
    return obj_new</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="LinearAlgebra.Color"><code class="flex name class">
<span>class <span class="ident">Color</span></span>
<span>(</span><span>r, g, b, name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Color():
        &#34;&#34;&#34;
    Class that defines a color in RGB format
    &#34;&#34;&#34;
        def __init__(self,r,g,b,name):
                self.r = r
                self.g = g
                self.b = b
                self.name = name</code></pre>
</details>
<div class="desc"><p>Class that defines a color in RGB format</p></div>
</dd>
<dt id="LinearAlgebra.Colors"><code class="flex name class">
<span>class <span class="ident">Colors</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Colors():
        &#34;&#34;&#34;
        Class that defines a list of colors by name
        &#34;&#34;&#34;
        colorsbyname = {
                &#39;Black&#39; : Color(0,0,0,&#39;Black&#39;),
                &#39;GrayObscure&#39; : Color(0.2,0.2,0.2,&#39;GrayObscure&#39;),
                &#39;GrayDark&#39; : Color(0.4,0.4,0.4,&#39;GrayDark&#39;),
                &#39;GrayLight&#39; : Color(0.6,0.6,0.6,&#39;GrayLight&#39;),
                &#39;GrayPale&#39; : Color(0.8,0.8,0.8,&#39;GrayPale&#39;),
                &#39;White&#39; : Color(1,1,1,&#39;White&#39;),
                &#39;Red&#39; : Color(1,0,0,&#39;Red&#39;),
                &#39;RedDarkHard&#39; : Color(0.8,0,0,&#39;RedDarkHard&#39;),
                &#39;RedLightHard&#39; : Color(1,0.2,0.2,&#39;RedLightHard&#39;),
                &#39;RedDarkFaded&#39; : Color(0.6,0,0,&#39;RedDarkFaded&#39;),
                &#39;RedMediumFaded&#39; : Color(0.8,0.2,0.2,&#39;RedMediumFaded&#39;),
                &#39;RedLightFaded&#39; : Color(1,0.4,0.4,&#39;RedLightFaded&#39;),
                &#39;RedObscureDull&#39; : Color(0.4,0,0,&#39;RedObscureDull&#39;),
                &#39;RedDarkDull&#39; : Color(0.6,0.2,0.2,&#39;RedDarkDull&#39;),
                &#39;RedLightDull&#39; : Color(0.8,0.4,0.4,&#39;RedLightDull&#39;),
                &#39;RedPaleDull&#39; : Color(1,0.6,0.6,&#39;RedPaleDull&#39;),
                &#39;RedObscureWeak&#39; : Color(0.2,0,0,&#39;RedObscureWeak&#39;),
                &#39;RedDarkWeak&#39; : Color(0.4,0.2,0.2,&#39;RedDarkWeak&#39;),
                &#39;RedMediumWeak&#39; : Color(0.6,0.4,0.4,&#39;RedMediumWeak&#39;),
                &#39;RedLightWeak&#39; : Color(0.8,0.6,0.6,&#39;RedLightWeak&#39;),
                &#39;RedPaleWeak&#39; : Color(1,0.8,0.8,&#39;RedPaleWeak&#39;),
                &#39;Orange&#39; : Color(1,0.37,0.12,&#39;Orange&#39;),
                &#39;OrangeRedDark&#39; : Color(0.6,0.2,0,&#39;OrangeRedDark&#39;),
                &#39;OrangeRedMedium&#39; : Color(0.8,0.4,0.2,&#39;OrangeRedMedium&#39;),
                &#39;OrangeRedLight&#39; : Color(1,0.6,0.4,&#39;OrangeRedLight&#39;),
                &#39;OrangeOrangeRed&#39; : Color(1,0.4,0,&#39;OrangeOrangeRed&#39;),
                &#39;RedOrangeDark&#39; : Color(0.8,0.2,0,&#39;RedOrangeDark&#39;),
                &#39;RedOrangeLight&#39; : Color(1,0.4,0.2,&#39;RedOrangeLight&#39;),
                &#39;RedRedOrange&#39; : Color(1,0.2,0,&#39;RedRedOrange&#39;),
                &#39;OrangeDarkHard&#39; : Color(0.8,0.4,0,&#39;OrangeDarkHard&#39;),
                &#39;OrangeLightHard&#39; : Color(1,0.6,0.2,&#39;OrangeLightHard&#39;),
                &#39;OrangeObscureDull&#39; : Color(0.4,0.2,0,&#39;OrangeObscureDull&#39;),
                &#39;OrangeDarkDull&#39; : Color(0.6,0.4,0.2,&#39;OrangeDarkDull&#39;),
                &#39;OrangeLightDull&#39; : Color(0.8,0.6,0.4,&#39;OrangeLightDull&#39;),
                &#39;OrangePaleDull&#39; : Color(1,0.8,0.6,&#39;OrangePaleDull&#39;),
                &#39;OrangeYellowDark&#39; : Color(0.6,0.4,0,&#39;OrangeYellowDark&#39;),
                &#39;OrangeYellowMedium&#39; : Color(0.8,0.6,0.2,&#39;OrangeYellowMedium&#39;),
                &#39;OrangeYellowLight&#39; : Color(1,0.8,0.4,&#39;OrangeYellowLight&#39;),
                &#39;OrangeOrangeYellow&#39; : Color(1,0.6,0,&#39;OrangeOrangeYellow&#39;),
                &#39;YellowOrangeDark&#39; : Color(0.8,0.6,0,&#39;YellowOrangeDark&#39;),
                &#39;YellowOrangeLight&#39; : Color(1,0.8,0.2,&#39;YellowOrangeLight&#39;),
                &#39;YellowYellowOrange&#39; : Color(1,0.8,0,&#39;YellowYellowOrange&#39;),
                &#39;Yellow&#39; : Color(1,1,0,&#39;Yellow&#39;),
                &#39;YellowDarkHard&#39; : Color(0.8,0.8,0,&#39;YellowDarkHard&#39;),
                &#39;YellowLightHard&#39; : Color(1,1,0.2,&#39;YellowLightHard&#39;),
                &#39;YellowDarkFaded&#39; : Color(0.6,0.6,0,&#39;YellowDarkFaded&#39;),
                &#39;YellowMediumFaded&#39; : Color(0.8,0.8,0.2,&#39;YellowMediumFaded&#39;),
                &#39;YellowLightFaded&#39; : Color(1,1,0.4,&#39;YellowLightFaded&#39;),
                &#39;YellowObscureDull&#39; : Color(0.4,0.4,0,&#39;YellowObscureDull&#39;),
                &#39;YellowDarkDull&#39; : Color(0.6,0.6,0.2,&#39;YellowDarkDull&#39;),
                &#39;YellowLightDull&#39; : Color(0.8,0.8,0.4,&#39;YellowLightDull&#39;),
                &#39;YellowPaleDull&#39; : Color(1,1,0.6,&#39;YellowPaleDull&#39;),
                &#39;YellowObscureWeak&#39; : Color(0.2,0.2,0,&#39;YellowObscureWeak&#39;),
                &#39;YellowDarkWeak&#39; : Color(0.4,0.4,0.2,&#39;YellowDarkWeak&#39;),
                &#39;YellowMediumWeak&#39; : Color(0.6,0.6,0.4,&#39;YellowMediumWeak&#39;),
                &#39;YellowLightWeak&#39; : Color(0.8,0.8,0.6,&#39;YellowLightWeak&#39;),
                &#39;YellowPaleWeak&#39; : Color(1,1,0.8,&#39;YellowPaleWeak&#39;),
                &#39;SpringYellowDark&#39; : Color(0.4,0.6,0,&#39;SpringYellowDark&#39;),
                &#39;SpringYellowMedium&#39; : Color(0.6,0.8,0.2,&#39;SpringYellowMedium&#39;),
                &#39;SpringYellowLight&#39; : Color(0.8,1,0.4,&#39;SpringYellowLight&#39;),
                &#39;SpringSpringYellow&#39; : Color(0.6,1,0,&#39;SpringSpringYellow&#39;),
                &#39;YellowSpringDark&#39; : Color(0.6,0.8,0,&#39;YellowSpringDark&#39;),
                &#39;YellowSpringLight&#39; : Color(0.8,1,0.2,&#39;YellowSpringLight&#39;),
                &#39;YellowYellowSpring&#39; : Color(0.8,1,0,&#39;YellowYellowSpring&#39;),
                &#39;SpringDarkHard&#39; : Color(0.4,0.8,0,&#39;SpringDarkHard&#39;),
                &#39;SpringLightHard&#39; : Color(0.6,1,0.2,&#39;SpringLightHard&#39;),
                &#39;SpringObscureDull&#39; : Color(0.2,0.4,0,&#39;SpringObscureDull&#39;),
                &#39;SpringDarkDull&#39; : Color(0.4,0.6,0.2,&#39;SpringDarkDull&#39;),
                &#39;SpringLightDull&#39; : Color(0.6,0.8,0.4,&#39;SpringLightDull&#39;),
                &#39;SpringPaleDull&#39; : Color(0.8,1,0.6,&#39;SpringPaleDull&#39;),
                &#39;SpringGreenDark&#39; : Color(0.2,0.6,0,&#39;SpringGreenDark&#39;),
                &#39;SpringGreenMedium&#39; : Color(0.4,0.8,0.2,&#39;SpringGreenMedium&#39;),
                &#39;SpringGreenLight&#39; : Color(0.6,1,0.4,&#39;SpringGreenLight&#39;),
                &#39;SpringSpringGreen&#39; : Color(0.4,1,0,&#39;SpringSpringGreen&#39;),
                &#39;GreenSpringDark&#39; : Color(0.2,0.8,0,&#39;GreenSpringDark&#39;),
                &#39;GreenSpringLight&#39; : Color(0.4,1,0.2,&#39;GreenSpringLight&#39;),
                &#39;GreenGreenSpring&#39; : Color(0.2,1,0,&#39;GreenGreenSpring&#39;),
                &#39;Green&#39; : Color(0,1,0,&#39;Green&#39;),
                &#39;GreenDarkHard&#39; : Color(0,0.8,0,&#39;GreenDarkHard&#39;),
                &#39;GreenLightHard&#39; : Color(0.2,1,0.2,&#39;GreenLightHard&#39;),
                &#39;GreenDarkFaded&#39; : Color(0,0.6,0,&#39;GreenDarkFaded&#39;),
                &#39;GreenMediumFaded&#39; : Color(0.2,0.8,0.2,&#39;GreenMediumFaded&#39;),
                &#39;GreenLightFaded&#39; : Color(0.4,1,0.4,&#39;GreenLightFaded&#39;),
                &#39;GreenObscureDull&#39; : Color(0,0.4,0,&#39;GreenObscureDull&#39;),
                &#39;GreenDarkDull&#39; : Color(0.2,0.6,0.2,&#39;GreenDarkDull&#39;),
                &#39;GreenLightDull&#39; : Color(0.4,0.8,0.4,&#39;GreenLightDull&#39;),
                &#39;GreenPaleDull&#39; : Color(0.6,1,0.6,&#39;GreenPaleDull&#39;),
                &#39;GreenObscureWeak&#39; : Color(0,0.2,0,&#39;GreenObscureWeak&#39;),
                &#39;GreenDarkWeak&#39; : Color(0.2,0.4,0.2,&#39;GreenDarkWeak&#39;),
                &#39;GreenMediumWeak&#39; : Color(0.4,0.6,0.4,&#39;GreenMediumWeak&#39;),
                &#39;GreenLightWeak&#39; : Color(0.6,0.8,0.6,&#39;GreenLightWeak&#39;),
                &#39;GreenPaleWeak&#39; : Color(0.8,1,0.8,&#39;GreenPaleWeak&#39;),
                &#39;TealGreenDark&#39; : Color(0,0.6,0.2,&#39;TealGreenDark&#39;),
                &#39;TealGreenMedium&#39; : Color(0.2,0.8,0.4,&#39;TealGreenMedium&#39;),
                &#39;TealGreenLight&#39; : Color(0.4,1,0.6,&#39;TealGreenLight&#39;),
                &#39;TealTealGreen&#39; : Color(0,1,0.4,&#39;TealTealGreen&#39;),
                &#39;GreenTealDark&#39; : Color(0,0.8,0.2,&#39;GreenTealDark&#39;),
                &#39;GreenTealLight&#39; : Color(0.2,1,0.4,&#39;GreenTealLight&#39;),
                &#39;GreenGreenTeal&#39; : Color(0,1,0.2,&#39;GreenGreenTeal&#39;),
                &#39;TealDarkHard&#39; : Color(0,0.8,0.4,&#39;TealDarkHard&#39;),
                &#39;TealLightHard&#39; : Color(0.2,1,0.6,&#39;TealLightHard&#39;),
                &#39;TealObscureDull&#39; : Color(0,0.4,0.2,&#39;TealObscureDull&#39;),
                &#39;TealDarkDull&#39; : Color(0.2,0.6,0.4,&#39;TealDarkDull&#39;),
                &#39;TealLightDull&#39; : Color(0.4,0.8,0.6,&#39;TealLightDull&#39;),
                &#39;TealPaleDull&#39; : Color(0.6,1,0.8,&#39;TealPaleDull&#39;),
                &#39;TealCyanDark&#39; : Color(0,0.6,0.4,&#39;TealCyanDark&#39;),
                &#39;TealCyanMedium&#39; : Color(0.2,0.8,0.6,&#39;TealCyanMedium&#39;),
                &#39;TealCyanLight&#39; : Color(0.4,1,0.8,&#39;TealCyanLight&#39;),
                &#39;TealTealCyan&#39; : Color(0,1,0.6,&#39;TealTealCyan&#39;),
                &#39;CyanTealDark&#39; : Color(0,0.8,0.6,&#39;CyanTealDark&#39;),
                &#39;CyanTealLight&#39; : Color(0.2,1,0.8,&#39;CyanTealLight&#39;),
                &#39;CyanCyanTeal&#39; : Color(0,1,0.8,&#39;CyanCyanTeal&#39;),
                &#39;Cyan&#39; : Color(0,1,1,&#39;Cyan&#39;),
                &#39;CyanDarkHard&#39; : Color(0,0.8,0.8,&#39;CyanDarkHard&#39;),
                &#39;CyanLightHard&#39; : Color(0.2,1,1,&#39;CyanLightHard&#39;),
                &#39;CyanDarkFaded&#39; : Color(0,0.6,0.6,&#39;CyanDarkFaded&#39;),
                &#39;CyanMediumFaded&#39; : Color(0.2,0.8,0.8,&#39;CyanMediumFaded&#39;),
                &#39;CyanLightFaded&#39; : Color(0.4,1,1,&#39;CyanLightFaded&#39;),
                &#39;CyanObscureDull&#39; : Color(0,0.4,0.4,&#39;CyanObscureDull&#39;),
                &#39;CyanDarkDull&#39; : Color(0.2,0.6,0.6,&#39;CyanDarkDull&#39;),
                &#39;CyanLightDull&#39; : Color(0.4,0.8,0.8,&#39;CyanLightDull&#39;),
                &#39;CyanPaleDull&#39; : Color(0.6,1,1,&#39;CyanPaleDull&#39;),
                &#39;CyanObscureWeak&#39; : Color(0,0.2,0.2,&#39;CyanObscureWeak&#39;),
                &#39;CyanDarkWeak&#39; : Color(0.2,0.4,0.4,&#39;CyanDarkWeak&#39;),
                &#39;CyanMediumWeak&#39; : Color(0.4,0.6,0.6,&#39;CyanMediumWeak&#39;),
                &#39;CyanLightWeak&#39; : Color(0.6,0.8,0.8,&#39;CyanLightWeak&#39;),
                &#39;CyanPaleWeak&#39; : Color(0.8,1,1,&#39;CyanPaleWeak&#39;),
                &#39;AzureCyanDark&#39; : Color(0,0.4,0.6,&#39;AzureCyanDark&#39;),
                &#39;AzureCyanMedium&#39; : Color(0.2,0.6,0.8,&#39;AzureCyanMedium&#39;),
                &#39;AzureCyanLight&#39; : Color(0.4,0.8,1,&#39;AzureCyanLight&#39;),
                &#39;AzureAzureCyan&#39; : Color(0,0.6,1,&#39;AzureAzureCyan&#39;),
                &#39;CyanAzureDark&#39; : Color(0,0.6,0.8,&#39;CyanAzureDark&#39;),
                &#39;CyanAzureLight&#39; : Color(0.2,0.8,1,&#39;CyanAzureLight&#39;),
                &#39;CyanCyanAzure&#39; : Color(0,0.8,1,&#39;CyanCyanAzure&#39;),
                &#39;AzureDarkHard&#39; : Color(0,0.4,0.8,&#39;AzureDarkHard&#39;),
                &#39;AzureLightHard&#39; : Color(0.2,0.6,1,&#39;AzureLightHard&#39;),
                &#39;AzureObscureDull&#39; : Color(0,0.2,0.4,&#39;AzureObscureDull&#39;),
                &#39;AzureDarkDull&#39; : Color(0.2,0.4,0.6,&#39;AzureDarkDull&#39;),
                &#39;AzureLightDull&#39; : Color(0.4,0.6,0.8,&#39;AzureLightDull&#39;),
                &#39;AzurePaleDull&#39; : Color(0.6,0.8,1,&#39;AzurePaleDull&#39;),
                &#39;AzureBlueDark&#39; : Color(0,0.2,0.6,&#39;AzureBlueDark&#39;),
                &#39;AzureBlueMedium&#39; : Color(0.2,0.4,0.8,&#39;AzureBlueMedium&#39;),
                &#39;AzureBlueLight&#39; : Color(0.4,0.6,1,&#39;AzureBlueLight&#39;),
                &#39;AzureAzureBlue&#39; : Color(0,0.4,1,&#39;AzureAzureBlue&#39;),
                &#39;BlueAzureDark&#39; : Color(0,0.2,0.8,&#39;BlueAzureDark&#39;),
                &#39;BlueAzureLight&#39; : Color(0.2,0.4,1,&#39;BlueAzureLight&#39;),
                &#39;BlueBlueAzure&#39; : Color(0,0.2,1,&#39;BlueBlueAzure&#39;),
                &#39;Blue&#39; : Color(0,0,1,&#39;Blue&#39;),
                &#39;BlueDarkHard&#39; : Color(0,0,0.8,&#39;BlueDarkHard&#39;),
                &#39;BlueLightHard&#39; : Color(0.2,0.2,1,&#39;BlueLightHard&#39;),
                &#39;BlueDarkFaded&#39; : Color(0,0,0.6,&#39;BlueDarkFaded&#39;),
                &#39;BlueMediumFaded&#39; : Color(0.2,0.2,0.8,&#39;BlueMediumFaded&#39;),
                &#39;BlueLightFaded&#39; : Color(0.4,0.4,1,&#39;BlueLightFaded&#39;),
                &#39;BlueObscureDull&#39; : Color(0,0,0.4,&#39;BlueObscureDull&#39;),
                &#39;BlueDarkDull&#39; : Color(0.2,0.2,0.6,&#39;BlueDarkDull&#39;),
                &#39;BlueLightDull&#39; : Color(0.4,0.4,0.8,&#39;BlueLightDull&#39;),
                &#39;BluePaleDull&#39; : Color(0.6,0.6,1,&#39;BluePaleDull&#39;),
                &#39;BlueObscureWeak&#39; : Color(0,0,0.2,&#39;BlueObscureWeak&#39;),
                &#39;BlueDarkWeak&#39; : Color(0.2,0.2,0.4,&#39;BlueDarkWeak&#39;),
                &#39;BlueMediumWeak&#39; : Color(0.4,0.4,0.6,&#39;BlueMediumWeak&#39;),
                &#39;BlueLightWeak&#39; : Color(0.6,0.6,0.8,&#39;BlueLightWeak&#39;),
                &#39;BluePaleWeak&#39; : Color(0.8,0.8,1,&#39;BluePaleWeak&#39;),
                &#39;VioletBlueDark&#39; : Color(0.2,0,0.6,&#39;VioletBlueDark&#39;),
                &#39;VioletBlueMedium&#39; : Color(0.4,0.2,0.8,&#39;VioletBlueMedium&#39;),
                &#39;VioletBlueLight&#39; : Color(0.6,0.4,1,&#39;VioletBlueLight&#39;),
                &#39;VioletVioletBlue&#39; : Color(0.4,0,1,&#39;VioletVioletBlue&#39;),
                &#39;BlueVioletDark&#39; : Color(0.2,0,0.8,&#39;BlueVioletDark&#39;),
                &#39;BlueVioletLight&#39; : Color(0.4,0.2,1,&#39;BlueVioletLight&#39;),
                &#39;BlueBlueViolet&#39; : Color(0.2,0,1,&#39;BlueBlueViolet&#39;),
                &#39;VioletDarkHard&#39; : Color(0.4,0,0.8,&#39;VioletDarkHard&#39;),
                &#39;VioletLightHard&#39; : Color(0.6,0.2,1,&#39;VioletLightHard&#39;),
                &#39;VioletObscureDull&#39; : Color(0.2,0,0.4,&#39;VioletObscureDull&#39;),
                &#39;VioletDarkDull&#39; : Color(0.4,0.2,0.6,&#39;VioletDarkDull&#39;),
                &#39;VioletLightDull&#39; : Color(0.6,0.4,0.8,&#39;VioletLightDull&#39;),
                &#39;VioletPaleDull&#39; : Color(0.8,0.6,1,&#39;VioletPaleDull&#39;),
                &#39;VioletMagentaDark&#39; : Color(0.4,0,0.6,&#39;VioletMagentaDark&#39;),
                &#39;VioletMagentaMedium&#39; : Color(0.6,0.2,0.8,&#39;VioletMagentaMedium&#39;),
                &#39;VioletMagentaLight&#39; : Color(0.8,0.4,1,&#39;VioletMagentaLight&#39;),
                &#39;VioletVioletMagenta&#39; : Color(0.6,0,1,&#39;VioletVioletMagenta&#39;),
                &#39;MagentaVioletDark&#39; : Color(0.6,0,0.8,&#39;MagentaVioletDark&#39;),
                &#39;MagentaVioletLight&#39; : Color(0.8,0.2,1,&#39;MagentaVioletLight&#39;),
                &#39;MagentaMagentaViolet&#39; : Color(0.8,0,1,&#39;MagentaMagentaViolet&#39;),
                &#39;Magenta&#39; : Color(1,0,1,&#39;Magenta&#39;),
                &#39;MagentaDarkHard&#39; : Color(0.8,0,0.8,&#39;MagentaDarkHard&#39;),
                &#39;MagentaLightHard&#39; : Color(1,0.2,1,&#39;MagentaLightHard&#39;),
                &#39;MagentaDarkFaded&#39; : Color(0.6,0,0.6,&#39;MagentaDarkFaded&#39;),
                &#39;MagentaMediumFaded&#39; : Color(0.8,0.2,0.8,&#39;MagentaMediumFaded&#39;),
                &#39;MagentaLightFaded&#39; : Color(1,0.4,1,&#39;MagentaLightFaded&#39;),
                &#39;MagentaObscureDull&#39; : Color(0.4,0,0.4,&#39;MagentaObscureDull&#39;),
                &#39;MagentaDarkDull&#39; : Color(0.6,0.2,0.6,&#39;MagentaDarkDull&#39;),
                &#39;MagentaLightDull&#39; : Color(0.8,0.4,0.8,&#39;MagentaLightDull&#39;),
                &#39;MagentaPaleDull&#39; : Color(1,0.6,1,&#39;MagentaPaleDull&#39;),
                &#39;MagentaObscureWeak&#39; : Color(0.2,0,0.2,&#39;MagentaObscureWeak&#39;),
                &#39;MagentaDarkWeak&#39; : Color(0.4,0.2,0.4,&#39;MagentaDarkWeak&#39;),
                &#39;MagentaMediumWeak&#39; : Color(0.6,0.4,0.6,&#39;MagentaMediumWeak&#39;),
                &#39;MagentaLightWeak&#39; : Color(0.8,0.6,0.8,&#39;MagentaLightWeak&#39;),
                &#39;MagentaPaleWeak&#39; : Color(1,0.8,1,&#39;MagentaPaleWeak&#39;),
                &#39;PinkMagentaDark&#39; : Color(0.6,0,0.4,&#39;PinkMagentaDark&#39;),
                &#39;PinkMagentaMedium&#39; : Color(0.8,0.2,0.6,&#39;PinkMagentaMedium&#39;),
                &#39;PinkMagentaLight&#39; : Color(1,0.4,0.8,&#39;PinkMagentaLight&#39;),
                &#39;PinkPinkMagenta&#39; : Color(1,0,0.6,&#39;PinkPinkMagenta&#39;),
                &#39;MagentaPinkDark&#39; : Color(0.8,0,0.6,&#39;MagentaPinkDark&#39;),
                &#39;MagentaPinkLight&#39; : Color(1,0.2,0.8,&#39;MagentaPinkLight&#39;),
                &#39;MagentaMagentaPink&#39; : Color(1,0,0.8,&#39;MagentaMagentaPink&#39;),
                &#39;PinkDarkHard&#39; : Color(0.8,0,0.4,&#39;PinkDarkHard&#39;),
                &#39;PinkLightHard&#39; : Color(1,0.2,0.6,&#39;PinkLightHard&#39;),
                &#39;PinkObscureDull&#39; : Color(0.4,0,0.2,&#39;PinkObscureDull&#39;),
                &#39;PinkDarkDull&#39; : Color(0.6,0.2,0.4,&#39;PinkDarkDull&#39;),
                &#39;PinkLightDull&#39; : Color(0.8,0.4,0.6,&#39;PinkLightDull&#39;),
                &#39;PinkPaleDull&#39; : Color(1,0.6,0.8,&#39;PinkPaleDull&#39;),
                &#39;PinkRedDark&#39; : Color(0.6,0,0.2,&#39;PinkRedDark&#39;),
                &#39;PinkRedMedium&#39; : Color(0.8,0.2,0.4,&#39;PinkRedMedium&#39;),
                &#39;PinkRedLight&#39; : Color(1,0.4,0.6,&#39;PinkRedLight&#39;),
                &#39;PinkPinkRed&#39; : Color(1,0,0.4,&#39;PinkPinkRed&#39;),
                &#39;RedPinkDark&#39; : Color(0.8,0,0.2,&#39;RedPinkDark&#39;),
                &#39;RedPinkLight&#39; : Color(1,0.2,0.4,&#39;RedPinkLight&#39;),
                &#39;RedRedPink&#39; : Color(1,0,0.2,&#39;RedRedPink&#39;)
        }
        #
        #
        #
        @classmethod
        def color(self,name):
                &#34;&#34;&#34;
                Function that returns a color from his name
                Parameters:
                   name: name of the color
                &#34;&#34;&#34;
                try:
                        color = self.colorsbyname[name]
                except:
                        return self.colorsbyname[&#34;Black&#34;]
                return color
        #
        #
        #
        @classmethod
        def colors(self,names):
                &#34;&#34;&#34;
                Return a list of colors fron their names
                Parameters:
                   names: list of names
                &#34;&#34;&#34;
                return [self.colorsbyname[x] for x in names]</code></pre>
</details>
<div class="desc"><p>Class that defines a list of colors by name</p></div>
<h3>Class variables</h3>
<dl>
<dt id="LinearAlgebra.Colors.colorsbyname"><code class="name">var <span class="ident">colorsbyname</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="LinearAlgebra.Colors.color"><code class="name flex">
<span>def <span class="ident">color</span></span>(<span>name)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that returns a color from his name</p>
<h2 id="parameters">Parameters</h2>
<p>name: name of the color</p></div>
</dd>
<dt id="LinearAlgebra.Colors.colors"><code class="name flex">
<span>def <span class="ident">colors</span></span>(<span>names)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of colors fron their names</p>
<h2 id="parameters">Parameters</h2>
<p>names: list of names</p></div>
</dd>
</dl>
</dd>
<dt id="LinearAlgebra.EuclideanReference"><code class="flex name class">
<span>class <span class="ident">EuclideanReference</span></span>
<span>(</span><span>o=Vector((0.0, 0.0, 0.0)),<br>u1=Vector((1.0, 0.0, 0.0)),<br>u2=Vector((0.0, 1.0, 0.0)))</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EuclideanReference():
        &#34;&#34;&#34;
        Class used to work with Eucliean References
        &#34;&#34;&#34;
        def __init__(self,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0])):
                &#34;&#34;&#34;
                Initializes the elements of the reference from the origin and two independent vectors
                Parameters:
                   o: origin of
                   u1, u2: vectors
                &#34;&#34;&#34;
                if isinstance(o,Vector):
                        self.origin = o
                else:
                        self.origin = Vector(o)
                if isinstance(u1,Vector):
                        v1 = u1
                else:
                        v1 = Vector(v1)
                if isinstance(u2,Vector):
                        v2 = u2
                else:
                        v2 = Vector(u2)
                v2 = v2 - v2.project(v1)
                v1.normalize()
                v2.normalize()
                v3 = v1.cross(v2)
                self.matrix = Matrix([v1,v2,v3]).transposed()
        #
        #
        #
        def coordinates(self,u=Vector([0,0,0])):
                &#34;&#34;&#34;
                Returns the coordinates of a point (expressed in the canonical reference) in the actual reference
                Parameters:
                   u: coordinates of a point in the canonical reference
                &#34;&#34;&#34;
                if not isinstance(u,Vector):
                        u = Vector(u)
                return self.matrix.transposed() @ (u - self.origin)
        #
        #
        #
        def base(self):
                &#34;&#34;&#34;
                Returns the columns of the matrix
                &#34;&#34;&#34;
                mat = self.matrix.transposed()
                return [mat.row[0],mat.row[1],mat.row[2]]</code></pre>
</details>
<div class="desc"><p>Class used to work with Eucliean References</p>
<p>Initializes the elements of the reference from the origin and two independent vectors</p>
<h2 id="parameters">Parameters</h2>
<p>o: origin of
u1, u2: vectors</p></div>
<h3>Methods</h3>
<dl>
<dt id="LinearAlgebra.EuclideanReference.base"><code class="name flex">
<span>def <span class="ident">base</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base(self):
        &#34;&#34;&#34;
        Returns the columns of the matrix
        &#34;&#34;&#34;
        mat = self.matrix.transposed()
        return [mat.row[0],mat.row[1],mat.row[2]]</code></pre>
</details>
<div class="desc"><p>Returns the columns of the matrix</p></div>
</dd>
<dt id="LinearAlgebra.EuclideanReference.coordinates"><code class="name flex">
<span>def <span class="ident">coordinates</span></span>(<span>self, u=Vector((0.0, 0.0, 0.0)))</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coordinates(self,u=Vector([0,0,0])):
        &#34;&#34;&#34;
        Returns the coordinates of a point (expressed in the canonical reference) in the actual reference
        Parameters:
           u: coordinates of a point in the canonical reference
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
                u = Vector(u)
        return self.matrix.transposed() @ (u - self.origin)</code></pre>
</details>
<div class="desc"><p>Returns the coordinates of a point (expressed in the canonical reference) in the actual reference</p>
<h2 id="parameters">Parameters</h2>
<p>u: coordinates of a point in the canonical reference</p></div>
</dd>
</dl>
</dd>
<dt id="LinearAlgebra.LinearAlgebra"><code class="flex name class">
<span>class <span class="ident">LinearAlgebra</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LinearAlgebra():
        &#34;&#34;&#34;
        Class used to define all the functions in this module to work with graphics in Blender
        &#34;&#34;&#34;
        def __init__(self):
                &#34;&#34;&#34;
        Initializes the values for scene, objects, meshes, collection, etc.
                &#34;&#34;&#34;
                self.scene = bpy.context.scene
                self.objects = bpy.data.objects
                self.meshes = bpy.data.meshes
                self.collection = bpy.context.collection
                self.ops = bpy.ops
                self.colors= Colors.colors([&#34;Red&#34;,&#34;GreenDarkHard&#34;,&#34;Blue&#34;])
                self.rotation = None
                self.origin = [0,0,0]
                self.base = [[1,0,0],[0,1,0],[0,0,1]]
                self.defaultcolor = None
                self.frame = 0
        #
        #
        #
        def base_cilinder(self):
                &#34;&#34;&#34;
                Draws a base cilinder with radius 1 and depth 1
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_cylinder_add(radius=1,depth=1,enter_editmode=False,location=(0, 0, 0))
                bpy.ops.transform.translate(value=(0, 0, 0.5), orient_type=&#39;GLOBAL&#39;,orient_matrix_type=&#39;GLOBAL&#39;,
                        constraint_axis=(False, False, True), mirror=True, use_proportional_edit=False,
                        proportional_edit_falloff=&#39;SMOOTH&#39;,proportional_size=1, use_proportional_connected=False, use_proportional_projected=False)
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                bpy.ops.object.shade_smooth()
                bpy.context.object.name = &#39;Arrow_stem&#39;
        #
        #
        #
        def base_cone(self):
                &#34;&#34;&#34;
                Draws a base cone with radius1=1.5, radius2=0, depth=2
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_cone_add(radius1=1.5, radius2=0, depth=2, enter_editmode=False, location=(0, 0, 0))
                bpy.ops.transform.translate(value=(0, 0, 1), orient_type=&#39;GLOBAL&#39;,orient_matrix_type=&#39;GLOBAL&#39;,
                        constraint_axis=(False, False, True), mirror=True, use_proportional_edit=False,
                        proportional_edit_falloff=&#39;SMOOTH&#39;, proportional_size=1, use_proportional_connected=False, use_proportional_projected=False)
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                bpy.ops.object.shade_smooth()
                bpy.context.object.name = &#39;Arrow_cone&#39;
        #
        #
        #
        def base_disk(self):
                &#34;&#34;&#34;
                Draws a base cone with radius1=1.5, radius2=0, depth=2
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_circle_add(vertices=32,fill_type=&#39;NGON&#39;,enter_editmode=False,align=&#39;WORLD&#39;,location=(0.0, 0.0, 0.0))
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                bpy.ops.object.shade_smooth()
                bpy.context.object.name = &#39;Base_disk&#39;
        #
        #
        #
        def delete_base_cilinder(self):
                &#34;&#34;&#34;
                Removes the base cilinder
                &#34;&#34;&#34;
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.data.objects[&#39;Arrow_stem&#39;].select_set(True)
                bpy.ops.object.delete()
        #
        #
        #
        def delete_base_cone(self):
                &#34;&#34;&#34;
                Removes the base cone
                &#34;&#34;&#34;
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.data.objects[&#39;Arrow_cone&#39;].select_set(True)
                bpy.ops.object.delete()
        #
        #
        #
        def delete_base_disk(self):
                &#34;&#34;&#34;
                Removes the base disk
                &#34;&#34;&#34;
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.data.objects[&#39;Base_disk&#39;].select_set(True)
                bpy.ops.object.delete()
        #
        #
        #
        def set_colors(self,names=None):
                &#34;&#34;&#34;
                Set self.colors to the list of colors with names &#39;names&#39;
                Parameters:
                   names: list of name colors
                &#34;&#34;&#34;
                if names is None:
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;GreenDarkHard&#34;,&#34;Blue&#34;])
                else:
                        self.colors = Colors.colors(names)
        #
        #
        #
        def reset_colors(self):
                &#34;&#34;&#34;
                Set self.colors to default colors
                &#34;&#34;&#34;
                self.colors = Colors.colors([&#34;Red&#34;,&#34;GreenDarkHard&#34;,&#34;Blue&#34;])
        #
        #
        #
        def set_default_color(self,name):
                &#34;&#34;&#34;
                Set self.defaultcolor to the color with name &#39;name&#39;
                Parameters:
                   name: name of a color
                &#34;&#34;&#34;
                self.defaultcolor = name
        #
        #
        #
        def reset_frames(self):
                &#34;&#34;&#34;
                Set self.frame to 0
                Parameters:
                   name: name of a color
                &#34;&#34;&#34;
                self.frame = 0
        #
        #
        #
        def reset(self):
                &#34;&#34;&#34;
                Resets origin, base, rotation, frames and colors
                &#34;&#34;&#34;
                self.reset_origin()
                self.reset_base()
                self.reset_rotation()
                self.reset_frames()
                self.reset_colors()
        #
        #
        #
        def set_rotation(self,angle=None,vector=None,quaternion=None):
                &#34;&#34;&#34;
                Sets self.rotation to the rotation defined by an angle and an axis or
                by a quaternion.
                Parameters:
                   angle: angle of rotation in degrees

                   vector: axis of rotation

                   quaternion: quaternion that defines a rotation

                The angle and vector takes precedence over the quaternion
                &#34;&#34;&#34;
                if angle is not None:
                        self.rotation = Rotation(angle,vector)
                elif quaternion is not None:
                        self.rotation = Rotation(quaternion=quaternion)
                else:
                        self.rotation = Rotation(0,[1,0,0])
        #
        #
        #
        def reset_rotation(self):
                &#34;&#34;&#34;
                Sets the rotation to identity, i.e., rotation of 0 degrees around the
                vector (1,0,0)
                &#34;&#34;&#34;
                self.set_rotation()
        #
        #
        #
        def set_origin(self,vector=[0,0,0]):
                &#34;&#34;&#34;
                Sets the origin of the reference coordinates used to display objects.
                Parameters:
                   vector: origin&#39;s position
                &#34;&#34;&#34;
                if isinstance(vector,Vector):
                        v1 = vector.copy()
                else:
                        v1 = Vector(vector)
                self.origin = v1
        #
        #
        #
        def reset_origin(self):
                &#34;&#34;&#34;
                Sets the origin to the point (0,0,0)
                &#34;&#34;&#34;
                self.origin = Vector([0,0,0])
        #
        #
        #
        def reset_base(self):
                &#34;&#34;&#34;
                Sets self.base to the canonical basis
                &#34;&#34;&#34;
                self.base = [[1,0,0],[0,1,0],[0,0,1]]
        #
        #
        #
        def set_base(self,base=[[1,0,0],[0,1,0],[0,0,1]],orthonormal=False):
                &#34;&#34;&#34;
                Sets the self.base, i.e., the basis of the reference coordinates used to display
                objects
                Parameters:
                   base: list of three vectors

                   orthonormal: if True, the Gram-Schmidt method is applied and the vectors
                   are normalized.
                &#34;&#34;&#34;
                if orthonormal:
                        u1 = base[0]
                        u2 = base[1]
                        if isinstance(u1,Vector):
                                v1 = u1
                        else:
                                v1 = Vector(u1)
                        if isinstance(u2,Vector):
                                v2 = u2
                        else:
                                v2 = Vector(u2)
                        v2 = v2 - v2.project(v1)
                        v1.normalize()
                        v2.normalize()
                        v3 = v1.cross(v2)
                        self.base=[v1,v2,v3]
                else:
                        self.base = base
        #
        #
        #
        def base_is_canonica(self):
                &#34;&#34;&#34;
                Returns True if self.base is the canonical basis
                &#34;&#34;&#34;
                return Matrix(self.base).is_identity
        #
        #
        #
        def add_material(self,obj,material_name,r,g,b,opacity=1.0):
                &#34;&#34;&#34;
                Adds a material and color to an object
                Parameters:
                   obj: object

                   material_name: material&#39;s name

                   r, g, b: RGB color values

                   opacity: the opacity
                &#34;&#34;&#34;
                material = bpy.data.materials.get(material_name)
                if material is None:
                        material = bpy.data.materials.new(material_name)
                material.use_nodes = True
                principled_bsdf = material.node_tree.nodes[&#39;Principled BSDF&#39;]
                if principled_bsdf is not None:
                        principled_bsdf.inputs[&#39;Base Color&#39;].default_value = (r, g, b, opacity)
                        principled_bsdf.inputs[&#39;IOR&#39;].default_value = 0.0
                        principled_bsdf.inputs[&#39;Metallic&#39;].default_value = 1.0
                        principled_bsdf.inputs[&#39;Roughness&#39;].default_value = 0.55
                        if bpy.app.version[0] &lt; 4:
                                principled_bsdf.inputs[&#39;Specular&#39;].default_value = 1.0
                        else:
                                principled_bsdf.inputs[&#39;Specular IOR Level&#39;].default_value = 1.0
                        if bpy.app.version[0] &lt; 4:
                                principled_bsdf.inputs[&#39;Emission&#39;].default_value = (r, g, b, opacity)
                        else:
                                principled_bsdf.inputs[&#39;Emission Color&#39;].default_value = (r, g, b, opacity)
                        principled_bsdf.inputs[&#39;Emission Strength&#39;].default_value = 0.0
                        if opacity &lt; 1.0:
                                material.blend_method = &#39;BLEND&#39;
                                principled_bsdf.inputs[&#39;Alpha&#39;].default_value = opacity
                        else:
                                material.blend_method = &#39;OPAQUE&#39;
                                principled_bsdf.inputs[&#39;Alpha&#39;].default_value = 1.0
                obj.active_material = material
        #
        #
        #
        def add_ligth(self,location=[0,0,100],energy=3,direction=[0,0,-1]):
                &#34;&#34;&#34;
                Adds a ligth to the scene
                Parameters:
                   location: location point of the light

                   energy: energy of the ligth

                   direction: direction of the light
                &#34;&#34;&#34;
                l = bpy.data.lights.new(name=&#34;Light&#34;, type=&#39;SUN&#39;)
                l.energy = energy
                l.specular_factor = 4
                obj = self.objects.new(name=&#34;Light&#34;, object_data=l)
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.location = location
                n = Vector(direction)
                mat = Matrix(self.base)
                mat.transpose()
                n = mat @ n
                z = Vector([0,0,-1])
                quaternion = z.rotation_difference(n)
                obj.rotation_quaternion.rotate(quaternion)
                self.collection.objects.link(obj)
        #
        #
        #
        def add_ligths(self,energy=1):
                &#34;&#34;&#34;
                Adds diferent lights to the scene
                Parameters:
                   energy: energy of the lights
                &#34;&#34;&#34;
                self.add_ligth()
                self.add_ligth(location=[100,0,0],direction=[-1,0,0],energy=energy)
                self.add_ligth(location=[0,100,0],direction=[0,-1,0],energy=energy)
                self.add_ligth(location=[-100,0,0],direction=[1,0,0],energy=energy)
                self.add_ligth(location=[0,-100,0],direction=[0,1,0],energy=energy)
        #
        #
        #
        def components_in_base(self,vector=None,base=None):
                &#34;&#34;&#34;
                Returns the components of the vector &#39;vector&#39; in the basis determined by
                self.rotation and the basis self.base
                Parameters:
                   vector: components of the vector in the canonical basis

                   base: A base of V3. If None, we use self.base
                &#34;&#34;&#34;
                if vector is None:
                        return Vector([0,0,0])
                if isinstance(vector,Vector):
                        u = vector
                else:
                        u = Vector(vector)
                if self.rotation is not None:
                        mat = self.rotation.quaternion.to_matrix()
                        mat.invert()
                        u = mat @ u
                mat = Matrix(self.base)
                if base is not None:
                        mat = Matrix(base)
                mat.transpose()
                mat.invert()
                u = mat @ u
                return u
        #
        #
        #
        def components_en_canonica(self,vector=None):
                &#34;&#34;&#34;
                Returns the components of the vector &#39;point&#39; in the base determined by
                self.rotation and the basis self.base
                Parameters:
                   vector: components of the vector in the base self.rotation + self.base
                &#34;&#34;&#34;
                if vector is None:
                        return Vector([0,0,0])
                if isinstance(vector,Vector):
                        u = vector
                else:
                        u = Vector(vector)
                if self.rotation is not None:
                        mat = self.rotation.quaternion.to_matrix()
                        u = mat @ u
                mat = Matrix(self.base)
                mat.transpose()
                u = mat @ u
                return u
        #
        #
        #
        def coordinates_en_referencia(self,point=None):
                &#34;&#34;&#34;
                Returns the coordinates of the point &#39;point&#39; in the reference determined by
                self.origin, self.rotation and the basis self.base
                Parameters:
                   point: coordinates of the point in the canonical reference
                &#34;&#34;&#34;
                if point is None:
                        return Vector([0,0,0])
                if isinstance(point,Vector):
                        u = point
                else:
                        u = Vector(point)
                if self.rotation is not None:
                        mat = self.rotation.quaternion.to_matrix()
                        mat.invert()
                        u = mat @ u
                mat = Matrix(self.base)
                mat.transpose()
                mat.invert()
                u = mat @ (u - Vector(self.origin))
                return u
        #
        #
        #
        def coordinates_en_canonica(self,point=None):
                &#34;&#34;&#34;
                Returns the coordinates of the point &#39;point&#39; in the reference determined by
                self.origin, self.rotation and the basis self.base
                Parameters:
                   point: coordinates of the point in the reference {self.origin;self.base}
                &#34;&#34;&#34;
                if point is None:
                        return Vector([0,0,0])
                if isinstance(point,Vector):
                        u = point
                else:
                        u = Vector(point)
                if self.rotation is not None:
                        mat = self.rotation.quaternion.to_matrix()
                        u = mat @ u
                mat = Matrix(self.base)
                mat.transpose()
                u = Vector(self.origin) + mat @ u
                return u
        #
        #
        #
        def set_cursor(self,origin=[0,0,0],direction=[1,0,0],axis=&#39;x&#39;):
                &#34;&#34;&#34;
                Sets the cursor position and direction
                Parameters:
                  origin: position of the cursor

                  direction: vector that indicates the direction of the axis &#39;axis&#39;

                  axis: &#39;x&#39;, &#39;y&#39; or &#39;z&#39;
                &#34;&#34;&#34;
                axis = axis.lower()
                if axis not in [&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]:
                        return
                eixos = {&#39;x&#39; : Vector([1,0,0]),
                                 &#39;y&#39; : Vector([0,1,0]),
                                 &#39;z&#39; : Vector([0,0,1])
                }
                if isinstance(direction,Vector):
                        d = direction
                else:
                        d = Vector(direction)
                x = eixos[axis]
                quaternion = x.rotation_difference(d)
                self.scene.cursor.location = origin
                self.scene.cursor.rotation_mode = &#39;QUATERNION&#39;
                self.scene.cursor.rotation_quaternion = quaternion
        #
        #
        #
        def set_cursor_rotation(self,origin=[0,0,0],rotation=Matrix.Identity(3)):
                &#34;&#34;&#34;
                Sets the rotation of the cursor
                Parameters:
                   origin: position of the cursor

                   rotation: matrix of a rotation
                &#34;&#34;&#34;
                m = rotation.copy()
                det = m.determinant()
                if abs(- det - 1.0) &lt; 0.1:
                        m[2] = - m[2]
                quaternion = m.to_quaternion()
                self.scene.cursor.location = origin
                self.scene.cursor.rotation_mode = &#39;QUATERNION&#39;
                self.scene.cursor.rotation_quaternion = quaternion.conjugated()
        #
        #
        #
        def draw_base_axis(self,scale=0.05,head_height=0.15,axis=0,name=&#34;Axis&#34;,positive=True,zaxis=True):
                &#34;&#34;&#34;
                Draws a reference axis given by self.origin, self.rotation and the basis self.base
                Parameters:
                   scale: scale of the cylinder

                   head_height: height of the head of the vector from self.base

                   axis: length of the coordinate axis. If the length is 0, only the basis vectors are drawn

                   name: name of the result object

                   positive: if True, draw the positive part of the axis

                   zaxis: if True, draw the z axis
                &#34;&#34;&#34;
                self.base_cilinder()
                self.base_cone()
                o = Vector([0,0,0])
                op = Vector(self.origin)
                color = 0

                if axis != 0 and axis &lt; 8:
                        scale /= 3

                base = self.base
                if not zaxis:
                        base = self.base[0:2]

                for vec in base:
                        #
                        # Draw the stem
                        #
                        v = Vector(vec)
                        t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                        obj = t.copy()
                        obj.name = &#34;Axis%d&#34; % (color + 1)
                        obj.data = obj.data.copy()
                        obj.location = o
                        obj.scale = (scale,scale,(v - o).length - 2 * head_height)
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if self.colors is not None and len(self.colors) &gt; color:
                                c = self.colors[color]
                                self.add_material(obj,c.name,c.r,c.g,c.b)
                        if self.rotation is not None:
                                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location = op
                        self.scene.collection.objects.link(obj)
                        #
                        # Draw the arrow
                        #
                        t = bpy.data.objects.get(&#34;Arrow_cone&#34;)
                        obj2 = t.copy()
                        obj2.name = &#34;Arrow&#34;
                        obj2.data = obj2.data.copy()
                        obj2.location =  v - 2 * head_height * v / v.length
                        obj2.scale = (scale + 0.05,scale + 0.05,head_height)
                        obj2.rotation_mode = &#39;QUATERNION&#39;
                        obj2.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if self.colors is not None and len(self.colors) &gt; color:
                                c = self.colors[color]
                                self.add_material(obj2,c.name,c.r,c.g,c.b)
                        if self.rotation is not None:
                                obj2.rotation_quaternion.rotate(self.rotation.quaternion)
                                obj2.location.rotate(self.rotation.quaternion)
                        obj2.location = op + obj2.location
                        self.scene.collection.objects.link(obj2)
                        #
                        # Draw the line
                        #
                        obj3 = None
                        if axis != 0:
                                v = axis * v/v.length
                                t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                                obj3 = t.copy()
                                obj3.name = &#34;Line&#34;
                                obj3.data = obj3.data.copy()
                                obj3.location = op - v/v.length
                                obj3.scale = (scale / 2,scale / 2,(2 * v).length)
                                obj3.rotation_mode = &#39;QUATERNION&#39;
                                obj3.rotation_quaternion = v.to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                                if self.colors is not None and len(self.colors) &gt; color:
                                        c = self.colors[color]
                                        self.add_material(obj3,c.name,c.r,c.g,c.b)
                                if self.rotation is not None:
                                        obj3.rotation_quaternion.rotate(self.rotation.quaternion)
                                if positive:
                                        obj3.location = op
                                else:
                                        if self.rotation is not None:
                                                v.rotate(self.rotation.quaternion)
                                        obj3.location = op - v
                                self.scene.collection.objects.link(obj3)
                        #
                        # Joint the three objects
                        #
                        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                        bpy.context.view_layer.objects.active = obj
                        obj.select_set(True)
                        obj2.select_set(True)
                        if obj3 is not None:
                                obj3.select_set(True)
                        bpy.ops.object.join()
                        color += 1
                #
                # Join all the axis
                #
                t1 = bpy.data.objects.get(&#34;Axis1&#34;)
                t1.name = name
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.context.view_layer.objects.active = t1
                t1.select_set(True)
                t2 = bpy.data.objects.get(&#34;Axis2&#34;)
                t2.select_set(True)
                if zaxis:
                        t3 = bpy.data.objects.get(&#34;Axis3&#34;)
                        t3.select_set(True)
                bpy.ops.object.join()
                self.delete_base_cilinder()
                self.delete_base_cone()
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return t1
        #
        #
        #
        def draw_vector(self,origin=Vector([0,0,0]),vector=None,canonica=False,color=&#34;Black&#34;,scale=0.05,arrow=True,head_height=None,axis=0,name=&#34;Vector&#34;,positive=True):
                &#34;&#34;&#34;
                Draw the vector with components &#39;vector&#39; trough &#39;origin&#39;
                Parameters:

                   origin: point of the line

                   vector: components of the vector

                   canonica: if True, the components are in the canonical basis, else they are in the basis self.base. Finally,
                      self.rotation is applied

                   color: color of the vector

                   scale: scale of the cylinder

                   arrow: if True draws the vector itself

                   head_height: height of the head of the vector

                   head_scale: scale of the head of the vector

                   axis: if not zero, draw also the line generated by the vector

                   positive: if axis is not zero and positive is True, draw only the positive part of the line
                      generated by the vector
                &#34;&#34;&#34;
                if vector is None:
                        return None
                if isinstance(vector,Vector):
                        vec = vector
                else:
                        vec = Vector(vector)
                if isinstance(origin,Vector):
                        orig = origin
                else:
                        orig = Vector(origin)
                if vec.length == 0:
                        return None
                self.base_cilinder()
                self.base_cone()
                o = Vector([0,0,0])
                op = Vector(self.origin + orig)
                if color is not None:
                        color = Colors.color(color)
                v = vec
                if not canonica:
                        mat = Matrix(self.base)
                        mat.transpose()
                        v = mat @ vec

                lon =  (v - o).length
                if head_height is None:
                        head_height = 0.03*lon
                if head_height &gt; 0.25:
                        head_height = 0.25

                if arrow:
                        t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                        obj = t.copy()
                        obj.name = name
                        obj.data = obj.data.copy()
                        obj.location = o
                        obj.scale = (scale,scale,lon - 2 * head_height)
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if color is not None:
                                self.add_material(obj,color.name,color.r,color.g,color.b)
                        if self.rotation is not None:
                                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location = op
                        self.scene.collection.objects.link(obj)

                        t = bpy.data.objects.get(&#34;Arrow_cone&#34;)
                        obj2 = t.copy()
                        obj2.data = obj2.data.copy()
                        obj2.name = &#34;Arrow&#34;
                        obj2.location =  v - 2 * head_height * v / v.length
                        obj2.scale = (1.5*scale,1.5*scale,head_height)
                        obj2.rotation_mode = &#39;QUATERNION&#39;
                        obj2.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if color is not None:
                                self.add_material(obj2,color.name,color.r,color.g,color.b)
                        if self.rotation is not None:
                                obj2.rotation_quaternion.rotate(self.rotation.quaternion)
                                obj2.location.rotate(self.rotation.quaternion)
                        obj2.location = op + obj2.location
                        self.scene.collection.objects.link(obj2)

                obj3 = None
                if axis != 0:
                        v = axis * v / v.length
                        t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                        obj3 = t.copy()
                        if not arrow:
                                obj3.name = name
                        else:
                                obj3.name = &#34;Generated&#34;
                        obj3.data = obj3.data.copy()
                        obj3.scale = (scale / 2,scale / 2,(2 * v).length)
                        obj3.rotation_mode = &#39;QUATERNION&#39;
                        obj3.rotation_quaternion = v.to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if color is not None:
                                self.add_material(obj3,color.name,color.r,color.g,color.b)
                        if self.rotation is not None:
                                obj3.rotation_quaternion.rotate(self.rotation.quaternion)
                        if positive:
                                obj3.location = op
                        else:
                                obj3.location = op - v
                        self.scene.collection.objects.link(obj3)

                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                if arrow:
                        bpy.context.view_layer.objects.active = obj
                elif axis != 0:
                        bpy.context.view_layer.objects.active = obj3
                if arrow:
                        obj.select_set(True)
                        obj2.select_set(True)
                if obj3 is not None:
                        obj3.select_set(True)
                if arrow:
                        bpy.ops.object.join()
                bpy.ops.object.shade_smooth()
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                self.delete_base_cilinder()
                self.delete_base_cone()
                bpy.context.view_layer.objects.active = None
                if arrow:
                        return obj
                if axis != 0:
                        return obj3
                self.set_origin()
                return None
        #
        #
        #
        def product_components(self,u,v):
                &#34;&#34;&#34;
                Computes the vectorial product u x v
                Parameters:
                   u, v: two Vectors
                &#34;&#34;&#34;
                if not isinstance(u,Vector):
                        u = Vector(u)
                if not isinstance(v,Vector):
                        v = Vector(v)
                return Vector([u.x * v.x,u.y * v.y,u.z * v.z])
        #
        #
        #
        def draw_line(self,start=[1,1,1],end=[10,10,10],scale=0.05,name=&#34;Line&#34;,color=&#34;Black&#34;,segment=False):
                &#34;&#34;&#34;
                Draws a line from the point start to the point end. The reference given by self.origin,
                self.rotation and the basis self.base is used
                Parameters:
                   start: starting point of the line

                   end: ending point of the line

                   scale: scale of the cylinder

                   name: name of the object

                   color: color of the vector

                   segment: if True, draw points start and end
                &#34;&#34;&#34;
                if start is None or end is None:
                        return
                self.base_cilinder()
                o = Vector([0,0,0])
                op = Vector(self.origin)
                if isinstance(start,Vector):
                        u = start
                else:
                        u = Vector(start)
                if isinstance(end,Vector):
                        v = end
                else:
                        v = Vector(end)
                mat = Matrix(self.base)
                mat.transpose()
                u = mat @ u
                v = mat @ v
                l = (v - u).length
                t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                obj = t.copy()
                obj.name = name
                obj.location = u
                obj.scale = (scale / 2,scale / 2,l)
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.rotation_quaternion = (v - u).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                if color is not None:
                        c = Colors.color(color)
                        self.add_material(obj,c.name,c.r,c.g,c.b)
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                obj.location = obj.location + op
                self.scene.collection.objects.link(obj)
                bpy.ops.object.shade_flat()
                self.delete_base_cilinder()
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.context.view_layer.objects.active = None
                if segment:
                        s1 = self.draw_point(radius=2*scale,location=end,name=&#34;End point&#34;,color=color,opacity=1.0)
                        s2 = self.draw_point(radius=2*scale,location=start,name=&#34;Start point&#34;,color=color,opacity=1.0)
                        self.join([obj,s1,s2])
                return obj
        #
        #
        #
        def draw_components(self,vector=None,color=&#34;Cyan&#34;,name=&#34;Components&#34;,scale=0.0075):
                &#34;&#34;&#34;
                Draws the components of the the vector &#39;vector&#39; in the reference given by self.origin,
                self.rotation and the basis self.base
                Parameters:
                   vector: the vector

                   color: color of the lines of components

                   name: name of the object

                   scale: scale of the lines
                &#34;&#34;&#34;
                if vector is None:
                        return
                if isinstance(vector,Vector):
                        v = vector
                else:
                        v = Vector(vector)
                mat = Matrix(self.base)
                mat.transpose()
                list = [[0,0,0],[1,0,0],[1,1,0],[0,1,0],[0,0,1],[1,0,1],[1,1,1],[0,1,1]]
                lines = [[0,1],[1,2],[2,3],[0,3],[0,4],[1,5],[2,6],[3,7],[4,5],[5,6],[6,7],[4,7]]
                vecs = [self.product_components(v,Vector(x)) for x in list]
                count = 0
                for first, last in lines:
                        if count == 0:
                                this = name
                        else:
                                this = f&#34;Line{count}&#34;
                        count += 1
                        self.draw_line(start=vecs[first],end=vecs[last],scale=scale,name=this,color=color)
                t = bpy.data.objects.get(name)
                list = [t]
                for count in range(1,12):
                        obj = bpy.data.objects.get(f&#34;Line{count}&#34;)
                        if obj is not None:
                                list.append(obj)
                t = self.join(list)
                bpy.context.view_layer.objects.active = None
                return t
        #
        #
        #
        def draw_vectors(self,vectors=[],canonica=False,color=&#34;Black&#34;,scale=0.05,head_height=0.2,name=&#34;Vectors&#34;,axis=0):
                &#34;&#34;&#34;
                Draws a list of vectors.
                Parameters:
                   vectors: list of vectors

                   canonica: if True, the the vectors are expressed in the canonical basis.

                   color: color of the vectors

                   scale: scale of the cylinder

                   head_height: height of the head of the vector

                   axis: if not zero, draw also the line generated by every vector
                &#34;&#34;&#34;
                if len(vectors) == 0:
                        return
                count = 0
                for v in vectors:
                        if count == 0:
                                this = name
                        else:
                                this = f&#34;Vector{count}&#34;
                        count += 1
                        t = self.draw_vector(vector=v,canonica=canonica,color=color,scale=scale,head_height=head_height,axis=axis,name=this)
                t = bpy.data.objects.get(name)
                list = [t]
                for count in range(1,len(vectors)+1):
                        obj = bpy.data.objects.get(f&#34;Vector{count}&#34;)
                        if obj is not None:
                                list.append(obj)
                t = self.join(list)
                return t
        #
        #
        #
        def draw_plane(self,normal=None,base=None,sizex=10,sizey=10,color=&#34;AzureBlueDark&#34;,name=&#39;Plane&#39;,opacity=1.0,thickness=0.01):
                &#34;&#34;&#34;
                Draws a plane with normal vector or base vectors. It passes through the point self.origin.
                Only normal or base can be not None
                Parameters:
                   normal: normal vector to the plane

                   base: list of two independent vectors

                   sizex: x-size of the plane

                   sizey: y-size of the plane

                   color: color of the plane

                   name: name of the plane

                   opacity: opacity of the plane

                   thickness: thickness of the plane
                &#34;&#34;&#34;
                if sizex == 0.0:
                        return
                bpy.ops.mesh.primitive_plane_add(size=sizex,enter_editmode=True,location=(0, 0, 0))
                bpy.context.object.name = name
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj = bpy.data.objects.get(name)
                if sizey is not None and sizey != 0.0:
                        t = sizey / sizex
                        obj.scale = [1,t,1]
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                if normal is not None and base is not None:
                        return
                if base is not None:
                        if len(base) != 2:
                                return
                        if isinstance(base[0],Vector):
                                v1 = base[0]
                        else:
                                v1 = Vector(base[0])
                        if isinstance(base[1],Vector):
                                v2 = base[1]
                        else:
                                v2 = Vector(base[1])

                        if self.base is None:
                                normal = v1.cross(v2)
                        else:
                                u1 = v1[0]*self.base[0] + v1[1]*self.base[1] + v1[2]*self.base[2]
                                u2 = v2[0]*self.base[0] + v2[1]*self.base[1] + v2[2]*self.base[2]
                                normal = u1.cross(u2)
                if normal is not None and normal != Vector([0,0,0]):
                        z = Vector([0,0,1])
                        quaternion = z.rotation_difference(normal)
                        obj.rotation_quaternion.rotate(quaternion)
                        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def simple_curve(self,f=None,tmin=0.0,tmax=1.0,steps=25,name=&#34;Simple curve&#34;,symmetry=None,draw=False):
                &#34;&#34;&#34;
                Return a curve defined by the parametrization f
                Parameters:
                   f: Parametrization of the curve

                   tmin: minimum value of the parameter

                   tmax: maximum value of the parameter

                   steps: number of steps

                   name: name of the curve

                   symmetry: None or a value in the list (&#39;XY&#39;,&#39;XZ&#39;,&#39;YZ&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;,&#39;O&#39;). Symmetry of the curve

                   draw: if True, the curve is drawn
                &#34;&#34;&#34;
                if f is None:
                        return None

                delta = (tmax - tmin)/steps
                t = tmin
                bm = bmesh.new()
                verts = []
                verts2 = []

                for k in range(steps + 1):
                        p = f(t)
                        q = None
                        verts.append(bm.verts.new(p))
                        if symmetry == &#39;XY&#39;:
                                q = (p[0],p[1],-p[2])
                        elif symmetry == &#39;XZ&#39;:
                                q = (p[0],-p[1],p[2])
                        elif symmetry == &#39;YZ&#39;:
                                q = (-p[0],p[1],p[2])
                        elif symmetry == &#39;X&#39;:
                                q = (p[0],-p[1],-p[2])
                        elif symmetry == &#39;Y&#39;:
                                q = (-p[0],p[1],-p[2])
                        elif symmetry == &#39;Z&#39;:
                                q = (-p[0],-p[1],p[2])
                        elif symmetry == &#39;O&#39;:
                                q = (-p[0],-p[1],-p[2])

                        if q is not None:
                                verts2.append(bm.verts.new(q))
                        t += delta
                        if t &gt; tmax:
                                t = tmax

                for i in range(len(verts) - 1):
                        bm.edges.new([verts[i], verts[i+1]])
                        if len(verts2) &gt; 0:
                                bm.edges.new([verts2[i], verts2[i+1]])

                me = bpy.data.meshes.new(&#39;placeholder_mesh&#39;)
                obj = bpy.data.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()

                if draw:
                        self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_elliptic_paraboloid(self,a=0.5,xmin=0.0,xmax=3.0,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;EllipticParaboloid&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws an elliptic paraboloid from the parabola z=a*t^2
                Parameters:
                   a: coefficient of the parabola

                   xmin: minimum value of x

                   xmax: maximum value of x

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                obj = self.simple_curve(f=lambda t:(t,0,a*t**2),tmin=xmin,tmax=xmax,steps=steps,name=name)
                modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                modifier.angle = 2 * math.pi
                modifier.steps = 128
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                self.scene.collection.objects.link(obj)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_one_sheet_hyperboloid(self,a=2.0,b=2.0,xmin=math.sqrt(2),xmax=5.0,steps=256,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperboloidOneSheet&#34;,opacity=1.0,thickness=0.05):
                r&#34;&#34;&#34;
                Draws a one sheet hyperboloid from the hyperbole z = \pm a*sqrt(x^2-b) in the XZ plane
                Parameters:
                   a, b: coefficients of the hyperbole

                   xmin: minimum value of x

                   xmax: maximum value of x

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                if xmin &lt; math.sqrt(b):
                        xmin = math.sqrt(b)
                delta = (xmax - xmin) / steps
                x = xmax
                bm = bmesh.new()
                verts = []

                for k in range(steps + 1):
                        if x &lt; math.sqrt(b):
                                z = 0.0
                        else:
                                z = - a * math.sqrt(x**2 - b)
                        verts.append(bm.verts.new((x,0,z)))
                        x -= delta
                x = math.sqrt(b)
                for k in range(steps):
                        x += delta
                        if x**2 &lt; b:
                                z = 0.0
                        else:
                                z = a * math.sqrt(x**2 - b)
                        verts.append(bm.verts.new((x,0,z)))

                for i in range(len(verts) - 1):
                        bm.edges.new([verts[i], verts[i+1]])

                me = self.meshes.new(&#39;placeholder_mesh&#39;)
                obj = self.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()
                modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                modifier.angle = 2 * math.pi
                modifier.steps = 128
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_two_sheets_hyperboloid(self,a=2.0,b=1.0,xmin=0.0,xmax=5.0,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperboloidTwoSheets&#34;,opacity=1.0,thickness=0.05):
                r&#34;&#34;&#34;
                Draws a two sheet hyperboloid from the hyperbole z = \pm a * math.sqrt(x**2+b) in the XZ plane
                Parameters:
                   a, b: coefficients of the hyperbole

                   xmin: minimum value of x

                   xmax: maximum value of x

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                delta = (xmax - xmin) / steps
                x = xmax
                bm = bmesh.new()
                verts = []
                count = 2 * steps + 2
                sign = 1
                for k in range(count):
                        if k == steps + 1:
                                sign = -1
                        z = sign * a * math.sqrt(x**2+b)
                        verts.append(bm.verts.new((x,0,z)))
                        if k == steps and xmin &gt; 0:
                                x = xmin
                        else:
                                x = x - sign * delta
                        if k == 0 or k == steps + 1:
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;placeholder_mesh&#39;)
                obj = self.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()

                modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                modifier.angle = 2 * math.pi
                modifier.steps = 128
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_cone(self,a=1.0,xmin=0.0,xmax=5.0,steps=50,scale=[1,1,1],half=False,color=&#34;AzureBlueDark&#34;,name=&#34;Cone&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws a cone from the line z = a*x in the XZ plane
                Parameters:
                   a: slope of the line

                   xmin: minimum value of x

                   xmax: maximum value of x

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   half: if True, draws half cone

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                delta = (xmax - xmin) / steps
                x = xmax
                bm = bmesh.new()
                verts = []
                count = 2 * steps + 2
                if xmin == 0.0:
                        count = 2 * steps + 1
                if half:
                        count = steps + 1
                for k in range(count):
                        z = a * x
                        verts.append(bm.verts.new((x,0,z)))
                        if k == steps and xmin &gt; 0:
                                x = - xmin
                        else:
                                x -= delta
                        if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;placeholder_mesh&#39;)
                obj = self.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()

                modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                modifier.angle = 2 * math.pi
                modifier.steps = 128
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_parabolic_cylinder(self,p=0.25,xmin=0.0,xmax=6.0,length=20,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;ParabolicCylinder&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws a parabolic cylinder from the parabola z=p*x^2 in the XZ plane
                Parameters:
                   p: coefficient of the parabola

                   xmin: minimum value of x

                   xmax: maximum value of x

                   length: length in the Y direction

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                delta = (xmax - xmin) / steps
                x = xmax
                bm = bmesh.new()
                verts = []
                count = 2 * steps + 2
                if xmin == 0.0:
                        count = 2 * steps + 1
                for k in range(count):
                        z = p * x**2
                        verts.append(bm.verts.new((x,0,z)))
                        if k == steps and xmin &gt; 0:
                                x = - xmin
                        else:
                                x -= delta
                        if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;ParabolicCylinderMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()

                bpy.context.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = obj
                bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
                bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
                bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
                bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0, length, 0),&#34;constraint_axis&#34;:(False, True, False),&#34;use_accurate&#34;:True})
                bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj.select_set(True)
                bpy.ops.transform.translate(value=(0, -length/2, 0),constraint_axis=(False, True, False))
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                obj.select_set(False)

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_hyperbolic_cylinder(self,a=1.0,b=4.0,xmin=2.0,xmax=6.0,length=20,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicCylinder&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws an hyperbolic cylinder from the hyperbole y = a * sqrt(x**2 - b) in the XY plane
                Parameters:
                   a, b: coefficients of the hyperbole

                   xmin: minimum value of x

                   xmax: maximum value of x

                   length: length in the Z direction

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                if xmin &lt; math.sqrt(b):
                        xmin = math.sqrt(b)
                delta = (xmax-xmin)/steps
                bm = bmesh.new()
                verts = []
                count = 2 * steps + 2
                if xmin == 0.0:
                        count = 2 * steps + 1
                for q, d in [[1,0],[-1,count]]:
                        x = xmax
                        sign = 1
                        for k in range(count):
                                if k == steps + 1:
                                        sign = -1
                                if x &lt; math.sqrt(b):
                                        x = math.sqrt(b)
                                y = sign * a * math.sqrt(x**2 - b)
                                verts.append(bm.verts.new((q * x,y,0)))
                                if k == steps and xmin &gt; math.sqrt(b):
                                        x = xmin
                                else:
                                        x = x - sign * delta
                                if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                                        continue
                                bm.edges.new([verts[d + k-1], verts[d + k]])

                me = self.meshes.new(&#39;HyperboliclinderMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()

                self.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = obj
                bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
                bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
                bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
                bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0,0,length),&#34;constraint_axis&#34;:(False,False,True),&#34;use_accurate&#34;:True})
                bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj.select_set(True)
                bpy.ops.transform.translate(value=(0,0,-length/2),constraint_axis=(False,False,True))
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                obj.select_set(False)

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_elliptic_cylinder(self,a=8.0,b=5.0,amin=0.0,amax=2*math.pi,length=20,steps=200,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;EllipticCylinder&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws an eliptic cylinder from the ellipse
                  x = a*cos(t)
                  y = b*sin(t)
                in the XY plane
                Parameters:
                   a, b: coefficients of the ellipsw

                   amin: minimum value of the angle t

                   amax: maximum value of the angle t

                   length: length in the Z direction

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                if amin &lt; 0.0:
                        amin = 0.0
                if amax &gt; 2 * math.pi:
                        amax = 2 * math.pi
                delta = (amax-amin)/steps
                bm = bmesh.new()
                verts = []
                t = amin
                for k in range(steps + 1):
                        x = a * math.cos(t)
                        y = b * math.sin(t)
                        verts.append(bm.verts.new((x,y,0)))
                        t += delta
                        if k == 0:
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;EllipticCylinderMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()
                self.scene.collection.objects.link(obj)

                bpy.context.view_layer.objects.active = obj
                bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
                bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
                bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
                bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0,0,length),&#34;constraint_axis&#34;:(False,False,True),&#34;use_accurate&#34;:True})
                bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj.select_set(True)
                bpy.ops.transform.translate(value=(0,0,-length/2),constraint_axis=(False,False,True))
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                obj.select_set(False)

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_hyperbolic_paraboloid(self,a=0.2,b=0.4,xmax=10.0,ymax=10.0,steps=64,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicParaboloid&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws an hyperbolic paraboloid with equation z = a*x^2 - b*y^2
                Parameters:
                   a, b: coefficients of the parabolic hyperboloid

                   xmax: maximum  value of x

                   ymax: maxim value y

                   steps: numbers of steps to draw the parabola

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                equ = lambda x,y: (x,y,a*x**2-b*y**2)
                obj = self.draw_surface(eq=equ,umin=-xmax,umax=xmax,usteps=steps,vmin=-ymax,vmax=ymax,vsteps=steps,thickness=thickness,opacity=opacity,pmax=0,name=&#34;Hyperbolic paraboloid&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),wrap_u=False,wrap_v=False,close_v=False)
                obj.scale = scale
                return obj
        #
        #
        #
        def draw_ellipsoid(self,radius=5.0,scale=[1.2,1.8,0.8],color=&#34;AzureBlueDark&#34;,name=&#34;Ellipsoid&#34;,opacity=1.0,thickness=0.05):
                &#34;&#34;&#34;
                Draws en ellipsoid
                Parameters:
                   radius: radius of the sphere

                   scale: scaling factors in the X, Y and Z directions

                   color: color of the surface

                   name: name of the surface

                   opacity: opacity of the surface

                   thickness: thickness of the surface
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_uv_sphere_add(segments=128, ring_count=128, radius=radius, enter_editmode=False, location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                if self.defaultcolor is not None:
                        c = Colors.color(self.defaultcolor)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                obj.location = o
                obj.scale = scale
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.location = op
                bpy.ops.object.shade_smooth()
                obj.select_set(False)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_plane_surface(self,origin=None,normal=None,base=None,sizex=10,sizey=10,vectors=False,scalelines=0.05,scalevector=0.03,
                                                color=&#34;AzureBlueDark&#34;,linecolor=&#34;BlueDarkDull&#34;,vectorcolor=&#34;Black&#34;,name=&#34;Plane&#34;,opacity=1.0,thickness=0.01):
                &#34;&#34;&#34;
                Draws a plane with normal vector or base vectors. It passes through the point origin.
                Only normal or base can be not None
                Parameters:
                   origin: a point in the plane

                   normal: normal vector to the plane

                   base: list of two independent vectors

                   sizex: x-size of the plane

                   sizey: y-size of the plane

                   vectors: if True, draw the generators of the plane

                   scalelines: scale of the lines limiting the plane

                   scalevector: scale of the generators

                   color: color of the plane

                   linecolor: color of the lines limiting the plane

                   vectorcolor: color of the generators

                   name: name of the plane

                   opacity: opacity of the plane

                   thickness: thickness of the plane
                &#34;&#34;&#34;
                if normal is not None and base is not None:
                        return
                if normal is None and base is None:
                        return
                mat = Matrix(self.base)
                mat.transpose()
                if normal is not None:
                        if not isinstance(normal,Vector):
                                normal= Vector(normal)
                        normal = mat @ normal
                if base is not None:
                        if len(base) != 2:
                                return
                        if isinstance(base[0],Vector):
                                v1 = base[0]
                        else:
                                v1 = Vector(base[0])
                        if isinstance(base[1],Vector):
                                v2 = base[1]
                        else:
                                v2 = Vector(base[1])
                        v1 = mat @ v1
                        v2 = mat @ v2
                        normal = v1.cross(v2)

                if normal == Vector([0,0,0]):
                        return

                steps = 4
                delta = sizex / steps
                x = - sizex / 2
                bm = bmesh.new()
                verts = []
                for k in range(steps + 1):
                        verts.append(bm.verts.new((x,0,0)))
                        x += delta
                        if k == 0:
                                continue
                        bm.edges.new([verts[k-1], verts[k]])

                me = self.meshes.new(&#39;PlaneSurfaceMesh&#39;)
                obj = self.objects.new(&#39;PlaneSurface&#39;, me)
                bm.to_mesh(me)
                bm.free()

                bpy.context.scene.collection.objects.link(obj)
                bpy.context.view_layer.objects.active = obj
                bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
                bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
                bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
                bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0, sizey, 0),&#34;constraint_axis&#34;:(False, True, False),&#34;use_accurate&#34;:True})
                bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
                obj.select_set(True)
                bpy.ops.transform.translate(value=(0, -sizey/2, 0),constraint_axis=(False, True, False))
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
                obj.select_set(False)

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                if origin is not None:
                        if isinstance(origin,Vector):
                                op = op + mat @ origin
                        else:
                                op = op + mat @ Vector(origin)
                obj.location = o
                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                lines = None
                vecs = None
                s = 0.0
                nodes = [[1,1,0],[-1,1,0],[-1,-1,0],[1,-1,0]]
                nodes = [self.product_components(Vector([sizex / 2,sizey / 2,0]),Vector(x)) for x in nodes]
                edges = [[0,1],[1,2],[2,3],[3,0]]

                if scalelines &gt; 0.0:
                        aux = self.origin
                        self.origin = Vector([0,0,0])
                        objects = []
                        aux2 = self.base
                        self.reset_base()
                        for edge in edges:
                                l = self.draw_line(start=nodes[edge[0]],end=nodes[edge[1]],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)
                        self.set_origin(aux)
                        self.set_base(aux2)

                if lines is not None:
                        obj = self.join([obj,lines])

                if vectors:
                        vecs = self.draw_vectors(nodes,True,color=vectorcolor,scale=scalevector,head_height=0.1,name=&#34;Vectors&#34;,axis=0)

                if vecs is not None:
                        obj = self.join([obj,vecs])
                obj.name = name

                if isinstance(normal,Vector):
                        n = normal
                else:
                        n = Vector(normal)
                z = Vector([0,0,1])
                quaternion = z.rotation_difference(n)
                tmp = obj.rotation_quaternion
                quaternion = tmp @ quaternion
                obj.rotation_quaternion = quaternion
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_point(self,radius=0.1,location=(0,0,0),name=&#34;Point&#34;,color=&#34;Black&#34;,opacity=1.0):
                &#34;&#34;&#34;
                Draws a point (in the reference self.origin, self.base)
                Parameters:
                   radius: radius of the point

                   location: location of the point

                   name: name of the point

                   color: color of the point

                   opacity: opacity of the point
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_uv_sphere_add(segments=8, ring_count=8, radius=radius, enter_editmode=False, location=location)
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                if not isinstance(location,Vector):
                        location = Vector(location)
                mat = Matrix(self.base)
                mat.transpose()
                location = mat @ location

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = 0.1
                modifier.offset = 0.0
                c = Colors.color(color)
                op = Vector(self.origin)
                obj.location = op + location
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                bpy.ops.object.shade_smooth()
                obj.select_set(False)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_cube(self,origin=None,scale=[1,1,1],scalelines=0.05,vectors=False,color=&#34;Blue&#34;,linecolor=&#34;Red&#34;,vectorcolor=&#34;Black&#34;,name=&#39;Parallelepiped&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a rectangular parallelepiped
                Parameters:
                   origin: center of the parallelepiped

                   scale: scale of the sides of the parallelepiped

                   scalelines: scale of the edges of the parallelepiped

                   vectors: if True, draws vectors from the origin to the vertices

                   color: color of the parallelepiped

                   linecolor: color of the edges

                   vectorcolor: color of the vectors

                   name: name of the parallelepiped

                   opacity: opacity of the parallelepiped

                   thickness: thickness of the parallelepiped
                &#34;&#34;&#34;
                bpy.ops.mesh.primitive_cube_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)
                o = Vector([0,0,0])
                op = Vector(self.origin)
                if origin is not None:
                        if isinstance(origin,Vector):
                                op = op + origin
                        else:
                                op = op + Vector(origin)
                obj.location = o
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                vecs = None
                s = 0.0
                nodes = [[1+s,1+s,1+s],[-1-s,1+s,1+s],[-1-s,-1-s,1+s],[1+s,-1-s,1+s],
                                [1+s,1+s,-1-s],[-1-s,1+s,-1-s],[-1-s,-1-s,-1-s],[1+s,-1-s,-1-s]]
                nodes = [self.product_components(Vector(scale),Vector(x)) for x in nodes]
                edges =[[0,1],[1,2],[2,3],[3,0],[0,4],[1,5],[2,6],[3,7],[4,5],[5,6],[6,7],[7,4]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=op+nodes[edge[0]],end=op+nodes[edge[1]],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                if vectors:
                        vecs = self.draw_vectors(nodes,color=vectorcolor,scale=0.05,head_height=0.2,name=&#34;Vectors&#34;,axis=0)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                obj.scale = scale

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                obj.location = op
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                if lines is not None:
                        obj = self.join([obj,lines])

                if vecs is not None:
                        obj = self.join([obj,vecs])
                return obj
        #
        #
        #
        def ortoedre(self,centre=Vector([0,0,0]),costats=[6,10,8],scalelines=0.05,vectors=False,color=&#34;Blue&#34;,linecolor=&#34;Red&#34;,vectorcolor=&#34;Black&#34;,name=&#39;Ortoedre&#39;,opacity=1.0,thickness=0.0):
                if not isinstance(centre,Vector):
                        centre = Vector(centre)
                self.draw_cube(origin=centre,scale=costats,scalelines=scalelines,vectors=vectors,color=color,linecolor=linecolor,vectorcolor=vectorcolor,name=name,opacity=opacity,thickness=thickness)
        #
        #
        #
        def draw_parallelepiped(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],u3=[0,0,1],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Parallelepiped&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a parallelepiped
                Parameters:
                   origin: base vertex of the parallelepiped

                   u1, u2, u3: vectors that gives the edges

                   scalelines: scale of the edges of the parallelepiped

                   color: color of the parallelepiped

                   linecolor: color of the edges

                   name: name of the parallelepiped

                   opacity: opacity of the parallelepiped

                   thickness: thickness of the parallelepiped
                &#34;&#34;&#34;
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                if not isinstance(u3,Vector):
                        u3 = Vector(u3)

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2
                u3 = mat @ u3

                bpy.ops.mesh.primitive_cube_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                verts = obj.data.vertices
                verts[0].co = op
                verts[1].co = op + u3
                verts[2].co = op + u2
                verts[3].co = op + u2 + u3
                verts[4].co = op + u1
                verts[5].co = op + u1 + u3
                verts[6].co = op + u1 + u2
                verts[7].co = op + u1 + u2 + u3

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                s = 0.0
                edges =[[0,1],[0,2],[0,4],[1,3],[1,5],[2,3],[2,6],[3,7],[4,5],[4,6],[5,7],[6,7]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj
        #
        #
        #
        def draw_tetrahedron(self,origin=[0,0,0],u1=[2,0,0],u2=[2*math.cos(math.pi/3),2*math.sin(math.pi/3),0],u3=[(2+2*math.cos(math.pi/3))/3,2*math.sin(math.pi/3)/3,2],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Tetrahedron&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a tetrahedron
                Parameters:
                   origin: base vertex of the tetrahedron

                   u1, u2, u3: vectors that gives the edges

                   scalelines: scale of the edges of the tetrahedron

                   color: color of the tetrahedron

                   linecolor: color of the edges

                   name: name of the tetrahedron

                   opacity: opacity of the tetrahedron

                   thickness: thickness of the tetrahedron
                &#34;&#34;&#34;
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                if not isinstance(u3,Vector):
                        u3 = Vector(u3)

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2
                u3 = mat @ u3

                bpy.ops.mesh.primitive_solid_add()
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                verts = obj.data.vertices
                verts[0].co = op + u3
                verts[1].co = op
                verts[2].co = op + u1
                verts[3].co = op + u2

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                s = 0.0
                edges =[[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj
        #
        #
        #
        def draw_pyramid(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],u3=[0.5,0.5,1],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Pyramid&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a pyramid
                Parameters:
                   origin: base vertex of the pyramid

                   u1, u2, u3: vectors that gives the edges

                   scalelines: scale of the edges of the pyramid

                   color: color of the pyramid

                   linecolor: color of the edges

                   name: name of the pyramid

                   opacity: opacity of the pyramid

                   thickness: thickness of the pyramid
                &#34;&#34;&#34;
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                if not isinstance(u3,Vector):
                        u3 = Vector(u3)

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2
                u3 = mat @ u3

                bpy.ops.mesh.primitive_cone_add(radius1=1, radius2=0, depth=2, enter_editmode=False, align=&#39;WORLD&#39;,vertices=4)
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                verts = obj.data.vertices
                verts[0].co = op
                verts[1].co = op + u1
                verts[2].co = op + u1 + u2
                verts[3].co = op + u2
                verts[4].co = op + u3

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                s = 0.0
                edges =[[0,1],[0,3],[0,4],[1,2],[1,4],[2,3],[2,4],[3,4]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj
        #
        #
        #
        def draw_parallelogram(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Parallelogram&#39;,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a parallelogram
                Parameters:
                   origin: base vertex of the parallelogram

                   u1, u2: vectors that gives the edges

                   scalelines: scale of the edges of the parallelogram

                   color: color of the parallelogram

                   linecolor: color of the edges

                   name: name of the parallelogram

                   opacity: opacity of the parallelogram

                   thickness: thickness of the parallelogram
                &#34;&#34;&#34;
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2

                bpy.ops.mesh.primitive_plane_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)

                verts = obj.data.vertices
                verts[0].co = op
                verts[1].co = op + u1
                verts[2].co = op + u2
                verts[3].co = op + u1 + u2

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 0.0

                lines = None
                s = 0.0
                edges =[[0,1],[0,2],[1,3],[2,3]]
                if scalelines &gt; 0.0:
                        objects = []
                        for edge in edges:
                                l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                if lines is not None:
                        obj = self.join([obj,lines])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None

                return obj
        #
        # Draw a polygon
        #
        def draw_polygon(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],points=[[0,0],[1,0],[0,1]],scalelines=0.075,color=&#34;AzureBlueMedium&#34;,linecolor=&#34;AzureBlueDark&#34;,name=&#39;Polygon&#39;,opacity=1.0,thickness=0.0,vectors=None,scalevectors=0.01):
                &#34;&#34;&#34;
                Draws a polygon
                Parameters:
                   origin: base vertex of the polygon

                   u1, u2: base vectors for the polygon

                   points: list of coordinates of points. The coordinates are taken in the reference {origin; u1, u2}

                   scalelines: scale of the edges of the polygon

                   color: color of the polygon

                   linecolor: color of the edges

                   name: name of the polygon

                   opacity: opacity of the polygon

                   thickness: thickness of the polygon
                &#34;&#34;&#34;
                if len(points) &lt; 3:
                        return
                op = Vector(self.origin)
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                for i in range(len(points)):
                        if not isinstance(points[i],Vector):
                                points[i] = Vector(points[i])

                mat = Matrix(self.base)
                mat.transpose()
                u1 = mat @ u1
                u2 = mat @ u2

                bpy.ops.curve.simple(Simple_Type=&#39;Polygon&#39;,Simple_sides=len(points),align=&#39;WORLD&#39;,location=(0, 0, 0))
                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)
                bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)

                baricentre = Vector([0,0,0])
                verts = obj.data.splines[0].bezier_points
                for i in range(len(verts)):
                        verts[i].co = op + points[i][0] * u1 + points[i][1] * u2
                        baricentre += verts[i].co
                baricentre /= len(verts)

                for i in range(len(verts)):
                        verts[i].co -= baricentre
                obj.location = baricentre

                obj.select_set(True)
                bpy.ops.object.convert(target=&#39;MESH&#39;)

                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

                ps = [op + points[i][0] * u1 + points[i][1] * u2 for i in range(len(points))]
                lines = None
                if scalelines &gt; 0.0:
                        objects = []
                        for i in range(len(points)):
                                l = self.draw_line(start=ps[i],end=ps[(i + 1) % len(points)],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                                objects.append(l)
                        lines = self.join(objects)

                if vectors is not None:
                        old = self.origin
                        self.set_origin(op)
                        ps = [points[i][0] * u1 + points[i][1] * u2 for i in range(len(points))]
                        vecs = self.draw_vectors(ps,color=vectors,scale=scalevectors)
                        self.set_origin(old)


                if lines is not None:
                        obj = self.join([obj,lines])
                if vectors is not None:
                        obj = self.join([obj,vecs])

                obj.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                return obj
        #
        # Draw a regular polygon
        #
        def draw_regular_polygon(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],vertexs=5,radius=1,scalelines=0.075,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;RegularPolygon&#39;,opacity=1.0,thickness=0.0,vectors=None):
                &#34;&#34;&#34;
                Draws a regular polygon
                Parameters:
                   origin: base vertex of the polygon

                   u1, u2: base vectors for the polygon

                   vertexs: number of vertices of the polygon

                   radius: radius of the polygon

                   scalelines: scale of the edges of the polygon

                   color: color of the polygon

                   linecolor: color of the edges

                   name: name of the polygon

                   opacity: opacity of the polygon

                   thickness: thickness of the polygon
                &#34;&#34;&#34;
                angle = 2*math.pi/vertexs
                points = [[radius*math.cos(i*angle),radius*math.sin(i*angle)] for i in range(vertexs)]
                return self.draw_polygon(origin=origin,u1=u1,u2=u2,points=points,scalelines=scalelines,color=color,linecolor=linecolor,name=name,opacity=opacity,thickness=thickness,vectors=vectors,scalevectors=radius/400)
        #
        # Draw a triangle
        #
        def draw_triangle(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],points=[[0,0],[1,0],[0,1]],scalelines=0.075,color=&#34;AzureBlueMedium&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#34;Triangle&#34;,opacity=1.0,thickness=0.01):
                &#34;&#34;&#34;
                Draws a triangle. It&#39;s a polygon with three vertices
                Parameters:
                   origin: base vertex of the triangle

                   u1, u2: base vectors for the triangle

                   points: list of coordinates of points. The coordinates are taken in the reference {origin; u1, u2}

                   scalelines: scale of the edges of the triangle

                   color: color of the triangle

                   linecolor: color of the edges

                   name: name of the triangle

                   opacity: opacity of the triangle

                   thickness: thickness of the triangle
                &#34;&#34;&#34;
                if len(points) != 3:
                        return
                self.draw_polygon(origin=origin,u1=u1,u2=u2,points=points,scalelines=scalelines,color=color,linecolor=linecolor,name=name,opacity=opacity,thickness=thickness)
        #
        # Draw a triangle from vertices
        #
        def triangle(self,vertices=[[0,0,0],[1,0,0],[0,1,0]],scalelines=0.075,color=&#34;AzureBlueMedium&#34;,linecolor=&#34;Blue&#34;,name=&#34;Triangle&#34;,baricentre=False,factors=(2,2,-2),ortocentre=False,circumcentre=False,opacity=1.0,radius=0.03):
                &#34;&#34;&#34;
                Draws a triangle from the vertices
                Parameters:
                   vertices: vertices of the triangle

                   scalelines: scale of the edges of the triangle

                   color: color of the triangle

                   linecolor: color of the edges

                   name: name of the triangle

                   opacity: opacity of the triangle

                   thickness: thickness of the triangle
                &#34;&#34;&#34;
                if len(vertices) != 3:
                        return None
                if len(factors) != 3:
                        return None
                v = [Vector(x) for x in vertices]
                if ortocentre:
                        u1 = v[1]-v[0]
                        u2 = v[2]-v[0]
                        u3 = v[2] - v[1]
                        p0 = v[1] - u1.project(u3)
                        self.draw_line(start=v[0],end=v[0]+factors[0]*(p0-v[0]),scale=scalelines,name=&#34;Altura 1&#34;,color=&#34;White&#34;)
                        p1 = v[2] - u3.project(u2)
                        self.draw_line(start=v[1],end=v[1]+factors[1]*(p1-v[1]),scale=scalelines,name=&#34;Altura 2&#34;,color=&#34;White&#34;)
                        p2 = v[0] + u2.project(u1)
                        self.draw_line(start=v[2],end=v[2]+factors[2]*(p2-v[2]),scale=scalelines,name=&#34;Altura 3&#34;,color=&#34;White&#34;)

                if circumcentre:
                        u1 = v[1] - v[0]
                        u2 = v[2] - v[0]
                        u3 = v[2] - v[1]
                        w = u1.cross(u2)
                        w.normalize()
                        w01 = w.cross(u1)
                        w02 = w.cross(u2)
                        w12 = w.cross(u3)
                        m12 = (v[2] + v[1])/2
                        m01 = (v[0] + v[1])/2
                        m02 = (v[2] + v[0])/2
                        self.draw_line(start=m01,end=m01+factors[0]*w01,scale=scalelines,name=&#34;Mediatriu 1&#34;,color=&#34;White&#34;)
                        self.draw_line(start=m02,end=m02+factors[1]*w02,scale=scalelines,name=&#34;Mediatriu 2&#34;,color=&#34;White&#34;)
                        self.draw_line(start=m12,end=m12+factors[2]*w12,scale=scalelines,name=&#34;Mediatriu 3&#34;,color=&#34;White&#34;)
                        p1 = self.draw_point(radius=radius,location=m01,name=&#34;Punt mitjà 1&#34;)
                        p2 = self.draw_point(radius=radius,location=m02,name=&#34;Punt mitjà 2&#34;)
                        p3 = self.draw_point(radius=radius,location=m12,name=&#34;Punt mitjà 3&#34;)

                if baricentre:
                        m01 = (v[0]+v[1])/2
                        m02 = (v[0]+v[2])/2
                        m12 = (v[1]+v[2])/2
                        m = (v[0]+v[1]+v[2])/3
                        self.draw_line(start=v[0],end=m12,scale=scalelines,name=&#34;Mitjana 1&#34;,color=&#34;White&#34;)
                        self.draw_line(start=v[1],end=m02,scale=scalelines,name=&#34;Mitjana 2&#34;,color=&#34;White&#34;)
                        self.draw_line(start=v[2],end=m01,scale=scalelines,name=&#34;Mitjana 2&#34;,color=&#34;White&#34;)
                self.draw_triangle(origin=v[0],u1=v[1]-v[0],u2=v[2]-v[0],scalelines=scalelines,color=color,linecolor=linecolor,name=name,opacity=opacity,thickness=0.01)
        #
        # Draw a rectangle
        #
        def rectangle(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],scalelines=0.1,color=&#34;AzureBlueMedium&#34;,linecolor=&#34;AzureBlueDark&#34;,name=&#34;Rectangle&#34;,sizex=10,sizey=10,opacity=1.0,thickness=0.0):
                &#34;&#34;&#34;
                Draws a rectangle
                Parameters:
                   origin: base vertex of the rectangle

                   u1, u2: base vectors for the rectangle

                   scalelines: scale of the edges of the rectangle

                   color: color of the rectangle

                   linecolor: color of the edges

                   name: name of the rectangle

                   sizex,  sizey: sizes of the rectangle

                   opacity: opacity of the rectangle

                   thickness: thickness of the rectangle
                &#34;&#34;&#34;
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                if not isinstance(origin,Vector):
                        origin = Vector(origin)
                u1.normalize()
                u2.normalize()
                points = [(0,0),(sizex,0),(sizex,sizey),(0,sizey)]
                self.draw_polygon(origin=origin-sizex/2*u1-sizex/2*u2,u1=u1,u2=u2,points=points,scalelines=scalelines,color=color,linecolor=linecolor,name=name,opacity=opacity,thickness=thickness)
        #
        # Draw a list of points
        #
        def draw_points(self,points=[],name=&#39;Points&#39;,color=&#34;Blue&#34;,opacity=1):
                &#34;&#34;&#34;
                Draws a list of points
                Parameters:
                   points: list of points

                   name: name of the list of points

                   color: color of the points

                   opacity: opacity of the points
                &#34;&#34;&#34;
                bm = bmesh.new()
                verts = []
                for p in points:
                        verts.append(bm.verts.new(p))

                me = self.meshes.new(&#39;PointsMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()
                self.scene.collection.objects.link(obj)
                return obj
        #
        # Draw a mesh
        #
        def draw_mesh(self,mesh=None,name=&#39;Mesh&#39;,color=&#34;Blue&#34;,opacity=1):
                &#34;&#34;&#34;
                Draws a mesh. This function is used by other functions
                Parameters:
                   mesh: the mesh to be drawn

                   name: name of the mesh

                   color: color of the mesh

                   opacity: opacity of the mesh
                &#34;&#34;&#34;
                bm = bmesh.new()
                verts = []
                for p in mesh.points:
                        verts.append(bm.verts.new(p))
                edges = [[0,1],[1,2],[2,3],[3,0]]
                for s in mesh.simplices:
                        for e in edges:
                                v = Vector(mesh.points[s[e[0]]]) - Vector(mesh.points[s[e[1]]])
                                edge = [verts[s[e[0]]],verts[s[e[1]]]]
                                try:
                                        bm.edges.new(edge)
                                except:
                                        pass
                me = self.meshes.new(&#39;PointsMesh&#39;)
                obj = self.objects.new(name, me)
                bm.to_mesh(me)
                bm.free()
                self.scene.collection.objects.link(obj)
                return obj
        #
        # Join a list a objects
        #
        def join(self,llista):
                &#34;&#34;&#34;
                Joins a list of objects
                Parameters:
                   llista: list of objects
                &#34;&#34;&#34;
                if len(llista) == 0:
                        return
                if len(llista) == 1:
                        return llista[0]
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.context.view_layer.objects.active = llista[0]
                for obj in llista:
                        obj.select_set(True)
                bpy.ops.object.join()
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                return llista[0]
        #
        # Vectors to quaternion
        #
        def vectors_to_quaternion(self,u1=Vector([1,0,0]),u2=Vector([0,1,0])):
                &#34;&#34;&#34;
                Returns the quaternion correspondint to the base {v1,v2,v3}
                u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
                       v1 = u1
                           v2 = u2 - u2.project(v1)
                           v1.normalize()
                           v2.normalize()
                           v3 = v1.cross(v2)
                &#34;&#34;&#34;
                if isinstance(u1,Vector):
                        v1 = u1
                else:
                        v1 = Vector(u1)
                if isinstance(u2,Vector):
                        v2 = u2
                else:
                        v2 = Vector(u2)
                v2 = v2 - v2.project(v1)
                v1.normalize()
                v2.normalize()
                v3 = v1.cross(v2)
                mat = Matrix([v1,v2,v3])
                mat.transpose()
                return mat.to_quaternion()
        #
        # Draw an ellpsoid
        #
        def ellipsoid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Ellipsoid&#34;,cmax=15,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
                &#34;&#34;&#34;
                Draws an ellipsoid
                Parameters:
                   o: center of the ellipsoid

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
                       v1 = u1
                           v2 = u2 - u2.project(v1)
                           v1.normalize()
                           v2.normalize()
                           v3 = v1.cross(v2)

                   a2, b2, c2: squares of semi-axes of the ellipsoid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 + z&#39;^2/c^2 = 1

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the ellipsoid

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -pmax and pmax

                   thickness: thickness of the ellipsoid

                   opacity: opaccity of the ellipsoid

                   preserve: Keep self.origin and self.base as the principal reference
                &#34;&#34;&#34;
                axis1 = None
                axis2 = None
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        axis2 = self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                c = math.sqrt(c2)
                el = self.draw_ellipsoid(radius=1,scale=[a,b,c],color=color,name=name,thickness=thickness,opacity=opacity)
                if not preserve:
                        self.set_origin()
                        self.set_base()
                        self.set_rotation()
                return axis1, axis2, el
        #
        #
        #
        def sphere(self,o=[0,0,0],r2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Sphere&#34;,cmax=15,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
                &#34;&#34;&#34;
                Draws a sphere of center &#39;o&#39; and radius squared equal to &#39;r2&#39;
                Parameters:
                   o: center of the sphere

                   r2: radius of the sphere squared

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the sphere

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the sphere

                   opacity: opacity of the sphere

                   preserve: Keep self.origin and self.base as the principal reference
                &#34;&#34;&#34;
                u1 = Vector([1,0,0])
                u2 = Vector([0,1,0])
                return self.ellipsoid(o=o,u1=u1,u2=u2,a2=r2,b2=r2,c2=r2,principal=principal,canonica=canonica,color=color,name=name,cmax=cmax,pmax=pmax,thickness=thickness,opacity=opacity,preserve=preserve)
        #
        #
        #
        def one_sheet_hyperboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;OneSheetHyperboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
                &#34;&#34;&#34;
                Draws an one sheet hyperboloid
                Parameters:
                   o: center of the hyperboloid

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = 1

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the hyperboloid

                   xmax: maximum value of the x coordinate

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the hyperboloid

                   opacity: opacity of the hyperboloid

                   preserve: Keep self.origin and self.base as the principal reference
                &#34;&#34;&#34;
                axis1 = None
                axis2 = None
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        axis2 = self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                c = math.sqrt(c2)
                if xmax is None:
                        xmax=10.0/a + 2
                xmax /= a
                hy = self.draw_one_sheet_hyperboloid(a=1.0,b=1.0,xmin=1.0,xmax=xmax,scale=[a,b,c],color=color,name=name,thickness=thickness,opacity=opacity)
                if not preserve:
                        self.set_origin()
                        self.set_base()
                        self.set_rotation()
                return axis1, axis2, hy
        #
        #
        #
        def two_sheets_hyperboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;TwoSheetParaboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
                &#34;&#34;&#34;
                Draws a two sheets hyperboloid
                Parameters:
                   o: center of the hyperboloid

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = -1

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the hyperboloid

                   xmax: maximum value of the x coordinate

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the hyperboloid

                   opacity: opacity of the hyperboloid

                   preserve: Keep self.origin and self.base as the principal reference
                &#34;&#34;&#34;
                axis1 = None
                axis2 = None
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        axis2 = self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                c = math.sqrt(c2)
                if xmax is None:
                        xmax = 5.0/a + 2
                xmax /= a
                hy = self.draw_two_sheets_hyperboloid(a=1.0,b=1.0,xmin=0.0,xmax=xmax,color=color,scale=[a,b,c],name=name,thickness=thickness,opacity=opacity)
                if not preserve:
                        self.set_origin()
                        self.set_base()
                        self.set_rotation()
                return axis1, axis2, hy
        #
        #
        #
        def cone(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,half=False,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Cone&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
                &#34;&#34;&#34;
                Draws a cone
                Parameters:
                   o: center of the cone

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   a2, b2, c2: squares of semi-axes of the cone. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = 0

                   half: if True draws half cone

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the cone

                   xmax: maximum value of the x coordinate

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -pmax and pmax

                   thickness: thickness of the cone

                   opacity: opacity of the cone

                   preserve: Keep self.origin and self.base as the principal reference
                &#34;&#34;&#34;
                axis1 = None
                axis2 = None
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                c = math.sqrt(c2)
                if xmax is None:
                        xmax = 10.0/a + 2
                xmax /= a
                co = self.draw_cone(a=1.0,xmin=0.0,xmax=xmax,steps=50,half=half,color=color,scale=[a,b,c],name=name,thickness=thickness,opacity=opacity)
                if not preserve:
                        self.set_origin()
                        self.set_base()
                        self.set_rotation()
                return axis1, axis2, co
        #
        #
        #
        def hyperbolic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Hyperbolic Cylinder&#34;,xmax=None,zmax=15,cmax=15,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
                &#34;&#34;&#34;
                Draws an hyperbolic cylinder
                Parameters:
                   o: center of the hyperbolic cylinder

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   a2, b2: squares of semi-axes of the hyperbolic cylinder. The equation is x&#39;^2/a^2 - y&#39;^2/b^2 = 1

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the hyperbolic cylinder

                   xmax: maximum value of the x coordinate

                   zmax: the hyperbolic cylinder is drawn between -zmax and zmax

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the hyperbolic cylinder

                   opacity: opacity of the hyperbolic cylinder

                   preserve: Keep self.origin and self.base as the principal reference
                &#34;&#34;&#34;
                if cmax &lt; zmax + 2:
                        cmax = zmax + 2
                axis1 = None
                axis2 = None
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        axis2 = self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                if xmax is None:
                        xmax = 5.0/a + 2
                xmax /= a
                hy = self.draw_hyperbolic_cylinder(a=1.0,b=1.0,xmin=1.0,xmax=xmax,length=2*zmax,steps=128,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)
                if not preserve:
                        self.set_origin()
                        self.set_base()
                        self.set_rotation()
                return axis1, axis2, hy
        #
        #
        #
        def elliptic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;EllipticCylinder&#34;,zmax=20,cmax=20,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
                &#34;&#34;&#34;
                Draws an elliptic cylinder
                Parameters:
                   o: center of the elliptic cylinder

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   a2, b2: squares of semi-axes of the elliptic cylinder. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 = 1

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the elliptic cylinder

                   zmax: the elliptic cylinder is drawn between -zmax and zmax

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the elliptic cylinder

                   opacity: opacity of the elliptic cylinder

                   preserve: Keep self.origin and self.base as the principal reference
                &#34;&#34;&#34;
                axis1 = None
                axis2 = None
                if cmax &lt; zmax + 2:
                        cmax = zmax + 2
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        axis2 = self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                el = self.draw_elliptic_cylinder(a=1.0,b=1.0,length=2*zmax,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)
                if not preserve:
                        self.set_origin()
                        self.set_base()
                        self.set_rotation()
                return axis1, axis2, el
        #
        #
        #
        def elliptic_paraboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;EllipticParaboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
                &#34;&#34;&#34;
                Draws an elliptic paraboloid
                Parameters:
                   o: vertex of the elliptic paraboloid

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   a2, b2: squares of semi-axes of the elliptic paraboloid. The equation is z = x&#39;^2/a^2 + y&#39;^2/b^2

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the elliptic paraboloid

                   xmax: maximum value of the coordinate x

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the elliptic paraboloid

                   opacity: opacity of the elliptic paraboloid

                   preserve: Keep self.origin and self.base as the principal reference
                &#34;&#34;&#34;
                axis1 = None
                axis2 = None
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        axis2 = self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                if xmax is None:
                        xmax = 10.0/a
                xmax /= a
                el = self.draw_elliptic_paraboloid(a=1.0,xmin=0.0,xmax=xmax,steps=50,scale=[a,b,1],color=color,name=name,opacity=opacity,thickness=thickness)
                if not preserve:
                        self.set_origin()
                        self.set_base()
                        self.set_rotation()
                return axis1, axis2, el
        #
        #
        #
        def hyperbolic_paraboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicParaboloid&#34;,xmax=None,ymax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
                &#34;&#34;&#34;
                Draws an hyperbolic paraboloid
                Parameters:
                   o: vertex of the hyperbolic paraboloid

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   a2, b2: squares of semi-axes of the hyperbolic paraboloid. The equation is z = x&#39;^2/a^2 - y&#39;^2/b^2

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the elliptic paraboloid

                   xmax: maximum value of the coordinate x

                   ymax: maximum value of the coordinate y

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the hyperbolic paraboloid

                   opacity: opacity of the hyperbolic paraboloid

                   preserve: Keep self.origin and self.base as the principal reference
                &#34;&#34;&#34;
                axis1 = None
                axis2 = None
                a = math.sqrt(a2)
                b = math.sqrt(b2)
                if xmax is None:
                        xmax = 10.0/a + 2
                if ymax is None:
                        ymax = 10.0/b + 1
                xmax /= a
                ymax /= b
                hy = self.draw_hyperbolic_paraboloid(a=1.0,b=1.0,xmax=xmax,ymax=ymax,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)

                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                hy.rotation_mode = &#39;QUATERNION&#39;
                if self.rotation is not None:
                        hy.rotation_quaternion.rotate(self.rotation.quaternion)
                        hy.location.rotate(self.rotation.quaternion)
                hy.location = o
                if not preserve:
                        self.set_origin()
                        self.set_base()
                        self.set_rotation()
                return axis1, axis2, hy
        #
        #
        #
        def parabolic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],p=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;ParabolicCylinder&#34;,xmax=12,ymax=30,cmax=20,pmax=20,thickness=0.02,opacity=1.0,preserve=True):
                &#34;&#34;&#34;
                Draws an hyperbolic paraboloid
                Parameters:
                   o: vertex of the hyperbolic paraboloid

                   u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

                   p: Parameter of the cylinder z&#39; = x&#39;^2/(2*p)

                   principal: if True, the principal axis are drawn

                   canonica: if True, the canonical axis are drawn

                   color: color of the surface

                   name: name of the elliptic paraboloid

                   xmax: maximum value of the coordinate x

                   ymax: maximum value of the coordinate y

                   cmax: the canonical axis are drawn between -cmax and cmax

                   pmax: the principal axis are drawn between -cmax and cmax

                   thickness: thickness of the hyperbolic paraboloid

                   opacity: opacity of the hyperbolic paraboloid

                   preserve: Keep self.origin and self.base as the principal reference
                &#34;&#34;&#34;
                axis1 = None
                axis2 = None
                coef = 1.0
                q = self.vectors_to_quaternion(u1,u2)
                u = Quaternion([1,0,0,0])
                orig = [0,0,0]
                if q != u or o != orig:
                        if canonica:
                                if principal:
                                        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                                else:
                                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                elif canonica and not principal:
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if principal:
                        axis2 = self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
                coef = 1.0
                if p &lt; 0:
                        coef = -1
                xmax /= math.sqrt(2*coef*p)
                pa = self.draw_parabolic_cylinder(p=coef,xmin=0.0,xmax=xmax,length=ymax,color=color,name=name,scale=[math.sqrt(2*coef*p),1,1],thickness=thickness,opacity=opacity)
                if not preserve:
                        self.set_origin()
                        self.set_base()
                        self.set_rotation()
                return axis1, axis2, pa
        #
        #
        #
        def draw_simple_curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.02,color=&#34;White&#34;,name=&#34;Curve&#34;):
                &#34;&#34;&#34;
                Draws a parametric curve
                Parameters:
                   fun: the parametric function

                   tmin: minimum value of the parameter

                   tmax: maximum value of the parameter

                   steps: number of steps

                   thickness: thickness of the curve

                   color: color of the curve

                   name: name of the curve
                &#34;&#34;&#34;
                if fun is None:
                        return None
                delta = (tmax - tmin) / steps
                t = tmin

                curve = bpy.data.curves.new(&#39;myCurve&#39;, type=&#39;CURVE&#39;)
                curve.dimensions = &#39;3D&#39;
                curve.resolution_u = 2

                line = curve.splines.new(&#39;POLY&#39;)
                line.points.add(steps)

                for i in range(steps+1):
                        p = fun(t)
                        p.append(1)
                        line.points[i].co = p
                        t += delta

                obj = bpy.data.objects.new(name, curve)
                curve.bevel_depth = thickness

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
                self.scene.collection.objects.link(obj)
                return obj
        #
        #
        #
        def draw_curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,axis=False,zaxis=True,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0])):
                &#34;&#34;&#34;
                Draws a curve in a reference R&#39; determined by the origin o and basis {v1, v2, v3} constructed from u1 and u2
                Parameters:
                   fun: the parametric function

                   tmin: minimum value of the parameter

                   tmax: maximum value of the parameter

                   steps: number of steps

                   thickness: thickness of the curve

                   name: name of the curve

                   color: color of the curve

                   axis: if True draws the axis of the reference R&#39;

                   zaxis: if True draws the z&#39; axis

                   o: origin of the reference R&#39;

                   u1, u2: vectors to construct the basis {v1, v2, v3}
                &#34;&#34;&#34;
                if fun is None:
                        return None
                qt = self.vectors_to_quaternion(u1,u2)
                delta = (tmax - tmin) / steps
                t = tmin
                bm = bmesh.new()
                verts = []

                pmax = 0
                for k in range(steps + 1):
                        p = fun(t)
                        m = max(map(abs,p))
                        if m &gt; pmax:
                                pmax = m
                        verts.append(bm.verts.new(p))
                        t += delta
                        if t &gt; tmax:
                                t = tmax

                for i in range(len(verts) - 1):
                        bm.edges.new([verts[i], verts[i+1]])

                me = self.meshes.new(&#39;placeholder_mesh&#39;)
                obj = self.objects.new(name,me)
                bm.to_mesh(me)
                bm.free()

                modifier = obj.modifiers.new(type=&#39;SKIN&#39;,name = &#39;skin&#39;)
                for v in obj.data.skin_vertices[0].data:
                        v.radius = (thickness,thickness)

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
                self.set_origin(o)
                self.set_rotation(quaternion=qt)
                if self.rotation is not None:
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                if axis:
                        self.draw_base_axis(axis = pmax+3,positive=False,name=&#34;Referència escollida&#34;,zaxis=zaxis)
                self.scene.collection.objects.link(obj)
                bpy.ops.object.shade_smooth()
                obj.location = o
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_disk(self,center=Vector([0,0,0]),radius=5,u1=Vector([1,0,0]),u2=Vector([0,1,0]),thickness=0.01,name=&#34;Disc&#34;,color=&#34;AzureBlueDark&#34;):
                &#34;&#34;&#34;
                Draws a disc in a reference R&#39; determined by self.origin and self.base
                Parameters:
                   radius: radius of the disc

                   thickness: thickness of the surface

                   name: name of the curve

                   color: color of the curve
                &#34;&#34;&#34;
                self.base_disk()
                t = bpy.data.objects.get(&#34;Base_disk&#34;)
                obj = t.copy()
                obj.name = name
                self.delete_base_disk()
                if radius != 1.0:
                        obj.scale = (radius,radius,1)
                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
                qt = self.vectors_to_quaternion(u1,u2)
                self.set_rotation(quaternion=qt)
                if self.rotation is not None:
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        ### obj.location.rotate(self.rotation.quaternion)
                obj.location = center
                self.scene.collection.objects.link(obj)
                bpy.ops.object.shade_smooth()
                bpy.context.view_layer.objects.active = None
                obj.select_set(False)
                return obj
        #
        #
        #
        def curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,axis=False,zaxis=True,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),symmetry=None,change=False):
                &#34;&#34;&#34;
                Draws a curve in a reference R&#39; determined by the origin o and basis {v1, v2, v3} constructed from u1 and u2 and
                the symmetric curve or curves from the parameter &#39;symmetry&#39;
                Parameters:
                   fun: the parametric function

                   tmin: minimum value of the parameter

                   tmax: maximum value of the parameter

                   steps: number of steps

                   thickness: thickness of the curve

                   name: name of the curve

                   color: color of the curve

                   axis: if True draws the axis of the reference R&#39;

                   zaxis: if True draws the z&#39; axis

                   o: origin of the reference R&#39;

                   u1, u2: vectors to construct the basis {v1, v2, v3}

                   symmetry: list of values in (&#39;XY&#39;,&#39;XZ&#39;,&#39;YZ&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;,&#39;O&#39;). For every value S, draw the symmetric curve respect to S

                   change: if True, set the reference self.origin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                if fun is None:
                        return None
                obj = self.draw_curve(fun,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=name,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)

                if symmetry is None:
                        if change:
                                self.set_origin(o)
                                self.set_base([u1,u2],orthonormal=True)
                        return obj
                objs = [obj]
                if isinstance(symmetry,str):
                        symmetry = [symmetry]
                elif not isinstance(symmetry,list) and not isinstance(symmetry,tuple):
                        if change:
                                self.set_origin(o)
                                self.set_base([u1,u2],orthonormal=True)
                        return obj
                for s in symmetry:
                        namem = name + s
                        if s == &#39;XY&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (p[0],p[1],-p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;XZ&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (p[0],-p[1],p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;YZ&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (-p[0],p[1],p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;X&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (p[0],-p[1],-p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;Y&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (-p[0],p[1],-p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;Z&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (-p[0],-p[1],p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                        if s == &#39;O&#39;:
                                def f(t):
                                        p = fun(t)
                                        return (-p[0],-p[1],-p[2])
                                obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                                objs.append(obj2)
                if change:
                        self.set_origin(o)
                        self.set_base([u1,u2],orthonormal=True)
                return self.join(objs)
        #
        #
        #
        def draw_circle(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),axis=False,zaxis=False,radius=1,steps=128,thickness=0.01,name=&#34;Circle&#34;,color=&#34;White&#34;,fillcolor=None,change=False):
                &#34;&#34;&#34;
                Draws a circle of center &#39;center&#39; and radius &#39;radius&#39; in the plane determined by vectors u1 and u2
                Parameters:
                   center: center of the circle

                   u1, u2: vectors to construct the basis {v1, v2, v3}

                   axis: if True draws the axis of the reference R&#39;

                   zaxis: if True draws the z&#39; axis

                   radius: radius of the circle

                   steps: number of steps

                   thickness: thickness of the curve

                   name: name of the curve

                   color: color of the curve

                   change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                d = None
                if fillcolor is not None:
                        d = self.draw_disk(center=center,radius=radius,u1=u1,u2=u2,thickness=0.5*thickness,name=&#34;Disc&#34;,color=fillcolor)
                c = self.draw_curve(lambda t: (radius*math.cos(t),radius*math.sin(t),0),tmin=0.0,tmax=2*math.pi,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
                if change:
                        self.set_origin(center)
                        self.set_base([u1,u2],orthonormal=True)
                return c, d
        #
        #
        #
        def draw_ellipse(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,b=1,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Ellipse&#34;,color=&#34;White&#34;,change=False):
                &#34;&#34;&#34;
                Draws an ellipse of center &#39;center&#39; and semi-axes a and b in the plane determined by vectors u1 and u2
                Parameters:
                   center: center of the ellipse

                   u1, u2: vectors to construct the basis {v1, v2, v3}

                   a, b: semi-axes of the ellipse

                   axis: if True draws the axis of the reference R&#39;

                   zaxis: if True draws the z&#39; axis

                   steps: number of steps

                   thickness: thickness of the curve

                   name: name of the curve

                   color: color of the curve

                   change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                if change:
                        self.set_origin(center)
                        self.set_base([u1,u2],orthonormal=True)
                return self.draw_curve(lambda t: (a*math.cos(t),b*math.sin(t),0),tmin=0.0,tmax=2*math.pi,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
        #
        #
        #
        def draw_parabola(self,vertex=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,xmax=3.0,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Parabola&#34;,color=&#34;White&#34;,change=False):
                &#34;&#34;&#34;
                Draws a parabola of vertex &#39;vertex&#39; of equation y&#39;=ax&#39;^2 in the reference {vertex; v1, v2, v3} determined by vectors u1 and u2
                Parameters:
                   vertex: vertex of the parabola

                   u1, u2: vectors to construct the basis {v1, v2, v3}

                   a: coefficient of the parabola

                   xmax: maximum value of x&#39;

                   axis: if True draws the axis of the reference R&#39;

                   zaxis: if True draws the z&#39; axis

                   steps: number of steps

                   thickness: thickness of the curve

                   name: name of the curve

                   color: color of the curve

                   change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                if change:
                        self.set_origin(vertex)
                        self.set_base([u1,u2],orthonormal=True)
                return self.draw_curve(lambda t: (t,a*t**2,0),tmin=-xmax,tmax=xmax,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=vertex,u1=u1,u2=u2)
        #
        #
        #
        def draw_hyperbole(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,b=1,ymax=3.0,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Hyperbole&#34;,color=&#34;White&#34;,change=False):
                &#34;&#34;&#34;
                Draws an hyperbole of center &#39;center&#39; and semi-axes a and b in the plane determined by vectors u1 and u2
                Parameters:
                   center: center of the hyperbole

                   u1, u2: vectors to construct the basis {v1, v2, v3}

                   a, b: semi-axes of the hyperbole

                   ymax: maximum value of the y&#39;

                   axis: if True draws the axis of the reference R&#39;

                   zaxis: if True draws the z&#39; axis

                   steps: number of steps

                   thickness: thickness of the curve

                   name: name of the curve

                   color: color of the curve

                   change: if True, set the reference self.origin, self.base to {o; v1, v2, v3}
                &#34;&#34;&#34;
                c1 = self.draw_curve(lambda t: (a*math.sqrt(1+t**2/b**2),t,0),tmin=-ymax,tmax=ymax,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
                c2 = self.draw_curve(lambda t: (-a*math.sqrt(1+t**2/b**2),t,0),tmin=-ymax,tmax=ymax,axis=False,zaxis=False,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
                self.join([c1,c2])
                if change:
                        self.set_origin(center)
                        self.set_base([u1,u2],orthonormal=True)
                return c1
        #
        #
        #
        def draw_surface(self,eq=None,umin=-1,umax=1,usteps=64,vmin=-1,vmax=1,vsteps=64,thickness=0.02,opacity=1.0,pmax=10,name=&#34;Surface&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),wrap_u=False,wrap_v=False,close_v=False):
                &#34;&#34;&#34;
                Draws a parametric surface in the reference R&#39;
                Parameters:
                   eq: parametric equacion f(u,v)

                   umin: minimum value of u

                   umax: maximum value of u

                   usteps: steps in the u direction

                   vmin: minimum value of v

                   vmax: maximum value of v

                   vsteps: steps in the v direction

                   thickness: thickness of the surface

                   opacity: opacity of the surface

                   color: color of the surface

                   pmax: the principal axis are drawn between -cmax and cmax

                   name: name of the surface

                   color: color of the surface

                   axis: if True draw the axis of the reference {o, v1, v2, v3}

                   o: origin of the reference R&#39;

                   u1, u2: vectors to construct the basis {v1, v2, v3}

                   scale: scale coefficients

                   wrap_u: wrap the u coordinate

                   wrap_v: wrap the u coordinate

                   close_v: close the v coordinate
                &#34;&#34;&#34;
                if eq is None:
                        return

                q = self.vectors_to_quaternion(u1,u2)
                draw_parametric_surface(eq=eq,range_u_min=umin,range_u_max=umax,range_u_step=usteps,range_v_min=vmin,range_v_max=vmax,range_v_step=vsteps,name=name,wrap_u=wrap_u,wrap_v=wrap_v,close_v=close_v)

                bpy.context.object.name = name
                obj = bpy.data.objects.get(name)
                obj.show_wire = False

                modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                modifier.levels = 4
                modifier.subdivision_type = &#39;SIMPLE&#39;
                if thickness &gt; 0.0:
                        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                        modifier.thickness = thickness
                        modifier.offset = 1.0
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if self.rotation is not None:
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                if axis:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència escollida&#34;)

                bpy.ops.object.shade_smooth()
                obj.location = o
                obj.select_set(False)
                bpy.context.view_layer.objects.active = None
                return obj
        #
        #
        #
        def draw_function(self,f=None,xmin=-3,xmax=3,xsteps=64,ymin=-3,ymax=3,ysteps=64,thickness=0.02,opacity=1.0,pmax=10,name=&#34;Function&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0])):
                &#34;&#34;&#34;
                Draws a function of two variables f(x,y) i the reference R&#39; = {o, v1, v2, v3}
                Parameters:
                   f: the function of two variables f(x,y)

                   xmin: minimum value of x

                   xmax: maximum value of x

                   xsteps: steps in the x direction

                   ymin: minimum value of y

                   ymax: maximum value of y

                   ysteps: steps in the x direction

                   thickness: thickness of the surface

                   opacity: opacity of the surface

                   pmax: the axis are drawn between -pmax and pmax

                   name: name of the surface

                   color: color of the surface

                   axis: if True the axis of the reference R&#39; are drawn

                   o: origin of the reference R&#39;

                   u1, u2: vectors to construct the basis {v1, v2, v3}
                &#34;&#34;&#34;
                if f is None:
                        return None
                return self.draw_surface(eq=lambda x,y:(x,y,f(x,y)),umin=xmin,umax=xmax,usteps=xsteps,vmin=ymin,vmax=ymax,vsteps=ysteps,thickness=thickness,opacity=opacity,pmax=pmax,name=name,color=color,axis=axis,o=o,u1=u1,u2=u2,wrap_u=False,wrap_v=False,close_v=False)
        #
        #
        #
        def draw_vector_field(self,f=None,xmin=-3,xmax=3,xsteps=8,ymin=-3,ymax=3,ysteps=8,zmin=-3,zmax=3,zsteps=8,name=&#34;Vector Field&#34;,color=&#34;Red&#34;,scale=0.02,head_height=0.05):
                &#34;&#34;&#34;
                Draws a vector field
                Parameters:
                   f: the vector field

                   xmin: minimum value of x

                   xmax: maximum value of x

                   xsteps: steps in the x direction

                   ymin: minimum value of y

                   ymax: maximum value of y

                   ysteps: steps in the y direction

                   zmin: minimum value of z

                   zmax: maximum value of z

                   zsteps: steps in the z direction

                   name: name of the vector field

                   color: color of the vector field

                   scale: scale of the vectors

                   head_height: head height of the vectors
                &#34;&#34;&#34;
                if f is None:
                        return None
                xstep = (xmax - xmin)/xsteps
                ystep = (ymax - ymin)/ysteps
                zstep = (zmax - zmin)/zsteps
                if xstep == 0 or ystep == 0 or zstep == 0:
                        return None
                vectors = []
                count = 1
                x = xmin
                while x &lt;= xmax:
                        y = ymin
                        while y &lt;= ymax:
                                z = zmin
                                while z &lt;= zmax:
                                        o = Vector([x,y,z])
                                        v = f(x,y,z)
                                        if not isinstance(v,Vector):
                                                v = Vector(v)
                                        self.set_origin(o)
                                        vec = self.draw_vector(vector=v,color=color,name=f&#34;Vector{count}&#34;,scale=scale,head_height=head_height)
                                        if vec is not None:
                                                vectors.append(vec)
                                        z += zstep
                                        count += 1
                                y += ystep
                        x += xstep
                v = self.join(vectors)
                bpy.context.object.name = name
                return v
        #
        #
        #
        def revolution_surface(self,fun=None,tmin=0.0,tmax=1.0,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),pmax=0,steps=256,thickness=0.025,axis=&#39;Z&#39;,name=&#34;Revolution surface&#34;,color=&#34;AzureBlueDark&#34;):
                &#34;&#34;&#34;
                Draws a revolution surface from a curve in the reference R&#39;
                Parameters:
                   fun: parametric equacion of the curve

                   steps: number of steps

                   axis: axis of revolution. It must be &#39;X&#39;, &#39;Y&#39; or &#39;Z&#39;

                   o: origin of the reference R&#39;

                   u1, u2: vectors to construct the basis {v1, v2, v3}

                   pmax: the principal axis are drawn between -pmax and pmax

                   color: color of the surface
                &#34;&#34;&#34;
                if fun is None:
                        return None
                q = self.vectors_to_quaternion(u1,u2)
                obj = self.simple_curve(fun,tmin=tmin,tmax=tmax,steps=steps,name=name)
                m = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                m.levels = 4
                m.subdivision_type = &#39;SIMPLE&#39;
                m = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                m.thickness = thickness
                m.offset = 1.0
                m = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                m.angle = 2*math.pi
                m.steps = steps
                m.axis =  axis
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
                bpy.context.scene.collection.objects.link(obj)
                self.set_origin(o)
                self.set_rotation(quaternion=q)
                if self.rotation is not None:
                        obj.rotation_mode = &#39;QUATERNION&#39;
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj.location.rotate(self.rotation.quaternion)
                if pmax &gt; 0.0:
                        self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència R&#39;&#34;)
                bpy.ops.object.shade_smooth()
                obj.location = o
                obj.select_set(False)
                bpy.context.view_layer.objects.active = None
        #
        #
        #
        def animate_revolution_surface(self,fun=None,tmin=0.0,tmax=1.0,steps=256,curvethicknes=0.025,thickness=0.025,frames=3,angle=3,radians=False,axis=&#39;Z&#39;,origin=Vector([0,0,0]),line=0,canonica=0,symmetry=None,name=&#34;Revolution surface&#34;,color=&#34;AzureBlueDark&#34;,point=None):
                &#34;&#34;&#34;
                Draws and animates a revolution surface from a curve
                Parameters:
                   fun: parametric equacion of the curve

                   steps: number of steps to graw the curve

                   curvethicknes: thickness of the curve

                   frames: number of frames at each step of revolution

                   angle: step angle of the revolution

                   radians: if True, angle must be in radians

                   axis: axis of revolution. It must be &#39;X&#39;, &#39;Y&#39; or &#39;Z&#39;

                   origin: point of the axis of revolution

                   symmetry: symmetry used to draw the curve

                   name: name of the surface

                   color: color of the surface

                   point: if not None draw three points and a cercle. Must be a float between tmax and tmin
                &#34;&#34;&#34;
                if radians:
                        angle *= 180/math.pi
                stepsr = int(360/angle) + 1
                angle = 360/stepsr
                if fun is None:
                        return None

                def myfun(t):
                        return Vector(fun(t)) - origin

                if not isinstance(origin,Vector):
                        origin = Vector(origin)

                if axis == &#39;X&#39;:
                        r = Rotation(angle,Vector([1,0,0]))
                        d0 = Vector([1,0,0])
                        d1 = Vector([0,1,0])
                        d2 = Vector([0,0,1])
                elif axis == &#39;Y&#39;:
                        r = Rotation(angle,Vector([0,1,0]))
                        d0 = Vector([0,1,0])
                        d1 = Vector([0,0,1])
                        d2 = Vector([1,0,0])
                elif axis == &#39;Z&#39;:
                        r = Rotation(angle,Vector([0,0,1]))
                        d0 = Vector([0,0,1])
                        d1 = Vector([1,0,0])
                        d2 = Vector([0,1,0])
                else:
                        return None

                if point is not None:
                        try:
                                tp = 1.0 * point
                        except:
                                pass
                        if not isinstance(tp,float):
                                return None
                        if tp &lt; tmin or tp &gt; tmax:
                                tp = random.uniform(tmin,tmax)
                        zp = Vector(myfun(tp))
                        e = d1.cross(d2)
                        z0 = zp.project(e)

                if line &gt; 0:
                        self.draw_line(start=-line*d0,end=line*d0,scale=0.1,name=&#34;Eix de rotació&#34;)

                if canonica &gt; 0:
                        self.set_origin(-origin)
                        self.draw_base_axis(axis=canonica,positive=False,scale=0.05,name=&#34;Referència canònica&#34;)
                        self.set_origin()


                p2 = self.curve(myfun,tmin=tmin,tmax=tmax,steps=steps,thickness=curvethicknes,color=&#34;Red&#34;,symmetry=symmetry,name=&#34;Rotating curve&#34;)
                p1 = self.curve(myfun,tmin=tmin,tmax=tmax,steps=steps,thickness=1.05*curvethicknes,color=&#34;Blue&#34;,symmetry=symmetry,name=&#34;Curve&#34;)
                obj = self.simple_curve(myfun,tmin=tmin,tmax=tmax,steps=steps,name=name,symmetry=symmetry)

                if point is not None:
                        m1 = self.draw_point(radius=0.1,location=zp,name=&#34;Punt p0&#34;,color=&#34;Red&#34;)
                        m2 = self.draw_point(radius=0.2,location=zp,name=&#34;Punt p1&#34;,color=&#34;Black&#34;)
                        m3 = self.draw_point(radius=0.1,location=z0,name=&#34;Punt p2&#34;,color=&#34;Blue&#34;)
                        l1 = self.draw_line(start=z0,end=zp,scale=0.04,name=&#34;Línia 1&#34;,color=&#34;Black&#34;)
                        l2 = self.draw_line(start=z0,end=zp,scale=0.03,name=&#34;Línia 2&#34;,color=&#34;Red&#34;)
                        l1 = self.join([l1,m2])
                        self.draw_circle(center=z0,u1=d1,u2=d2,radius=(zp-z0).length,steps=128,thickness=0.005,name=&#34;Circle&#34;,color=&#34;Cyan&#34;)

                m = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
                m.levels = 4
                m.subdivision_type = &#39;SIMPLE&#39;
                m = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                m.thickness = thickness
                m.offset = 1.0
                m = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
                m.angle = 0.0
                m.steps = steps
                m.axis =  axis
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
                bpy.context.scene.collection.objects.link(obj)

                bpy.context.scene.frame_set(self.frame)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                obj.keyframe_insert(data_path=&#39;modifiers[&#34;Screw&#34;].angle&#39;,index=-1)
                p2.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if point is not None:
                        l1.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        # m2.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn = frames + self.frame
                w = Vector([-1,0,3])
                for i in range(0,stepsr):
                        bpy.context.scene.frame_set(fn)
                        p2.rotation_quaternion.rotate(r.quaternion)
                        p2.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        obj.modifiers[&#34;Screw&#34;].angle = 2 * (i+1) * math.pi / stepsr
                        obj.modifiers[&#34;Screw&#34;].steps = i+1
                        obj.keyframe_insert(data_path=&#39;modifiers[&#34;Screw&#34;].angle&#39;,index=-1)
                        if point is not None:
                                l1.rotation_quaternion.rotate(r.quaternion)
                                l1.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                                #m2.location.rotate(r.quaternion)
                                # m2.location = m2.location + w
                                #m2.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames
                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame
                bpy.context.view_layer.update()
                self.reset()
                bpy.context.scene.frame_set(0)
                bpy.ops.object.select_all(action=&#39;SELECT&#39;)
                bpy.ops.transform.translate(value=origin)
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        #
        # Helical motion or rotation of objects
        #
        def rotate_objects(self,objs=[],axis=&#39;Z&#39;,angle=None,frames=1,origin=Vector([0,0,0]),translation=0,rounds=1,length=25,stop=0,draw=False):
                &#34;&#34;&#34;
                Rotates an object around the axis
                Parameters:
                   objs: the list of objects

                   axis: it must be &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39; or a Vector

                   angle: angle of rotation

                   frames: number of frames between

                   origin: origin of rotation

                   translation: translation betwwen intial and final positions
                &#34;&#34;&#34;
                if objs is None or (not isinstance(objs,list) and not isinstance(objs,tuple)):
                        return None
                if not isinstance(origin,Vector):
                        origin = Vector(origin)
                if isinstance(axis,str):
                        axis = axis.strip().upper()
                if axis == &#39;X&#39;:
                        u = Vector([1,0,0])
                elif axis == &#39;Y&#39;:
                        u = Vector([0,1,0])
                elif axis == &#39;Z&#39;:
                        u = Vector([0,0,1])
                elif isinstance(axis,Vector):
                        u = axis
                else:
                        u = Vector(axis)

                if angle is None:
                        angle = 360
                else:
                        rounds = 1

                if draw:
                        self.draw_vector(origin=origin,vector=u,axis=length,positive=False,color=&#34;White&#34;)
                r = Rotation(1/int(frames),u)
                axis, alfa = r.to_axis_angle()
                axis.normalize()
                t =  translation / (alfa * int(frames) * angle) * u
                bpy.context.scene.frame_set(self.frame)
                for obj in objs:
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn = self.frame + 1
                for i in range(int(frames) * int(rounds) * angle):
                        for obj in objs:
                                bpy.context.scene.frame_set(fn)
                                obj.rotation_quaternion.rotate(r.quaternion)
                                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                                w = obj.location - origin
                                w.rotate(r.quaternion)
                                obj.location = origin + w + t
                                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += 1
                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame + stop
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()
        #
        # Rotation of a vector
        #
        def rotate_vector(self,vector=None,axis=&#39;Z&#39;,length=25,angle=360,stop=0):
                &#34;&#34;&#34;
                Rotates a vector around the axis
                Parameters:
                   vector: the vector

                   axis: it must be &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39; or a vector
                &#34;&#34;&#34;
                draw = False
                if vector is None:
                        return None
                if axis == &#39;X&#39;:
                        u = Vector([1,0,0])
                elif axis == &#39;Y&#39;:
                        u = Vector([0,1,0])
                elif axis == &#39;Z&#39;:
                        u = Vector([0,0,1])
                elif isinstance(axis,Vector):
                        u = axis
                else:
                        u = Vector(axis)
                self.draw_vector(vector=vector,color=&#34;Black&#34;,scale=0.1,name=&#34;Vector inicial&#34;)
                obj = self.draw_vector(vector=vector,color=&#34;Red&#34;,scale=0.1,name=&#34;Vector que gira&#34;)
                w1 = u.orthogonal().normalized()
                vec1 = vector.project(u)
                w3 = vec1.normalized()
                w2 = w3.cross(w1)
                a = vec1.length
                b = (vector-vec1).length
                p2 = b**2/a**2
                self.rotate_object(obj,u,angle=angle,stop=stop,length=length)
                self.cone(u1=w1,u2=w2,a2=p2,b2=p2,c2=1,half=True, principal=False,canonica=False,xmax=b,color=&#34;GrayLight&#34;,opacity=0.7,thickness=0.04)
        #
        # Rotation of a point
        #
        def rotate_point(self,punt=None,origen=Vector([0,0,0]),axis=&#39;Z&#39;,angle=360,length=20,stop=0,vectors=True):
                &#34;&#34;&#34;
                Rotates a point around an affine line
                Parameters:
                   point: the point

                   origen: a point of the affine line

                   axis: it must be &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39; or a vector

                   length: length of the
                &#34;&#34;&#34;
                draw = False
                if punt is None:
                        return None
                if axis == &#39;X&#39;:
                        u = Vector([1,0,0])
                elif axis == &#39;Y&#39;:
                        u = Vector([0,1,0])
                elif axis == &#39;Z&#39;:
                        u = Vector([0,0,1])
                elif isinstance(axis,Vector):
                        u = axis
                else:
                        u = Vector(axis)

                if not isinstance(origen,Vector):
                        origen = Vector(origen)

                self.draw_point(radius=0.2,location=punt,name=&#34;Blue&#34;,color=&#34;Blue&#34;)
                obj = self.draw_point(radius=0.2,location=punt,name=&#34;Red&#34;,color=&#34;Red&#34;)
                if vectors:
                        self.set_origin(origen)
                        self.draw_vector(vector=punt-origen,name=&#34;VBlack&#34;,color=&#34;Black&#34;)
                        obj2 = self.draw_vector(vector=punt-origen,name=&#34;VRed&#34;,color=&#34;Red&#34;)
                w1 = u.orthogonal().normalized()
                vec1 = (punt-origen).project(u)
                center = origen + vec1
                radius = (center-punt).length
                w3 = vec1.normalized()
                w2 = w3.cross(w1)
                a = vec1.length
                b = (punt-origen-vec1).length
                p2 = b**2/a**2
                self.reset()
                if vectors:
                        self.rotate_objects([obj,obj2],u,angle=angle,origin=origen,length=length,stop=stop,draw=True)
                else:
                        self.rotate_object(obj,u,origin=origen,angle=angle,stop=stop,length=length)
                self.draw_circle(center=center,u1=w1,u2=w2,radius=radius,name=&#34;Circumferència&#34;,steps=128,color=&#34;Yellow&#34;)
                self.cone(o=origen,u1=w1,u2=w2,a2=p2,b2=p2,c2=1,half=True, principal=False,canonica=False,xmax=b,color=&#34;GrayLight&#34;,opacity=0.25,thickness=0.01)
                self.reset()
        #
        #
        #
        def rotate_object_by_axis_angle(self,obj=None,axis=Vector([1,0,0]),angle=90,amax=15,frames=1,scaleaxis=0.075,local=False):
                &#34;&#34;&#34;
                Rotates an object around an angle &#39;angle&#39; around the axis
                Parameters:
                   obj: the object

                   axis: any non nul Vector

                   angle: the angle of rotation in degrees

                   frames: increment of the frame set

                   scaleaxis: scale value for draw_base_axis

                   local: if True the center of rotation is the location of the object
                &#34;&#34;&#34;
                if obj is None:
                        return None
                if isinstance(axis,Vector):
                        u = axis
                else:
                        u = Vector(axis)
                if u.length == 0.0 or angle &lt;= 1:
                        return

                self.draw_base_axis(axis = amax,scale=scaleaxis,positive=False,name=&#34;Base canònica&#34;)
                self.draw_vector(vector=u,scale=0.1,axis=amax,positive=False,color=&#34;White&#34;,name=&#34;Eix rotació&#34;)

                num = int(angle)
                alfa = angle / num
                r = Rotation(alfa,u)
                bpy.context.scene.frame_set(self.frame)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if not local:
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn = frames + self.frame

                for i in range(num):
                        bpy.context.scene.frame_set(fn)
                        obj.rotation_quaternion.rotate(r.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if not local:
                                w = obj.location
                                w.rotate(r.quaternion)
                                obj.location = w
                                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames
                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()
        #
        # Rotation by Euler&#39;s angles
        #
        def rotate_euler(self,obj=None,psi=0.0,theta=0.0,phi=0.0,frames=3,axis=&#39;ZXZ&#39;,amax=15,scaleaxis=0.075,reverse=False,local=False,stop=0,radians=False,canonica=True,positive=False):
                &#34;&#34;&#34;
                Rotates an object by the Euler angles psi, theta and phi
                Parameters:
                   object: the object

                   psi, theta, phi: the Euler angles expressed in degrees

                   axis: it must be &#39;XYZ&#39;, &#39;XZY&#39;, &#39;YXZ&#39;, &#39;YZX&#39;, &#39;ZXY&#39;, &#39;ZYX&#39;, &#39;XYX&#39;, &#39;XZX&#39;, &#39;YXY&#39;, &#39;YZY&#39;, &#39;ZXZ&#39; or &#39;ZYZ&#39;

                   amax: axis value for draw_base_axis

                   scaleaxis: scale value for draw_base_axis

                   local: if True the center of rotation is the location of the object

                   radians: if True, psi, theta and phi must be in radians

                   positive: if False and psi, theta or phi are greather than 180 degrees, they are converted
                             to negative angles
                &#34;&#34;&#34;
                def vector_from_axis(axis):
                        if axis == &#39;X&#39;:
                                return Vector([1,0,0])
                        if axis == &#39;Y&#39;:
                                return Vector([0,1,0])
                        if axis == &#39;Z&#39;:
                                return Vector([0,0,1])
                        return None

                if obj is None or axis is None:
                        return None

                if not isinstance(axis,str):
                        return None

                axis = axis.upper()
                if axis not in (&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,&#39;XYX&#39;,&#39;XZX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;):
                        return None

                u1 = vector_from_axis(axis[0])
                u2 = vector_from_axis(axis[1])
                u3 = vector_from_axis(axis[2])

                if radians:
                        psi *= 180/math.pi
                        theta *= 180/math.pi
                        phi *= 180/math.pi
                if positive:
                        if psi &lt; 0.0:
                                psi += 360
                        if theta &lt; 0.0:
                                theta += 360
                        if phi &lt; 0.0:
                                phi += 360
                else:
                        if psi &gt; 180.0:
                                psi -= 360
                        if theta &gt; 180.0:
                                theta -= 360
                        if phi &gt; 180.0:
                                phi -= 360

                if reverse:
                        self.set_colors([&#34;OrangeRedDark&#34;,&#34;Yellow&#34;,&#34;Magenta&#34;])
                        axis = self.draw_base_axis(axis=amax,scale=scaleaxis,positive=False,name=&#34;Eixos transformats&#34;)
                        obj = self.join([obj,axis])
                        u1, u2, u3 = u3, u2, u1
                        psi, theta, phi = phi, theta, psi
                        s = Rotation(psi,u1)
                        u2 = s.apply(u2)
                        u3 = s.apply(u3)
                        s = Rotation(theta,u2)
                        u3 = s.apply(u3)
                elif canonica:
                        self.draw_base_axis(axis=amax,scale=scaleaxis,positive=False,name=&#34;Base canònica&#34;)

                bpy.context.scene.frame_set(self.frame)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if not local:
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn = frames + self.frame
                if psi &gt; 0:
                        num = int(psi)
                elif psi &lt; 0:
                        num = int(-psi)
                alfa = psi / num
                r = Rotation(alfa,u1)
                for i in range(num):
                        bpy.context.scene.frame_set(fn)
                        obj.rotation_quaternion.rotate(r.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if not local:
                                w = obj.location
                                w.rotate(r.quaternion)
                                obj.location = w
                                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames

                if theta &gt; 0:
                        num = int(theta)
                elif theta &lt; 0:
                        num = int(-theta)
                alfa = theta / num
                r = Rotation(alfa,u2)
                for i in range(num):
                        bpy.context.scene.frame_set(fn)
                        obj.rotation_quaternion.rotate(r.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if not local:
                                w = obj.location
                                w.rotate(r.quaternion)
                                obj.location = w
                                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames

                if phi &gt; 0:
                        num = int(phi)
                elif phi &lt; 0:
                        num = int(-phi)
                alfa = phi / num
                r = Rotation(alfa,u3)
                for i in range(num):
                        bpy.context.scene.frame_set(fn)
                        obj.rotation_quaternion.rotate(r.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if not local:
                                w = obj.location
                                w.rotate(r.quaternion)
                                obj.location = w
                                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += frames

                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame + stop
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()
        #
        # Rotate objects or helical motion
        #
        def rotate_object(self,obj=None,axis=&#39;Z&#39;,frames=1,origin=Vector([0,0,0]),angle=360,localaxis=None,localangle=None,translation=0.0,rounds=1,stop=0,length=25,draw=True):
                &#34;&#34;&#34;
                Rotates an object around the axis
                Parameters:
                   obj: the object

                   axis: it must be &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39; or a Vector

                   frames: increment of the frame set

                   traslation: tranlation by round

                   local: if True the center of rotation is the location of the object
                &#34;&#34;&#34;
                if obj is None:
                        return None
                if not isinstance(origin,Vector):
                        origin = Vector(origin)
                if isinstance(axis,str):
                        axis = axis.strip().upper()
                if axis == &#39;X&#39;:
                        u = Vector([1,0,0])
                elif axis == &#39;Y&#39;:
                        u = Vector([0,1,0])
                elif axis == &#39;Z&#39;:
                        u = Vector([0,0,1])
                elif isinstance(axis,Vector):
                        u = axis
                else:
                        u = Vector(axis)

                if angle != 360:
                        rounds = 1

                line = None
                if localaxis is not None and localangle is not None:
                        old = self.origin
                        self.set_origin(obj.location)
                        l = obj.dimensions.length / 2
                        line = self.draw_vector(vector=localaxis,axis=l,scale=0.1,arrow=False,positive=False,color=&#34;Orange&#34;,name=&#34;Eix rotació local&#34;)
                        line.select_set(True)
                        bpy.ops.object.origin_set(type=&#39;ORIGIN_CENTER_OF_MASS&#39;, center=&#39;MEDIAN&#39;)
                        line.select_set(False)
                        self.set_origin(old)
                        lr = Rotation(localangle,localaxis)
                if draw:
                        self.set_origin(origin)
                        self.draw_vector(vector=u,axis=length,positive=False,color=&#34;White&#34;)
                        self.set_origin()
                r = Rotation(1/int(frames),u)
                axis, alpha = r.to_axis_angle()
                axis.normalize()
                t =  translation / (alpha * int(frames) * int(angle)) * axis
                bpy.context.scene.frame_set(self.frame)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn = self.frame + 1
                for i in range(int(frames) * int(rounds) * int(angle)):
                        bpy.context.scene.frame_set(fn)
                        if line is None:
                                obj.rotation_quaternion.rotate(r.quaternion)
                        else:
                                obj.rotation_quaternion.rotate(lr.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        w = obj.location - origin
                        w.rotate(r.quaternion)
                        obj.location = origin + w + t
                        if line is not None:
                                line.location = origin + w + t
                                line.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        fn += 1
                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame + stop
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()
        #
        #
        #
        def draw_frenet_curve(self,fun=None,var=None,tmin=0.0,tmax=1.0,radius=0.1,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,point=True,tangent=False,acceleration=False,normal=False,osculator=False,frenet=False,units=False,sizex=8,sizey=8,axis=10):
                &#34;&#34;&#34;
                Draws a curve and diferents elements related to the curve
                Parameters:
                   fun: the parametric function

                   var = parameter variable of the function fun

                   tmin: minimum value of the parameter

                   tmax: maximum value of the parameter

                   radius: radius of the point

                   steps: number of steps

                   frames: increment of the frame set

                   thickness: thickness of the curve

                   name: name of the curve

                   color: color of the curve

                   point: if True draw a point along the curve

                   tangent: if True draw the tangent vector along the curve

                   acceleration: if True draw the acceleration vector along the curve

                   normal: if True draw the normal vector along the curve

                   osculator: if True draw the osculating plane along the curve

                   frenet: if True draw the Frenet trihedron along the curve

                   units: if True normalize the tangent and normal vectors

                   sizex, sizey: sizes of the osculating plane

                   axis: length of the coordinate axis
                &#34;&#34;&#34;
                if fun is None:
                        return None

                self.draw_base_axis(axis=axis,positive=False)

                def _fun_(x):
                        return [u.subs(var,x) for u in fun]

                def frenet_quaternion(tangent,normal):
                        v1 = tangent.normalized()
                        v2 = normal.normalized()
                        v3 = v1.cross(v2)
                        return Matrix([v1,v2,v3]).transposed().to_quaternion()

                frames = 1
                curve = self.draw_curve(_fun_,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,color=color,axis=False)
                if not point and not tangent and not osculator and not frenet:
                        return curve

                T = [diff(u,var) for u in fun]
                #
                # Here is sqrt from sympy
                #
                Tnorm = math.sqrt(sum([u**2 for u in T]))
                A = [diff(u,var) for u in T]
                p0 = Vector([u.subs(var,tmin) for u in fun])
                v0 = Vector([N(u.subs(var,tmin)) for u in T])
                a0 = Vector([N(u.subs(var,tmin)) for u in A])
                n0 = a0 - a0.project(v0)
                q0 = frenet_quaternion(v0,n0)
                f0 = [Vector([1,0,0]),Vector([0,1,0]),Vector([0,0,1])]

                if units:
                        v0.normalize()
                        n0.normalize()
                bpy.context.scene.frame_set(self.frame)

                if point:
                        p = self.draw_point(radius=radius,location=p0,name=&#34;Punt&#34;,color=&#34;Black&#34;)
                        p.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                self.set_origin(p0)
                if tangent:
                        l = v0.length
                        if not units:
                                vp = 5*v0.normalized()
                        else:
                                vp = v0
                        if not units:
                                v = self.draw_vector(vector=vp,color=&#34;Red&#34;,scale=0.035,head_height=0.3)
                                v.scale.z *= l / 5.0
                        else:
                                v = self.draw_vector(vector=vp,color=&#34;Red&#34;,scale=0.035,head_height=0.2)
                        v.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        v.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        v.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if acceleration:
                        l = a0.length
                        ap = 5*a0.normalized()
                        a = self.draw_vector(vector=ap,color=&#34;Green&#34;,scale=0.035,head_height=0.2)
                        a.scale.z *= l / 5.0
                        a.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        a.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        a.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if normal:
                        l = n0.length
                        if not units:
                                np = 5*n0.normalized()
                        else:
                                np = n0
                        if not units:
                                n = self.draw_vector(vector=np,color=&#34;Red&#34;,scale=0.035,head_height=0.2)
                                n.scale.z *= l / 5.0
                        else:
                                n = self.draw_vector(vector=np,color=&#34;Red&#34;,scale=0.035,head_height=0.1)
                        n.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        n.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        n.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if osculator:
                        o = self.draw_plane_surface(base=[[1,0,0],[0,1,0]],color=&#34;GreenPaleDull&#34;,linecolor=&#34;GreenDarkDull&#34;,sizex=sizex,sizey=sizey,opacity=0.25)
                        o.rotation_quaternion = q0
                        o.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        o.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if frenet:
                        f = self.draw_vectors(f0,color=&#34;Red&#34;,scale=0.035,head_height=0.1)
                        f.rotation_quaternion = q0
                        f.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        f.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                self.set_origin()

                fn = frames + self.frame
                for i in range(steps):
                        bpy.context.scene.frame_set(fn)
                        x = tmin + (tmax - tmin)*i/steps
                        pos = Vector([u.subs(var,x) for u in fun])
                        v1 = Vector([N(u.subs(var,x)) for u in T])
                        a1 = Vector([N(u.subs(var,x)) for u in A])
                        n1 = a1 - a1.project(v1)
                        q1 = frenet_quaternion(v1,n1)
                        if point:
                                p.location = pos
                                p.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        if tangent:
                                if not units:
                                        r = v1.length / v0.length
                                        v.scale.z *= r
                                v.location = pos
                                v.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                v.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                                q = v0.rotation_difference(v1)
                                v.rotation_quaternion.rotate(q)
                                v.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if acceleration:
                                r = a1.length / a0.length
                                a.scale.z *= r
                                a.location = pos
                                a.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                a.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                                q = a0.rotation_difference(a1)
                                a.rotation_quaternion.rotate(q)
                                a.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if normal:
                                if not units:
                                        r = n1.length / n0.length
                                        n.scale.z *= r
                                n.location = pos
                                n.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                n.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                                q = n0.rotation_difference(n1)
                                n.rotation_quaternion.rotate(q)
                                n.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if osculator:
                                o.location = pos
                                o.rotation_quaternion = q1
                                o.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                o.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        if frenet:
                                f.location = pos
                                f.rotation_quaternion = q1
                                f.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                                f.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        v0 = v1.copy()
                        a0 = a1.copy()
                        n0 = n1.copy()
                        fn += frames
                self.frame = fn - frames
                bpy.context.scene.frame_end = self.frame
                bpy.context.scene.frame_set(0)
                bpy.context.view_layer.update()
        #
        # Examples of use
        #
        def clear(self):
                &#34;&#34;&#34;
                Clears and removes all the elements
                &#34;&#34;&#34;
                self.reset()
                for obj in bpy.data.objects:
                        bpy.data.objects.remove(obj)
        #
        # Base canònica
        #
        def base_canonica(self,origin=Vector([0,0,0]),length=15,scale=0.04,zaxis=True,name=&#34;Base canònica&#34;):
                &#34;&#34;&#34;
                Draws the canonical base
                Parameters:
                   origin: point where to represent the base

                   length: length of the axis

                   scale: scale of the cylinder

                   zaxis: if False the z axis is not drawn

                   name: name of the object
                &#34;&#34;&#34;
                if not isinstance(origin,Vector):
                        origin = Vector(origin)
                self.set_origin(origin)
                self.draw_base_axis(axis=length,positive=False,scale=scale,zaxis=zaxis,name=name)
        #
        #
        def base_canonica_white(self,origin=Vector([0,0,0]),length=20,scale=0.04,zaxis=True,name=&#34;Base canònica&#34;):
                &#34;&#34;&#34;
                Draws the canonical base in white
                Parameters:
                   origin: point where to represent the base

                   length: length of the axis

                   scale: scale of the cylinder

                   zaxis: if False the z axis is not drawn

                   name: name of the object
                &#34;&#34;&#34;
                if not isinstance(origin,Vector):
                        origin = Vector(origin)
                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                self.draw_base_axis(axis=length,positive=False,scale=scale,zaxis=zaxis,name=name)
                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        #
        # Vector i base canònica
        #
        def vector_base_canonica(self,vector=Vector([-4,7,6]),length=12,name=&#34;Vector&#34;,components=True):
                &#34;&#34;&#34;
                Draws a vector expressed in the canonical base
                Parameters:
                   vector: the vector to draw

                   length: length of the axis

                   name: name of the vector

                   components: if True draws lines representing the components
                &#34;&#34;&#34;
                self.base_canonica(length=length)
                if not isinstance(vector,Vector):
                        vector = Vector(vector)
                self.draw_vector(vector=vector,name=name)
                if components:
                        self.draw_components(vector,name=&#34;Components en base canònica&#34;)
        #
        # Base no canònica
        #
        def base_no_canonica(self,origin=Vector([0,0,0]),u1=Vector([1,-1,0]),u2=1/2*Vector([1,-1,-1]),u3=Vector([-1,0,1]),length=12,scale=0.04,preserve=False,name=&#34;Base B&#39;&#34;):
                &#34;&#34;&#34;
                Draws the base {u1,u2,u3} with origin in the point origin and sets the default
                origin and default base to them
                Parameters:
                        origin: origin of the vector and the base

                        u1, u2, u3: vectors of the base

                        length: length of the axis

                        scale: scale of the base

                        name: name of the base

                        preserve:
                &#34;&#34;&#34;
                if not isinstance(origin,Vector):
                        origin = Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                if not isinstance(u3,Vector):
                        u3 = Vector(u3)
                self.set_origin(origin)
                self.set_base([u1,u2,u3])
                self.draw_base_axis(axis=length,positive=False,scale=scale,name=name)
                if not preserve:
                        self.set_origin()
                        self.set_base()
                        self.set_rotation()
        #
        # Base a partir d&#39;un eix
        #
        def base_adaptada(self,origin=Vector([0,0,0]),axis=Vector([1,1,1]),length=15,scale=0.04,name=&#34;Base adaptada&#34;):
                &#34;&#34;&#34;
                Draws an ortonormal base from vector axis with origin in the point origin and sets the default
                origin and default base to them
                Parameters:
                        origin: origin of the vector and the base

                        axis: first vector of the base

                        length: length of the axis

                        scale: scale of the base

                        name: name of the base
                &#34;&#34;&#34;
                if not isinstance(origin,Vector):
                        origin = Vector(origin)
                if not isinstance(axis,Vector):
                        axis = Vector(axis)
                self.set_origin(origin)
                u1 = axis.normalized()
                u2 = u1.orthogonal().normalized()
                u3 = u1.cross(u2)
                self.set_base([u1,u2,u3])
                self.set_colors([&#34;Magenta&#34;,&#34;Yellow&#34;,&#34;Cyan&#34;])
                self.draw_base_axis(axis=length,positive=False,scale=scale,name=name)
                self.set_colors()
                self.reset()
        #
        # Vector en base no canònica
        #
        def vector_base_no_canonica(self,vector=Vector([5,6,-5]),origin=Vector([0,0,0]),u1=1/3*Vector([-1,-2,2]),u2=1/3*Vector([2,1,2]),u3=1/3*Vector([-2,2,1]),length=12,scale=0.04,name=&#34;Base B&#39;&#34;,canonica=True,preserve=False):
                &#34;&#34;&#34;
                Draws a vector expressed in the base {u1,u2,u3} with origin in the point origin and sets the default
                origin and default base to them
                Parameters:
                        vector: vector to draw

                        origin: origin of the vector and the base

                        u1, u2, u3: vectors of the base

                        length: length of the axis

                        scale: scale of the base

                        name: name of the base
                &#34;&#34;&#34;
                self.base_no_canonica(origin=origin,u1=u1,u2=u2,u3=u3,length=length,scale=scale,preserve=preserve,name=name)
                if not isinstance(vector,Vector):
                        vector = Vector(vector)
                if canonica:
                        vector = self.coordinates_en_referencia(vector)
                self.draw_vector(vector=vector,scale=0.06,head_height=0.25)
                self.draw_components(vector,scale=0.015,name=&#34;Components en base B&#39;&#34;)
                if not preserve:
                        self.set_origin()
                        self.set_base()
                        self.set_rotation()
        #
        # Canvi de base
        #
        def canvi_base(self,vector=Vector([8,-6,7]),u1=1/3*Vector([-1,-2,2]),u2=1/3*Vector([2,1,2]),u3=1/3*Vector([-2,2,1]),length=12):
                &#34;&#34;&#34;
                Draw the components of a vectors in the canonical base and in the base {u1,u2,u3}. Sets the default
                origin and default base to them
                Parameters:
                        vector: vector to draw

                        u1, u2, u3: vectors of the base

                        length: length of the axis
                &#34;&#34;&#34;
                self.vector_base_canonica(vector=vector,length=length)
                self.set_colors([&#34;Magenta&#34;,&#34;Yellow&#34;,&#34;Cyan&#34;])
                self.base_no_canonica(u1=u1,u2=u2,u3=u3,length=length,preserve=True)
                v = self.components_in_base(vector)
                self.draw_components(v,color=&#34;White&#34;,name=&#34;Components en la base B&#39;&#34;)
        #
        # Pla vectorial
        #
        def pla_vectorial(self,v1=Vector([3,2,1]),v2=Vector([1,-2,0.5]),canonica=False,length=15,color=&#34;Cyan&#34;,sizex=25,sizey=20,opacity=0.8,thickness=0.01):
                &#34;&#34;&#34;
                Draws the plane generated by two vectors
                Parameters:
                        v1, v2: generators of the plane

                        canonica: if True, draws the x, y and z axis

                        length: length of the axis x, y and z

                        color: color of the plane

                        sizex, sizey: size of the plane

                        opacicity: opacity of the plane

                        thickness: thickness of the plane
                &#34;&#34;&#34;
                if canonica:
                        if length &gt; 15:
                                self.base_canonica(length=length,scale=0.01)
                        else:
                                self.base_canonica(length=length)
                self.draw_vectors([v1,v2],color=&#34;Blue&#34;)
                self.draw_plane_surface(base=[v1,v2],color=color,sizex=sizex,sizey=sizey,opacity=opacity,thickness=thickness)
        #
        # Pla afí
        #
        def pla_afi(self,punt=Vector([0,0,0]),normal=None,v1=Vector([3,2,1]),v2=Vector([1,-2,0.5]),canonica=False,name=&#34;Pla afí&#34;,length=15,color=&#34;Cyan&#34;,sizex=25,sizey=20,opacity=0.9,elements=True):
                &#34;&#34;&#34;
                Draws the affine plane generated by two vectors passing through a point
                Parameters:
                        punt: point of the plane

                        normal: normal vector of the plane

                        v1, v2: generators of the plane

                        canonica: if True, draws the x, y and z axis

                        name: name of the affine plane

                        length: length of the axis x, y and z

                        color: color of the plane

                        sizex, sizey: size of the plane

                        opacicity: opacity of the plane
                &#34;&#34;&#34;
                if not isinstance(punt,Vector):
                        punt = Vector(punt)
                punt = self.components_en_canonica(punt)
                if canonica:
                        if length &gt; 15:
                                self.base_canonica(length=length,scale=0.08)
                        else:
                                self.base_canonica(length=length)
                if normal is not None:
                        if not isinstance(normal,Vector):
                                normal = Vector(normal)
                        self.draw_plane_surface(origin=punt,normal=normal,color=color,sizex=sizex,sizey=sizey,name=name,opacity=opacity)
                else:
                        self.draw_plane_surface(origin=punt,base=[v1,v2],color=color,sizex=sizex,sizey=sizey,name=name,opacity=opacity)
                if elements:
                        self.set_origin(punt)
                        self.draw_point(color=&#34;Blue&#34;)
                        if normal is not None:
                                self.draw_vector(vector=normal,color=&#34;Blue&#34;)
                        else:
                                self.draw_vectors(vectors=[v1,v2],canonica=canonica,color=&#34;Blue&#34;)
                        self.set_origin()
        #
        # Posició relativa de tres plans
        #
        def posicio_relativa_tres_plans(self,punts=None,normals=None,colors=None,canonica=True,length=25,sizex=45,sizey=40,opacity=1.0,elements=False):
                &#34;&#34;&#34;
                Draws threee planes
                Parametres:
                        punts: three points, one for each plane

                        normals: three normal vectors, one for each plane

                        colors: three colors, one for each plane

                        canonica: if True, draws the x, y and z axis

                        length: length of the axis x, y and z

                        sizex, sizey: size of the planes

                        opacicity: opacity of the planes

                        elements: if True, draws the point and the normal vector for each plane
                &#34;&#34;&#34;
                punts = [p if isinstance(p,Vector) else Vector(p) for p in punts]
                normals = [n if isinstance(n,Vector) else Vector(n) for n in normals]
                n = (&#34;Primer pla&#34;,&#34;Segon pla&#34;,&#34;Tercer pla&#34;)
                if canonica:
                        b = (True,False,False)
                else:
                        b = (False,False,False)
                for i in range(3):
                        self.pla_afi(punt=punts[i],normal=normals[i],canonica=b[i],name=n[i],length=length,color=colors[i],sizex=sizex,sizey=sizey,opacity=opacity,elements=elements)
        #
        # Recta afí
        #
        def recta_afi(self,punt=Vector([3,4,-2]),v=Vector([1,2,1]),color=&#34;Black&#34;,size=15,name=&#34;Recta afí&#34;,canonica=True,length=12,scale=0.03,elements=True):
                &#34;&#34;&#34;
                Draws the affine line generated by a vector passing through a point
                Parameters:
                        punt: point of the line

                        v: generator of the line

                        canonica: if True, draws the x, y and z axis

                        name: name of the affine plane

                        length: length of the axis x, y and z

                        color: color of the plane

                        size: lenght of the line

                        scale: scale of the line
                &#34;&#34;&#34;
                if canonica:
                        if length &gt; 15:
                                self.base_canonica(length=length,scale=0.08)
                        else:
                                self.base_canonica(length=length)
                if not isinstance(v,Vector):
                        v = Vector(v)
                if not isinstance(punt,Vector):
                        punt = Vector(punt)
                l = v.length
                p0 = punt + size/l * v
                p1 = punt - size/l * v
                self.draw_line(start=p0,end=p1,scale=0.04,color=color)
                if elements:
                        self.set_origin(punt)
                        self.draw_point(color=color,radius=2 * scale)
                        self.draw_vector(vector=v,color=color)
                        self.set_origin()
        #
        # Recta vectorial
        #
        def recta_vectorial(self,v=Vector([1,2,1]),color=&#34;Black&#34;,size=15,name=&#34;Recta vectorial&#34;,canonica=True,length=12,scale=0.03):
                &#34;&#34;&#34;
                Draws the affine line generated by a vector passing through a point
                Parameters:
                        v: generator of the line

                        canonica: if True, draws the x, y and z axis

                        name: name of the affine plane

                        length: length of the axis x, y and z

                        color: color of the plane

                        size: lenght of the line

                        scale: scale of the line
                &#34;&#34;&#34;
                if canonica:
                        if length &gt; 15:
                                self.base_canonica(length=length,scale=0.08)
                        else:
                                self.base_canonica(length=length)
                if not isinstance(v,Vector):
                        v = Vector(v)
                l = v.length
                p0 = size/l * v
                p1 = - size/l * v
                self.draw_line(start=p0,end=p1,scale=scale,color=color)
                self.draw_vector(vector=v,scale=1.2*scale,color=color)
        #
        # Distància entre dues rectes que s&#39;encreuen
        #
        def distancia_rectes_encreuen(self,p0=Vector([3,4,-2]),v0=Vector([1,2,3]),c0=&#34;Black&#34;,n0=&#34;Primera recta&#34;,p1=Vector([-3,4,1]),v1=Vector([1,-2,-1]),c1=&#34;Blue&#34;,n1=&#34;Segona recta&#34;,canonica=True,length=12,size=15,scale=0.03):
                &#34;&#34;&#34;
                Draws the distance between two affine lines
                Parameters:
                        p0: point of the first line

                        v0: generator of the first line

                        c0: color of the first line

                        n0: name of the first line

                        p1: point of the second line

                        v1: generator of the second line

                        c1: color of the second line

                        n1: name of the second line

                        canonica: if True, draws the x, y and z axis

                        length: length of the axis x, y and z

                        size: lenght of the lines
                &#34;&#34;&#34;
                self.recta_afi(punt=p0,v=v0,color=c0,name=n0,canonica=canonica,length=length,size=size,scale=scale)
                self.recta_afi(punt=p1,v=v1,color=c1,name=n1,canonica=False,length=length,size=size,scale=scale)
                u = p0 - p1
                w = v0.cross(v1)
                t0, t1, t2 = self.components_in_base(u,[v0,v1,w])
                self.draw_line(start=p0-t0*v0,end=p1+t1*v1,scale=0.04,color=&#34;White&#34;,name=&#34;Distància&#34;,segment=True)
                self.pla_afi(punt=p0,v1=v0,v2=v1,name=&#34;Pla que conté a 1a recta i és paral·lel a la segon&#34;,sizex=2*size,sizey=2*size,opacity=0.9,elements=False)
        #
        # Projecció ortogonal i simètric sobre un pla vectorial
        #
        def projeccio_ortogonal_simetric_pla_vectorial(self,vector=Vector([7,-1,12]),v1=Vector([3,-1,1]),v2=Vector([1,0.5,0.5]),sizex=None,sizey=None,color=&#34;AzureBlueDark&#34;,canonica=True,orthogonal=False,orthonormal=False,thickness=0.01):
                &#34;&#34;&#34;
                Draws the otoghonal projection and the symmetric of a vector with respecte a plane
                Parameters:
                        vector: the initial vector

                        v1, v2: generators of the plane

                        sizex, sizey: size of the plane

                        canonica: if True, draws the x, y and z axis

                        thickness:
                &#34;&#34;&#34;
                if not isinstance(vector,Vector):
                        vector = Vector(vector)
                if not isinstance(v1,Vector):
                        v1 = Vector(v1)
                if not isinstance(v2,Vector):
                        v2 = Vector(v2)
                self.draw_vector(vector=vector)
                w = v1.cross(v2)
                vp = vector - vector.project(w)
                self.draw_vector(vector=vp,color=&#34;Red&#34;,name=&#34;Projecció ortogonal&#34;)
                if sizex is None:
                        sizex = 4*vp.length
                if sizey is None:
                        sizey = 4*vp.length
                self.pla_vectorial(v1,v2,sizex=sizex,sizey=sizey,canonica=canonica,color=color,thickness=thickness)
                if orthogonal:
                        u1 = v1
                        u2 = v2
                        u2 = u1.dot(u1)*u2 - u2.dot(u1)*u1
                        self.draw_vectors(vectors=(u1,u2),name=&#34;Base ortogonal&#34;,color=&#34;Green&#34;)
                if orthonormal:
                        u1 = v1
                        u2 = v2
                        u2 = u1.dot(u1)*u2 - u2.dot(u1)*u1
                        u1.normalize()
                        u2.normalize()
                        self.draw_vectors(vectors=(u1,u2),name=&#34;Base ortonormal&#34;,color=&#34;Orange&#34;)
                        self.set_base([u1,u2,w])
                        vb = self.components_in_base(vector)
                        self.set_base()
                        p1 = vb.x * u1
                        p2 = vb.y * u2
                        l1 = self.draw_line(start=[0,0,0],end=p1,scale=0.04,color=&#34;Orange&#34;,name=&#34;Lines 1&#34;)
                        l2 = self.draw_line(start=[0,0,0],end=p2,scale=0.04,color=&#34;Orange&#34;)
                        l3 = self.draw_line(start=vp,end=p1,scale=0.04,color=&#34;Orange&#34;)
                        l4 = self.draw_line(start=vp,end=p2,scale=0.04,color=&#34;Orange&#34;)
                        l11 = self.join([l1,l2,l3,l4])
                self.set_origin(vp)
                self.draw_vector(vector=vector.project(w),scale=0.025,color=&#34;White&#34;,name=&#34;Vector perpendicular&#34;)
                self.set_origin()
                self.set_base([v1,v2,w])
                vb = self.components_in_base(vector)
                self.set_base()
                p1 = vb.x * v1
                p2 = vb.y * v2
                l1 = self.draw_line(start=[0,0,0],end=p1,scale=0.04,color=&#34;Blue&#34;,name=&#34;Lines 2&#34;)
                l2 = self.draw_line(start=[0,0,0],end=p2,scale=0.04,color=&#34;Blue&#34;)
                l3 = self.draw_line(start=vp,end=p1,scale=0.04,color=&#34;Blue&#34;)
                l4 = self.draw_line(start=vp,end=p2,scale=0.04,color=&#34;Blue&#34;)
                l1 = self.join([l1,l2,l3,l4])
                self.draw_vector(vector=2 * vp - vector,color=&#34;Green&#34;,name=&#34;Simètric&#34;)
                self.draw_line(start=2 * vp - vector,end=vp,scale=0.04,color=&#34;White&#34;,name=&#34;Vector perpendicular&#34;)
        #
        # Projecció ortogonal i simètric d&#39;un punt sobre un pla afí
        #
        def projeccio_ortogonal_simetric_pla_afi(self,punt=Vector([6,-5,8]),p0=Vector([3,-2,-3]),v1=Vector([3,-1,1]),v2=Vector([1,0.5,0.5]),radi=0.15,sizex=35,sizey=30,line=1.8,canonica=True):
                &#34;&#34;&#34;
                Draws the orthogonal projection and the symmetric of a point with respect an affine plane
                Parameters:
                        punt: the initial point

                        p0: point of the affine plane

                        v1, v2: generators of the plane

                        radi: radius of the points

                        sizex, sizey: sizes of the affine plane

                        factor: how to draw the perpendicular line

                        canonica: if True, draws the x, y and z axis
                &#34;&#34;&#34;
                if not isinstance(punt,Vector):
                        punt = Vector(punt)
                if not isinstance(p0,Vector):
                        p0 = Vector(p0)
                if not isinstance(v1,Vector):
                        v1 = Vector(v1)
                if not isinstance(v2,Vector):
                        v2 = Vector(v2)
                self.draw_point(location=punt,color=&#34;Black&#34;,radius=radi,name=&#34;Punt&#34;)
                w = v1.cross(v2)
                self.pla_afi(punt=p0,v1=v1,v2=v2,sizex=sizex,sizey=sizey,color=&#34;AzureBlueMedium&#34;,canonica=canonica,elements=False)
                u = punt - p0
                up = punt - u.project(w)
                self.draw_point(location=up,color=&#34;Red&#34;,radius=radi,name=&#34;Projecció ortogonal&#34;)
                us = punt - 2*u.project(w)
                self.draw_point(location=us,color=&#34;Green&#34;,radius=radi,name=&#34;Simètric&#34;)
                u = punt - up
                self.draw_line(start=up-line*u,end=up+line*u,scale=0.04,color=&#34;White&#34;,name=&#34;Recta perpendicular al pla&#34;)
        #
        # Projecció ortogonal i simètric d&#39;un punt sobre una recta afí
        #
        def projeccio_ortogonal_simetric_recta_afi(self,punt=Vector([6,-5,8]),p0=Vector([3,-2,-3]),v1=Vector([3,-1,1]),scale=0.1,radi=0.15,sizex=10,sizey=10,canonica=True,opacity=1.0):
                &#34;&#34;&#34;
                Draws the orthogonal projection and the symmetric of a point with respect an affine line
                Parameters:
                        punt: the initial point

                        p0: point of the affine line

                        v1: generator of the line

                        radi: radius of the points

                        sizex, sizey: sizes of the affine plane

                        canonica: if True, draws the x, y and z axis
                &#34;&#34;&#34;
                if not isinstance(punt,Vector):
                        punt = Vector(punt)
                if not isinstance(p0,Vector):
                        p0 = Vector(p0)
                if not isinstance(v1,Vector):
                        v1 = Vector(v1)
                if canonica:
                        self.base_canonica(length=0.75*sizex,name=&#34;Referència canònica&#34;)
                self.draw_point(location=p0,color=&#34;Blue&#34;,radius=radi,name=&#34;Punt de la recta&#34;)
                self.set_origin(p0)
                self.draw_vector(vector=v1,canonica=canonica,scale=scale,head_height=0.15,axis=20,name=&#34;Recta afí&#34;,color=&#34;Blue&#34;,positive=False)
                self.set_origin()
                self.draw_point(location=punt,color=&#34;Black&#34;,radius=radi,name=&#34;Punt inicial&#34;)
                u = punt - p0
                p1 = p0 + u.project(v1)
                self.draw_point(location=p1,color=&#34;Red&#34;,radius=radi,name=&#34;Projecció ortogonal&#34;)
                self.draw_plane_surface(origin=p1,normal=v1,name=&#34;Pla perpendicular a la recta&#34;,sizex=sizex,sizey=sizey,color=&#34;AzureBlueMedium&#34;,opacity=opacity)
                self.draw_point(location=2*p1-punt,color=&#34;Green&#34;,radius=radi,name=&#34;Simètric&#34;)
                self.draw_line(start=punt,end=2*p1-punt,scale=0.04,color=&#34;White&#34;)
        #
        # Projecció ortogonal i simètric sobre una recta vectorial
        #
        def projeccio_ortogonal_simetric_recta_vectorial(self,vector=Vector([7,-1,12]),v1=Vector([3,-1,1]),canonica=True,length=15):
                &#34;&#34;&#34;
                Draws the otoghonal projection and the symmetric of a vector with respecte a line
                Parameters:
                        vector: the initial vector

                        v1: generator of the line

                        canonica: if True, draws the x, y and z axis

                        length: length for x, y and z axis and v1 axis
                &#34;&#34;&#34;
                if not isinstance(vector,Vector):
                        vector = Vector(vector)
                if not isinstance(v1,Vector):
                        v1 = Vector(v1)
                if canonica:
                        self.base_canonica(length=length)
                self.draw_vector(vector=v1,axis=length,positive=False,color=&#34;Blue&#34;,scale=0.066)
                self.draw_vector(vector=vector)
                vp = vector.project(v1)
                self.draw_vector(vector=vp,color=&#34;Red&#34;)
                self.draw_vector(origin=vp,vector=vector - vp,scale=0.025,color=&#34;White&#34;)
                self.draw_vector(vector=2 * vp - vector,color=&#34;Green&#34;)
                self.draw_line(start=2 * vp - vector,end=vp,scale=0.04,color=&#34;White&#34;)
        #
        # Perpendicular comuna a dues rectes
        #
        def perpendicular_comuna_a_dues_rectes(self,p0=Vector([1,1,1]),u=Vector([1,0,0]),q0=Vector([-1,2,-2]),v=Vector([0,0,1]),sizex=60,sizey=80,length=5,t1=0,t2=0,head_height=0.1):
                &#34;&#34;&#34;
                Draws the straigth line perpendicular to a given two non parallel lines
                Parameters:
                   p0: point of the first line

                   u: director vector of the first line

                   q0: point of the second line

                   v: director vector of the second line

                   sizex, sizey: sizes of the rectangle

                   length: length og the vectors

                   t1, t2: displacement of the points p0 and q0
                &#34;&#34;&#34;
                if not isinstance(p0,Vector):
                        p0 = Vector(p0)
                if not isinstance(q0,Vector):
                        q0 = Vector(q0)
                if not isinstance(u,Vector):
                        u = Vector(u)
                if not isinstance(v,Vector):
                        v = Vector(v)

                w = u.cross(v)
                if w.length == 0:
                        return None
                pq = q0 - p0
                mat = Matrix([u,v,w])
                mat.transpose()
                mat.invert()
                pq1 = mat @ pq

                m0 = p0 + pq1.x * u
                m1 = m0 + pq1.z * w
                m = (m0 + m1)/2
                u.normalize()
                v.normalize()
                w.normalize()
                self.draw_vector(origin=p0+t1*u,vector=length*u,axis=30,scale=0.15,head_height=head_height,color=&#34;Blue&#34;,name=&#34;Recta  1&#34;,positive=False)
                self.draw_vector(origin=q0+t2*v,vector=length*v,axis=30,scale=0.15,head_height=head_height,color=&#34;Green&#34;,name=&#34;Recta  2&#34;,positive=False)
                self.draw_vector(origin=m,vector=length*w,axis=sizex/2+10,scale=0.15,head_height=head_height,color=&#34;Red&#34;,name=&#34;Recta perpendicular comuna&#34;,positive=False)
                self.rectangle(origin=m,u1=w,u2=u,sizex=sizex,sizey=sizey,name=&#34;Pla P&#34;,opacity=1)
                self.rectangle(origin=m,u1=w,u2=v,sizex=sizex,sizey=sizey,color=&#34;CyanAzureDark&#34;,name=&#34;Pla Q&#34;,opacity=1)
                self.draw_point(location=p0+t1*u,radius=0.5,name=&#34;Punt p0&#34;,color=&#34;Blue&#34;)
                self.draw_point(location=q0+t2*v,radius=0.5,name=&#34;Punt q0&#34;,color=&#34;Green&#34;)
                self.draw_point(location=m0,radius=0.5,name=&#34;Punt interseccio 1&#34;)
                self.draw_point(location=m1,radius=0.5,name=&#34;Punt interseccio 2&#34;)
                self.draw_point(location=m,radius=0.5,name=&#34;Punt recta perpendicular&#34;,color=&#34;Red&#34;)
        #
        # Referència canònica
        #
        def referencia_canonica(self,origin=Vector([0,0,0]),length=15,scale=0.04,zaxis=True,name=&#34;Referència canònica&#34;):
                &#34;&#34;&#34;
                Draws the canonical reference
                Parameters:
                   origin: point where to represent the base

                   length: length of the axis

                   scale: scale of the cylinder

                   zaxis: if False the z axis is not drawn

                   name: name of the object
                &#34;&#34;&#34;
                if not isinstance(origin,Vector):
                        origin = Vector(origin)
                self.set_origin(origin)
                self.draw_base_axis(axis=length,positive=False,scale=scale,zaxis=zaxis,name=name)
        #
        # Punt en referència canònica
        #
        def punt_referencia_canonica(self,punt=Vector([-4,7,6]),radius=0.1,length=12,scale=0.06,name=&#34;Punt p&#34;,color=&#34;Black&#34;,coordenades=True,vector=True):
                &#34;&#34;&#34;
                Draws a point expressed in the canonical reference
                Parameters:
                   punt: the point to draw

                   length: length of the axis

                   name: name of the point

                   coordenades: if True draws lines representing the coordinates

                   vector: if True, it draws the position vector
                &#34;&#34;&#34;
                self.base_canonica(length=length,scale=scale,name=&#34;Referència canònica&#34;)
                if not isinstance(punt,Vector):
                        punt = Vector(punt)
                self.draw_point(location=punt,color=&#34;Black&#34;,radius=radius,name=name)
                if coordenades:
                        self.draw_components(punt,name=&#34;Coordenades en referència canònica&#34;)
                if vector:
                        self.draw_vector(vector=punt,name=&#34;Vector de posició refereǹcia canònica&#34;,color=color)
        #
        # Referència no canònica
        #
        def referencia_no_canonica(self,origin=Vector([0,0,0]),u1=Vector([1,-1,0]),u2=1/2*Vector([-1,2,1]),u3=Vector([-1,0,1]),length=12,scale=0.04,preserve=True,name=&#34;Referència R&#39;&#34;):
                &#34;&#34;&#34;
                Draws the reference {o;u1,u2,u3} with origin in the point origin and sets the default
                origin and default base to them
                Parameters:
                        origin: origin of the reference

                        u1, u2, u3: vectors of the base

                        length: length of the axis

                        scale: scale of the axis

                        name: name of the reference
                &#34;&#34;&#34;
                if not isinstance(origin,Vector):
                        origin = Vector(origin)
                if not isinstance(u1,Vector):
                        u1 = Vector(u1)
                if not isinstance(u2,Vector):
                        u2 = Vector(u2)
                if not isinstance(u3,Vector):
                        u3 = Vector(u3)
                self.set_origin(origin)
                self.set_base([u1,u2,u3])
                self.draw_base_axis(axis=length,positive=False,scale=scale,name=name)
                if not preserve:
                        self.set_origin()
                        self.set_base()
                        self.set_rotation()
        #
        # Punt en referencia no canònica
        #
        def punt_referencia_no_canonica(self,punt=Vector([5,6,-5]),origin=Vector([-2,3,3]),u1=1/3*Vector([-1,-2,2]),u2=1/3*Vector([2,1,2]),u3=1/3*Vector([-2,2,1]),color=&#34;Black&#34;,length=12,scale=0.04,radius=0.1,name=&#34;Punt p&#34;,vector=True):
                &#34;&#34;&#34;
                Draws a point expressed in the reference {o,u1,u2,u3} with origin in the point origin and sets the default
                origin and default base to them
                Parameters:
                        punt: point to draw

                        origin: origin of the reference

                        u1, u2, u3: vectors of the base

                        length: length of the axis

                        scale: scale of the axis

                        name: name of the reference

                        vector: if True, it draws the position vector
                &#34;&#34;&#34;
                self.referencia_no_canonica(origin=origin,u1=u1,u2=u2,u3=u3,length=length,scale=scale,name=&#34;Referència R&#39;&#34;)
                if not isinstance(punt,Vector):
                        punt = Vector(punt)
                self.draw_point(location=punt,color=&#34;Black&#34;,radius=radius,name=name)
                self.draw_components(punt,scale=0.015,name=&#34;Coordenades en referència R&#39;&#34;)
                if vector:
                        self.draw_vector(vector=punt,name=&#34;Vector de posició referència R&#39;&#34;)
        #
        # Canvi de coordenades
        #
        def canvi_coordenades(self,punt=Vector([8,-6,7]),origin=Vector([-2,3,3]),u1=1/3*Vector([-1,-2,2]),u2=1/3*Vector([2,1,2]),u3=1/3*Vector([-2,2,1]),canonica=False,scale=0.06,length=12,radius=0.1):
                &#34;&#34;&#34;
                Draw the coordinates of a point in the canonical reference and in the reference {o;u1,u2,u3}. Sets the default
                origin and default base to them
                Parameters:
                        punt: point to draw

                        origin: origin of the reference

                        u1, u2, u3: vectors of the base

                        canonica: if True, the coordinates of punt are in the canonical reference

                        length: length of the axis
                &#34;&#34;&#34;
                self.set_origin(origin)
                self.set_base([u1,u2,u3])
                if canonica:
                        p = punt
                        p1 = self.coordinates_en_referencia(punt)
                else:
                        p = self.coordinates_en_canonica(punt)
                        p1 = punt
                self.reset()
                ## self.punt_referencia_canonica(punt=p,length=length,scale=scale,radius=radius)
                self.set_colors([&#34;Magenta&#34;,&#34;Yellow&#34;,&#34;AzureBlueDark&#34;])
                self.punt_referencia_no_canonica(punt=p1,origin=origin,u1=u1,u2=u2,u3=u3,length=length,scale=scale,radius=radius)
                self.reset()
                self.draw_vector(vector=p,name=&#34;Vector de posició en referència canònica&#34;,color=&#34;White&#34;)
                self.draw_components(p,color=&#34;Magenta&#34;,name=&#34;Coordenades en referència canònica&#34;)
        #
        # El·lipse
        #
        def ellipse(self,center=Vector([0,0,0]),a=8,b=5,canonica=True):
                &#34;&#34;&#34;
                Draws the ellipse of equation (x-x0)^2/a^2 + (y-y0)^2/b^2 == 1
                Parameters:
                        centre: center of the ellipse

                        a, b: semiaxis of the ellipse

                        canonica: if True, draws the x and y axis
                &#34;&#34;&#34;
                if len(center) == 2:
                        center = (center[0],center[1],0)
                if not isinstance(center,Vector):
                        center = Vector(center)
                if a &gt;= b:
                        c = math.sqrt(a**2 - b**2)
                        f1 = Vector([c,0,0])
                        f2 = Vector([-c,0,0])
                else:
                        c = math.sqrt(b**2 - a**2)
                        f1 = Vector([0,c,0])
                        f2 = Vector([0,-c,0])
                if canonica:
                        self.referencia_canonica(zaxis=False)
                self.draw_ellipse(center=center,a=a,b=b,thickness=0.02,steps=128,axis=False)
                self.draw_point(radius=0.167,location=(0,0,0),name=&#34;Centre&#34;,color=&#34;White&#34;)
                self.draw_point(radius=0.167,location=f1,name=&#34;F1&#34;,color=&#34;Black&#34;)
                self.draw_point(radius=0.167,location=f2,name=&#34;F2&#34;,color=&#34;Black&#34;)
                self.set_origin()
        #
        # Hipèrbola
        #
        def hiperbola(self,center=Vector([0,0,0]),a=8,b=5,negatiu=False,canonica=True):
                &#34;&#34;&#34;
                Draws the hyperbole of equation (x-x0)^2/a^2 - (y-y0)^2/b^2 == 1 (or -1)
                Parameters:
                        centre: center of the hyperbole

                        a, b: semiaxis of the hyperbole

                        canonica: if True, draws the x and y axis

                        negatiu: if True, draws the hyperbole (x-x0)^2/a^2 - (y-y0)^2/b^2 == -1
                &#34;&#34;&#34;
                if len(center) == 2:
                        center = (center[0],center[1],0)
                if not isinstance(center,Vector):
                        center = Vector(center)
                u1 = Vector([a,b,0])
                u2 = Vector([a,-b,0])
                c = math.sqrt(a**2 + b**2)
                f1 = [c,0,0]
                f2 = [-c,0,0]
                if canonica:
                        self.referencia_canonica(zaxis=False)
                v1 = Vector([1,0,0])
                v2 = Vector([0,1,0])
                if negatiu:
                        self.set_base(base=[[0,1,0],[-1,0,0],[0,0,1]])
                        v1 = Vector([0,1,0])
                        v2 = Vector([-1,0,0])
                        u1 = Vector([b,a,0])
                        u2 = Vector([b,-a,0])
                self.draw_hyperbole(center=center,u1=v1,u2=v2,a=a,b=b,ymax=14,thickness=0.02,steps=128,axis=False)
                self.draw_point(radius=0.167,location=(0,0,0),name=&#34;Centre&#34;,color=&#34;White&#34;)
                self.draw_point(radius=0.167,location=f1,name=&#34;F1&#34;,color=&#34;Black&#34;)
                self.draw_point(radius=0.167,location=f2,name=&#34;F2&#34;,color=&#34;Black&#34;)
                self.draw_line(start=-5*u1,end=5*u1,color=&#34;Blue&#34;,scale=0.03,name=&#34;Asímptota 1&#34;)
                self.draw_line(start=-5*u2,end=5*u2,color=&#34;Blue&#34;,scale=0.03,name=&#34;Asímptota 2&#34;)
                self.set_origin()
                self.set_base()
                self.set_rotation()
        #
        # Paràbola
        #
        def parabola(self,vertex=Vector([0,0,0]),p=5,xmax=15,eixos=&#39;XY&#39;,canonica=True):
                &#34;&#34;&#34;
                Draws the parabola of equation y - y0 = (x-x0)^2/(2*p) or x - x0 = (y-y0)^2/(2*p)
                Parameters:
                        vertex: vertex of the parabola

                        p: parameter of the parabola

                        pmax: maximum value of the independent variable

                        eixos: &#39;XY&#39;, draws y - y0 = (x-x0)^2/(2*p)
                                   &#39;YX&#39;, draws x - x0 = (y-y0)^2/(2*p)

                        canonica: if True, draws the x and y axis
                &#34;&#34;&#34;
                if len(vertex) == 2:
                        vertex = (vertex[0],vertex[1],0)
                if not isinstance(vertex,Vector):
                        vertex = Vector(vertex)
                f = [0,p/2,0]
                if canonica:
                        self.referencia_canonica(zaxis=False)
                u1 = Vector([1,0,0])
                u2 = Vector([0,1,0])
                if eixos == &#39;YX&#39; or eixos == &#39;yx&#39;:
                        self.set_base(base=[[0,1,0],[1,0,0],[0,0,-1]])
                        u1 = Vector([0,1,0])
                        u2 = Vector([1,0,0])
                self.draw_parabola(vertex=vertex,a=1/(2*p),u1=u1,u2=u2,xmax=xmax,thickness=0.02,steps=128,axis=False)
                self.reset_rotation()
                self.draw_point(radius=0.167,location=f,name=&#34;Focus&#34;,color=&#34;Black&#34;)
                self.draw_point(radius=0.167,location=(0,0,0),name=&#34;Vèrtex&#34;,color=&#34;White&#34;)
                self.draw_line(start=[-xmax-3,-p/2,0],end=[xmax+3,-p/2,0],color=&#34;Blue&#34;,scale=0.04,name=&#34;Recta directriu&#34;)
                self.set_origin()
                self.set_base()
                self.set_rotation()
        #
        # El·lipsoide de revolucio
        #
        def ellipsoide_revolucio(self,a=12,b=8,direccio=&#39;Z&#39;,punt=None):
                &#34;&#34;&#34;
                Draws an animation showing an ellipsoid of revolution
                        a, b: semiaxis of the initial ellipse

                        direccio: &#39;X&#39;, the initial ellipse is in the plane XZ and rotates around the X axis
                                          &#39;Y&#39;, the initial ellipse is in the plane YZ and rotates around the Y axis
                                          &#39;Z&#39;, the initial ellipse is in the plane ZX and rotates around the Z axis

                        punt: if it&#39;s a value between 0 and pi, the animation shows a rotating point
                &#34;&#34;&#34;
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        F = lambda t: (a*math.cos(t),0,b*math.sin(t))
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        F = lambda t: (0,a*math.cos(t),b*math.sin(t))
                else:
                        F = lambda t: (b*math.sin(t),0,a*math.cos(t))
                self.base_canonica()
                self.animate_revolution_surface(F,tmin=0,tmax=math.pi,steps=128,axis=direccio,point=punt)
        #
        # Hiperboloide d&#39;una fulla de revolució
        #
        def hiperboloide_una_fulla_revolucio(self,a=3,b=2,pmax=8,direccio=&#39;Z&#39;,plane=&#39;XZ&#39;,punt=None):
                &#34;&#34;&#34;
                Draws an animation showing an one sheet hyperboloid of revolution
                        a, b: semiaxis of the initial hyperbole

                        pmax: maximum value of the independent variable

                        direccio: &#39;X&#39;, the initial hyperbole is in the plane XZ and rotates around the X axis
                                  &#39;Y&#39;, the initial hyperbole is in the plane YX and rotates around the Y axis
                                      &#39;Z&#39;, the initial hyperbole is in the plane ZX and rotates around the Z axis

                        plane: plane containing the initial hyperbole. It can be &#39;XY&#39;, &#39;XZ&#39; or &#39;YZ&#39;

                        punt: if it&#39;s a value between 0 and pi, the animation shows a rotating point
                &#34;&#34;&#34;
                plane = plane.upper()
                direccio = direccio.upper()
                if plane not in (&#39;XY&#39;,&#39;XZ&#39;,&#39;YZ&#39;):
                        return None
                if direccio not in (&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;):
                        return None
                if plane == &#39;XY&#39;:
                        F = lambda t: (a*math.sqrt(1+t**2/b**2),t,0)
                elif plane == &#39;XZ&#39;:
                        F = lambda t: (a*math.sqrt(1+t**2/b**2),0,t)
                else:
                        F = lambda t: (0,a*math.sqrt(1+t**2/b**2),t)
                self.base_canonica()
                self.animate_revolution_surface(F,tmin=-pmax,tmax=pmax,steps=128,axis=direccio,point=punt)
        #
        # Hiperboloide de dues fulles de revolució
        #
        def hiperboloide_dues_fulles_revolucio(self,a=3,b=2,pmax=8,direccio=&#39;Z&#39;,plane=&#39;XZ&#39;,punt=None):
                &#34;&#34;&#34;
                Draws an animation showing a two sheet hyperboloid of revolution
                        a, b: semiaxis of the initial hyperbole

                        pmax: maximum value of the independent variable

                        direccio: &#39;X&#39;, the initial hyperbole is in the plane YX and rotates around the X axis
                                  &#39;Y&#39;, the initial hyperbole is in the plane ZY and rotates around the Y axis
                                      &#39;Z&#39;, the initial hyperbole is in the plane XZ and rotates around the Z axis
                        
                        plane: plane containing the initial hyperbole. It can be &#39;XY&#39;, &#39;XZ&#39; or &#39;YZ&#39;

                        punt: if it&#39;s a value between 0 and pi, the animation shows a rotating point
                &#34;&#34;&#34;
                plane = plane.upper()
                direccio = direccio.upper()
                if plane not in (&#39;XY&#39;,&#39;XZ&#39;,&#39;YZ&#39;):
                        return None
                if direccio not in (&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;):
                        return None
                if plane == &#39;XY&#39;:
                        F = lambda t: (a*math.sqrt(1+t**2/b**2),t,0)
                elif plane == &#39;XZ&#39;:
                        F = lambda t: (a*math.sqrt(1+t**2/b**2),0,t)
                else:
                        F = lambda t: (0,a*math.sqrt(1+t**2/b**2),t)

                if direccio == &#39;X&#39;:
                        if plane == &#39;YZ&#39;:
                                return None
                        s = &#39;Z&#39;
                elif direccio == &#39;Y&#39;:
                        if plane == &#39;XZ&#39;:
                                return None
                        s = &#39;Y&#39;
                else:
                        if plane == &#39;XY&#39;:
                                return None
                        s = &#39;X&#39;

                self.base_canonica()
                self.animate_revolution_surface(F,tmin=0,tmax=pmax,steps=128,axis=direccio,symmetry=s,point=punt)
        #
        # Con de revolució
        #
        def con_revolucio(self,a=1.5,pmax=8,direccio=&#39;Z&#39;,punt=None):
                &#34;&#34;&#34;
                Draws an animation showing a cone of revolution
                        a: slope of the initial straight line

                        pmax: maximum value of the independent variable

                        direccio: &#39;X&#39;, the initial line is in the plane YX and rotates around the X axis
                                  &#39;Y&#39;, the initial line is in the plane ZY and rotates around the Y axis
                                      &#39;Z&#39;, the initial line is in the plane XZ and rotates around the Z axis

                        punt: if it&#39;s a value between -pmax and pmax, the animation shows a rotating point
                &#34;&#34;&#34;
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        F = lambda t: (a*t,t,0)
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        F = lambda t: (0,a*t,t)
                else:
                        F = lambda t: (t,0,a*t)
                self.base_canonica()
                self.animate_revolution_surface(F,tmin=-pmax,tmax=pmax,steps=128,axis=direccio,point=punt)
        #
        # Paraboloide el·líptic de revolució
        #
        def paraboloide_elliptic_revolucio(self,a=0.5,pmax=5,direccio=&#39;Z&#39;,punt=None):
                &#34;&#34;&#34;
                Draws an animation showing an elliptic paraboloid of revolution
                        a: The constant of the initial parabola

                        pmax: maximum value of the independent variable

                        direccio: &#39;X&#39;, the initial parabola is in the plane YX and rotates around the X axis
                                  &#39;Y&#39;, the initial parabola is in the plane ZY and rotates around the Y axis
                                      &#39;Z&#39;, the initial parabola is in the plane XZ and rotates around the Z axis

                        punt: if it&#39;s a value between -pmax and pmax, the animation shows a rotating point
                &#34;&#34;&#34;
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        F = lambda t: (a*t**2,t,0)
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        F = lambda t: (0,a*t**2,t)
                else:
                        F = lambda t: (t,0,a*t**2)
                self.base_canonica()
                self.animate_revolution_surface(F,tmin=0,tmax=pmax,steps=128,axis=direccio,point=punt)
        #
        # Paraboloide hiperbòlic
        #
        def paraboloide_hiperbolic_simple(self,a=3,b=4,xmax=12,ymax=12):
                &#34;&#34;&#34;
                Draws the hyperbolic paraboloid of equation z = x^2/a^2 - y^2/b^2
                Parameters:
                        a, b: constants the defines he hyperbolic paraboloid

                        xmax, ymax: maximun values of the x and y coordinates
                &#34;&#34;&#34;
                return self.hyperbolic_paraboloid(a2=a**2,b2=b**2,xmax=xmax,ymax=ymax,canonica=True,principal=False)
        #
        # Paraboloide elliptic
        #
        def paraboloide_elliptic_simple(self,a=3,b=4,direccio=&#39;Z&#39;,xmax=12):
                &#34;&#34;&#34;
                Draws the hyperbolic paraboloid of equation z = x^2/a^2 - y^2/b^2
                Parameters:
                        a, b: constants the defines he hyperbolic paraboloid

                        xmax, ymax: maximun values of the x and y coordinates
                &#34;&#34;&#34;
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        u1 = Vector([0,0,1])
                        u2 = Vector([0,1,0])
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        u1 = Vector([1,0,0])
                        u2 = Vector([0,0,-1])
                else:
                        u1 = Vector([1,0,0])
                        u2 = Vector([0,1,0])
                el = self.elliptic_paraboloid(a2=a**2,b2=b**2,u1=u1,u2=u2,xmax=xmax,cmax=xmax,canonica=True,principal=False)
                self.reset()
                return el
        #
        # Cilindre el·líptic
        #
        def cilindre_elliptic_simple(self,a=10,b=6,direccio=&#39;Z&#39;,pmax=20):
                &#34;&#34;&#34;
                Draws an elliptic cylinder with direction X, Y or Z
                Parameters:
                        a, b: semiaxis of the ellipse

                        direction: direction of translation of the ellipse

                        pmax = height of the cylindrer
                &#34;&#34;&#34;
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        u1 = Vector([0,0,1])
                        u2 = Vector([0,1,0])
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        u1 = Vector([1,0,0])
                        u2 = Vector([0,0,1])
                else:
                        u1 = Vector([1,0,0])
                        u2 = Vector([0,1,0])
                cy = self.elliptic_cylinder(a2=a**2,b2=b**2,u1=u1,u2=u2,zmax=pmax,canonica=True,principal=False)
                el = self.draw_ellipse(a=a,b=b,u1=u1,u2=u2,thickness=0.02,steps=128,axis=False)
                self.reset()
                return list(cy) + [el]
        #
        # Cilindre hiperbòlic
        #
        def cilindre_hiperbolic_simple(self,a=4,b=3,direccio=&#39;Z&#39;,pmax=15,hmax=20):
                &#34;&#34;&#34;
                Draws an hyperbolic cylinder with direction X, Y or Z
                Parameters:
                        a, b: semiaxis of the hyperbole

                        direccio: direction of translation of the hyperbole

                        pmax = maximum value of the independent variable

                        hmax = height of the cylindrer
                &#34;&#34;&#34;
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        u1 = Vector([0,0,1])
                        u2 = Vector([0,1,0])
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        u1 = Vector([1,0,0])
                        u2 = Vector([0,0,1])
                else:
                        u1 = Vector([1,0,0])
                        u2 = Vector([0,1,0])
                cy = self.hyperbolic_cylinder(a2=a**2,b2=b**2,u1=u1,u2=u2,xmax=pmax,zmax=hmax,canonica=True,principal=False)
                hy = self.draw_hyperbole(a=a,b=b,u1=u1,u2=u2,thickness=0.02,ymax=b*math.sqrt(-1+(pmax/a)**2),steps=128,axis=False)
                self.reset()
                return list(cy) + [hy]
        #
        # Cilindre parabòlic
        #
        def cilindre_parabolic_simple(self,a=3,direccio=&#39;Z&#39;,pmax=12,hmax=45):
                r&#34;&#34;&#34;
                Draws a parabolic cylinder with direction X, Y or Z
                Parameters:
                        a: the initial parabola has equation of type z=\pm x^2/a^2

                        direccio: direction of translation of the parabola

                        pmax = maximum value of the independent variable

                        hmax = height of the cylindrer
                &#34;&#34;&#34;
                if a == 0:
                        return
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        u1 = Vector([0,0,1])
                        u2 = Vector([0,-1,0])
                        v1 = Vector([0,0,1])
                        v2 = Vector([1,0,0])
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        u1 = Vector([1,0,0])
                        u2 = Vector([0,0,-1])
                        v1 = Vector([1,0,0])
                        v2 = Vector([0,1,0])
                else:
                        u1 = Vector([1,0,0])
                        u2 = Vector([0,1,0])
                        v1 = Vector([1,0,0])
                        v2 = Vector([0,0,1])
                s = 1
                if a &lt; 0:
                        s = -1
                cy = self.parabolic_cylinder(p=a**2/2,u1=u1,u2=u2,xmax=pmax,ymax=hmax,canonica=True,principal=False)
                pa = self.draw_parabola(a=s/a**2,u1=v1,u2=v2,thickness=0.02,xmax=pmax,steps=128,axis=False)
                self.reset()
                return list(cy) + [pa]
        #
        # Con
        #
        def con_simple(self,a=4,b=3,c=2,direccio=&#39;Z&#39;,pmax=12):
                &#34;&#34;&#34;
                Draws a con with direction X, Y or Z
                Parameters:
                        a, b, c: semiaxis of the cone

                        direccio: direction of the negative coefficient

                        pmax = maximum value of the independent variables

                        hmax = height of the cone
                &#34;&#34;&#34;
                if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                        u1 = Vector([0,0,1])
                        u2 = Vector([0,-1,0])
                        v1 = Vector([0,0,1])
                        v2 = Vector([1,0,0])
                elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                        u1 = Vector([1,0,0])
                        u2 = Vector([0,0,-1])
                        v1 = Vector([1,0,0])
                        v2 = Vector([0,1,0])
                else:
                        u1 = Vector([1,0,0])
                        u2 = Vector([0,1,0])
                        v1 = Vector([1,0,0])
                        v2 = Vector([0,0,1])
                co = self.cone(a2=a**2,b2=b**2,c2=c**2,u1=u1,u2=u2,xmax=pmax,canonica=True,principal=False)
                self.reset()
                return co
        #
        # Cilindre fitat
        #
        def cilindre(self,centre=Vector([0,0,0]),radi=1,height=5,eix=&#39;Z&#39;,color=&#34;AzureBlueDark&#34;,circlecolor=&#34;Blue&#34;):
                &#34;&#34;&#34;
                Draws a bounded cylinder with direction eix
                Parameters:

                centre: center of the cylinder

                radi: radius

                height: height

                eix: X, Y, Z or a vector

                color: color of the cylinder

                circlecolor: color of the two circles of a bounded cylinder
                &#34;&#34;&#34;
                if not isinstance(centre,Vector):
                        centre = Vector(centre)
                if isinstance(eix,str):
                        eix = eix.strip().upper()
                if eix == &#39;X&#39;:
                        u = Vector([1,0,0])
                elif eix == &#39;Y&#39;:
                        u = Vector([0,1,0])
                elif eix == &#39;Z&#39;:
                        u = Vector([0,0,1])
                elif isinstance(eix,Vector):
                        u = eix
                else:
                        u = Vector(eix)

                u1 = u.orthogonal().normalized()
                u2 = u.normalized().cross(u1)
                center1 = centre + height/2 * u.normalized()
                center2 = centre - height/2 * u.normalized()

                c1, d1 = self.draw_circle(center=center1,radius=radi,u1=u1,u2=u2,axis=False,zaxis=False,steps=128,thickness=0.02,name=&#34;Circumferències&#34;,fillcolor=color,color=circlecolor)
                c2, d2 = self.draw_circle(center=center2,radius=radi,u1=u1,u2=u2,axis=False,zaxis=False,steps=128,thickness=0.02,name=&#34;Circumferència 2&#34;,fillcolor=color,color=circlecolor)
                _, _, cil = self.elliptic_cylinder(o=centre,a2=radi**2,b2=radi**2,u1=u1,u2=u2,principal=False,canonica=False,zmax=height/2,color=color,thickness=0.01,name=&#34;Cilindre&#34;)
                self.join([cil,d1,d2])
                self.join([c1,c2])
                self.reset()
                return cil, c1
        #
        # Esfera
        #
        def esfera(self,centre=Vector([0,0,0]),radi=10,cmax=20,name=&#34;Esfera&#34;):
                &#34;&#34;&#34;
                Draws a sphere
                Parametre:
                        centre: center of the sphere

                        radi: radius of the sphere

                        cmax: maximum values of the x, y and z coordinates
                &#34;&#34;&#34;
                return self.sphere(o=centre,r2=radi**2,canonica=True,principal=False,cmax=cmax,preserve=False,name=name,thickness=0.001)
        #
        # Tor
        #
        def tor(self,centre=Vector([8,0,3]),radi=3,cmax=15,punt=None):
                &#34;&#34;&#34;
                Draws a torus of revolution from a circumference
                Parameters:
                        centre: center of the circumference

                        radi: radius of the circumference

                        cmax: maximum values of the x, y and z coordinates

                        punt: if it&#39;s a float value, draws a moving poing
                &#34;&#34;&#34;
                self.base_canonica(length=cmax)
                if len(centre) == 2:
                        centre = (centre[0],0,centre[1])
                if not isinstance(centre,Vector):
                        centre = Vector(centre)
                def F(t):
                        return (centre + Vector([radi*math.cos(t),0,radi*math.sin(t)]))
                self.animate_revolution_surface(F,tmin=0,tmax=2*math.pi,steps=128,axis=&#39;Z&#39;,point=punt)
        #
        # Revolució d&#39;una paràbola que no és un paraboloide
        #
        def superficie_revolucio_parabola(self,a=0.2,vertex=Vector([0,0,0]),pmax=8,pla=&#39;XZ&#39;,punt=None):
                &#34;&#34;&#34;
                Draws an animation of a revolution surface from a paràbola
                Parameters:
                        a: the paràbola is of the form y = a*x^2

                        vertex: vertex of the parabola

                        pmax: maximum value of the independent variable

                        pla: a value from the list (&#39;XY&#39;,&#39;YX&#39;,&#39;XZ&#39;,&#39;ZX&#39;,&#39;YZ&#39;,&#39;ZY&#39;) representing
                             the variables for the equation
                                 &#39;XY&#39; y = a*x^2 and rotaqtion around the X axis
                                 &#39;YX&#39; x = a*y^2 and rotaqtion around the Y axis
                                 &#39;XZ&#39; z = a*x^2 and rotaqtion around the X axis
                                 &#39;ZX&#39; x = a*x^2 and rotaqtion around the Z axis
                                 &#39;YZ&#39; z = a*y^2 and rotaqtion around the Y axis
                                 &#39;ZY&#39; y = a*z^2 and rotaqtion around the Z axis

                        punt: punt: if it&#39;s a float value, draws a moving poing
                &#34;&#34;&#34;
                self.base_canonica()
                if not isinstance(vertex,Vector):
                        vertex = Vector(vertex)
                def F(t):
                        if pla.upper() == &#39;XZ&#39;:
                                return (vertex + Vector([t,0,a*t**2]))
                        if pla.upper() == &#39;XY&#39;:
                                return (vertex + Vector([t,a*t**2,0]))
                        if pla.upper() == &#39;ZX&#39;:
                                return (vertex + Vector([a*t**2,0,t]))
                        if pla.upper() == &#39;ZY&#39;:
                                return (vertex + Vector([0,a*t**2,t]))
                        if pla.upper() == &#39;YZ&#39;:
                                return (vertex + Vector([0,t,a*t**2]))
                        if pla.upper() == &#39;YX&#39;:
                                return (vertex + Vector([a*t**2,t,0]))
                self.animate_revolution_surface(F,tmin=-pmax,tmax=pmax,steps=128,axis=pla[0],point=punt)
        #
        # Rotació d&#39;un ortoedre
        #
        def rotacio_ortoedre(self,centre=Vector([0,0,0]),costats=Vector([8,5,4]),eix=&#39;Z&#39;,angle=360,stop=0,opacity=1):
                &#34;&#34;&#34;
                Draws an animation of an orthohedron rotating around a vectorial line
                Parameters:
                        centre: center of the orthohedron

                        costats: half sides of the orthohedron

                        eix: axis of rotation

                        opacity: opacity of the orthohedron
                &#34;&#34;&#34;
                self.base_canonica()
                if not isinstance(centre,Vector):
                        centre = Vector(centre)
                if not isinstance(costats,Vector):
                        costats = Vector(costats)
                ortoedre = self.draw_cube(origin=centre,scale=costats,color=&#34;AzureBlueDark&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Ortoedre&#34;)
                self.rotate_object(ortoedre,axis=eix,angle=angle,stop=stop,draw=False)
        #
        # Rotació d&#39;un vector
        #
        def rotacio_vector(self,vector=Vector([6,8,5]),eix=Vector([1,1,1]),angle=360,stop=0,adaptada=False):
                &#34;&#34;&#34;
                Draws an animation of a vector rotating around a vectorial line
                Parameters:
                        vector: vector to rotate

                        eix: axis of rotation, given by a vector or by X, Y or Z

                        adaptada: if True, draws a base adapted to the rotation
                &#34;&#34;&#34;
                if not isinstance(vector,Vector):
                        vector = Vector(vector)
                if eix == &#39;X&#39;:
                        u = Vector([1,0,0])
                elif eix == &#39;Y&#39;:
                        u = Vector([0,1,0])
                elif eix == &#39;Z&#39;:
                        u = Vector([0,0,1])
                elif isinstance(eix,Vector):
                        u = eix
                else:
                        u = Vector(eix)
                e = vector.project(eix)
                l = e.length
                if l &lt; 18:
                        l = 18
                if adaptada:
                        self.base_adaptada(axis=eix,length=l,scale=0.1)
                self.base_canonica(length=l)
                self.rotate_vector(vector,eix,length=l,angle=angle,stop=stop)
    #
        # Rotació d&#39;un punt al voltant d&#39;un eix
        #
        def rotacio_punt(self,punt=Vector([6,8,5]),origen=Vector([4,3,0]),angle=360,eix=Vector([1,1,1]),length=None,stop=0,vectors=True):
                &#34;&#34;&#34;
                Draws an animation of a point rotating around an afine line
                Parameters:
                        punt: point to rotate

                        origen: point of the affine line

                        eix: axis of rotation, given by a vector or by X, Y or Z
                &#34;&#34;&#34;
                if not isinstance(punt,Vector):
                        punt = Vector(punt)
                if eix == &#39;X&#39;:
                        u = Vector([1,0,0])
                elif eix == &#39;Y&#39;:
                        u = Vector([0,1,0])
                elif eix == &#39;Z&#39;:
                        u = Vector([0,0,1])
                elif isinstance(eix,Vector):
                        u = eix
                else:
                        u = Vector(eix)

                if not isinstance(origen,Vector):
                        origen = Vector(origen)
                e = (punt-origen).project(u)
                l = e.length
                if length is not None:
                        l = length
                self.base_canonica(length=l)
                self.rotate_point(punt,origen,u,angle=angle,length=l,stop=stop,vectors=vectors)
        #
        # Rotació d&#39;un ortoedre a partir dels angles d&#39;Euler
        #
        def rotacio_ortoedre_angles_euler(self,centre=Vector([0,0,0]),costats=Vector([8,5,4]),psi=90,theta=60,phi=45,radians=False,opacity=1,eixos=&#39;zxz&#39;):
                &#34;&#34;&#34;
                Draws an animation of an orthohedron rotating given the Euler&#39;s angles
                Parameters:
                        centre: center of the orthohedron

                        costats: half sides of the orthohedron

                        psi, theta, phi: Euler&#39;s angles

                        radians: if True the Euler&#39;s angles must in radians. If False in degrees

                        opacity: opacity of the orthohedron

                        eixos: axis of the three rotations
                &#34;&#34;&#34;
                if not isinstance(centre,Vector):
                        centre = Vector(centre)
                if not isinstance(costats,Vector):
                        costats = Vector(costats)
                ortoedre = self.draw_cube(origin=centre,scale=costats,color=&#34;AzureBlueDark&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Ortoedre&#34;)
                self.rotate_euler(ortoedre,psi,theta,phi,radians=radians,axis=eixos)
        #
        # Rotació d&#39;un ortoedre al voltant d&#39;un eix i angles d&#39;Euler
        #
        def rotacio_ortoedre_voltant_vector(self,centre=Vector([0,0,0]),costats=Vector([8,5,4]),angle=80,radians=False,vector=Vector([1,-2,1]),opacity=0.7,euler=None,reverse=False):
                &#34;&#34;&#34;
                Draws an animation of a vector rotating around a vectorial line
                Parameters:
                        centre: center of the orthohedron

                        costats: half sides of the orthohedron

                        angle: angle of rotation

                        radians: if True the Euler&#39;s angles must in radians. If False in degrees

                        vector: generator of the vectorial line

                        opacity: opacity of the orthohedron

                        euler: None or the value of the three Euler&#39;s axis

                        reverse: if True, shows the rotation with Euler&#39;s angles in reverse order
                &#34;&#34;&#34;
                if not isinstance(centre,Vector):
                        centre = Vector(centre)
                if not isinstance(costats,Vector):
                        costats = Vector(costats)
                if not isinstance(vector,Vector):
                        vector = Vector(vector)
                ortoedre = self.draw_cube(origin=centre,scale=costats,color=&#34;AzureBlueDark&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Primer ortoedre&#34;)
                if euler is not None:
                        ortoedre2 = self.draw_cube(origin=centre,scale=costats,color=&#34;Green&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Segon ortoedre&#34;)
                self.rotate_object_by_axis_angle(obj=ortoedre,axis=vector,angle=angle,frames=3)
                if euler is not None:
                        R = Rotation(angle=angle,vector=vector)
                        psi, theta, phi = R.to_euler_angles(axis=euler)
                        self.rotate_euler(ortoedre2,psi=psi,theta=theta,phi=phi,axis=euler,canonica=False,reverse=reverse)
        #
        # Rotation or helical motion
        #
        def moviment_helicoidal_ortoedre(self,centre=Vector([0,0,0]),costats=Vector([3,5,2]),opacity=1,origen=Vector([4,3,0]),eix=&#39;Z&#39;,rounds=1,translacio=0.0,aligned=False):
                &#34;&#34;&#34;
                Draws an animation of the helical motion of an orthohedron around an affine line
                Parameters:
                        centre: center of the orthohedron

                        costats: half sides of the orthohedron

                        origen: point of the affine line

                        eix: axis of rotation

                        opacity: opacity of the orthohedron

                        translation: translation of the helical motion (distance by round)
                                     if translation = 0.0, it&#39;s a rotation motion

                        aligned: if True, aligns the orthohedron with the axis of rotation
                &#34;&#34;&#34;
                if isinstance(eix,str):
                        eix = eix.strip().upper()
                if eix == &#39;X&#39;:
                        u = Vector([1,0,0])
                elif eix == &#39;Y&#39;:
                        u = Vector([0,1,0])
                elif eix == &#39;Z&#39;:
                        u = Vector([0,0,1])
                elif isinstance(eix,Vector):
                        u = eix
                else:
                        u = Vector(eix)
                w1 = u.normalized()
                w2 = u.orthogonal().normalized()
                w3 = w1.cross(w2)
                self.base_canonica()
                if not isinstance(centre,Vector):
                        centre = Vector(centre)
                if not isinstance(costats,Vector):
                        costats = Vector(costats)
                if not isinstance(origen,Vector):
                        origen = Vector(origen)
                ortoedre = self.draw_cube(origin=centre,scale=costats,color=&#34;AzureBlueDark&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Ortoedre&#34;)
                if aligned:
                        ortoedre.rotation_mode = &#39;QUATERNION&#39;
                        x = Vector([1,0,0])
                        quaternion = x.rotation_difference(w1)
                        ortoedre.rotation_quaternion.rotate(quaternion)
                self.rotate_object(ortoedre,axis=eix,origin=origen,translation=translacio,rounds=rounds)
        #
        # Rotation or helical motion of a cylinder
        #
        def moviment_helicoidal_cilindre(self,centre=Vector([0,0,0]),radi=3,altura=12,opacity=1,origen=Vector([4,3,0]),eix=&#39;Z&#39;,rounds=1,translacio=0.0,aligned=False,reverse=False):
                &#34;&#34;&#34;
                Draws an animation of the helical motion of an orthohedron around an affine line
                Parameters:
                        centre: center of the cylinder

                        radi: radius of the cylinder

                        altura: height of the cylinder

                        origen: point of the affine line

                        eix: axis of rotation

                        opacity: opacity of the orthohedron

                        translation: translation of the helical motion (distance by round)
                                     if translation = 0.0, it&#39;s a rotation motion

                        aligned: if True, aligns the orthohedron with the axis of rotation
                &#34;&#34;&#34;
                if isinstance(eix,str):
                        eix = eix.strip().upper()
                if eix == &#39;X&#39;:
                        u = Vector([1,0,0])
                elif eix == &#39;Y&#39;:
                        u = Vector([0,1,0])
                elif eix == &#39;Z&#39;:
                        u = Vector([0,0,1])
                elif isinstance(eix,Vector):
                        u = eix
                else:
                        u = Vector(eix)

                w1 = u.normalized()
                w2 = u.orthogonal().normalized()
                w3 = w1.cross(w2)
                self.base_canonica()
                if not isinstance(centre,Vector):
                        centre = Vector(centre)
                if not isinstance(origen,Vector):
                        origen = Vector(origen)
                cil, cir = self.cilindre(centre=centre,radi=radi,height=altura,eix=&#39;Z&#39;,color=&#34;AzureBlueDark&#34;,circlecolor=&#34;Blue&#34;)
                if aligned:
                        cil.rotation_mode = &#39;QUATERNION&#39;
                        cir.rotation_mode = &#39;QUATERNION&#39;
                        x = Vector([0,0,1])
                        quaternion = x.rotation_difference(w1)
                        cil.rotation_quaternion.rotate(quaternion)
                        cir.rotation_quaternion.rotate(quaternion)
                        cir.location = cil.location + altura/2 * w1
                if reverse:
                        u *= -1
                self.rotate_objects([cil,cir],axis=u,origin=origen,translation=translacio,rounds=rounds,draw=True)
        #
        # Rotation or helical motion of a point
        #
        def moviment_helicoidal_punt(self,punt=Vector([0,0,0]),origen=Vector([-3,-3,-4]),eix=&#39;Z&#39;,rounds=5,angle=360,stop=0,translacio=2,vectors=True,length=15,reverse=False):
                &#34;&#34;&#34;
                Draws an animation of the helical motion of an orthohedron around an affine line
                Parameters:
                        punt: posició inicial del punt

                        origen: point of the affine line

                        eix: axis of rotation

                        rounds: rounds of the point aroud the axis

                        translation: translation of the helical motion (distance by frame)
                                     if translation = 0.0, it&#39;s a rotation motion
                &#34;&#34;&#34;
                if isinstance(eix,str):
                        eix = eix.strip().upper()
                if eix == &#39;X&#39;:
                        u = Vector([1,0,0])
                elif eix == &#39;Y&#39;:
                        u = Vector([0,1,0])
                elif eix == &#39;Z&#39;:
                        u = Vector([0,0,1])
                elif isinstance(eix,Vector):
                        u = eix
                else:
                        u = Vector(eix)

                if angle &lt; 360:
                        rounds = 1
                self.base_canonica()
                if not isinstance(punt,Vector):
                        punt = Vector(punt)
                if not isinstance(origen,Vector):
                        origen = Vector(origen)
                self.draw_point(radius=0.2,location=punt,name=&#34;Blue&#34;,color=&#34;Blue&#34;)
                obj = self.draw_point(radius=0.2,location=punt,name=&#34;Red&#34;,color=&#34;Red&#34;)
                obj2 = None
                if vectors:
                        self.draw_vector(origin=origen,vector=punt-origen,name=&#34;VBlack&#34;,color=&#34;Black&#34;)
                        obj2 = self.draw_vector(origin=origen,vector=punt-origen,name=&#34;VRed&#34;,color=&#34;Red&#34;)
                if obj2 is None:
                        if reverse:
                                self.rotate_object(obj,axis=-u,origin=origen,translation=translacio,angle=angle,stop=stop,length=length,rounds=rounds,draw=True)
                        else:
                                self.rotate_object(obj,axis=u,origin=origen,translation=translacio,angle=angle,stop=stop,length=length,rounds=rounds,draw=True)
                else:
                        if reverse:
                                self.rotate_objects([obj,obj2],axis=-u,origin=origen,translation=translacio,angle=angle,stop=stop,length=length,rounds=rounds,draw=True)
                        else:
                                self.rotate_objects([obj,obj2],axis=u,origin=origen,translation=translacio,angle=angle,stop=stop,length=length,rounds=rounds,draw=True)
                vec1 = (punt-origen).project(u)
                center = origen + vec1
                w1 = (punt-center).normalized()
                w3 = u.normalized()
                w2 = w3.cross(w1)
                radius = (center-punt).length
                if angle &lt; 360:
                        self.curve(lambda t: (radius*math.cos(t),radius*math.sin(t),180*translacio*u.length/(angle*math.pi)*t),tmin=0,tmax=2*rounds*math.pi,steps=128,thickness=0.005,name=&#34;Hèlix&#34;,color=&#34;Yellow&#34;,o=center,u1=w1,u2=w2)
                else:
                        self.curve(lambda t: (radius*math.cos(t),radius*math.sin(t),translacio*t/(2*math.pi)),tmin=-2*rounds*math.pi,tmax=2*rounds*math.pi,steps=128*rounds,thickness=0.005,name=&#34;Hèlix&#34;,color=&#34;Yellow&#34;,o=center,u1=w1,u2=w2)
                self.reset()
        #
        # Gir en el pla d&#39;un poligon
        #
        def gir_poligon(self,centre=Vector([0,0,0]),costats=6,origen=Vector([0,0,0]),radi=8):
                &#34;&#34;&#34;
                Draws an animation of the rotation around a point of a polygon in the plane XY
                Parameters:
                        centre: center of the polygon

                        costats: sides of the polygon

                        origen: center of the rotation

                        radi: radius of the polygon
                &#34;&#34;&#34;
                if len(centre) == 2:
                        centre = [centre[0],centre[1],0]
                if len(origen) == 2:
                        origen = [origen[0],origen[1],0]
                if not isinstance(centre,Vector):
                        centre = Vector(centre)
                if not isinstance(origen,Vector):
                        origen = Vector(origen)
                self.base_canonica(zaxis=False)
                self.draw_point(radius=0.167,location=origen,name=&#34;Centre del gir&#34;,color=&#34;White&#34;)
                poligon = self.draw_regular_polygon(origin=centre,vertexs=costats,radius=radi,name=&#34;Polígon regular&#34;)
                self.rotate_object(poligon,axis=&#39;Z&#39;,origin=origen,draw=False)
        #
        # Quàdriques
        #
        circumferencia = draw_circle
        ellipsoide = ellipsoid
        hiperboloide_dues_fulles = two_sheets_hyperboloid
        hiperboloide_una_fulla = one_sheet_hyperboloid
        con = cone
        paraboloide_elliptic = elliptic_paraboloid
        paraboloide_hiperbolic = hyperbolic_paraboloid
        cilindre_elliptic = elliptic_cylinder
        cilindre_hiperbolic = hyperbolic_cylinder
        cilindre_parabolic = parabolic_cylinder
        #
        # Esfera i cilindre el·liptic
        #
        def esfera_cilindre_elliptic(self,radi=10,x0=5,a=5,b=5):
                &#34;&#34;&#34;
                Draws an sphere centered at (0,0,0), an elliptic cylinder and their intersection
                Parameters:
                        radi: radius of the sphere

                        x0: (x0,0,0) is the center of the ellipse in the plain XY

                        a, b: semiaxis of this ellipse
                &#34;&#34;&#34;
                if radi &lt;= 0:
                        return
                def F(t):
                        x = x0 + a*math.cos(t)
                        y = b*math.sin(t)
                        z = radi**2 - x**2 - y**2
                        if z &lt; 0:
                                z  = 0
                        z = math.sqrt(z)
                        return (x,y,z)
                self.sphere(r2=radi**2,canonica=True,color=&#34;GrayLight&#34;,thickness=0.0001,pmax=3*radi+3,name=&#34;Esfera&#34;)
                self.elliptic_cylinder(o=[x0,0,0],a2=a**2,b2=b**2,principal=False,canonica=False,zmax=3*radi,thickness=0.01,name=&#34;Cilindre&#34;)
                x, y = symbols(&#39;x y&#39;,real=True)
                sol = solve([x**2 + y**2 - radi**2, (x-x0)**2/a**2 + y**2/b**2 - 1],[x,y],dict=True)
                #
                # 1. solve retorna una única solució
                # La solució és el punt (x0+a,0) o (x0-a,0,0)
                #
                if len(sol) == 1:
                        #
                        # L&#39;altre vèrtex està dins o fora de la circumferència x^2 + y^2 = radi^2
                        #
                        if (sol[0][x] == radi and abs(x0 - a) &lt; radi) or (sol[0][x] == - radi and abs(x0 + a) &lt; radi):
                                self.curve(F,tmin=0,tmax=2*math.pi,steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
                        else:
                                self.draw_point(radius=0.2,location=(sol[0][x],sol[0][y],0),name=&#34;Punt intersecció&#34;,color=&#34;Black&#34;,opacity=1.0)
                #
                # 2. solve retorna dues solucions
                #
                if len(sol) == 2:
                        try:
                                sol[0][x]
                                sol[0][y]
                                sol[1][x]
                                sol[1][y]
                                circ = False
                        except:
                                circ = True
                        if circ:
                                #
                                # El cilindre és de revolució i les circumferències al pla XY coincideixen
                                #
                                self.draw_circle(radius=radi,steps=64,thickness=0.05,name=&#34;Circumferència&#34;,color=&#34;Black&#34;)
                        else:
                                #
                                # Tenim dues solucions diferents, que han de ser (radi,0) i (-radi,0)
                                #
                                if abs(b) &lt; radi:
                                        theta = [math.atan2(sol[i][y]/b,(sol[i][x] - x0)/a) for i in range(2)]
                                        theta.sort()
                                        if x0 &gt; 0:
                                                self.curve(F,tmin=theta[1],tmax=2*math.pi-theta[1],steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
                                        else:
                                                self.curve(F,tmin=theta[0],tmax=theta[1],steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
                                else:
                                        self.draw_point(radius=0.2,location=(sol[0][x],sol[0][y],0),name=&#34;Punt intersecció 1&#34;,color=&#34;Black&#34;,opacity=1.0)
                                        self.draw_point(radius=0.2,location=(sol[1][x],sol[1][y],0),name=&#34;Punt intersecció 2&#34;,color=&#34;Black&#34;,opacity=1.0)
                #
                # 2. solve retorna tres solucions
                #
                if len(sol) == 3:
                        theta = [math.atan2(sol[i][y]/b,(sol[i][x] - x0)/a) for i in range(3)]
                        theta.sort()
                        if theta[1] == 0.0:
                                self.curve(F,tmin=theta[0],tmax=theta[2],steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
                        if theta[2] == math.pi:
                                self.curve(F,tmin=theta[1],tmax=theta[0]+2*math.pi,steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
                #
                # 2. solve retorna quatre solucions
                #
                if len(sol) == 4:
                        theta = [math.atan2(sol[i][y]/b,(sol[i][x] - x0)/a) for i in range(4)]
                        theta.sort()
                        self.curve(F,tmin=theta[2],tmax=theta[3],steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=(&#39;XY&#39;,&#39;XZ&#39;,&#39;X&#39;),name=&#34;Corba intersecció&#34;)
        #
        # Con i cilindre el·liptic
        #
        def con_cilindre_elliptic(self,a2=1,b2=1,c2=1,x0=5,a=8,b=5,zmax=15):
                &#34;&#34;&#34;
                Draws a cone with vertex at (0,0,0) and equation x^2/a2 + y^2/b2 - z^2/c2 == 0,
                an elliptic cylinder and their intersection
                Parameters:
                        a2, b2, c2: coefficients of the equation of the cone

                        x0: (x0,0,0) is the center of the ellipse in the plain XY

                        a, b: semiaxis of this ellipse

                        zmax: maximum value of the z coordinate
                &#34;&#34;&#34;
                a2, b2, c2 = abs(a2), abs(b2), abs(c2)
                if a2*b2*c2 == 0:
                        return
                xmax = zmax*math.sqrt(a2/c2)
                def F(t):
                        x = x0 + a*math.cos(t)
                        y = b*math.sin(t)
                        z = math.sqrt(c2*(x**2/a2 + y**2/b2))
                        return (x,y,z)
                self.cone(a2=a2,b2=b2,c2=c2,principal=False,canonica=True,color=&#34;GrayLight&#34;,thickness=0.0001,name=&#34;Con&#34;,xmax=xmax,cmax=xmax+5,opacity=1.0)
                self.elliptic_cylinder(o=[x0,0,0],a2=a**2,b2=b**2,principal=False,canonica=False,zmax=2*(zmax+3),thickness=0.01,name=&#34;Cilindre&#34;)
                self.curve(F,tmin=0,tmax=2*math.pi,steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
        #
        # Segment esfèric
        #
        def segment_esferic(self,r=10,p1=math.pi/2,s1=0,p2=math.pi/2,s2=math.pi/2,name=&#34;Segment&#34;):
                &#34;&#34;&#34;
                Draws an spheric segment in a sphere centered at origin with radius r from the point
                whith spherical coordinates (radi,p1,s1) to the point (radi,p2,s2).
                Parameters:
                   r: radius of the sphere
                   p1: polar angle of the first point
                   s1: azimuthal angle of the first point
                   p2: polar angle of the second point
                   s2: azimuthal angle of the second point
                &#34;&#34;&#34;
                x = Vector([r*math.sin(p1)*math.cos(s1),r*math.sin(p1)*math.sin(s1),r*math.cos(p1)])
                y = Vector([r*math.sin(p2)*math.cos(s2),r*math.sin(p2)*math.sin(s2),r*math.cos(p2)])
                R = EuclideanReference(u1=x,u2=y)
                x1 = R.coordinates(x)
                y1 = R.coordinates(y)
                b = R.base()
                t0 = math.atan2(x1[1],x1[0])
                t1 = math.atan2(y1[1],y1[0])
                def F(t):
                        x = r*math.cos(t)
                        y = r*math.sin(t)
                        z = 0
                        return (x,y,z)
                c = self.draw_curve(F,tmin=t0,tmax=t1,steps=256,thickness=0.05,color=&#34;Red&#34;,name=name,u1=b[0],u2=b[1])
                return c
        #
        # Triangle esfèric
        #
        def triangle_esferic(self,r=10,p1=math.pi/2,s1=0,p2=math.pi/2,s2=math.pi/2,p3=0,s3=0):
                &#34;&#34;&#34;
                Draws an spheric triangle in a sphere centered at origin with radius r  with vetices
                whith spherical coordinates (radi,p1,s1), (radi,p2,s2) and (radi,p2,s2).
                Parameters:
                   r: radius of the sphere
                   p1: polar angle of the first point
                   s1: azimuthal angle of the first point
                   p2: polar angle of the second point
                   s2: azimuthal angle of the second point
                   p3: polar angle of the third point
                   s3: azimuthal angle of the third point
                &#34;&#34;&#34;
                es = self.esfera(r2=r**2,canonica=False,principal=False,thickness=0.001,name=&#34;Esfera&#34;)
                c1 = self.segment_esferic(r=r,p1=p1,s1=s1,p2=p2,s2=s2,name=&#34;Costat 1&#34;)
                c2 = self.segment_esferic(r=r,p1=p2,s1=s2,p2=p3,s2=s3,name=&#34;Costat 2&#34;)
                c3 = self.segment_esferic(r=r,p1=p3,s1=s3,p2=p1,s2=s1,name=&#34;Costat 3&#34;)
        #
        # Triangle esfèric aleatori
        #
        def triangle_esferic_aleatori(self,r=10):
                &#34;&#34;&#34;
                Draws a random spheric triangle in a sphere centered at origin with radius r
                Parameters:
                   r: radius of the sphere
                &#34;&#34;&#34;
                std = math.pi/9
                mean = math.pi/2
                nums = np.random.normal(loc=mean, scale=std, size=20)
                nums = [x for x in nums if x &gt; 0 and x &lt; math.pi]
                p1, p2, p3 = nums[0:3]

                std = math.pi/6
                mean = 0
                nums = np.random.normal(loc=mean, scale=std, size=20)
                nums = [x for x in nums if x &lt; math.pi/2 and x &gt; -math.pi/2]
                s1, s2, s3 = nums[0:3]
                print(s1,s2,s3)
                self.triangle_esferic(r=r,p1=p1,s1=s1,p2=p2,s2=s2,p3=p3,s3=s3)</code></pre>
</details>
<div class="desc"><p>Class used to define all the functions in this module to work with graphics in Blender</p>
<p>Initializes the values for scene, objects, meshes, collection, etc.</p></div>
<h3>Methods</h3>
<dl>
<dt id="LinearAlgebra.LinearAlgebra.add_ligth"><code class="name flex">
<span>def <span class="ident">add_ligth</span></span>(<span>self, location=[0, 0, 100], energy=3, direction=[0, 0, -1])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_ligth(self,location=[0,0,100],energy=3,direction=[0,0,-1]):
        &#34;&#34;&#34;
        Adds a ligth to the scene
        Parameters:
           location: location point of the light

           energy: energy of the ligth

           direction: direction of the light
        &#34;&#34;&#34;
        l = bpy.data.lights.new(name=&#34;Light&#34;, type=&#39;SUN&#39;)
        l.energy = energy
        l.specular_factor = 4
        obj = self.objects.new(name=&#34;Light&#34;, object_data=l)
        obj.rotation_mode = &#39;QUATERNION&#39;
        obj.location = location
        n = Vector(direction)
        mat = Matrix(self.base)
        mat.transpose()
        n = mat @ n
        z = Vector([0,0,-1])
        quaternion = z.rotation_difference(n)
        obj.rotation_quaternion.rotate(quaternion)
        self.collection.objects.link(obj)</code></pre>
</details>
<div class="desc"><p>Adds a ligth to the scene</p>
<h2 id="parameters">Parameters</h2>
<p>location: location point of the light</p>
<p>energy: energy of the ligth</p>
<p>direction: direction of the light</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.add_ligths"><code class="name flex">
<span>def <span class="ident">add_ligths</span></span>(<span>self, energy=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_ligths(self,energy=1):
        &#34;&#34;&#34;
        Adds diferent lights to the scene
        Parameters:
           energy: energy of the lights
        &#34;&#34;&#34;
        self.add_ligth()
        self.add_ligth(location=[100,0,0],direction=[-1,0,0],energy=energy)
        self.add_ligth(location=[0,100,0],direction=[0,-1,0],energy=energy)
        self.add_ligth(location=[-100,0,0],direction=[1,0,0],energy=energy)
        self.add_ligth(location=[0,-100,0],direction=[0,1,0],energy=energy)</code></pre>
</details>
<div class="desc"><p>Adds diferent lights to the scene</p>
<h2 id="parameters">Parameters</h2>
<p>energy: energy of the lights</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.add_material"><code class="name flex">
<span>def <span class="ident">add_material</span></span>(<span>self, obj, material_name, r, g, b, opacity=1.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_material(self,obj,material_name,r,g,b,opacity=1.0):
        &#34;&#34;&#34;
        Adds a material and color to an object
        Parameters:
           obj: object

           material_name: material&#39;s name

           r, g, b: RGB color values

           opacity: the opacity
        &#34;&#34;&#34;
        material = bpy.data.materials.get(material_name)
        if material is None:
                material = bpy.data.materials.new(material_name)
        material.use_nodes = True
        principled_bsdf = material.node_tree.nodes[&#39;Principled BSDF&#39;]
        if principled_bsdf is not None:
                principled_bsdf.inputs[&#39;Base Color&#39;].default_value = (r, g, b, opacity)
                principled_bsdf.inputs[&#39;IOR&#39;].default_value = 0.0
                principled_bsdf.inputs[&#39;Metallic&#39;].default_value = 1.0
                principled_bsdf.inputs[&#39;Roughness&#39;].default_value = 0.55
                if bpy.app.version[0] &lt; 4:
                        principled_bsdf.inputs[&#39;Specular&#39;].default_value = 1.0
                else:
                        principled_bsdf.inputs[&#39;Specular IOR Level&#39;].default_value = 1.0
                if bpy.app.version[0] &lt; 4:
                        principled_bsdf.inputs[&#39;Emission&#39;].default_value = (r, g, b, opacity)
                else:
                        principled_bsdf.inputs[&#39;Emission Color&#39;].default_value = (r, g, b, opacity)
                principled_bsdf.inputs[&#39;Emission Strength&#39;].default_value = 0.0
                if opacity &lt; 1.0:
                        material.blend_method = &#39;BLEND&#39;
                        principled_bsdf.inputs[&#39;Alpha&#39;].default_value = opacity
                else:
                        material.blend_method = &#39;OPAQUE&#39;
                        principled_bsdf.inputs[&#39;Alpha&#39;].default_value = 1.0
        obj.active_material = material</code></pre>
</details>
<div class="desc"><p>Adds a material and color to an object</p>
<h2 id="parameters">Parameters</h2>
<p>obj: object</p>
<p>material_name: material's name</p>
<p>r, g, b: RGB color values</p>
<p>opacity: the opacity</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.animate_revolution_surface"><code class="name flex">
<span>def <span class="ident">animate_revolution_surface</span></span>(<span>self,<br>fun=None,<br>tmin=0.0,<br>tmax=1.0,<br>steps=256,<br>curvethicknes=0.025,<br>thickness=0.025,<br>frames=3,<br>angle=3,<br>radians=False,<br>axis='Z',<br>origin=Vector((0.0, 0.0, 0.0)),<br>line=0,<br>canonica=0,<br>symmetry=None,<br>name='Revolution surface',<br>color='AzureBlueDark',<br>point=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def animate_revolution_surface(self,fun=None,tmin=0.0,tmax=1.0,steps=256,curvethicknes=0.025,thickness=0.025,frames=3,angle=3,radians=False,axis=&#39;Z&#39;,origin=Vector([0,0,0]),line=0,canonica=0,symmetry=None,name=&#34;Revolution surface&#34;,color=&#34;AzureBlueDark&#34;,point=None):
        &#34;&#34;&#34;
        Draws and animates a revolution surface from a curve
        Parameters:
           fun: parametric equacion of the curve

           steps: number of steps to graw the curve

           curvethicknes: thickness of the curve

           frames: number of frames at each step of revolution

           angle: step angle of the revolution

           radians: if True, angle must be in radians

           axis: axis of revolution. It must be &#39;X&#39;, &#39;Y&#39; or &#39;Z&#39;

           origin: point of the axis of revolution

           symmetry: symmetry used to draw the curve

           name: name of the surface

           color: color of the surface

           point: if not None draw three points and a cercle. Must be a float between tmax and tmin
        &#34;&#34;&#34;
        if radians:
                angle *= 180/math.pi
        stepsr = int(360/angle) + 1
        angle = 360/stepsr
        if fun is None:
                return None

        def myfun(t):
                return Vector(fun(t)) - origin

        if not isinstance(origin,Vector):
                origin = Vector(origin)

        if axis == &#39;X&#39;:
                r = Rotation(angle,Vector([1,0,0]))
                d0 = Vector([1,0,0])
                d1 = Vector([0,1,0])
                d2 = Vector([0,0,1])
        elif axis == &#39;Y&#39;:
                r = Rotation(angle,Vector([0,1,0]))
                d0 = Vector([0,1,0])
                d1 = Vector([0,0,1])
                d2 = Vector([1,0,0])
        elif axis == &#39;Z&#39;:
                r = Rotation(angle,Vector([0,0,1]))
                d0 = Vector([0,0,1])
                d1 = Vector([1,0,0])
                d2 = Vector([0,1,0])
        else:
                return None

        if point is not None:
                try:
                        tp = 1.0 * point
                except:
                        pass
                if not isinstance(tp,float):
                        return None
                if tp &lt; tmin or tp &gt; tmax:
                        tp = random.uniform(tmin,tmax)
                zp = Vector(myfun(tp))
                e = d1.cross(d2)
                z0 = zp.project(e)

        if line &gt; 0:
                self.draw_line(start=-line*d0,end=line*d0,scale=0.1,name=&#34;Eix de rotació&#34;)

        if canonica &gt; 0:
                self.set_origin(-origin)
                self.draw_base_axis(axis=canonica,positive=False,scale=0.05,name=&#34;Referència canònica&#34;)
                self.set_origin()


        p2 = self.curve(myfun,tmin=tmin,tmax=tmax,steps=steps,thickness=curvethicknes,color=&#34;Red&#34;,symmetry=symmetry,name=&#34;Rotating curve&#34;)
        p1 = self.curve(myfun,tmin=tmin,tmax=tmax,steps=steps,thickness=1.05*curvethicknes,color=&#34;Blue&#34;,symmetry=symmetry,name=&#34;Curve&#34;)
        obj = self.simple_curve(myfun,tmin=tmin,tmax=tmax,steps=steps,name=name,symmetry=symmetry)

        if point is not None:
                m1 = self.draw_point(radius=0.1,location=zp,name=&#34;Punt p0&#34;,color=&#34;Red&#34;)
                m2 = self.draw_point(radius=0.2,location=zp,name=&#34;Punt p1&#34;,color=&#34;Black&#34;)
                m3 = self.draw_point(radius=0.1,location=z0,name=&#34;Punt p2&#34;,color=&#34;Blue&#34;)
                l1 = self.draw_line(start=z0,end=zp,scale=0.04,name=&#34;Línia 1&#34;,color=&#34;Black&#34;)
                l2 = self.draw_line(start=z0,end=zp,scale=0.03,name=&#34;Línia 2&#34;,color=&#34;Red&#34;)
                l1 = self.join([l1,m2])
                self.draw_circle(center=z0,u1=d1,u2=d2,radius=(zp-z0).length,steps=128,thickness=0.005,name=&#34;Circle&#34;,color=&#34;Cyan&#34;)

        m = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        m.levels = 4
        m.subdivision_type = &#39;SIMPLE&#39;
        m = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
        m.thickness = thickness
        m.offset = 1.0
        m = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
        m.angle = 0.0
        m.steps = steps
        m.axis =  axis
        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
        bpy.context.scene.collection.objects.link(obj)

        bpy.context.scene.frame_set(self.frame)
        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        obj.keyframe_insert(data_path=&#39;modifiers[&#34;Screw&#34;].angle&#39;,index=-1)
        p2.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        if point is not None:
                l1.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                # m2.keyframe_insert(data_path=&#34;location&#34;,index=-1)
        fn = frames + self.frame
        w = Vector([-1,0,3])
        for i in range(0,stepsr):
                bpy.context.scene.frame_set(fn)
                p2.rotation_quaternion.rotate(r.quaternion)
                p2.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                obj.modifiers[&#34;Screw&#34;].angle = 2 * (i+1) * math.pi / stepsr
                obj.modifiers[&#34;Screw&#34;].steps = i+1
                obj.keyframe_insert(data_path=&#39;modifiers[&#34;Screw&#34;].angle&#39;,index=-1)
                if point is not None:
                        l1.rotation_quaternion.rotate(r.quaternion)
                        l1.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        #m2.location.rotate(r.quaternion)
                        # m2.location = m2.location + w
                        #m2.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn += frames
        self.frame = fn - frames
        bpy.context.scene.frame_end = self.frame
        bpy.context.view_layer.update()
        self.reset()
        bpy.context.scene.frame_set(0)
        bpy.ops.object.select_all(action=&#39;SELECT&#39;)
        bpy.ops.transform.translate(value=origin)
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)</code></pre>
</details>
<div class="desc"><p>Draws and animates a revolution surface from a curve</p>
<h2 id="parameters">Parameters</h2>
<p>fun: parametric equacion of the curve</p>
<p>steps: number of steps to graw the curve</p>
<p>curvethicknes: thickness of the curve</p>
<p>frames: number of frames at each step of revolution</p>
<p>angle: step angle of the revolution</p>
<p>radians: if True, angle must be in radians</p>
<p>axis: axis of revolution. It must be 'X', 'Y' or 'Z'</p>
<p>origin: point of the axis of revolution</p>
<p>symmetry: symmetry used to draw the curve</p>
<p>name: name of the surface</p>
<p>color: color of the surface</p>
<p>point: if not None draw three points and a cercle. Must be a float between tmax and tmin</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.base_adaptada"><code class="name flex">
<span>def <span class="ident">base_adaptada</span></span>(<span>self,<br>origin=Vector((0.0, 0.0, 0.0)),<br>axis=Vector((1.0, 1.0, 1.0)),<br>length=15,<br>scale=0.04,<br>name='Base adaptada')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_adaptada(self,origin=Vector([0,0,0]),axis=Vector([1,1,1]),length=15,scale=0.04,name=&#34;Base adaptada&#34;):
        &#34;&#34;&#34;
        Draws an ortonormal base from vector axis with origin in the point origin and sets the default
        origin and default base to them
        Parameters:
                origin: origin of the vector and the base

                axis: first vector of the base

                length: length of the axis

                scale: scale of the base

                name: name of the base
        &#34;&#34;&#34;
        if not isinstance(origin,Vector):
                origin = Vector(origin)
        if not isinstance(axis,Vector):
                axis = Vector(axis)
        self.set_origin(origin)
        u1 = axis.normalized()
        u2 = u1.orthogonal().normalized()
        u3 = u1.cross(u2)
        self.set_base([u1,u2,u3])
        self.set_colors([&#34;Magenta&#34;,&#34;Yellow&#34;,&#34;Cyan&#34;])
        self.draw_base_axis(axis=length,positive=False,scale=scale,name=name)
        self.set_colors()
        self.reset()</code></pre>
</details>
<div class="desc"><p>Draws an ortonormal base from vector axis with origin in the point origin and sets the default
origin and default base to them</p>
<h2 id="parameters">Parameters</h2>
<p>origin: origin of the vector and the base</p>
<p>axis: first vector of the base</p>
<p>length: length of the axis</p>
<p>scale: scale of the base</p>
<p>name: name of the base</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.base_canonica"><code class="name flex">
<span>def <span class="ident">base_canonica</span></span>(<span>self,<br>origin=Vector((0.0, 0.0, 0.0)),<br>length=15,<br>scale=0.04,<br>zaxis=True,<br>name='Base canònica')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_canonica(self,origin=Vector([0,0,0]),length=15,scale=0.04,zaxis=True,name=&#34;Base canònica&#34;):
        &#34;&#34;&#34;
        Draws the canonical base
        Parameters:
           origin: point where to represent the base

           length: length of the axis

           scale: scale of the cylinder

           zaxis: if False the z axis is not drawn

           name: name of the object
        &#34;&#34;&#34;
        if not isinstance(origin,Vector):
                origin = Vector(origin)
        self.set_origin(origin)
        self.draw_base_axis(axis=length,positive=False,scale=scale,zaxis=zaxis,name=name)</code></pre>
</details>
<div class="desc"><p>Draws the canonical base</p>
<h2 id="parameters">Parameters</h2>
<p>origin: point where to represent the base</p>
<p>length: length of the axis</p>
<p>scale: scale of the cylinder</p>
<p>zaxis: if False the z axis is not drawn</p>
<p>name: name of the object</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.base_canonica_white"><code class="name flex">
<span>def <span class="ident">base_canonica_white</span></span>(<span>self,<br>origin=Vector((0.0, 0.0, 0.0)),<br>length=20,<br>scale=0.04,<br>zaxis=True,<br>name='Base canònica')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_canonica_white(self,origin=Vector([0,0,0]),length=20,scale=0.04,zaxis=True,name=&#34;Base canònica&#34;):
        &#34;&#34;&#34;
        Draws the canonical base in white
        Parameters:
           origin: point where to represent the base

           length: length of the axis

           scale: scale of the cylinder

           zaxis: if False the z axis is not drawn

           name: name of the object
        &#34;&#34;&#34;
        if not isinstance(origin,Vector):
                origin = Vector(origin)
        self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
        self.draw_base_axis(axis=length,positive=False,scale=scale,zaxis=zaxis,name=name)
        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])</code></pre>
</details>
<div class="desc"><p>Draws the canonical base in white</p>
<h2 id="parameters">Parameters</h2>
<p>origin: point where to represent the base</p>
<p>length: length of the axis</p>
<p>scale: scale of the cylinder</p>
<p>zaxis: if False the z axis is not drawn</p>
<p>name: name of the object</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.base_cilinder"><code class="name flex">
<span>def <span class="ident">base_cilinder</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_cilinder(self):
        &#34;&#34;&#34;
        Draws a base cilinder with radius 1 and depth 1
        &#34;&#34;&#34;
        bpy.ops.mesh.primitive_cylinder_add(radius=1,depth=1,enter_editmode=False,location=(0, 0, 0))
        bpy.ops.transform.translate(value=(0, 0, 0.5), orient_type=&#39;GLOBAL&#39;,orient_matrix_type=&#39;GLOBAL&#39;,
                constraint_axis=(False, False, True), mirror=True, use_proportional_edit=False,
                proportional_edit_falloff=&#39;SMOOTH&#39;,proportional_size=1, use_proportional_connected=False, use_proportional_projected=False)
        bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
        bpy.ops.object.shade_smooth()
        bpy.context.object.name = &#39;Arrow_stem&#39;</code></pre>
</details>
<div class="desc"><p>Draws a base cilinder with radius 1 and depth 1</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.base_cone"><code class="name flex">
<span>def <span class="ident">base_cone</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_cone(self):
        &#34;&#34;&#34;
        Draws a base cone with radius1=1.5, radius2=0, depth=2
        &#34;&#34;&#34;
        bpy.ops.mesh.primitive_cone_add(radius1=1.5, radius2=0, depth=2, enter_editmode=False, location=(0, 0, 0))
        bpy.ops.transform.translate(value=(0, 0, 1), orient_type=&#39;GLOBAL&#39;,orient_matrix_type=&#39;GLOBAL&#39;,
                constraint_axis=(False, False, True), mirror=True, use_proportional_edit=False,
                proportional_edit_falloff=&#39;SMOOTH&#39;, proportional_size=1, use_proportional_connected=False, use_proportional_projected=False)
        bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
        bpy.ops.object.shade_smooth()
        bpy.context.object.name = &#39;Arrow_cone&#39;</code></pre>
</details>
<div class="desc"><p>Draws a base cone with radius1=1.5, radius2=0, depth=2</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.base_disk"><code class="name flex">
<span>def <span class="ident">base_disk</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_disk(self):
        &#34;&#34;&#34;
        Draws a base cone with radius1=1.5, radius2=0, depth=2
        &#34;&#34;&#34;
        bpy.ops.mesh.primitive_circle_add(vertices=32,fill_type=&#39;NGON&#39;,enter_editmode=False,align=&#39;WORLD&#39;,location=(0.0, 0.0, 0.0))
        bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
        bpy.ops.object.shade_smooth()
        bpy.context.object.name = &#39;Base_disk&#39;</code></pre>
</details>
<div class="desc"><p>Draws a base cone with radius1=1.5, radius2=0, depth=2</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.base_is_canonica"><code class="name flex">
<span>def <span class="ident">base_is_canonica</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_is_canonica(self):
        &#34;&#34;&#34;
        Returns True if self.base is the canonical basis
        &#34;&#34;&#34;
        return Matrix(self.base).is_identity</code></pre>
</details>
<div class="desc"><p>Returns True if self.base is the canonical basis</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.base_no_canonica"><code class="name flex">
<span>def <span class="ident">base_no_canonica</span></span>(<span>self,<br>origin=Vector((0.0, 0.0, 0.0)),<br>u1=Vector((1.0, -1.0, 0.0)),<br>u2=Vector((0.5, -0.5, -0.5)),<br>u3=Vector((-1.0, 0.0, 1.0)),<br>length=12,<br>scale=0.04,<br>preserve=False,<br>name="Base B'")</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_no_canonica(self,origin=Vector([0,0,0]),u1=Vector([1,-1,0]),u2=1/2*Vector([1,-1,-1]),u3=Vector([-1,0,1]),length=12,scale=0.04,preserve=False,name=&#34;Base B&#39;&#34;):
        &#34;&#34;&#34;
        Draws the base {u1,u2,u3} with origin in the point origin and sets the default
        origin and default base to them
        Parameters:
                origin: origin of the vector and the base

                u1, u2, u3: vectors of the base

                length: length of the axis

                scale: scale of the base

                name: name of the base

                preserve:
        &#34;&#34;&#34;
        if not isinstance(origin,Vector):
                origin = Vector(origin)
        if not isinstance(u1,Vector):
                u1 = Vector(u1)
        if not isinstance(u2,Vector):
                u2 = Vector(u2)
        if not isinstance(u3,Vector):
                u3 = Vector(u3)
        self.set_origin(origin)
        self.set_base([u1,u2,u3])
        self.draw_base_axis(axis=length,positive=False,scale=scale,name=name)
        if not preserve:
                self.set_origin()
                self.set_base()
                self.set_rotation()</code></pre>
</details>
<div class="desc"><p>Draws the base {u1,u2,u3} with origin in the point origin and sets the default
origin and default base to them</p>
<h2 id="parameters">Parameters</h2>
<p>origin: origin of the vector and the base</p>
<p>u1, u2, u3: vectors of the base</p>
<p>length: length of the axis</p>
<p>scale: scale of the base</p>
<p>name: name of the base</p>
<p>preserve:</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.canvi_base"><code class="name flex">
<span>def <span class="ident">canvi_base</span></span>(<span>self,<br>vector=Vector((8.0, -6.0, 7.0)),<br>u1=Vector((-0.3333333432674408, -0.6666666865348816, 0.6666666865348816)),<br>u2=Vector((0.6666666865348816, 0.3333333432674408, 0.6666666865348816)),<br>u3=Vector((-0.6666666865348816, 0.6666666865348816, 0.3333333432674408)),<br>length=12)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def canvi_base(self,vector=Vector([8,-6,7]),u1=1/3*Vector([-1,-2,2]),u2=1/3*Vector([2,1,2]),u3=1/3*Vector([-2,2,1]),length=12):
        &#34;&#34;&#34;
        Draw the components of a vectors in the canonical base and in the base {u1,u2,u3}. Sets the default
        origin and default base to them
        Parameters:
                vector: vector to draw

                u1, u2, u3: vectors of the base

                length: length of the axis
        &#34;&#34;&#34;
        self.vector_base_canonica(vector=vector,length=length)
        self.set_colors([&#34;Magenta&#34;,&#34;Yellow&#34;,&#34;Cyan&#34;])
        self.base_no_canonica(u1=u1,u2=u2,u3=u3,length=length,preserve=True)
        v = self.components_in_base(vector)
        self.draw_components(v,color=&#34;White&#34;,name=&#34;Components en la base B&#39;&#34;)</code></pre>
</details>
<div class="desc"><p>Draw the components of a vectors in the canonical base and in the base {u1,u2,u3}. Sets the default
origin and default base to them</p>
<h2 id="parameters">Parameters</h2>
<p>vector: vector to draw</p>
<p>u1, u2, u3: vectors of the base</p>
<p>length: length of the axis</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.canvi_coordenades"><code class="name flex">
<span>def <span class="ident">canvi_coordenades</span></span>(<span>self,<br>punt=Vector((8.0, -6.0, 7.0)),<br>origin=Vector((-2.0, 3.0, 3.0)),<br>u1=Vector((-0.3333333432674408, -0.6666666865348816, 0.6666666865348816)),<br>u2=Vector((0.6666666865348816, 0.3333333432674408, 0.6666666865348816)),<br>u3=Vector((-0.6666666865348816, 0.6666666865348816, 0.3333333432674408)),<br>canonica=False,<br>scale=0.06,<br>length=12,<br>radius=0.1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def canvi_coordenades(self,punt=Vector([8,-6,7]),origin=Vector([-2,3,3]),u1=1/3*Vector([-1,-2,2]),u2=1/3*Vector([2,1,2]),u3=1/3*Vector([-2,2,1]),canonica=False,scale=0.06,length=12,radius=0.1):
        &#34;&#34;&#34;
        Draw the coordinates of a point in the canonical reference and in the reference {o;u1,u2,u3}. Sets the default
        origin and default base to them
        Parameters:
                punt: point to draw

                origin: origin of the reference

                u1, u2, u3: vectors of the base

                canonica: if True, the coordinates of punt are in the canonical reference

                length: length of the axis
        &#34;&#34;&#34;
        self.set_origin(origin)
        self.set_base([u1,u2,u3])
        if canonica:
                p = punt
                p1 = self.coordinates_en_referencia(punt)
        else:
                p = self.coordinates_en_canonica(punt)
                p1 = punt
        self.reset()
        ## self.punt_referencia_canonica(punt=p,length=length,scale=scale,radius=radius)
        self.set_colors([&#34;Magenta&#34;,&#34;Yellow&#34;,&#34;AzureBlueDark&#34;])
        self.punt_referencia_no_canonica(punt=p1,origin=origin,u1=u1,u2=u2,u3=u3,length=length,scale=scale,radius=radius)
        self.reset()
        self.draw_vector(vector=p,name=&#34;Vector de posició en referència canònica&#34;,color=&#34;White&#34;)
        self.draw_components(p,color=&#34;Magenta&#34;,name=&#34;Coordenades en referència canònica&#34;)</code></pre>
</details>
<div class="desc"><p>Draw the coordinates of a point in the canonical reference and in the reference {o;u1,u2,u3}. Sets the default
origin and default base to them</p>
<h2 id="parameters">Parameters</h2>
<p>punt: point to draw</p>
<p>origin: origin of the reference</p>
<p>u1, u2, u3: vectors of the base</p>
<p>canonica: if True, the coordinates of punt are in the canonical reference</p>
<p>length: length of the axis</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.cilindre"><code class="name flex">
<span>def <span class="ident">cilindre</span></span>(<span>self,<br>centre=Vector((0.0, 0.0, 0.0)),<br>radi=1,<br>height=5,<br>eix='Z',<br>color='AzureBlueDark',<br>circlecolor='Blue')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cilindre(self,centre=Vector([0,0,0]),radi=1,height=5,eix=&#39;Z&#39;,color=&#34;AzureBlueDark&#34;,circlecolor=&#34;Blue&#34;):
        &#34;&#34;&#34;
        Draws a bounded cylinder with direction eix
        Parameters:

        centre: center of the cylinder

        radi: radius

        height: height

        eix: X, Y, Z or a vector

        color: color of the cylinder

        circlecolor: color of the two circles of a bounded cylinder
        &#34;&#34;&#34;
        if not isinstance(centre,Vector):
                centre = Vector(centre)
        if isinstance(eix,str):
                eix = eix.strip().upper()
        if eix == &#39;X&#39;:
                u = Vector([1,0,0])
        elif eix == &#39;Y&#39;:
                u = Vector([0,1,0])
        elif eix == &#39;Z&#39;:
                u = Vector([0,0,1])
        elif isinstance(eix,Vector):
                u = eix
        else:
                u = Vector(eix)

        u1 = u.orthogonal().normalized()
        u2 = u.normalized().cross(u1)
        center1 = centre + height/2 * u.normalized()
        center2 = centre - height/2 * u.normalized()

        c1, d1 = self.draw_circle(center=center1,radius=radi,u1=u1,u2=u2,axis=False,zaxis=False,steps=128,thickness=0.02,name=&#34;Circumferències&#34;,fillcolor=color,color=circlecolor)
        c2, d2 = self.draw_circle(center=center2,radius=radi,u1=u1,u2=u2,axis=False,zaxis=False,steps=128,thickness=0.02,name=&#34;Circumferència 2&#34;,fillcolor=color,color=circlecolor)
        _, _, cil = self.elliptic_cylinder(o=centre,a2=radi**2,b2=radi**2,u1=u1,u2=u2,principal=False,canonica=False,zmax=height/2,color=color,thickness=0.01,name=&#34;Cilindre&#34;)
        self.join([cil,d1,d2])
        self.join([c1,c2])
        self.reset()
        return cil, c1</code></pre>
</details>
<div class="desc"><p>Draws a bounded cylinder with direction eix
Parameters:</p>
<p>centre: center of the cylinder</p>
<p>radi: radius</p>
<p>height: height</p>
<p>eix: X, Y, Z or a vector</p>
<p>color: color of the cylinder</p>
<p>circlecolor: color of the two circles of a bounded cylinder</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.cilindre_elliptic"><code class="name flex">
<span>def <span class="ident">cilindre_elliptic</span></span>(<span>self,<br>o=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>a2=1,<br>b2=1,<br>principal=True,<br>canonica=True,<br>color='AzureBlueDark',<br>name='EllipticCylinder',<br>zmax=20,<br>cmax=20,<br>pmax=15,<br>thickness=0.02,<br>opacity=1.0,<br>preserve=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def elliptic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;EllipticCylinder&#34;,zmax=20,cmax=20,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
        &#34;&#34;&#34;
        Draws an elliptic cylinder
        Parameters:
           o: center of the elliptic cylinder

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2: squares of semi-axes of the elliptic cylinder. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 = 1

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the elliptic cylinder

           zmax: the elliptic cylinder is drawn between -zmax and zmax

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the elliptic cylinder

           opacity: opacity of the elliptic cylinder

           preserve: Keep self.origin and self.base as the principal reference
        &#34;&#34;&#34;
        axis1 = None
        axis2 = None
        if cmax &lt; zmax + 2:
                cmax = zmax + 2
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                axis2 = self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        el = self.draw_elliptic_cylinder(a=1.0,b=1.0,length=2*zmax,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)
        if not preserve:
                self.set_origin()
                self.set_base()
                self.set_rotation()
        return axis1, axis2, el</code></pre>
</details>
<div class="desc"><p>Draws an elliptic cylinder</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the elliptic cylinder</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2: squares of semi-axes of the elliptic cylinder. The equation is x'^2/a^2 + y'^2/b^2 = 1</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the elliptic cylinder</p>
<p>zmax: the elliptic cylinder is drawn between -zmax and zmax</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the elliptic cylinder</p>
<p>opacity: opacity of the elliptic cylinder</p>
<p>preserve: Keep self.origin and self.base as the principal reference</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.cilindre_elliptic_simple"><code class="name flex">
<span>def <span class="ident">cilindre_elliptic_simple</span></span>(<span>self, a=10, b=6, direccio='Z', pmax=20)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cilindre_elliptic_simple(self,a=10,b=6,direccio=&#39;Z&#39;,pmax=20):
        &#34;&#34;&#34;
        Draws an elliptic cylinder with direction X, Y or Z
        Parameters:
                a, b: semiaxis of the ellipse

                direction: direction of translation of the ellipse

                pmax = height of the cylindrer
        &#34;&#34;&#34;
        if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                u1 = Vector([0,0,1])
                u2 = Vector([0,1,0])
        elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                u1 = Vector([1,0,0])
                u2 = Vector([0,0,1])
        else:
                u1 = Vector([1,0,0])
                u2 = Vector([0,1,0])
        cy = self.elliptic_cylinder(a2=a**2,b2=b**2,u1=u1,u2=u2,zmax=pmax,canonica=True,principal=False)
        el = self.draw_ellipse(a=a,b=b,u1=u1,u2=u2,thickness=0.02,steps=128,axis=False)
        self.reset()
        return list(cy) + [el]</code></pre>
</details>
<div class="desc"><p>Draws an elliptic cylinder with direction X, Y or Z</p>
<h2 id="parameters">Parameters</h2>
<p>a, b: semiaxis of the ellipse</p>
<p>direction: direction of translation of the ellipse</p>
<p>pmax = height of the cylindrer</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.cilindre_hiperbolic"><code class="name flex">
<span>def <span class="ident">cilindre_hiperbolic</span></span>(<span>self,<br>o=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>a2=1,<br>b2=1,<br>principal=True,<br>canonica=True,<br>color='AzureBlueDark',<br>name='Hyperbolic Cylinder',<br>xmax=None,<br>zmax=15,<br>cmax=15,<br>pmax=15,<br>thickness=0.02,<br>opacity=1.0,<br>preserve=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hyperbolic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Hyperbolic Cylinder&#34;,xmax=None,zmax=15,cmax=15,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
        &#34;&#34;&#34;
        Draws an hyperbolic cylinder
        Parameters:
           o: center of the hyperbolic cylinder

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2: squares of semi-axes of the hyperbolic cylinder. The equation is x&#39;^2/a^2 - y&#39;^2/b^2 = 1

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the hyperbolic cylinder

           xmax: maximum value of the x coordinate

           zmax: the hyperbolic cylinder is drawn between -zmax and zmax

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the hyperbolic cylinder

           opacity: opacity of the hyperbolic cylinder

           preserve: Keep self.origin and self.base as the principal reference
        &#34;&#34;&#34;
        if cmax &lt; zmax + 2:
                cmax = zmax + 2
        axis1 = None
        axis2 = None
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                axis2 = self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        if xmax is None:
                xmax = 5.0/a + 2
        xmax /= a
        hy = self.draw_hyperbolic_cylinder(a=1.0,b=1.0,xmin=1.0,xmax=xmax,length=2*zmax,steps=128,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)
        if not preserve:
                self.set_origin()
                self.set_base()
                self.set_rotation()
        return axis1, axis2, hy</code></pre>
</details>
<div class="desc"><p>Draws an hyperbolic cylinder</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the hyperbolic cylinder</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2: squares of semi-axes of the hyperbolic cylinder. The equation is x'^2/a^2 - y'^2/b^2 = 1</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the hyperbolic cylinder</p>
<p>xmax: maximum value of the x coordinate</p>
<p>zmax: the hyperbolic cylinder is drawn between -zmax and zmax</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the hyperbolic cylinder</p>
<p>opacity: opacity of the hyperbolic cylinder</p>
<p>preserve: Keep self.origin and self.base as the principal reference</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.cilindre_hiperbolic_simple"><code class="name flex">
<span>def <span class="ident">cilindre_hiperbolic_simple</span></span>(<span>self, a=4, b=3, direccio='Z', pmax=15, hmax=20)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cilindre_hiperbolic_simple(self,a=4,b=3,direccio=&#39;Z&#39;,pmax=15,hmax=20):
        &#34;&#34;&#34;
        Draws an hyperbolic cylinder with direction X, Y or Z
        Parameters:
                a, b: semiaxis of the hyperbole

                direccio: direction of translation of the hyperbole

                pmax = maximum value of the independent variable

                hmax = height of the cylindrer
        &#34;&#34;&#34;
        if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                u1 = Vector([0,0,1])
                u2 = Vector([0,1,0])
        elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                u1 = Vector([1,0,0])
                u2 = Vector([0,0,1])
        else:
                u1 = Vector([1,0,0])
                u2 = Vector([0,1,0])
        cy = self.hyperbolic_cylinder(a2=a**2,b2=b**2,u1=u1,u2=u2,xmax=pmax,zmax=hmax,canonica=True,principal=False)
        hy = self.draw_hyperbole(a=a,b=b,u1=u1,u2=u2,thickness=0.02,ymax=b*math.sqrt(-1+(pmax/a)**2),steps=128,axis=False)
        self.reset()
        return list(cy) + [hy]</code></pre>
</details>
<div class="desc"><p>Draws an hyperbolic cylinder with direction X, Y or Z</p>
<h2 id="parameters">Parameters</h2>
<p>a, b: semiaxis of the hyperbole</p>
<p>direccio: direction of translation of the hyperbole</p>
<p>pmax = maximum value of the independent variable</p>
<p>hmax = height of the cylindrer</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.cilindre_parabolic"><code class="name flex">
<span>def <span class="ident">cilindre_parabolic</span></span>(<span>self,<br>o=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>p=1,<br>principal=True,<br>canonica=True,<br>color='AzureBlueDark',<br>name='ParabolicCylinder',<br>xmax=12,<br>ymax=30,<br>cmax=20,<br>pmax=20,<br>thickness=0.02,<br>opacity=1.0,<br>preserve=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parabolic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],p=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;ParabolicCylinder&#34;,xmax=12,ymax=30,cmax=20,pmax=20,thickness=0.02,opacity=1.0,preserve=True):
        &#34;&#34;&#34;
        Draws an hyperbolic paraboloid
        Parameters:
           o: vertex of the hyperbolic paraboloid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           p: Parameter of the cylinder z&#39; = x&#39;^2/(2*p)

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the elliptic paraboloid

           xmax: maximum value of the coordinate x

           ymax: maximum value of the coordinate y

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the hyperbolic paraboloid

           opacity: opacity of the hyperbolic paraboloid

           preserve: Keep self.origin and self.base as the principal reference
        &#34;&#34;&#34;
        axis1 = None
        axis2 = None
        coef = 1.0
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                axis2 = self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        coef = 1.0
        if p &lt; 0:
                coef = -1
        xmax /= math.sqrt(2*coef*p)
        pa = self.draw_parabolic_cylinder(p=coef,xmin=0.0,xmax=xmax,length=ymax,color=color,name=name,scale=[math.sqrt(2*coef*p),1,1],thickness=thickness,opacity=opacity)
        if not preserve:
                self.set_origin()
                self.set_base()
                self.set_rotation()
        return axis1, axis2, pa</code></pre>
</details>
<div class="desc"><p>Draws an hyperbolic paraboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: vertex of the hyperbolic paraboloid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>p: Parameter of the cylinder z' = x'^2/(2*p)</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the elliptic paraboloid</p>
<p>xmax: maximum value of the coordinate x</p>
<p>ymax: maximum value of the coordinate y</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the hyperbolic paraboloid</p>
<p>opacity: opacity of the hyperbolic paraboloid</p>
<p>preserve: Keep self.origin and self.base as the principal reference</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.cilindre_parabolic_simple"><code class="name flex">
<span>def <span class="ident">cilindre_parabolic_simple</span></span>(<span>self, a=3, direccio='Z', pmax=12, hmax=45)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cilindre_parabolic_simple(self,a=3,direccio=&#39;Z&#39;,pmax=12,hmax=45):
        r&#34;&#34;&#34;
        Draws a parabolic cylinder with direction X, Y or Z
        Parameters:
                a: the initial parabola has equation of type z=\pm x^2/a^2

                direccio: direction of translation of the parabola

                pmax = maximum value of the independent variable

                hmax = height of the cylindrer
        &#34;&#34;&#34;
        if a == 0:
                return
        if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                u1 = Vector([0,0,1])
                u2 = Vector([0,-1,0])
                v1 = Vector([0,0,1])
                v2 = Vector([1,0,0])
        elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                u1 = Vector([1,0,0])
                u2 = Vector([0,0,-1])
                v1 = Vector([1,0,0])
                v2 = Vector([0,1,0])
        else:
                u1 = Vector([1,0,0])
                u2 = Vector([0,1,0])
                v1 = Vector([1,0,0])
                v2 = Vector([0,0,1])
        s = 1
        if a &lt; 0:
                s = -1
        cy = self.parabolic_cylinder(p=a**2/2,u1=u1,u2=u2,xmax=pmax,ymax=hmax,canonica=True,principal=False)
        pa = self.draw_parabola(a=s/a**2,u1=v1,u2=v2,thickness=0.02,xmax=pmax,steps=128,axis=False)
        self.reset()
        return list(cy) + [pa]</code></pre>
</details>
<div class="desc"><p>Draws a parabolic cylinder with direction X, Y or Z</p>
<h2 id="parameters">Parameters</h2>
<p>a: the initial parabola has equation of type z=\pm x^2/a^2</p>
<p>direccio: direction of translation of the parabola</p>
<p>pmax = maximum value of the independent variable</p>
<p>hmax = height of the cylindrer</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.circumferencia"><code class="name flex">
<span>def <span class="ident">circumferencia</span></span>(<span>self,<br>center=[0, 0, 0],<br>u1=Vector((1.0, 0.0, 0.0)),<br>u2=Vector((0.0, 1.0, 0.0)),<br>axis=False,<br>zaxis=False,<br>radius=1,<br>steps=128,<br>thickness=0.01,<br>name='Circle',<br>color='White',<br>fillcolor=None,<br>change=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_circle(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),axis=False,zaxis=False,radius=1,steps=128,thickness=0.01,name=&#34;Circle&#34;,color=&#34;White&#34;,fillcolor=None,change=False):
        &#34;&#34;&#34;
        Draws a circle of center &#39;center&#39; and radius &#39;radius&#39; in the plane determined by vectors u1 and u2
        Parameters:
           center: center of the circle

           u1, u2: vectors to construct the basis {v1, v2, v3}

           axis: if True draws the axis of the reference R&#39;

           zaxis: if True draws the z&#39; axis

           radius: radius of the circle

           steps: number of steps

           thickness: thickness of the curve

           name: name of the curve

           color: color of the curve

           change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
        &#34;&#34;&#34;
        d = None
        if fillcolor is not None:
                d = self.draw_disk(center=center,radius=radius,u1=u1,u2=u2,thickness=0.5*thickness,name=&#34;Disc&#34;,color=fillcolor)
        c = self.draw_curve(lambda t: (radius*math.cos(t),radius*math.sin(t),0),tmin=0.0,tmax=2*math.pi,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
        if change:
                self.set_origin(center)
                self.set_base([u1,u2],orthonormal=True)
        return c, d</code></pre>
</details>
<div class="desc"><p>Draws a circle of center 'center' and radius 'radius' in the plane determined by vectors u1 and u2</p>
<h2 id="parameters">Parameters</h2>
<p>center: center of the circle</p>
<p>u1, u2: vectors to construct the basis {v1, v2, v3}</p>
<p>axis: if True draws the axis of the reference R'</p>
<p>zaxis: if True draws the z' axis</p>
<p>radius: radius of the circle</p>
<p>steps: number of steps</p>
<p>thickness: thickness of the curve</p>
<p>name: name of the curve</p>
<p>color: color of the curve</p>
<p>change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
        &#34;&#34;&#34;
        Clears and removes all the elements
        &#34;&#34;&#34;
        self.reset()
        for obj in bpy.data.objects:
                bpy.data.objects.remove(obj)</code></pre>
</details>
<div class="desc"><p>Clears and removes all the elements</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.components_en_canonica"><code class="name flex">
<span>def <span class="ident">components_en_canonica</span></span>(<span>self, vector=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def components_en_canonica(self,vector=None):
        &#34;&#34;&#34;
        Returns the components of the vector &#39;point&#39; in the base determined by
        self.rotation and the basis self.base
        Parameters:
           vector: components of the vector in the base self.rotation + self.base
        &#34;&#34;&#34;
        if vector is None:
                return Vector([0,0,0])
        if isinstance(vector,Vector):
                u = vector
        else:
                u = Vector(vector)
        if self.rotation is not None:
                mat = self.rotation.quaternion.to_matrix()
                u = mat @ u
        mat = Matrix(self.base)
        mat.transpose()
        u = mat @ u
        return u</code></pre>
</details>
<div class="desc"><p>Returns the components of the vector 'point' in the base determined by
self.rotation and the basis self.base</p>
<h2 id="parameters">Parameters</h2>
<p>vector: components of the vector in the base self.rotation + self.base</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.components_in_base"><code class="name flex">
<span>def <span class="ident">components_in_base</span></span>(<span>self, vector=None, base=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def components_in_base(self,vector=None,base=None):
        &#34;&#34;&#34;
        Returns the components of the vector &#39;vector&#39; in the basis determined by
        self.rotation and the basis self.base
        Parameters:
           vector: components of the vector in the canonical basis

           base: A base of V3. If None, we use self.base
        &#34;&#34;&#34;
        if vector is None:
                return Vector([0,0,0])
        if isinstance(vector,Vector):
                u = vector
        else:
                u = Vector(vector)
        if self.rotation is not None:
                mat = self.rotation.quaternion.to_matrix()
                mat.invert()
                u = mat @ u
        mat = Matrix(self.base)
        if base is not None:
                mat = Matrix(base)
        mat.transpose()
        mat.invert()
        u = mat @ u
        return u</code></pre>
</details>
<div class="desc"><p>Returns the components of the vector 'vector' in the basis determined by
self.rotation and the basis self.base</p>
<h2 id="parameters">Parameters</h2>
<p>vector: components of the vector in the canonical basis</p>
<p>base: A base of V3. If None, we use self.base</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.con"><code class="name flex">
<span>def <span class="ident">con</span></span>(<span>self,<br>o=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>a2=1,<br>b2=1,<br>c2=1,<br>half=False,<br>principal=True,<br>canonica=True,<br>color='AzureBlueDark',<br>name='Cone',<br>xmax=None,<br>cmax=15,<br>pmax=15,<br>thickness=0.02,<br>opacity=1.0,<br>preserve=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cone(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,half=False,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Cone&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
        &#34;&#34;&#34;
        Draws a cone
        Parameters:
           o: center of the cone

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2, c2: squares of semi-axes of the cone. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = 0

           half: if True draws half cone

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the cone

           xmax: maximum value of the x coordinate

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -pmax and pmax

           thickness: thickness of the cone

           opacity: opacity of the cone

           preserve: Keep self.origin and self.base as the principal reference
        &#34;&#34;&#34;
        axis1 = None
        axis2 = None
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        c = math.sqrt(c2)
        if xmax is None:
                xmax = 10.0/a + 2
        xmax /= a
        co = self.draw_cone(a=1.0,xmin=0.0,xmax=xmax,steps=50,half=half,color=color,scale=[a,b,c],name=name,thickness=thickness,opacity=opacity)
        if not preserve:
                self.set_origin()
                self.set_base()
                self.set_rotation()
        return axis1, axis2, co</code></pre>
</details>
<div class="desc"><p>Draws a cone</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the cone</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2, c2: squares of semi-axes of the cone. The equation is x'^2/a^2 + y'^2/b^2 - z'^2/c^2 = 0</p>
<p>half: if True draws half cone</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the cone</p>
<p>xmax: maximum value of the x coordinate</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -pmax and pmax</p>
<p>thickness: thickness of the cone</p>
<p>opacity: opacity of the cone</p>
<p>preserve: Keep self.origin and self.base as the principal reference</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.con_cilindre_elliptic"><code class="name flex">
<span>def <span class="ident">con_cilindre_elliptic</span></span>(<span>self, a2=1, b2=1, c2=1, x0=5, a=8, b=5, zmax=15)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def con_cilindre_elliptic(self,a2=1,b2=1,c2=1,x0=5,a=8,b=5,zmax=15):
        &#34;&#34;&#34;
        Draws a cone with vertex at (0,0,0) and equation x^2/a2 + y^2/b2 - z^2/c2 == 0,
        an elliptic cylinder and their intersection
        Parameters:
                a2, b2, c2: coefficients of the equation of the cone

                x0: (x0,0,0) is the center of the ellipse in the plain XY

                a, b: semiaxis of this ellipse

                zmax: maximum value of the z coordinate
        &#34;&#34;&#34;
        a2, b2, c2 = abs(a2), abs(b2), abs(c2)
        if a2*b2*c2 == 0:
                return
        xmax = zmax*math.sqrt(a2/c2)
        def F(t):
                x = x0 + a*math.cos(t)
                y = b*math.sin(t)
                z = math.sqrt(c2*(x**2/a2 + y**2/b2))
                return (x,y,z)
        self.cone(a2=a2,b2=b2,c2=c2,principal=False,canonica=True,color=&#34;GrayLight&#34;,thickness=0.0001,name=&#34;Con&#34;,xmax=xmax,cmax=xmax+5,opacity=1.0)
        self.elliptic_cylinder(o=[x0,0,0],a2=a**2,b2=b**2,principal=False,canonica=False,zmax=2*(zmax+3),thickness=0.01,name=&#34;Cilindre&#34;)
        self.curve(F,tmin=0,tmax=2*math.pi,steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)</code></pre>
</details>
<div class="desc"><p>Draws a cone with vertex at (0,0,0) and equation x^2/a2 + y^2/b2 - z^2/c2 == 0,
an elliptic cylinder and their intersection</p>
<h2 id="parameters">Parameters</h2>
<p>a2, b2, c2: coefficients of the equation of the cone</p>
<p>x0: (x0,0,0) is the center of the ellipse in the plain XY</p>
<p>a, b: semiaxis of this ellipse</p>
<p>zmax: maximum value of the z coordinate</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.con_revolucio"><code class="name flex">
<span>def <span class="ident">con_revolucio</span></span>(<span>self, a=1.5, pmax=8, direccio='Z', punt=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def con_revolucio(self,a=1.5,pmax=8,direccio=&#39;Z&#39;,punt=None):
        &#34;&#34;&#34;
        Draws an animation showing a cone of revolution
                a: slope of the initial straight line

                pmax: maximum value of the independent variable

                direccio: &#39;X&#39;, the initial line is in the plane YX and rotates around the X axis
                          &#39;Y&#39;, the initial line is in the plane ZY and rotates around the Y axis
                              &#39;Z&#39;, the initial line is in the plane XZ and rotates around the Z axis

                punt: if it&#39;s a value between -pmax and pmax, the animation shows a rotating point
        &#34;&#34;&#34;
        if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                F = lambda t: (a*t,t,0)
        elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                F = lambda t: (0,a*t,t)
        else:
                F = lambda t: (t,0,a*t)
        self.base_canonica()
        self.animate_revolution_surface(F,tmin=-pmax,tmax=pmax,steps=128,axis=direccio,point=punt)</code></pre>
</details>
<div class="desc"><p>Draws an animation showing a cone of revolution
a: slope of the initial straight line</p>
<pre><code>    pmax: maximum value of the independent variable

    direccio: 'X', the initial line is in the plane YX and rotates around the X axis
              'Y', the initial line is in the plane ZY and rotates around the Y axis
                  'Z', the initial line is in the plane XZ and rotates around the Z axis

    punt: if it's a value between -pmax and pmax, the animation shows a rotating point
</code></pre></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.con_simple"><code class="name flex">
<span>def <span class="ident">con_simple</span></span>(<span>self, a=4, b=3, c=2, direccio='Z', pmax=12)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def con_simple(self,a=4,b=3,c=2,direccio=&#39;Z&#39;,pmax=12):
        &#34;&#34;&#34;
        Draws a con with direction X, Y or Z
        Parameters:
                a, b, c: semiaxis of the cone

                direccio: direction of the negative coefficient

                pmax = maximum value of the independent variables

                hmax = height of the cone
        &#34;&#34;&#34;
        if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                u1 = Vector([0,0,1])
                u2 = Vector([0,-1,0])
                v1 = Vector([0,0,1])
                v2 = Vector([1,0,0])
        elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                u1 = Vector([1,0,0])
                u2 = Vector([0,0,-1])
                v1 = Vector([1,0,0])
                v2 = Vector([0,1,0])
        else:
                u1 = Vector([1,0,0])
                u2 = Vector([0,1,0])
                v1 = Vector([1,0,0])
                v2 = Vector([0,0,1])
        co = self.cone(a2=a**2,b2=b**2,c2=c**2,u1=u1,u2=u2,xmax=pmax,canonica=True,principal=False)
        self.reset()
        return co</code></pre>
</details>
<div class="desc"><p>Draws a con with direction X, Y or Z</p>
<h2 id="parameters">Parameters</h2>
<p>a, b, c: semiaxis of the cone</p>
<p>direccio: direction of the negative coefficient</p>
<p>pmax = maximum value of the independent variables</p>
<p>hmax = height of the cone</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.cone"><code class="name flex">
<span>def <span class="ident">cone</span></span>(<span>self,<br>o=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>a2=1,<br>b2=1,<br>c2=1,<br>half=False,<br>principal=True,<br>canonica=True,<br>color='AzureBlueDark',<br>name='Cone',<br>xmax=None,<br>cmax=15,<br>pmax=15,<br>thickness=0.02,<br>opacity=1.0,<br>preserve=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cone(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,half=False,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Cone&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
        &#34;&#34;&#34;
        Draws a cone
        Parameters:
           o: center of the cone

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2, c2: squares of semi-axes of the cone. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = 0

           half: if True draws half cone

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the cone

           xmax: maximum value of the x coordinate

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -pmax and pmax

           thickness: thickness of the cone

           opacity: opacity of the cone

           preserve: Keep self.origin and self.base as the principal reference
        &#34;&#34;&#34;
        axis1 = None
        axis2 = None
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        c = math.sqrt(c2)
        if xmax is None:
                xmax = 10.0/a + 2
        xmax /= a
        co = self.draw_cone(a=1.0,xmin=0.0,xmax=xmax,steps=50,half=half,color=color,scale=[a,b,c],name=name,thickness=thickness,opacity=opacity)
        if not preserve:
                self.set_origin()
                self.set_base()
                self.set_rotation()
        return axis1, axis2, co</code></pre>
</details>
<div class="desc"><p>Draws a cone</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the cone</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2, c2: squares of semi-axes of the cone. The equation is x'^2/a^2 + y'^2/b^2 - z'^2/c^2 = 0</p>
<p>half: if True draws half cone</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the cone</p>
<p>xmax: maximum value of the x coordinate</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -pmax and pmax</p>
<p>thickness: thickness of the cone</p>
<p>opacity: opacity of the cone</p>
<p>preserve: Keep self.origin and self.base as the principal reference</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.coordinates_en_canonica"><code class="name flex">
<span>def <span class="ident">coordinates_en_canonica</span></span>(<span>self, point=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coordinates_en_canonica(self,point=None):
        &#34;&#34;&#34;
        Returns the coordinates of the point &#39;point&#39; in the reference determined by
        self.origin, self.rotation and the basis self.base
        Parameters:
           point: coordinates of the point in the reference {self.origin;self.base}
        &#34;&#34;&#34;
        if point is None:
                return Vector([0,0,0])
        if isinstance(point,Vector):
                u = point
        else:
                u = Vector(point)
        if self.rotation is not None:
                mat = self.rotation.quaternion.to_matrix()
                u = mat @ u
        mat = Matrix(self.base)
        mat.transpose()
        u = Vector(self.origin) + mat @ u
        return u</code></pre>
</details>
<div class="desc"><p>Returns the coordinates of the point 'point' in the reference determined by
self.origin, self.rotation and the basis self.base</p>
<h2 id="parameters">Parameters</h2>
<p>point: coordinates of the point in the reference {self.origin;self.base}</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.coordinates_en_referencia"><code class="name flex">
<span>def <span class="ident">coordinates_en_referencia</span></span>(<span>self, point=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coordinates_en_referencia(self,point=None):
        &#34;&#34;&#34;
        Returns the coordinates of the point &#39;point&#39; in the reference determined by
        self.origin, self.rotation and the basis self.base
        Parameters:
           point: coordinates of the point in the canonical reference
        &#34;&#34;&#34;
        if point is None:
                return Vector([0,0,0])
        if isinstance(point,Vector):
                u = point
        else:
                u = Vector(point)
        if self.rotation is not None:
                mat = self.rotation.quaternion.to_matrix()
                mat.invert()
                u = mat @ u
        mat = Matrix(self.base)
        mat.transpose()
        mat.invert()
        u = mat @ (u - Vector(self.origin))
        return u</code></pre>
</details>
<div class="desc"><p>Returns the coordinates of the point 'point' in the reference determined by
self.origin, self.rotation and the basis self.base</p>
<h2 id="parameters">Parameters</h2>
<p>point: coordinates of the point in the canonical reference</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.curve"><code class="name flex">
<span>def <span class="ident">curve</span></span>(<span>self,<br>fun=None,<br>tmin=0.0,<br>tmax=1.0,<br>steps=25,<br>thickness=0.01,<br>name='Curve',<br>color='White',<br>axis=False,<br>zaxis=True,<br>o=Vector((0.0, 0.0, 0.0)),<br>u1=Vector((1.0, 0.0, 0.0)),<br>u2=Vector((0.0, 1.0, 0.0)),<br>symmetry=None,<br>change=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,axis=False,zaxis=True,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),symmetry=None,change=False):
        &#34;&#34;&#34;
        Draws a curve in a reference R&#39; determined by the origin o and basis {v1, v2, v3} constructed from u1 and u2 and
        the symmetric curve or curves from the parameter &#39;symmetry&#39;
        Parameters:
           fun: the parametric function

           tmin: minimum value of the parameter

           tmax: maximum value of the parameter

           steps: number of steps

           thickness: thickness of the curve

           name: name of the curve

           color: color of the curve

           axis: if True draws the axis of the reference R&#39;

           zaxis: if True draws the z&#39; axis

           o: origin of the reference R&#39;

           u1, u2: vectors to construct the basis {v1, v2, v3}

           symmetry: list of values in (&#39;XY&#39;,&#39;XZ&#39;,&#39;YZ&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;,&#39;O&#39;). For every value S, draw the symmetric curve respect to S

           change: if True, set the reference self.origin, self.base to {o; v1, v2, v3}
        &#34;&#34;&#34;
        if fun is None:
                return None
        obj = self.draw_curve(fun,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=name,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)

        if symmetry is None:
                if change:
                        self.set_origin(o)
                        self.set_base([u1,u2],orthonormal=True)
                return obj
        objs = [obj]
        if isinstance(symmetry,str):
                symmetry = [symmetry]
        elif not isinstance(symmetry,list) and not isinstance(symmetry,tuple):
                if change:
                        self.set_origin(o)
                        self.set_base([u1,u2],orthonormal=True)
                return obj
        for s in symmetry:
                namem = name + s
                if s == &#39;XY&#39;:
                        def f(t):
                                p = fun(t)
                                return (p[0],p[1],-p[2])
                        obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                        objs.append(obj2)
                if s == &#39;XZ&#39;:
                        def f(t):
                                p = fun(t)
                                return (p[0],-p[1],p[2])
                        obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                        objs.append(obj2)
                if s == &#39;YZ&#39;:
                        def f(t):
                                p = fun(t)
                                return (-p[0],p[1],p[2])
                        obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                        objs.append(obj2)
                if s == &#39;X&#39;:
                        def f(t):
                                p = fun(t)
                                return (p[0],-p[1],-p[2])
                        obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                        objs.append(obj2)
                if s == &#39;Y&#39;:
                        def f(t):
                                p = fun(t)
                                return (-p[0],p[1],-p[2])
                        obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                        objs.append(obj2)
                if s == &#39;Z&#39;:
                        def f(t):
                                p = fun(t)
                                return (-p[0],-p[1],p[2])
                        obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                        objs.append(obj2)
                if s == &#39;O&#39;:
                        def f(t):
                                p = fun(t)
                                return (-p[0],-p[1],-p[2])
                        obj2 = self.draw_curve(f,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,name=namem,color=color,axis=axis,zaxis=zaxis,o=o,u1=u1,u2=u2)
                        objs.append(obj2)
        if change:
                self.set_origin(o)
                self.set_base([u1,u2],orthonormal=True)
        return self.join(objs)</code></pre>
</details>
<div class="desc"><p>Draws a curve in a reference R' determined by the origin o and basis {v1, v2, v3} constructed from u1 and u2 and
the symmetric curve or curves from the parameter 'symmetry'</p>
<h2 id="parameters">Parameters</h2>
<p>fun: the parametric function</p>
<p>tmin: minimum value of the parameter</p>
<p>tmax: maximum value of the parameter</p>
<p>steps: number of steps</p>
<p>thickness: thickness of the curve</p>
<p>name: name of the curve</p>
<p>color: color of the curve</p>
<p>axis: if True draws the axis of the reference R'</p>
<p>zaxis: if True draws the z' axis</p>
<p>o: origin of the reference R'</p>
<p>u1, u2: vectors to construct the basis {v1, v2, v3}</p>
<p>symmetry: list of values in ('XY','XZ','YZ','X','Y','Z','O'). For every value S, draw the symmetric curve respect to S</p>
<p>change: if True, set the reference self.origin, self.base to {o; v1, v2, v3}</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.delete_base_cilinder"><code class="name flex">
<span>def <span class="ident">delete_base_cilinder</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_base_cilinder(self):
        &#34;&#34;&#34;
        Removes the base cilinder
        &#34;&#34;&#34;
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        bpy.data.objects[&#39;Arrow_stem&#39;].select_set(True)
        bpy.ops.object.delete()</code></pre>
</details>
<div class="desc"><p>Removes the base cilinder</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.delete_base_cone"><code class="name flex">
<span>def <span class="ident">delete_base_cone</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_base_cone(self):
        &#34;&#34;&#34;
        Removes the base cone
        &#34;&#34;&#34;
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        bpy.data.objects[&#39;Arrow_cone&#39;].select_set(True)
        bpy.ops.object.delete()</code></pre>
</details>
<div class="desc"><p>Removes the base cone</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.delete_base_disk"><code class="name flex">
<span>def <span class="ident">delete_base_disk</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_base_disk(self):
        &#34;&#34;&#34;
        Removes the base disk
        &#34;&#34;&#34;
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        bpy.data.objects[&#39;Base_disk&#39;].select_set(True)
        bpy.ops.object.delete()</code></pre>
</details>
<div class="desc"><p>Removes the base disk</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.distancia_rectes_encreuen"><code class="name flex">
<span>def <span class="ident">distancia_rectes_encreuen</span></span>(<span>self,<br>p0=Vector((3.0, 4.0, -2.0)),<br>v0=Vector((1.0, 2.0, 3.0)),<br>c0='Black',<br>n0='Primera recta',<br>p1=Vector((-3.0, 4.0, 1.0)),<br>v1=Vector((1.0, -2.0, -1.0)),<br>c1='Blue',<br>n1='Segona recta',<br>canonica=True,<br>length=12,<br>size=15,<br>scale=0.03)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distancia_rectes_encreuen(self,p0=Vector([3,4,-2]),v0=Vector([1,2,3]),c0=&#34;Black&#34;,n0=&#34;Primera recta&#34;,p1=Vector([-3,4,1]),v1=Vector([1,-2,-1]),c1=&#34;Blue&#34;,n1=&#34;Segona recta&#34;,canonica=True,length=12,size=15,scale=0.03):
        &#34;&#34;&#34;
        Draws the distance between two affine lines
        Parameters:
                p0: point of the first line

                v0: generator of the first line

                c0: color of the first line

                n0: name of the first line

                p1: point of the second line

                v1: generator of the second line

                c1: color of the second line

                n1: name of the second line

                canonica: if True, draws the x, y and z axis

                length: length of the axis x, y and z

                size: lenght of the lines
        &#34;&#34;&#34;
        self.recta_afi(punt=p0,v=v0,color=c0,name=n0,canonica=canonica,length=length,size=size,scale=scale)
        self.recta_afi(punt=p1,v=v1,color=c1,name=n1,canonica=False,length=length,size=size,scale=scale)
        u = p0 - p1
        w = v0.cross(v1)
        t0, t1, t2 = self.components_in_base(u,[v0,v1,w])
        self.draw_line(start=p0-t0*v0,end=p1+t1*v1,scale=0.04,color=&#34;White&#34;,name=&#34;Distància&#34;,segment=True)
        self.pla_afi(punt=p0,v1=v0,v2=v1,name=&#34;Pla que conté a 1a recta i és paral·lel a la segon&#34;,sizex=2*size,sizey=2*size,opacity=0.9,elements=False)</code></pre>
</details>
<div class="desc"><p>Draws the distance between two affine lines</p>
<h2 id="parameters">Parameters</h2>
<p>p0: point of the first line</p>
<p>v0: generator of the first line</p>
<p>c0: color of the first line</p>
<p>n0: name of the first line</p>
<p>p1: point of the second line</p>
<p>v1: generator of the second line</p>
<p>c1: color of the second line</p>
<p>n1: name of the second line</p>
<p>canonica: if True, draws the x, y and z axis</p>
<p>length: length of the axis x, y and z</p>
<p>size: lenght of the lines</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_base_axis"><code class="name flex">
<span>def <span class="ident">draw_base_axis</span></span>(<span>self, scale=0.05, head_height=0.15, axis=0, name='Axis', positive=True, zaxis=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_base_axis(self,scale=0.05,head_height=0.15,axis=0,name=&#34;Axis&#34;,positive=True,zaxis=True):
        &#34;&#34;&#34;
        Draws a reference axis given by self.origin, self.rotation and the basis self.base
        Parameters:
           scale: scale of the cylinder

           head_height: height of the head of the vector from self.base

           axis: length of the coordinate axis. If the length is 0, only the basis vectors are drawn

           name: name of the result object

           positive: if True, draw the positive part of the axis

           zaxis: if True, draw the z axis
        &#34;&#34;&#34;
        self.base_cilinder()
        self.base_cone()
        o = Vector([0,0,0])
        op = Vector(self.origin)
        color = 0

        if axis != 0 and axis &lt; 8:
                scale /= 3

        base = self.base
        if not zaxis:
                base = self.base[0:2]

        for vec in base:
                #
                # Draw the stem
                #
                v = Vector(vec)
                t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                obj = t.copy()
                obj.name = &#34;Axis%d&#34; % (color + 1)
                obj.data = obj.data.copy()
                obj.location = o
                obj.scale = (scale,scale,(v - o).length - 2 * head_height)
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                if self.colors is not None and len(self.colors) &gt; color:
                        c = self.colors[color]
                        self.add_material(obj,c.name,c.r,c.g,c.b)
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location = op
                self.scene.collection.objects.link(obj)
                #
                # Draw the arrow
                #
                t = bpy.data.objects.get(&#34;Arrow_cone&#34;)
                obj2 = t.copy()
                obj2.name = &#34;Arrow&#34;
                obj2.data = obj2.data.copy()
                obj2.location =  v - 2 * head_height * v / v.length
                obj2.scale = (scale + 0.05,scale + 0.05,head_height)
                obj2.rotation_mode = &#39;QUATERNION&#39;
                obj2.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                if self.colors is not None and len(self.colors) &gt; color:
                        c = self.colors[color]
                        self.add_material(obj2,c.name,c.r,c.g,c.b)
                if self.rotation is not None:
                        obj2.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj2.location.rotate(self.rotation.quaternion)
                obj2.location = op + obj2.location
                self.scene.collection.objects.link(obj2)
                #
                # Draw the line
                #
                obj3 = None
                if axis != 0:
                        v = axis * v/v.length
                        t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                        obj3 = t.copy()
                        obj3.name = &#34;Line&#34;
                        obj3.data = obj3.data.copy()
                        obj3.location = op - v/v.length
                        obj3.scale = (scale / 2,scale / 2,(2 * v).length)
                        obj3.rotation_mode = &#39;QUATERNION&#39;
                        obj3.rotation_quaternion = v.to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                        if self.colors is not None and len(self.colors) &gt; color:
                                c = self.colors[color]
                                self.add_material(obj3,c.name,c.r,c.g,c.b)
                        if self.rotation is not None:
                                obj3.rotation_quaternion.rotate(self.rotation.quaternion)
                        if positive:
                                obj3.location = op
                        else:
                                if self.rotation is not None:
                                        v.rotate(self.rotation.quaternion)
                                obj3.location = op - v
                        self.scene.collection.objects.link(obj3)
                #
                # Joint the three objects
                #
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
                bpy.context.view_layer.objects.active = obj
                obj.select_set(True)
                obj2.select_set(True)
                if obj3 is not None:
                        obj3.select_set(True)
                bpy.ops.object.join()
                color += 1
        #
        # Join all the axis
        #
        t1 = bpy.data.objects.get(&#34;Axis1&#34;)
        t1.name = name
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        bpy.context.view_layer.objects.active = t1
        t1.select_set(True)
        t2 = bpy.data.objects.get(&#34;Axis2&#34;)
        t2.select_set(True)
        if zaxis:
                t3 = bpy.data.objects.get(&#34;Axis3&#34;)
                t3.select_set(True)
        bpy.ops.object.join()
        self.delete_base_cilinder()
        self.delete_base_cone()
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return t1</code></pre>
</details>
<div class="desc"><p>Draws a reference axis given by self.origin, self.rotation and the basis self.base</p>
<h2 id="parameters">Parameters</h2>
<p>scale: scale of the cylinder</p>
<p>head_height: height of the head of the vector from self.base</p>
<p>axis: length of the coordinate axis. If the length is 0, only the basis vectors are drawn</p>
<p>name: name of the result object</p>
<p>positive: if True, draw the positive part of the axis</p>
<p>zaxis: if True, draw the z axis</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_circle"><code class="name flex">
<span>def <span class="ident">draw_circle</span></span>(<span>self,<br>center=[0, 0, 0],<br>u1=Vector((1.0, 0.0, 0.0)),<br>u2=Vector((0.0, 1.0, 0.0)),<br>axis=False,<br>zaxis=False,<br>radius=1,<br>steps=128,<br>thickness=0.01,<br>name='Circle',<br>color='White',<br>fillcolor=None,<br>change=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_circle(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),axis=False,zaxis=False,radius=1,steps=128,thickness=0.01,name=&#34;Circle&#34;,color=&#34;White&#34;,fillcolor=None,change=False):
        &#34;&#34;&#34;
        Draws a circle of center &#39;center&#39; and radius &#39;radius&#39; in the plane determined by vectors u1 and u2
        Parameters:
           center: center of the circle

           u1, u2: vectors to construct the basis {v1, v2, v3}

           axis: if True draws the axis of the reference R&#39;

           zaxis: if True draws the z&#39; axis

           radius: radius of the circle

           steps: number of steps

           thickness: thickness of the curve

           name: name of the curve

           color: color of the curve

           change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
        &#34;&#34;&#34;
        d = None
        if fillcolor is not None:
                d = self.draw_disk(center=center,radius=radius,u1=u1,u2=u2,thickness=0.5*thickness,name=&#34;Disc&#34;,color=fillcolor)
        c = self.draw_curve(lambda t: (radius*math.cos(t),radius*math.sin(t),0),tmin=0.0,tmax=2*math.pi,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
        if change:
                self.set_origin(center)
                self.set_base([u1,u2],orthonormal=True)
        return c, d</code></pre>
</details>
<div class="desc"><p>Draws a circle of center 'center' and radius 'radius' in the plane determined by vectors u1 and u2</p>
<h2 id="parameters">Parameters</h2>
<p>center: center of the circle</p>
<p>u1, u2: vectors to construct the basis {v1, v2, v3}</p>
<p>axis: if True draws the axis of the reference R'</p>
<p>zaxis: if True draws the z' axis</p>
<p>radius: radius of the circle</p>
<p>steps: number of steps</p>
<p>thickness: thickness of the curve</p>
<p>name: name of the curve</p>
<p>color: color of the curve</p>
<p>change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_components"><code class="name flex">
<span>def <span class="ident">draw_components</span></span>(<span>self, vector=None, color='Cyan', name='Components', scale=0.0075)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_components(self,vector=None,color=&#34;Cyan&#34;,name=&#34;Components&#34;,scale=0.0075):
        &#34;&#34;&#34;
        Draws the components of the the vector &#39;vector&#39; in the reference given by self.origin,
        self.rotation and the basis self.base
        Parameters:
           vector: the vector

           color: color of the lines of components

           name: name of the object

           scale: scale of the lines
        &#34;&#34;&#34;
        if vector is None:
                return
        if isinstance(vector,Vector):
                v = vector
        else:
                v = Vector(vector)
        mat = Matrix(self.base)
        mat.transpose()
        list = [[0,0,0],[1,0,0],[1,1,0],[0,1,0],[0,0,1],[1,0,1],[1,1,1],[0,1,1]]
        lines = [[0,1],[1,2],[2,3],[0,3],[0,4],[1,5],[2,6],[3,7],[4,5],[5,6],[6,7],[4,7]]
        vecs = [self.product_components(v,Vector(x)) for x in list]
        count = 0
        for first, last in lines:
                if count == 0:
                        this = name
                else:
                        this = f&#34;Line{count}&#34;
                count += 1
                self.draw_line(start=vecs[first],end=vecs[last],scale=scale,name=this,color=color)
        t = bpy.data.objects.get(name)
        list = [t]
        for count in range(1,12):
                obj = bpy.data.objects.get(f&#34;Line{count}&#34;)
                if obj is not None:
                        list.append(obj)
        t = self.join(list)
        bpy.context.view_layer.objects.active = None
        return t</code></pre>
</details>
<div class="desc"><p>Draws the components of the the vector 'vector' in the reference given by self.origin,
self.rotation and the basis self.base</p>
<h2 id="parameters">Parameters</h2>
<p>vector: the vector</p>
<p>color: color of the lines of components</p>
<p>name: name of the object</p>
<p>scale: scale of the lines</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_cone"><code class="name flex">
<span>def <span class="ident">draw_cone</span></span>(<span>self,<br>a=1.0,<br>xmin=0.0,<br>xmax=5.0,<br>steps=50,<br>scale=[1, 1, 1],<br>half=False,<br>color='AzureBlueDark',<br>name='Cone',<br>opacity=1.0,<br>thickness=0.05)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_cone(self,a=1.0,xmin=0.0,xmax=5.0,steps=50,scale=[1,1,1],half=False,color=&#34;AzureBlueDark&#34;,name=&#34;Cone&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws a cone from the line z = a*x in the XZ plane
        Parameters:
           a: slope of the line

           xmin: minimum value of x

           xmax: maximum value of x

           steps: numbers of steps to draw the parabola

           scale: scaling factors in the X, Y and Z directions

           half: if True, draws half cone

           color: color of the surface

           name: name of the surface

           opacity: opacity of the surface

           thickness: thickness of the surface
        &#34;&#34;&#34;
        delta = (xmax - xmin) / steps
        x = xmax
        bm = bmesh.new()
        verts = []
        count = 2 * steps + 2
        if xmin == 0.0:
                count = 2 * steps + 1
        if half:
                count = steps + 1
        for k in range(count):
                z = a * x
                verts.append(bm.verts.new((x,0,z)))
                if k == steps and xmin &gt; 0:
                        x = - xmin
                else:
                        x -= delta
                if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                        continue
                bm.edges.new([verts[k-1], verts[k]])

        me = self.meshes.new(&#39;placeholder_mesh&#39;)
        obj = self.objects.new(name,me)
        bm.to_mesh(me)
        bm.free()

        modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
        modifier.angle = 2 * math.pi
        modifier.steps = 128
        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        self.scene.collection.objects.link(obj)
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
<div class="desc"><p>Draws a cone from the line z = a*x in the XZ plane</p>
<h2 id="parameters">Parameters</h2>
<p>a: slope of the line</p>
<p>xmin: minimum value of x</p>
<p>xmax: maximum value of x</p>
<p>steps: numbers of steps to draw the parabola</p>
<p>scale: scaling factors in the X, Y and Z directions</p>
<p>half: if True, draws half cone</p>
<p>color: color of the surface</p>
<p>name: name of the surface</p>
<p>opacity: opacity of the surface</p>
<p>thickness: thickness of the surface</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_cube"><code class="name flex">
<span>def <span class="ident">draw_cube</span></span>(<span>self,<br>origin=None,<br>scale=[1, 1, 1],<br>scalelines=0.05,<br>vectors=False,<br>color='Blue',<br>linecolor='Red',<br>vectorcolor='Black',<br>name='Parallelepiped',<br>opacity=1.0,<br>thickness=0.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_cube(self,origin=None,scale=[1,1,1],scalelines=0.05,vectors=False,color=&#34;Blue&#34;,linecolor=&#34;Red&#34;,vectorcolor=&#34;Black&#34;,name=&#39;Parallelepiped&#39;,opacity=1.0,thickness=0.0):
        &#34;&#34;&#34;
        Draws a rectangular parallelepiped
        Parameters:
           origin: center of the parallelepiped

           scale: scale of the sides of the parallelepiped

           scalelines: scale of the edges of the parallelepiped

           vectors: if True, draws vectors from the origin to the vertices

           color: color of the parallelepiped

           linecolor: color of the edges

           vectorcolor: color of the vectors

           name: name of the parallelepiped

           opacity: opacity of the parallelepiped

           thickness: thickness of the parallelepiped
        &#34;&#34;&#34;
        bpy.ops.mesh.primitive_cube_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        if origin is not None:
                if isinstance(origin,Vector):
                        op = op + origin
                else:
                        op = op + Vector(origin)
        obj.location = o
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 0.0

        lines = None
        vecs = None
        s = 0.0
        nodes = [[1+s,1+s,1+s],[-1-s,1+s,1+s],[-1-s,-1-s,1+s],[1+s,-1-s,1+s],
                        [1+s,1+s,-1-s],[-1-s,1+s,-1-s],[-1-s,-1-s,-1-s],[1+s,-1-s,-1-s]]
        nodes = [self.product_components(Vector(scale),Vector(x)) for x in nodes]
        edges =[[0,1],[1,2],[2,3],[3,0],[0,4],[1,5],[2,6],[3,7],[4,5],[5,6],[6,7],[7,4]]
        if scalelines &gt; 0.0:
                objects = []
                for edge in edges:
                        l = self.draw_line(start=op+nodes[edge[0]],end=op+nodes[edge[1]],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                        objects.append(l)
                lines = self.join(objects)

        if vectors:
                vecs = self.draw_vectors(nodes,color=vectorcolor,scale=0.05,head_height=0.2,name=&#34;Vectors&#34;,axis=0)

        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.scale = scale

        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        obj.location = op
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        if lines is not None:
                obj = self.join([obj,lines])

        if vecs is not None:
                obj = self.join([obj,vecs])
        return obj</code></pre>
</details>
<div class="desc"><p>Draws a rectangular parallelepiped</p>
<h2 id="parameters">Parameters</h2>
<p>origin: center of the parallelepiped</p>
<p>scale: scale of the sides of the parallelepiped</p>
<p>scalelines: scale of the edges of the parallelepiped</p>
<p>vectors: if True, draws vectors from the origin to the vertices</p>
<p>color: color of the parallelepiped</p>
<p>linecolor: color of the edges</p>
<p>vectorcolor: color of the vectors</p>
<p>name: name of the parallelepiped</p>
<p>opacity: opacity of the parallelepiped</p>
<p>thickness: thickness of the parallelepiped</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_curve"><code class="name flex">
<span>def <span class="ident">draw_curve</span></span>(<span>self,<br>fun=None,<br>tmin=0.0,<br>tmax=1.0,<br>steps=25,<br>thickness=0.01,<br>name='Curve',<br>color='White',<br>axis=False,<br>zaxis=True,<br>o=Vector((0.0, 0.0, 0.0)),<br>u1=Vector((1.0, 0.0, 0.0)),<br>u2=Vector((0.0, 1.0, 0.0)))</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,axis=False,zaxis=True,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0])):
        &#34;&#34;&#34;
        Draws a curve in a reference R&#39; determined by the origin o and basis {v1, v2, v3} constructed from u1 and u2
        Parameters:
           fun: the parametric function

           tmin: minimum value of the parameter

           tmax: maximum value of the parameter

           steps: number of steps

           thickness: thickness of the curve

           name: name of the curve

           color: color of the curve

           axis: if True draws the axis of the reference R&#39;

           zaxis: if True draws the z&#39; axis

           o: origin of the reference R&#39;

           u1, u2: vectors to construct the basis {v1, v2, v3}
        &#34;&#34;&#34;
        if fun is None:
                return None
        qt = self.vectors_to_quaternion(u1,u2)
        delta = (tmax - tmin) / steps
        t = tmin
        bm = bmesh.new()
        verts = []

        pmax = 0
        for k in range(steps + 1):
                p = fun(t)
                m = max(map(abs,p))
                if m &gt; pmax:
                        pmax = m
                verts.append(bm.verts.new(p))
                t += delta
                if t &gt; tmax:
                        t = tmax

        for i in range(len(verts) - 1):
                bm.edges.new([verts[i], verts[i+1]])

        me = self.meshes.new(&#39;placeholder_mesh&#39;)
        obj = self.objects.new(name,me)
        bm.to_mesh(me)
        bm.free()

        modifier = obj.modifiers.new(type=&#39;SKIN&#39;,name = &#39;skin&#39;)
        for v in obj.data.skin_vertices[0].data:
                v.radius = (thickness,thickness)

        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
        self.set_origin(o)
        self.set_rotation(quaternion=qt)
        if self.rotation is not None:
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        if axis:
                self.draw_base_axis(axis = pmax+3,positive=False,name=&#34;Referència escollida&#34;,zaxis=zaxis)
        self.scene.collection.objects.link(obj)
        bpy.ops.object.shade_smooth()
        obj.location = o
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
<div class="desc"><p>Draws a curve in a reference R' determined by the origin o and basis {v1, v2, v3} constructed from u1 and u2</p>
<h2 id="parameters">Parameters</h2>
<p>fun: the parametric function</p>
<p>tmin: minimum value of the parameter</p>
<p>tmax: maximum value of the parameter</p>
<p>steps: number of steps</p>
<p>thickness: thickness of the curve</p>
<p>name: name of the curve</p>
<p>color: color of the curve</p>
<p>axis: if True draws the axis of the reference R'</p>
<p>zaxis: if True draws the z' axis</p>
<p>o: origin of the reference R'</p>
<p>u1, u2: vectors to construct the basis {v1, v2, v3}</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_disk"><code class="name flex">
<span>def <span class="ident">draw_disk</span></span>(<span>self,<br>center=Vector((0.0, 0.0, 0.0)),<br>radius=5,<br>u1=Vector((1.0, 0.0, 0.0)),<br>u2=Vector((0.0, 1.0, 0.0)),<br>thickness=0.01,<br>name='Disc',<br>color='AzureBlueDark')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_disk(self,center=Vector([0,0,0]),radius=5,u1=Vector([1,0,0]),u2=Vector([0,1,0]),thickness=0.01,name=&#34;Disc&#34;,color=&#34;AzureBlueDark&#34;):
        &#34;&#34;&#34;
        Draws a disc in a reference R&#39; determined by self.origin and self.base
        Parameters:
           radius: radius of the disc

           thickness: thickness of the surface

           name: name of the curve

           color: color of the curve
        &#34;&#34;&#34;
        self.base_disk()
        t = bpy.data.objects.get(&#34;Base_disk&#34;)
        obj = t.copy()
        obj.name = name
        self.delete_base_disk()
        if radius != 1.0:
                obj.scale = (radius,radius,1)
        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
        qt = self.vectors_to_quaternion(u1,u2)
        self.set_rotation(quaternion=qt)
        if self.rotation is not None:
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                ### obj.location.rotate(self.rotation.quaternion)
        obj.location = center
        self.scene.collection.objects.link(obj)
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        obj.select_set(False)
        return obj</code></pre>
</details>
<div class="desc"><p>Draws a disc in a reference R' determined by self.origin and self.base</p>
<h2 id="parameters">Parameters</h2>
<p>radius: radius of the disc</p>
<p>thickness: thickness of the surface</p>
<p>name: name of the curve</p>
<p>color: color of the curve</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_ellipse"><code class="name flex">
<span>def <span class="ident">draw_ellipse</span></span>(<span>self,<br>center=[0, 0, 0],<br>u1=Vector((1.0, 0.0, 0.0)),<br>u2=Vector((0.0, 1.0, 0.0)),<br>a=1,<br>b=1,<br>axis=False,<br>zaxis=False,<br>steps=25,<br>thickness=0.01,<br>name='Ellipse',<br>color='White',<br>change=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_ellipse(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,b=1,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Ellipse&#34;,color=&#34;White&#34;,change=False):
        &#34;&#34;&#34;
        Draws an ellipse of center &#39;center&#39; and semi-axes a and b in the plane determined by vectors u1 and u2
        Parameters:
           center: center of the ellipse

           u1, u2: vectors to construct the basis {v1, v2, v3}

           a, b: semi-axes of the ellipse

           axis: if True draws the axis of the reference R&#39;

           zaxis: if True draws the z&#39; axis

           steps: number of steps

           thickness: thickness of the curve

           name: name of the curve

           color: color of the curve

           change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
        &#34;&#34;&#34;
        if change:
                self.set_origin(center)
                self.set_base([u1,u2],orthonormal=True)
        return self.draw_curve(lambda t: (a*math.cos(t),b*math.sin(t),0),tmin=0.0,tmax=2*math.pi,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)</code></pre>
</details>
<div class="desc"><p>Draws an ellipse of center 'center' and semi-axes a and b in the plane determined by vectors u1 and u2</p>
<h2 id="parameters">Parameters</h2>
<p>center: center of the ellipse</p>
<p>u1, u2: vectors to construct the basis {v1, v2, v3}</p>
<p>a, b: semi-axes of the ellipse</p>
<p>axis: if True draws the axis of the reference R'</p>
<p>zaxis: if True draws the z' axis</p>
<p>steps: number of steps</p>
<p>thickness: thickness of the curve</p>
<p>name: name of the curve</p>
<p>color: color of the curve</p>
<p>change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_ellipsoid"><code class="name flex">
<span>def <span class="ident">draw_ellipsoid</span></span>(<span>self,<br>radius=5.0,<br>scale=[1.2, 1.8, 0.8],<br>color='AzureBlueDark',<br>name='Ellipsoid',<br>opacity=1.0,<br>thickness=0.05)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_ellipsoid(self,radius=5.0,scale=[1.2,1.8,0.8],color=&#34;AzureBlueDark&#34;,name=&#34;Ellipsoid&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws en ellipsoid
        Parameters:
           radius: radius of the sphere

           scale: scaling factors in the X, Y and Z directions

           color: color of the surface

           name: name of the surface

           opacity: opacity of the surface

           thickness: thickness of the surface
        &#34;&#34;&#34;
        bpy.ops.mesh.primitive_uv_sphere_add(segments=128, ring_count=128, radius=radius, enter_editmode=False, location=(0, 0, 0))
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)

        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        obj.select_set(False)
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
<div class="desc"><p>Draws en ellipsoid</p>
<h2 id="parameters">Parameters</h2>
<p>radius: radius of the sphere</p>
<p>scale: scaling factors in the X, Y and Z directions</p>
<p>color: color of the surface</p>
<p>name: name of the surface</p>
<p>opacity: opacity of the surface</p>
<p>thickness: thickness of the surface</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_elliptic_cylinder"><code class="name flex">
<span>def <span class="ident">draw_elliptic_cylinder</span></span>(<span>self,<br>a=8.0,<br>b=5.0,<br>amin=0.0,<br>amax=6.283185307179586,<br>length=20,<br>steps=200,<br>scale=[1, 1, 1],<br>color='AzureBlueDark',<br>name='EllipticCylinder',<br>opacity=1.0,<br>thickness=0.05)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_elliptic_cylinder(self,a=8.0,b=5.0,amin=0.0,amax=2*math.pi,length=20,steps=200,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;EllipticCylinder&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws an eliptic cylinder from the ellipse
          x = a*cos(t)
          y = b*sin(t)
        in the XY plane
        Parameters:
           a, b: coefficients of the ellipsw

           amin: minimum value of the angle t

           amax: maximum value of the angle t

           length: length in the Z direction

           steps: numbers of steps to draw the parabola

           scale: scaling factors in the X, Y and Z directions

           color: color of the surface

           name: name of the surface

           opacity: opacity of the surface

           thickness: thickness of the surface
        &#34;&#34;&#34;
        if amin &lt; 0.0:
                amin = 0.0
        if amax &gt; 2 * math.pi:
                amax = 2 * math.pi
        delta = (amax-amin)/steps
        bm = bmesh.new()
        verts = []
        t = amin
        for k in range(steps + 1):
                x = a * math.cos(t)
                y = b * math.sin(t)
                verts.append(bm.verts.new((x,y,0)))
                t += delta
                if k == 0:
                        continue
                bm.edges.new([verts[k-1], verts[k]])

        me = self.meshes.new(&#39;EllipticCylinderMesh&#39;)
        obj = self.objects.new(name, me)
        bm.to_mesh(me)
        bm.free()
        self.scene.collection.objects.link(obj)

        bpy.context.view_layer.objects.active = obj
        bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
        bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
        bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
        bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0,0,length),&#34;constraint_axis&#34;:(False,False,True),&#34;use_accurate&#34;:True})
        bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
        bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
        obj.select_set(True)
        bpy.ops.transform.translate(value=(0,0,-length/2),constraint_axis=(False,False,True))
        bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
        obj.select_set(False)

        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
<div class="desc"><p>Draws an eliptic cylinder from the ellipse
x = a<em>cos(t)
y = b</em>sin(t)
in the XY plane</p>
<h2 id="parameters">Parameters</h2>
<p>a, b: coefficients of the ellipsw</p>
<p>amin: minimum value of the angle t</p>
<p>amax: maximum value of the angle t</p>
<p>length: length in the Z direction</p>
<p>steps: numbers of steps to draw the parabola</p>
<p>scale: scaling factors in the X, Y and Z directions</p>
<p>color: color of the surface</p>
<p>name: name of the surface</p>
<p>opacity: opacity of the surface</p>
<p>thickness: thickness of the surface</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_elliptic_paraboloid"><code class="name flex">
<span>def <span class="ident">draw_elliptic_paraboloid</span></span>(<span>self,<br>a=0.5,<br>xmin=0.0,<br>xmax=3.0,<br>steps=50,<br>scale=[1, 1, 1],<br>color='AzureBlueDark',<br>name='EllipticParaboloid',<br>opacity=1.0,<br>thickness=0.05)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_elliptic_paraboloid(self,a=0.5,xmin=0.0,xmax=3.0,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;EllipticParaboloid&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws an elliptic paraboloid from the parabola z=a*t^2
        Parameters:
           a: coefficient of the parabola

           xmin: minimum value of x

           xmax: maximum value of x

           steps: numbers of steps to draw the parabola

           scale: scaling factors in the X, Y and Z directions

           color: color of the surface

           name: name of the surface

           opacity: opacity of the surface

           thickness: thickness of the surface
        &#34;&#34;&#34;
        obj = self.simple_curve(f=lambda t:(t,0,a*t**2),tmin=xmin,tmax=xmax,steps=steps,name=name)
        modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
        modifier.angle = 2 * math.pi
        modifier.steps = 128
        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        self.scene.collection.objects.link(obj)
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
<div class="desc"><p>Draws an elliptic paraboloid from the parabola z=a*t^2</p>
<h2 id="parameters">Parameters</h2>
<p>a: coefficient of the parabola</p>
<p>xmin: minimum value of x</p>
<p>xmax: maximum value of x</p>
<p>steps: numbers of steps to draw the parabola</p>
<p>scale: scaling factors in the X, Y and Z directions</p>
<p>color: color of the surface</p>
<p>name: name of the surface</p>
<p>opacity: opacity of the surface</p>
<p>thickness: thickness of the surface</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_frenet_curve"><code class="name flex">
<span>def <span class="ident">draw_frenet_curve</span></span>(<span>self,<br>fun=None,<br>var=None,<br>tmin=0.0,<br>tmax=1.0,<br>radius=0.1,<br>steps=25,<br>thickness=0.01,<br>name='Curve',<br>color='White',<br>point=True,<br>tangent=False,<br>acceleration=False,<br>normal=False,<br>osculator=False,<br>frenet=False,<br>units=False,<br>sizex=8,<br>sizey=8,<br>axis=10)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_frenet_curve(self,fun=None,var=None,tmin=0.0,tmax=1.0,radius=0.1,steps=25,thickness=0.01,name=&#34;Curve&#34;,color=&#34;White&#34;,point=True,tangent=False,acceleration=False,normal=False,osculator=False,frenet=False,units=False,sizex=8,sizey=8,axis=10):
        &#34;&#34;&#34;
        Draws a curve and diferents elements related to the curve
        Parameters:
           fun: the parametric function

           var = parameter variable of the function fun

           tmin: minimum value of the parameter

           tmax: maximum value of the parameter

           radius: radius of the point

           steps: number of steps

           frames: increment of the frame set

           thickness: thickness of the curve

           name: name of the curve

           color: color of the curve

           point: if True draw a point along the curve

           tangent: if True draw the tangent vector along the curve

           acceleration: if True draw the acceleration vector along the curve

           normal: if True draw the normal vector along the curve

           osculator: if True draw the osculating plane along the curve

           frenet: if True draw the Frenet trihedron along the curve

           units: if True normalize the tangent and normal vectors

           sizex, sizey: sizes of the osculating plane

           axis: length of the coordinate axis
        &#34;&#34;&#34;
        if fun is None:
                return None

        self.draw_base_axis(axis=axis,positive=False)

        def _fun_(x):
                return [u.subs(var,x) for u in fun]

        def frenet_quaternion(tangent,normal):
                v1 = tangent.normalized()
                v2 = normal.normalized()
                v3 = v1.cross(v2)
                return Matrix([v1,v2,v3]).transposed().to_quaternion()

        frames = 1
        curve = self.draw_curve(_fun_,tmin=tmin,tmax=tmax,steps=steps,thickness=thickness,color=color,axis=False)
        if not point and not tangent and not osculator and not frenet:
                return curve

        T = [diff(u,var) for u in fun]
        #
        # Here is sqrt from sympy
        #
        Tnorm = math.sqrt(sum([u**2 for u in T]))
        A = [diff(u,var) for u in T]
        p0 = Vector([u.subs(var,tmin) for u in fun])
        v0 = Vector([N(u.subs(var,tmin)) for u in T])
        a0 = Vector([N(u.subs(var,tmin)) for u in A])
        n0 = a0 - a0.project(v0)
        q0 = frenet_quaternion(v0,n0)
        f0 = [Vector([1,0,0]),Vector([0,1,0]),Vector([0,0,1])]

        if units:
                v0.normalize()
                n0.normalize()
        bpy.context.scene.frame_set(self.frame)

        if point:
                p = self.draw_point(radius=radius,location=p0,name=&#34;Punt&#34;,color=&#34;Black&#34;)
                p.keyframe_insert(data_path=&#34;location&#34;,index=-1)
        self.set_origin(p0)
        if tangent:
                l = v0.length
                if not units:
                        vp = 5*v0.normalized()
                else:
                        vp = v0
                if not units:
                        v = self.draw_vector(vector=vp,color=&#34;Red&#34;,scale=0.035,head_height=0.3)
                        v.scale.z *= l / 5.0
                else:
                        v = self.draw_vector(vector=vp,color=&#34;Red&#34;,scale=0.035,head_height=0.2)
                v.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                v.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                v.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        if acceleration:
                l = a0.length
                ap = 5*a0.normalized()
                a = self.draw_vector(vector=ap,color=&#34;Green&#34;,scale=0.035,head_height=0.2)
                a.scale.z *= l / 5.0
                a.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                a.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                a.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        if normal:
                l = n0.length
                if not units:
                        np = 5*n0.normalized()
                else:
                        np = n0
                if not units:
                        n = self.draw_vector(vector=np,color=&#34;Red&#34;,scale=0.035,head_height=0.2)
                        n.scale.z *= l / 5.0
                else:
                        n = self.draw_vector(vector=np,color=&#34;Red&#34;,scale=0.035,head_height=0.1)
                n.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                n.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                n.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        if osculator:
                o = self.draw_plane_surface(base=[[1,0,0],[0,1,0]],color=&#34;GreenPaleDull&#34;,linecolor=&#34;GreenDarkDull&#34;,sizex=sizex,sizey=sizey,opacity=0.25)
                o.rotation_quaternion = q0
                o.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                o.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        if frenet:
                f = self.draw_vectors(f0,color=&#34;Red&#34;,scale=0.035,head_height=0.1)
                f.rotation_quaternion = q0
                f.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                f.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        self.set_origin()

        fn = frames + self.frame
        for i in range(steps):
                bpy.context.scene.frame_set(fn)
                x = tmin + (tmax - tmin)*i/steps
                pos = Vector([u.subs(var,x) for u in fun])
                v1 = Vector([N(u.subs(var,x)) for u in T])
                a1 = Vector([N(u.subs(var,x)) for u in A])
                n1 = a1 - a1.project(v1)
                q1 = frenet_quaternion(v1,n1)
                if point:
                        p.location = pos
                        p.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                if tangent:
                        if not units:
                                r = v1.length / v0.length
                                v.scale.z *= r
                        v.location = pos
                        v.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        v.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        q = v0.rotation_difference(v1)
                        v.rotation_quaternion.rotate(q)
                        v.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if acceleration:
                        r = a1.length / a0.length
                        a.scale.z *= r
                        a.location = pos
                        a.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        a.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        q = a0.rotation_difference(a1)
                        a.rotation_quaternion.rotate(q)
                        a.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if normal:
                        if not units:
                                r = n1.length / n0.length
                                n.scale.z *= r
                        n.location = pos
                        n.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        n.keyframe_insert(data_path=&#34;scale&#34;,index=-1)
                        q = n0.rotation_difference(n1)
                        n.rotation_quaternion.rotate(q)
                        n.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if osculator:
                        o.location = pos
                        o.rotation_quaternion = q1
                        o.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        o.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if frenet:
                        f.location = pos
                        f.rotation_quaternion = q1
                        f.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                        f.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                v0 = v1.copy()
                a0 = a1.copy()
                n0 = n1.copy()
                fn += frames
        self.frame = fn - frames
        bpy.context.scene.frame_end = self.frame
        bpy.context.scene.frame_set(0)
        bpy.context.view_layer.update()</code></pre>
</details>
<div class="desc"><p>Draws a curve and diferents elements related to the curve</p>
<h2 id="parameters">Parameters</h2>
<p>fun: the parametric function</p>
<p>var = parameter variable of the function fun</p>
<p>tmin: minimum value of the parameter</p>
<p>tmax: maximum value of the parameter</p>
<p>radius: radius of the point</p>
<p>steps: number of steps</p>
<p>frames: increment of the frame set</p>
<p>thickness: thickness of the curve</p>
<p>name: name of the curve</p>
<p>color: color of the curve</p>
<p>point: if True draw a point along the curve</p>
<p>tangent: if True draw the tangent vector along the curve</p>
<p>acceleration: if True draw the acceleration vector along the curve</p>
<p>normal: if True draw the normal vector along the curve</p>
<p>osculator: if True draw the osculating plane along the curve</p>
<p>frenet: if True draw the Frenet trihedron along the curve</p>
<p>units: if True normalize the tangent and normal vectors</p>
<p>sizex, sizey: sizes of the osculating plane</p>
<p>axis: length of the coordinate axis</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_function"><code class="name flex">
<span>def <span class="ident">draw_function</span></span>(<span>self,<br>f=None,<br>xmin=-3,<br>xmax=3,<br>xsteps=64,<br>ymin=-3,<br>ymax=3,<br>ysteps=64,<br>thickness=0.02,<br>opacity=1.0,<br>pmax=10,<br>name='Function',<br>color='AzureBlueDark',<br>axis=False,<br>o=Vector((0.0, 0.0, 0.0)),<br>u1=Vector((1.0, 0.0, 0.0)),<br>u2=Vector((0.0, 1.0, 0.0)))</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_function(self,f=None,xmin=-3,xmax=3,xsteps=64,ymin=-3,ymax=3,ysteps=64,thickness=0.02,opacity=1.0,pmax=10,name=&#34;Function&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0])):
        &#34;&#34;&#34;
        Draws a function of two variables f(x,y) i the reference R&#39; = {o, v1, v2, v3}
        Parameters:
           f: the function of two variables f(x,y)

           xmin: minimum value of x

           xmax: maximum value of x

           xsteps: steps in the x direction

           ymin: minimum value of y

           ymax: maximum value of y

           ysteps: steps in the x direction

           thickness: thickness of the surface

           opacity: opacity of the surface

           pmax: the axis are drawn between -pmax and pmax

           name: name of the surface

           color: color of the surface

           axis: if True the axis of the reference R&#39; are drawn

           o: origin of the reference R&#39;

           u1, u2: vectors to construct the basis {v1, v2, v3}
        &#34;&#34;&#34;
        if f is None:
                return None
        return self.draw_surface(eq=lambda x,y:(x,y,f(x,y)),umin=xmin,umax=xmax,usteps=xsteps,vmin=ymin,vmax=ymax,vsteps=ysteps,thickness=thickness,opacity=opacity,pmax=pmax,name=name,color=color,axis=axis,o=o,u1=u1,u2=u2,wrap_u=False,wrap_v=False,close_v=False)</code></pre>
</details>
<div class="desc"><p>Draws a function of two variables f(x,y) i the reference R' = {o, v1, v2, v3}</p>
<h2 id="parameters">Parameters</h2>
<p>f: the function of two variables f(x,y)</p>
<p>xmin: minimum value of x</p>
<p>xmax: maximum value of x</p>
<p>xsteps: steps in the x direction</p>
<p>ymin: minimum value of y</p>
<p>ymax: maximum value of y</p>
<p>ysteps: steps in the x direction</p>
<p>thickness: thickness of the surface</p>
<p>opacity: opacity of the surface</p>
<p>pmax: the axis are drawn between -pmax and pmax</p>
<p>name: name of the surface</p>
<p>color: color of the surface</p>
<p>axis: if True the axis of the reference R' are drawn</p>
<p>o: origin of the reference R'</p>
<p>u1, u2: vectors to construct the basis {v1, v2, v3}</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_hyperbole"><code class="name flex">
<span>def <span class="ident">draw_hyperbole</span></span>(<span>self,<br>center=[0, 0, 0],<br>u1=Vector((1.0, 0.0, 0.0)),<br>u2=Vector((0.0, 1.0, 0.0)),<br>a=1,<br>b=1,<br>ymax=3.0,<br>axis=False,<br>zaxis=False,<br>steps=25,<br>thickness=0.01,<br>name='Hyperbole',<br>color='White',<br>change=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_hyperbole(self,center=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,b=1,ymax=3.0,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Hyperbole&#34;,color=&#34;White&#34;,change=False):
        &#34;&#34;&#34;
        Draws an hyperbole of center &#39;center&#39; and semi-axes a and b in the plane determined by vectors u1 and u2
        Parameters:
           center: center of the hyperbole

           u1, u2: vectors to construct the basis {v1, v2, v3}

           a, b: semi-axes of the hyperbole

           ymax: maximum value of the y&#39;

           axis: if True draws the axis of the reference R&#39;

           zaxis: if True draws the z&#39; axis

           steps: number of steps

           thickness: thickness of the curve

           name: name of the curve

           color: color of the curve

           change: if True, set the reference self.origin, self.base to {o; v1, v2, v3}
        &#34;&#34;&#34;
        c1 = self.draw_curve(lambda t: (a*math.sqrt(1+t**2/b**2),t,0),tmin=-ymax,tmax=ymax,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
        c2 = self.draw_curve(lambda t: (-a*math.sqrt(1+t**2/b**2),t,0),tmin=-ymax,tmax=ymax,axis=False,zaxis=False,steps=steps,thickness=thickness,name=name,color=color,o=center,u1=u1,u2=u2)
        self.join([c1,c2])
        if change:
                self.set_origin(center)
                self.set_base([u1,u2],orthonormal=True)
        return c1</code></pre>
</details>
<div class="desc"><p>Draws an hyperbole of center 'center' and semi-axes a and b in the plane determined by vectors u1 and u2</p>
<h2 id="parameters">Parameters</h2>
<p>center: center of the hyperbole</p>
<p>u1, u2: vectors to construct the basis {v1, v2, v3}</p>
<p>a, b: semi-axes of the hyperbole</p>
<p>ymax: maximum value of the y'</p>
<p>axis: if True draws the axis of the reference R'</p>
<p>zaxis: if True draws the z' axis</p>
<p>steps: number of steps</p>
<p>thickness: thickness of the curve</p>
<p>name: name of the curve</p>
<p>color: color of the curve</p>
<p>change: if True, set the reference self.origin, self.base to {o; v1, v2, v3}</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_hyperbolic_cylinder"><code class="name flex">
<span>def <span class="ident">draw_hyperbolic_cylinder</span></span>(<span>self,<br>a=1.0,<br>b=4.0,<br>xmin=2.0,<br>xmax=6.0,<br>length=20,<br>steps=50,<br>scale=[1, 1, 1],<br>color='AzureBlueDark',<br>name='HyperbolicCylinder',<br>opacity=1.0,<br>thickness=0.05)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_hyperbolic_cylinder(self,a=1.0,b=4.0,xmin=2.0,xmax=6.0,length=20,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicCylinder&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws an hyperbolic cylinder from the hyperbole y = a * sqrt(x**2 - b) in the XY plane
        Parameters:
           a, b: coefficients of the hyperbole

           xmin: minimum value of x

           xmax: maximum value of x

           length: length in the Z direction

           steps: numbers of steps to draw the parabola

           scale: scaling factors in the X, Y and Z directions

           color: color of the surface

           name: name of the surface

           opacity: opacity of the surface

           thickness: thickness of the surface
        &#34;&#34;&#34;
        if xmin &lt; math.sqrt(b):
                xmin = math.sqrt(b)
        delta = (xmax-xmin)/steps
        bm = bmesh.new()
        verts = []
        count = 2 * steps + 2
        if xmin == 0.0:
                count = 2 * steps + 1
        for q, d in [[1,0],[-1,count]]:
                x = xmax
                sign = 1
                for k in range(count):
                        if k == steps + 1:
                                sign = -1
                        if x &lt; math.sqrt(b):
                                x = math.sqrt(b)
                        y = sign * a * math.sqrt(x**2 - b)
                        verts.append(bm.verts.new((q * x,y,0)))
                        if k == steps and xmin &gt; math.sqrt(b):
                                x = xmin
                        else:
                                x = x - sign * delta
                        if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                                continue
                        bm.edges.new([verts[d + k-1], verts[d + k]])

        me = self.meshes.new(&#39;HyperboliclinderMesh&#39;)
        obj = self.objects.new(name, me)
        bm.to_mesh(me)
        bm.free()

        self.scene.collection.objects.link(obj)
        bpy.context.view_layer.objects.active = obj
        bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
        bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
        bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
        bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0,0,length),&#34;constraint_axis&#34;:(False,False,True),&#34;use_accurate&#34;:True})
        bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
        bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
        obj.select_set(True)
        bpy.ops.transform.translate(value=(0,0,-length/2),constraint_axis=(False,False,True))
        bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
        obj.select_set(False)

        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
<div class="desc"><p>Draws an hyperbolic cylinder from the hyperbole y = a * sqrt(x**2 - b) in the XY plane</p>
<h2 id="parameters">Parameters</h2>
<p>a, b: coefficients of the hyperbole</p>
<p>xmin: minimum value of x</p>
<p>xmax: maximum value of x</p>
<p>length: length in the Z direction</p>
<p>steps: numbers of steps to draw the parabola</p>
<p>scale: scaling factors in the X, Y and Z directions</p>
<p>color: color of the surface</p>
<p>name: name of the surface</p>
<p>opacity: opacity of the surface</p>
<p>thickness: thickness of the surface</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_hyperbolic_paraboloid"><code class="name flex">
<span>def <span class="ident">draw_hyperbolic_paraboloid</span></span>(<span>self,<br>a=0.2,<br>b=0.4,<br>xmax=10.0,<br>ymax=10.0,<br>steps=64,<br>scale=[1, 1, 1],<br>color='AzureBlueDark',<br>name='HyperbolicParaboloid',<br>opacity=1.0,<br>thickness=0.05)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_hyperbolic_paraboloid(self,a=0.2,b=0.4,xmax=10.0,ymax=10.0,steps=64,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicParaboloid&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws an hyperbolic paraboloid with equation z = a*x^2 - b*y^2
        Parameters:
           a, b: coefficients of the parabolic hyperboloid

           xmax: maximum  value of x

           ymax: maxim value y

           steps: numbers of steps to draw the parabola

           scale: scaling factors in the X, Y and Z directions

           color: color of the surface

           name: name of the surface

           opacity: opacity of the surface

           thickness: thickness of the surface
        &#34;&#34;&#34;
        equ = lambda x,y: (x,y,a*x**2-b*y**2)
        obj = self.draw_surface(eq=equ,umin=-xmax,umax=xmax,usteps=steps,vmin=-ymax,vmax=ymax,vsteps=steps,thickness=thickness,opacity=opacity,pmax=0,name=&#34;Hyperbolic paraboloid&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),wrap_u=False,wrap_v=False,close_v=False)
        obj.scale = scale
        return obj</code></pre>
</details>
<div class="desc"><p>Draws an hyperbolic paraboloid with equation z = a<em>x^2 - b</em>y^2</p>
<h2 id="parameters">Parameters</h2>
<p>a, b: coefficients of the parabolic hyperboloid</p>
<p>xmax: maximum
value of x</p>
<p>ymax: maxim value y</p>
<p>steps: numbers of steps to draw the parabola</p>
<p>scale: scaling factors in the X, Y and Z directions</p>
<p>color: color of the surface</p>
<p>name: name of the surface</p>
<p>opacity: opacity of the surface</p>
<p>thickness: thickness of the surface</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_line"><code class="name flex">
<span>def <span class="ident">draw_line</span></span>(<span>self,<br>start=[1, 1, 1],<br>end=[10, 10, 10],<br>scale=0.05,<br>name='Line',<br>color='Black',<br>segment=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_line(self,start=[1,1,1],end=[10,10,10],scale=0.05,name=&#34;Line&#34;,color=&#34;Black&#34;,segment=False):
        &#34;&#34;&#34;
        Draws a line from the point start to the point end. The reference given by self.origin,
        self.rotation and the basis self.base is used
        Parameters:
           start: starting point of the line

           end: ending point of the line

           scale: scale of the cylinder

           name: name of the object

           color: color of the vector

           segment: if True, draw points start and end
        &#34;&#34;&#34;
        if start is None or end is None:
                return
        self.base_cilinder()
        o = Vector([0,0,0])
        op = Vector(self.origin)
        if isinstance(start,Vector):
                u = start
        else:
                u = Vector(start)
        if isinstance(end,Vector):
                v = end
        else:
                v = Vector(end)
        mat = Matrix(self.base)
        mat.transpose()
        u = mat @ u
        v = mat @ v
        l = (v - u).length
        t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
        obj = t.copy()
        obj.name = name
        obj.location = u
        obj.scale = (scale / 2,scale / 2,l)
        obj.rotation_mode = &#39;QUATERNION&#39;
        obj.rotation_quaternion = (v - u).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
        if color is not None:
                c = Colors.color(color)
                self.add_material(obj,c.name,c.r,c.g,c.b)
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        obj.location = obj.location + op
        self.scene.collection.objects.link(obj)
        bpy.ops.object.shade_flat()
        self.delete_base_cilinder()
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        bpy.context.view_layer.objects.active = None
        if segment:
                s1 = self.draw_point(radius=2*scale,location=end,name=&#34;End point&#34;,color=color,opacity=1.0)
                s2 = self.draw_point(radius=2*scale,location=start,name=&#34;Start point&#34;,color=color,opacity=1.0)
                self.join([obj,s1,s2])
        return obj</code></pre>
</details>
<div class="desc"><p>Draws a line from the point start to the point end. The reference given by self.origin,
self.rotation and the basis self.base is used</p>
<h2 id="parameters">Parameters</h2>
<p>start: starting point of the line</p>
<p>end: ending point of the line</p>
<p>scale: scale of the cylinder</p>
<p>name: name of the object</p>
<p>color: color of the vector</p>
<p>segment: if True, draw points start and end</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_mesh"><code class="name flex">
<span>def <span class="ident">draw_mesh</span></span>(<span>self, mesh=None, name='Mesh', color='Blue', opacity=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_mesh(self,mesh=None,name=&#39;Mesh&#39;,color=&#34;Blue&#34;,opacity=1):
        &#34;&#34;&#34;
        Draws a mesh. This function is used by other functions
        Parameters:
           mesh: the mesh to be drawn

           name: name of the mesh

           color: color of the mesh

           opacity: opacity of the mesh
        &#34;&#34;&#34;
        bm = bmesh.new()
        verts = []
        for p in mesh.points:
                verts.append(bm.verts.new(p))
        edges = [[0,1],[1,2],[2,3],[3,0]]
        for s in mesh.simplices:
                for e in edges:
                        v = Vector(mesh.points[s[e[0]]]) - Vector(mesh.points[s[e[1]]])
                        edge = [verts[s[e[0]]],verts[s[e[1]]]]
                        try:
                                bm.edges.new(edge)
                        except:
                                pass
        me = self.meshes.new(&#39;PointsMesh&#39;)
        obj = self.objects.new(name, me)
        bm.to_mesh(me)
        bm.free()
        self.scene.collection.objects.link(obj)
        return obj</code></pre>
</details>
<div class="desc"><p>Draws a mesh. This function is used by other functions</p>
<h2 id="parameters">Parameters</h2>
<p>mesh: the mesh to be drawn</p>
<p>name: name of the mesh</p>
<p>color: color of the mesh</p>
<p>opacity: opacity of the mesh</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_one_sheet_hyperboloid"><code class="name flex">
<span>def <span class="ident">draw_one_sheet_hyperboloid</span></span>(<span>self,<br>a=2.0,<br>b=2.0,<br>xmin=1.4142135623730951,<br>xmax=5.0,<br>steps=256,<br>scale=[1, 1, 1],<br>color='AzureBlueDark',<br>name='HyperboloidOneSheet',<br>opacity=1.0,<br>thickness=0.05)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_one_sheet_hyperboloid(self,a=2.0,b=2.0,xmin=math.sqrt(2),xmax=5.0,steps=256,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperboloidOneSheet&#34;,opacity=1.0,thickness=0.05):
        r&#34;&#34;&#34;
        Draws a one sheet hyperboloid from the hyperbole z = \pm a*sqrt(x^2-b) in the XZ plane
        Parameters:
           a, b: coefficients of the hyperbole

           xmin: minimum value of x

           xmax: maximum value of x

           steps: numbers of steps to draw the parabola

           scale: scaling factors in the X, Y and Z directions

           color: color of the surface

           name: name of the surface

           opacity: opacity of the surface

           thickness: thickness of the surface
        &#34;&#34;&#34;
        if xmin &lt; math.sqrt(b):
                xmin = math.sqrt(b)
        delta = (xmax - xmin) / steps
        x = xmax
        bm = bmesh.new()
        verts = []

        for k in range(steps + 1):
                if x &lt; math.sqrt(b):
                        z = 0.0
                else:
                        z = - a * math.sqrt(x**2 - b)
                verts.append(bm.verts.new((x,0,z)))
                x -= delta
        x = math.sqrt(b)
        for k in range(steps):
                x += delta
                if x**2 &lt; b:
                        z = 0.0
                else:
                        z = a * math.sqrt(x**2 - b)
                verts.append(bm.verts.new((x,0,z)))

        for i in range(len(verts) - 1):
                bm.edges.new([verts[i], verts[i+1]])

        me = self.meshes.new(&#39;placeholder_mesh&#39;)
        obj = self.objects.new(name,me)
        bm.to_mesh(me)
        bm.free()
        modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
        modifier.angle = 2 * math.pi
        modifier.steps = 128
        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        self.scene.collection.objects.link(obj)
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
<div class="desc"><p>Draws a one sheet hyperboloid from the hyperbole z = \pm a*sqrt(x^2-b) in the XZ plane</p>
<h2 id="parameters">Parameters</h2>
<p>a, b: coefficients of the hyperbole</p>
<p>xmin: minimum value of x</p>
<p>xmax: maximum value of x</p>
<p>steps: numbers of steps to draw the parabola</p>
<p>scale: scaling factors in the X, Y and Z directions</p>
<p>color: color of the surface</p>
<p>name: name of the surface</p>
<p>opacity: opacity of the surface</p>
<p>thickness: thickness of the surface</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_parabola"><code class="name flex">
<span>def <span class="ident">draw_parabola</span></span>(<span>self,<br>vertex=[0, 0, 0],<br>u1=Vector((1.0, 0.0, 0.0)),<br>u2=Vector((0.0, 1.0, 0.0)),<br>a=1,<br>xmax=3.0,<br>axis=False,<br>zaxis=False,<br>steps=25,<br>thickness=0.01,<br>name='Parabola',<br>color='White',<br>change=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_parabola(self,vertex=[0,0,0],u1=Vector([1,0,0]),u2=Vector([0,1,0]),a=1,xmax=3.0,axis=False,zaxis=False,steps=25,thickness=0.01,name=&#34;Parabola&#34;,color=&#34;White&#34;,change=False):
        &#34;&#34;&#34;
        Draws a parabola of vertex &#39;vertex&#39; of equation y&#39;=ax&#39;^2 in the reference {vertex; v1, v2, v3} determined by vectors u1 and u2
        Parameters:
           vertex: vertex of the parabola

           u1, u2: vectors to construct the basis {v1, v2, v3}

           a: coefficient of the parabola

           xmax: maximum value of x&#39;

           axis: if True draws the axis of the reference R&#39;

           zaxis: if True draws the z&#39; axis

           steps: number of steps

           thickness: thickness of the curve

           name: name of the curve

           color: color of the curve

           change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}
        &#34;&#34;&#34;
        if change:
                self.set_origin(vertex)
                self.set_base([u1,u2],orthonormal=True)
        return self.draw_curve(lambda t: (t,a*t**2,0),tmin=-xmax,tmax=xmax,axis=axis,zaxis=zaxis,steps=steps,thickness=thickness,name=name,color=color,o=vertex,u1=u1,u2=u2)</code></pre>
</details>
<div class="desc"><p>Draws a parabola of vertex 'vertex' of equation y'=ax'^2 in the reference {vertex; v1, v2, v3} determined by vectors u1 and u2</p>
<h2 id="parameters">Parameters</h2>
<p>vertex: vertex of the parabola</p>
<p>u1, u2: vectors to construct the basis {v1, v2, v3}</p>
<p>a: coefficient of the parabola</p>
<p>xmax: maximum value of x'</p>
<p>axis: if True draws the axis of the reference R'</p>
<p>zaxis: if True draws the z' axis</p>
<p>steps: number of steps</p>
<p>thickness: thickness of the curve</p>
<p>name: name of the curve</p>
<p>color: color of the curve</p>
<p>change: if True, set the reference self.orifin, self.base to {o; v1, v2, v3}</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_parabolic_cylinder"><code class="name flex">
<span>def <span class="ident">draw_parabolic_cylinder</span></span>(<span>self,<br>p=0.25,<br>xmin=0.0,<br>xmax=6.0,<br>length=20,<br>steps=50,<br>scale=[1, 1, 1],<br>color='AzureBlueDark',<br>name='ParabolicCylinder',<br>opacity=1.0,<br>thickness=0.05)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_parabolic_cylinder(self,p=0.25,xmin=0.0,xmax=6.0,length=20,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;ParabolicCylinder&#34;,opacity=1.0,thickness=0.05):
        &#34;&#34;&#34;
        Draws a parabolic cylinder from the parabola z=p*x^2 in the XZ plane
        Parameters:
           p: coefficient of the parabola

           xmin: minimum value of x

           xmax: maximum value of x

           length: length in the Y direction

           steps: numbers of steps to draw the parabola

           scale: scaling factors in the X, Y and Z directions

           color: color of the surface

           name: name of the surface

           opacity: opacity of the surface

           thickness: thickness of the surface
        &#34;&#34;&#34;
        delta = (xmax - xmin) / steps
        x = xmax
        bm = bmesh.new()
        verts = []
        count = 2 * steps + 2
        if xmin == 0.0:
                count = 2 * steps + 1
        for k in range(count):
                z = p * x**2
                verts.append(bm.verts.new((x,0,z)))
                if k == steps and xmin &gt; 0:
                        x = - xmin
                else:
                        x -= delta
                if k == 0 or (k == steps + 1 and xmin &gt; 0.0):
                        continue
                bm.edges.new([verts[k-1], verts[k]])

        me = self.meshes.new(&#39;ParabolicCylinderMesh&#39;)
        obj = self.objects.new(name, me)
        bm.to_mesh(me)
        bm.free()

        bpy.context.scene.collection.objects.link(obj)
        bpy.context.view_layer.objects.active = obj
        bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
        bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
        bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
        bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0, length, 0),&#34;constraint_axis&#34;:(False, True, False),&#34;use_accurate&#34;:True})
        bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
        bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
        obj.select_set(True)
        bpy.ops.transform.translate(value=(0, -length/2, 0),constraint_axis=(False, True, False))
        bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
        obj.select_set(False)

        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
<div class="desc"><p>Draws a parabolic cylinder from the parabola z=p*x^2 in the XZ plane</p>
<h2 id="parameters">Parameters</h2>
<p>p: coefficient of the parabola</p>
<p>xmin: minimum value of x</p>
<p>xmax: maximum value of x</p>
<p>length: length in the Y direction</p>
<p>steps: numbers of steps to draw the parabola</p>
<p>scale: scaling factors in the X, Y and Z directions</p>
<p>color: color of the surface</p>
<p>name: name of the surface</p>
<p>opacity: opacity of the surface</p>
<p>thickness: thickness of the surface</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_parallelepiped"><code class="name flex">
<span>def <span class="ident">draw_parallelepiped</span></span>(<span>self,<br>origin=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>u3=[0, 0, 1],<br>scalelines=0.025,<br>color='AzureBlueDark',<br>linecolor='OrangeObscureDull',<br>name='Parallelepiped',<br>opacity=1.0,<br>thickness=0.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_parallelepiped(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],u3=[0,0,1],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Parallelepiped&#39;,opacity=1.0,thickness=0.0):
        &#34;&#34;&#34;
        Draws a parallelepiped
        Parameters:
           origin: base vertex of the parallelepiped

           u1, u2, u3: vectors that gives the edges

           scalelines: scale of the edges of the parallelepiped

           color: color of the parallelepiped

           linecolor: color of the edges

           name: name of the parallelepiped

           opacity: opacity of the parallelepiped

           thickness: thickness of the parallelepiped
        &#34;&#34;&#34;
        op = Vector(self.origin)
        if isinstance(origin,Vector):
                op = op + origin
        else:
                op = op + Vector(origin)
        if not isinstance(u1,Vector):
                u1 = Vector(u1)
        if not isinstance(u2,Vector):
                u2 = Vector(u2)
        if not isinstance(u3,Vector):
                u3 = Vector(u3)

        mat = Matrix(self.base)
        mat.transpose()
        u1 = mat @ u1
        u2 = mat @ u2
        u3 = mat @ u3

        bpy.ops.mesh.primitive_cube_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)

        verts = obj.data.vertices
        verts[0].co = op
        verts[1].co = op + u3
        verts[2].co = op + u2
        verts[3].co = op + u2 + u3
        verts[4].co = op + u1
        verts[5].co = op + u1 + u3
        verts[6].co = op + u1 + u2
        verts[7].co = op + u1 + u2 + u3

        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 0.0

        lines = None
        s = 0.0
        edges =[[0,1],[0,2],[0,4],[1,3],[1,5],[2,3],[2,6],[3,7],[4,5],[4,6],[5,7],[6,7]]
        if scalelines &gt; 0.0:
                objects = []
                for edge in edges:
                        l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                        objects.append(l)
                lines = self.join(objects)

        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

        if lines is not None:
                obj = self.join([obj,lines])

        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None

        return obj</code></pre>
</details>
<div class="desc"><p>Draws a parallelepiped</p>
<h2 id="parameters">Parameters</h2>
<p>origin: base vertex of the parallelepiped</p>
<p>u1, u2, u3: vectors that gives the edges</p>
<p>scalelines: scale of the edges of the parallelepiped</p>
<p>color: color of the parallelepiped</p>
<p>linecolor: color of the edges</p>
<p>name: name of the parallelepiped</p>
<p>opacity: opacity of the parallelepiped</p>
<p>thickness: thickness of the parallelepiped</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_parallelogram"><code class="name flex">
<span>def <span class="ident">draw_parallelogram</span></span>(<span>self,<br>origin=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>scalelines=0.025,<br>color='AzureBlueDark',<br>linecolor='OrangeObscureDull',<br>name='Parallelogram',<br>opacity=1.0,<br>thickness=0.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_parallelogram(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Parallelogram&#39;,opacity=1.0,thickness=0.0):
        &#34;&#34;&#34;
        Draws a parallelogram
        Parameters:
           origin: base vertex of the parallelogram

           u1, u2: vectors that gives the edges

           scalelines: scale of the edges of the parallelogram

           color: color of the parallelogram

           linecolor: color of the edges

           name: name of the parallelogram

           opacity: opacity of the parallelogram

           thickness: thickness of the parallelogram
        &#34;&#34;&#34;
        op = Vector(self.origin)
        if isinstance(origin,Vector):
                op = op + origin
        else:
                op = op + Vector(origin)
        if not isinstance(u1,Vector):
                u1 = Vector(u1)
        if not isinstance(u2,Vector):
                u2 = Vector(u2)

        mat = Matrix(self.base)
        mat.transpose()
        u1 = mat @ u1
        u2 = mat @ u2

        bpy.ops.mesh.primitive_plane_add(size=2,enter_editmode=False,align=&#39;WORLD&#39;,location=(0, 0, 0))
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)

        verts = obj.data.vertices
        verts[0].co = op
        verts[1].co = op + u1
        verts[2].co = op + u2
        verts[3].co = op + u1 + u2

        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 0.0

        lines = None
        s = 0.0
        edges =[[0,1],[0,2],[1,3],[2,3]]
        if scalelines &gt; 0.0:
                objects = []
                for edge in edges:
                        l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                        objects.append(l)
                lines = self.join(objects)

        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

        if lines is not None:
                obj = self.join([obj,lines])

        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None

        return obj</code></pre>
</details>
<div class="desc"><p>Draws a parallelogram</p>
<h2 id="parameters">Parameters</h2>
<p>origin: base vertex of the parallelogram</p>
<p>u1, u2: vectors that gives the edges</p>
<p>scalelines: scale of the edges of the parallelogram</p>
<p>color: color of the parallelogram</p>
<p>linecolor: color of the edges</p>
<p>name: name of the parallelogram</p>
<p>opacity: opacity of the parallelogram</p>
<p>thickness: thickness of the parallelogram</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_plane"><code class="name flex">
<span>def <span class="ident">draw_plane</span></span>(<span>self,<br>normal=None,<br>base=None,<br>sizex=10,<br>sizey=10,<br>color='AzureBlueDark',<br>name='Plane',<br>opacity=1.0,<br>thickness=0.01)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_plane(self,normal=None,base=None,sizex=10,sizey=10,color=&#34;AzureBlueDark&#34;,name=&#39;Plane&#39;,opacity=1.0,thickness=0.01):
        &#34;&#34;&#34;
        Draws a plane with normal vector or base vectors. It passes through the point self.origin.
        Only normal or base can be not None
        Parameters:
           normal: normal vector to the plane

           base: list of two independent vectors

           sizex: x-size of the plane

           sizey: y-size of the plane

           color: color of the plane

           name: name of the plane

           opacity: opacity of the plane

           thickness: thickness of the plane
        &#34;&#34;&#34;
        if sizex == 0.0:
                return
        bpy.ops.mesh.primitive_plane_add(size=sizex,enter_editmode=True,location=(0, 0, 0))
        bpy.context.object.name = name
        bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
        obj = bpy.data.objects.get(name)
        if sizey is not None and sizey != 0.0:
                t = sizey / sizex
                obj.scale = [1,t,1]
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        if normal is not None and base is not None:
                return
        if base is not None:
                if len(base) != 2:
                        return
                if isinstance(base[0],Vector):
                        v1 = base[0]
                else:
                        v1 = Vector(base[0])
                if isinstance(base[1],Vector):
                        v2 = base[1]
                else:
                        v2 = Vector(base[1])

                if self.base is None:
                        normal = v1.cross(v2)
                else:
                        u1 = v1[0]*self.base[0] + v1[1]*self.base[1] + v1[2]*self.base[2]
                        u2 = v2[0]*self.base[0] + v2[1]*self.base[1] + v2[2]*self.base[2]
                        normal = u1.cross(u2)
        if normal is not None and normal != Vector([0,0,0]):
                z = Vector([0,0,1])
                quaternion = z.rotation_difference(normal)
                obj.rotation_quaternion.rotate(quaternion)
                bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        obj.location = op
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
<div class="desc"><p>Draws a plane with normal vector or base vectors. It passes through the point self.origin.
Only normal or base can be not None</p>
<h2 id="parameters">Parameters</h2>
<p>normal: normal vector to the plane</p>
<p>base: list of two independent vectors</p>
<p>sizex: x-size of the plane</p>
<p>sizey: y-size of the plane</p>
<p>color: color of the plane</p>
<p>name: name of the plane</p>
<p>opacity: opacity of the plane</p>
<p>thickness: thickness of the plane</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_plane_surface"><code class="name flex">
<span>def <span class="ident">draw_plane_surface</span></span>(<span>self,<br>origin=None,<br>normal=None,<br>base=None,<br>sizex=10,<br>sizey=10,<br>vectors=False,<br>scalelines=0.05,<br>scalevector=0.03,<br>color='AzureBlueDark',<br>linecolor='BlueDarkDull',<br>vectorcolor='Black',<br>name='Plane',<br>opacity=1.0,<br>thickness=0.01)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_plane_surface(self,origin=None,normal=None,base=None,sizex=10,sizey=10,vectors=False,scalelines=0.05,scalevector=0.03,
                                        color=&#34;AzureBlueDark&#34;,linecolor=&#34;BlueDarkDull&#34;,vectorcolor=&#34;Black&#34;,name=&#34;Plane&#34;,opacity=1.0,thickness=0.01):
        &#34;&#34;&#34;
        Draws a plane with normal vector or base vectors. It passes through the point origin.
        Only normal or base can be not None
        Parameters:
           origin: a point in the plane

           normal: normal vector to the plane

           base: list of two independent vectors

           sizex: x-size of the plane

           sizey: y-size of the plane

           vectors: if True, draw the generators of the plane

           scalelines: scale of the lines limiting the plane

           scalevector: scale of the generators

           color: color of the plane

           linecolor: color of the lines limiting the plane

           vectorcolor: color of the generators

           name: name of the plane

           opacity: opacity of the plane

           thickness: thickness of the plane
        &#34;&#34;&#34;
        if normal is not None and base is not None:
                return
        if normal is None and base is None:
                return
        mat = Matrix(self.base)
        mat.transpose()
        if normal is not None:
                if not isinstance(normal,Vector):
                        normal= Vector(normal)
                normal = mat @ normal
        if base is not None:
                if len(base) != 2:
                        return
                if isinstance(base[0],Vector):
                        v1 = base[0]
                else:
                        v1 = Vector(base[0])
                if isinstance(base[1],Vector):
                        v2 = base[1]
                else:
                        v2 = Vector(base[1])
                v1 = mat @ v1
                v2 = mat @ v2
                normal = v1.cross(v2)

        if normal == Vector([0,0,0]):
                return

        steps = 4
        delta = sizex / steps
        x = - sizex / 2
        bm = bmesh.new()
        verts = []
        for k in range(steps + 1):
                verts.append(bm.verts.new((x,0,0)))
                x += delta
                if k == 0:
                        continue
                bm.edges.new([verts[k-1], verts[k]])

        me = self.meshes.new(&#39;PlaneSurfaceMesh&#39;)
        obj = self.objects.new(&#39;PlaneSurface&#39;, me)
        bm.to_mesh(me)
        bm.free()

        bpy.context.scene.collection.objects.link(obj)
        bpy.context.view_layer.objects.active = obj
        bpy.ops.object.mode_set(mode=&#39;EDIT&#39;)
        bpy.ops.mesh.select_mode(type=&#34;EDGE&#34;)
        bpy.ops.mesh.select_all(action=&#39;SELECT&#39;)
        bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={&#34;value&#34;:(0, sizey, 0),&#34;constraint_axis&#34;:(False, True, False),&#34;use_accurate&#34;:True})
        bpy.ops.mesh.select_all(action=&#39;DESELECT&#39;)
        bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)
        obj.select_set(True)
        bpy.ops.transform.translate(value=(0, -sizey/2, 0),constraint_axis=(False, True, False))
        bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;, center=&#39;MEDIAN&#39;)
        obj.select_set(False)

        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        if origin is not None:
                if isinstance(origin,Vector):
                        op = op + mat @ origin
                else:
                        op = op + mat @ Vector(origin)
        obj.location = o
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

        lines = None
        vecs = None
        s = 0.0
        nodes = [[1,1,0],[-1,1,0],[-1,-1,0],[1,-1,0]]
        nodes = [self.product_components(Vector([sizex / 2,sizey / 2,0]),Vector(x)) for x in nodes]
        edges = [[0,1],[1,2],[2,3],[3,0]]

        if scalelines &gt; 0.0:
                aux = self.origin
                self.origin = Vector([0,0,0])
                objects = []
                aux2 = self.base
                self.reset_base()
                for edge in edges:
                        l = self.draw_line(start=nodes[edge[0]],end=nodes[edge[1]],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                        objects.append(l)
                lines = self.join(objects)
                self.set_origin(aux)
                self.set_base(aux2)

        if lines is not None:
                obj = self.join([obj,lines])

        if vectors:
                vecs = self.draw_vectors(nodes,True,color=vectorcolor,scale=scalevector,head_height=0.1,name=&#34;Vectors&#34;,axis=0)

        if vecs is not None:
                obj = self.join([obj,vecs])
        obj.name = name

        if isinstance(normal,Vector):
                n = normal
        else:
                n = Vector(normal)
        z = Vector([0,0,1])
        quaternion = z.rotation_difference(n)
        tmp = obj.rotation_quaternion
        quaternion = tmp @ quaternion
        obj.rotation_quaternion = quaternion
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        obj.location = op
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
<div class="desc"><p>Draws a plane with normal vector or base vectors. It passes through the point origin.
Only normal or base can be not None</p>
<h2 id="parameters">Parameters</h2>
<p>origin: a point in the plane</p>
<p>normal: normal vector to the plane</p>
<p>base: list of two independent vectors</p>
<p>sizex: x-size of the plane</p>
<p>sizey: y-size of the plane</p>
<p>vectors: if True, draw the generators of the plane</p>
<p>scalelines: scale of the lines limiting the plane</p>
<p>scalevector: scale of the generators</p>
<p>color: color of the plane</p>
<p>linecolor: color of the lines limiting the plane</p>
<p>vectorcolor: color of the generators</p>
<p>name: name of the plane</p>
<p>opacity: opacity of the plane</p>
<p>thickness: thickness of the plane</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_point"><code class="name flex">
<span>def <span class="ident">draw_point</span></span>(<span>self, radius=0.1, location=(0, 0, 0), name='Point', color='Black', opacity=1.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_point(self,radius=0.1,location=(0,0,0),name=&#34;Point&#34;,color=&#34;Black&#34;,opacity=1.0):
        &#34;&#34;&#34;
        Draws a point (in the reference self.origin, self.base)
        Parameters:
           radius: radius of the point

           location: location of the point

           name: name of the point

           color: color of the point

           opacity: opacity of the point
        &#34;&#34;&#34;
        bpy.ops.mesh.primitive_uv_sphere_add(segments=8, ring_count=8, radius=radius, enter_editmode=False, location=location)
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)

        if not isinstance(location,Vector):
                location = Vector(location)
        mat = Matrix(self.base)
        mat.transpose()
        location = mat @ location

        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
        modifier.thickness = 0.1
        modifier.offset = 0.0
        c = Colors.color(color)
        op = Vector(self.origin)
        obj.location = op + location
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        bpy.ops.object.shade_smooth()
        obj.select_set(False)
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
<div class="desc"><p>Draws a point (in the reference self.origin, self.base)</p>
<h2 id="parameters">Parameters</h2>
<p>radius: radius of the point</p>
<p>location: location of the point</p>
<p>name: name of the point</p>
<p>color: color of the point</p>
<p>opacity: opacity of the point</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_points"><code class="name flex">
<span>def <span class="ident">draw_points</span></span>(<span>self, points=[], name='Points', color='Blue', opacity=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_points(self,points=[],name=&#39;Points&#39;,color=&#34;Blue&#34;,opacity=1):
        &#34;&#34;&#34;
        Draws a list of points
        Parameters:
           points: list of points

           name: name of the list of points

           color: color of the points

           opacity: opacity of the points
        &#34;&#34;&#34;
        bm = bmesh.new()
        verts = []
        for p in points:
                verts.append(bm.verts.new(p))

        me = self.meshes.new(&#39;PointsMesh&#39;)
        obj = self.objects.new(name, me)
        bm.to_mesh(me)
        bm.free()
        self.scene.collection.objects.link(obj)
        return obj</code></pre>
</details>
<div class="desc"><p>Draws a list of points</p>
<h2 id="parameters">Parameters</h2>
<p>points: list of points</p>
<p>name: name of the list of points</p>
<p>color: color of the points</p>
<p>opacity: opacity of the points</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_polygon"><code class="name flex">
<span>def <span class="ident">draw_polygon</span></span>(<span>self,<br>origin=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>points=[[0, 0], [1, 0], [0, 1]],<br>scalelines=0.075,<br>color='AzureBlueMedium',<br>linecolor='AzureBlueDark',<br>name='Polygon',<br>opacity=1.0,<br>thickness=0.0,<br>vectors=None,<br>scalevectors=0.01)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_polygon(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],points=[[0,0],[1,0],[0,1]],scalelines=0.075,color=&#34;AzureBlueMedium&#34;,linecolor=&#34;AzureBlueDark&#34;,name=&#39;Polygon&#39;,opacity=1.0,thickness=0.0,vectors=None,scalevectors=0.01):
        &#34;&#34;&#34;
        Draws a polygon
        Parameters:
           origin: base vertex of the polygon

           u1, u2: base vectors for the polygon

           points: list of coordinates of points. The coordinates are taken in the reference {origin; u1, u2}

           scalelines: scale of the edges of the polygon

           color: color of the polygon

           linecolor: color of the edges

           name: name of the polygon

           opacity: opacity of the polygon

           thickness: thickness of the polygon
        &#34;&#34;&#34;
        if len(points) &lt; 3:
                return
        op = Vector(self.origin)
        if isinstance(origin,Vector):
                op = op + origin
        else:
                op = op + Vector(origin)
        if not isinstance(u1,Vector):
                u1 = Vector(u1)
        if not isinstance(u2,Vector):
                u2 = Vector(u2)
        for i in range(len(points)):
                if not isinstance(points[i],Vector):
                        points[i] = Vector(points[i])

        mat = Matrix(self.base)
        mat.transpose()
        u1 = mat @ u1
        u2 = mat @ u2

        bpy.ops.curve.simple(Simple_Type=&#39;Polygon&#39;,Simple_sides=len(points),align=&#39;WORLD&#39;,location=(0, 0, 0))
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)
        bpy.ops.object.mode_set(mode=&#39;OBJECT&#39;)

        baricentre = Vector([0,0,0])
        verts = obj.data.splines[0].bezier_points
        for i in range(len(verts)):
                verts[i].co = op + points[i][0] * u1 + points[i][1] * u2
                baricentre += verts[i].co
        baricentre /= len(verts)

        for i in range(len(verts)):
                verts[i].co -= baricentre
        obj.location = baricentre

        obj.select_set(True)
        bpy.ops.object.convert(target=&#39;MESH&#39;)

        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

        ps = [op + points[i][0] * u1 + points[i][1] * u2 for i in range(len(points))]
        lines = None
        if scalelines &gt; 0.0:
                objects = []
                for i in range(len(points)):
                        l = self.draw_line(start=ps[i],end=ps[(i + 1) % len(points)],scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                        objects.append(l)
                lines = self.join(objects)

        if vectors is not None:
                old = self.origin
                self.set_origin(op)
                ps = [points[i][0] * u1 + points[i][1] * u2 for i in range(len(points))]
                vecs = self.draw_vectors(ps,color=vectors,scale=scalevectors)
                self.set_origin(old)


        if lines is not None:
                obj = self.join([obj,lines])
        if vectors is not None:
                obj = self.join([obj,vecs])

        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
<div class="desc"><p>Draws a polygon</p>
<h2 id="parameters">Parameters</h2>
<p>origin: base vertex of the polygon</p>
<p>u1, u2: base vectors for the polygon</p>
<p>points: list of coordinates of points. The coordinates are taken in the reference {origin; u1, u2}</p>
<p>scalelines: scale of the edges of the polygon</p>
<p>color: color of the polygon</p>
<p>linecolor: color of the edges</p>
<p>name: name of the polygon</p>
<p>opacity: opacity of the polygon</p>
<p>thickness: thickness of the polygon</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_pyramid"><code class="name flex">
<span>def <span class="ident">draw_pyramid</span></span>(<span>self,<br>origin=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>u3=[0.5, 0.5, 1],<br>scalelines=0.025,<br>color='AzureBlueDark',<br>linecolor='OrangeObscureDull',<br>name='Pyramid',<br>opacity=1.0,<br>thickness=0.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_pyramid(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],u3=[0.5,0.5,1],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Pyramid&#39;,opacity=1.0,thickness=0.0):
        &#34;&#34;&#34;
        Draws a pyramid
        Parameters:
           origin: base vertex of the pyramid

           u1, u2, u3: vectors that gives the edges

           scalelines: scale of the edges of the pyramid

           color: color of the pyramid

           linecolor: color of the edges

           name: name of the pyramid

           opacity: opacity of the pyramid

           thickness: thickness of the pyramid
        &#34;&#34;&#34;
        op = Vector(self.origin)
        if isinstance(origin,Vector):
                op = op + origin
        else:
                op = op + Vector(origin)
        if not isinstance(u1,Vector):
                u1 = Vector(u1)
        if not isinstance(u2,Vector):
                u2 = Vector(u2)
        if not isinstance(u3,Vector):
                u3 = Vector(u3)

        mat = Matrix(self.base)
        mat.transpose()
        u1 = mat @ u1
        u2 = mat @ u2
        u3 = mat @ u3

        bpy.ops.mesh.primitive_cone_add(radius1=1, radius2=0, depth=2, enter_editmode=False, align=&#39;WORLD&#39;,vertices=4)
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)

        verts = obj.data.vertices
        verts[0].co = op
        verts[1].co = op + u1
        verts[2].co = op + u1 + u2
        verts[3].co = op + u2
        verts[4].co = op + u3

        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 0.0

        lines = None
        s = 0.0
        edges =[[0,1],[0,3],[0,4],[1,2],[1,4],[2,3],[2,4],[3,4]]
        if scalelines &gt; 0.0:
                objects = []
                for edge in edges:
                        l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                        objects.append(l)
                lines = self.join(objects)

        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

        if lines is not None:
                obj = self.join([obj,lines])

        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None

        return obj</code></pre>
</details>
<div class="desc"><p>Draws a pyramid</p>
<h2 id="parameters">Parameters</h2>
<p>origin: base vertex of the pyramid</p>
<p>u1, u2, u3: vectors that gives the edges</p>
<p>scalelines: scale of the edges of the pyramid</p>
<p>color: color of the pyramid</p>
<p>linecolor: color of the edges</p>
<p>name: name of the pyramid</p>
<p>opacity: opacity of the pyramid</p>
<p>thickness: thickness of the pyramid</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_regular_polygon"><code class="name flex">
<span>def <span class="ident">draw_regular_polygon</span></span>(<span>self,<br>origin=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>vertexs=5,<br>radius=1,<br>scalelines=0.075,<br>color='AzureBlueDark',<br>linecolor='OrangeObscureDull',<br>name='RegularPolygon',<br>opacity=1.0,<br>thickness=0.0,<br>vectors=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_regular_polygon(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],vertexs=5,radius=1,scalelines=0.075,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;RegularPolygon&#39;,opacity=1.0,thickness=0.0,vectors=None):
        &#34;&#34;&#34;
        Draws a regular polygon
        Parameters:
           origin: base vertex of the polygon

           u1, u2: base vectors for the polygon

           vertexs: number of vertices of the polygon

           radius: radius of the polygon

           scalelines: scale of the edges of the polygon

           color: color of the polygon

           linecolor: color of the edges

           name: name of the polygon

           opacity: opacity of the polygon

           thickness: thickness of the polygon
        &#34;&#34;&#34;
        angle = 2*math.pi/vertexs
        points = [[radius*math.cos(i*angle),radius*math.sin(i*angle)] for i in range(vertexs)]
        return self.draw_polygon(origin=origin,u1=u1,u2=u2,points=points,scalelines=scalelines,color=color,linecolor=linecolor,name=name,opacity=opacity,thickness=thickness,vectors=vectors,scalevectors=radius/400)</code></pre>
</details>
<div class="desc"><p>Draws a regular polygon</p>
<h2 id="parameters">Parameters</h2>
<p>origin: base vertex of the polygon</p>
<p>u1, u2: base vectors for the polygon</p>
<p>vertexs: number of vertices of the polygon</p>
<p>radius: radius of the polygon</p>
<p>scalelines: scale of the edges of the polygon</p>
<p>color: color of the polygon</p>
<p>linecolor: color of the edges</p>
<p>name: name of the polygon</p>
<p>opacity: opacity of the polygon</p>
<p>thickness: thickness of the polygon</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_simple_curve"><code class="name flex">
<span>def <span class="ident">draw_simple_curve</span></span>(<span>self, fun=None, tmin=0.0, tmax=1.0, steps=25, thickness=0.02, color='White', name='Curve')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_simple_curve(self,fun=None,tmin=0.0,tmax=1.0,steps=25,thickness=0.02,color=&#34;White&#34;,name=&#34;Curve&#34;):
        &#34;&#34;&#34;
        Draws a parametric curve
        Parameters:
           fun: the parametric function

           tmin: minimum value of the parameter

           tmax: maximum value of the parameter

           steps: number of steps

           thickness: thickness of the curve

           color: color of the curve

           name: name of the curve
        &#34;&#34;&#34;
        if fun is None:
                return None
        delta = (tmax - tmin) / steps
        t = tmin

        curve = bpy.data.curves.new(&#39;myCurve&#39;, type=&#39;CURVE&#39;)
        curve.dimensions = &#39;3D&#39;
        curve.resolution_u = 2

        line = curve.splines.new(&#39;POLY&#39;)
        line.points.add(steps)

        for i in range(steps+1):
                p = fun(t)
                p.append(1)
                line.points[i].co = p
                t += delta

        obj = bpy.data.objects.new(name, curve)
        curve.bevel_depth = thickness

        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
        self.scene.collection.objects.link(obj)
        return obj</code></pre>
</details>
<div class="desc"><p>Draws a parametric curve</p>
<h2 id="parameters">Parameters</h2>
<p>fun: the parametric function</p>
<p>tmin: minimum value of the parameter</p>
<p>tmax: maximum value of the parameter</p>
<p>steps: number of steps</p>
<p>thickness: thickness of the curve</p>
<p>color: color of the curve</p>
<p>name: name of the curve</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_surface"><code class="name flex">
<span>def <span class="ident">draw_surface</span></span>(<span>self,<br>eq=None,<br>umin=-1,<br>umax=1,<br>usteps=64,<br>vmin=-1,<br>vmax=1,<br>vsteps=64,<br>thickness=0.02,<br>opacity=1.0,<br>pmax=10,<br>name='Surface',<br>color='AzureBlueDark',<br>axis=False,<br>o=Vector((0.0, 0.0, 0.0)),<br>u1=Vector((1.0, 0.0, 0.0)),<br>u2=Vector((0.0, 1.0, 0.0)),<br>wrap_u=False,<br>wrap_v=False,<br>close_v=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_surface(self,eq=None,umin=-1,umax=1,usteps=64,vmin=-1,vmax=1,vsteps=64,thickness=0.02,opacity=1.0,pmax=10,name=&#34;Surface&#34;,color=&#34;AzureBlueDark&#34;,axis=False,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),wrap_u=False,wrap_v=False,close_v=False):
        &#34;&#34;&#34;
        Draws a parametric surface in the reference R&#39;
        Parameters:
           eq: parametric equacion f(u,v)

           umin: minimum value of u

           umax: maximum value of u

           usteps: steps in the u direction

           vmin: minimum value of v

           vmax: maximum value of v

           vsteps: steps in the v direction

           thickness: thickness of the surface

           opacity: opacity of the surface

           color: color of the surface

           pmax: the principal axis are drawn between -cmax and cmax

           name: name of the surface

           color: color of the surface

           axis: if True draw the axis of the reference {o, v1, v2, v3}

           o: origin of the reference R&#39;

           u1, u2: vectors to construct the basis {v1, v2, v3}

           scale: scale coefficients

           wrap_u: wrap the u coordinate

           wrap_v: wrap the u coordinate

           close_v: close the v coordinate
        &#34;&#34;&#34;
        if eq is None:
                return

        q = self.vectors_to_quaternion(u1,u2)
        draw_parametric_surface(eq=eq,range_u_min=umin,range_u_max=umax,range_u_step=usteps,range_v_min=vmin,range_v_max=vmax,range_v_step=vsteps,name=name,wrap_u=wrap_u,wrap_v=wrap_v,close_v=close_v)

        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)
        obj.show_wire = False

        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if self.rotation is not None:
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        if axis:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència escollida&#34;)

        bpy.ops.object.shade_smooth()
        obj.location = o
        obj.select_set(False)
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
<div class="desc"><p>Draws a parametric surface in the reference R'</p>
<h2 id="parameters">Parameters</h2>
<p>eq: parametric equacion f(u,v)</p>
<p>umin: minimum value of u</p>
<p>umax: maximum value of u</p>
<p>usteps: steps in the u direction</p>
<p>vmin: minimum value of v</p>
<p>vmax: maximum value of v</p>
<p>vsteps: steps in the v direction</p>
<p>thickness: thickness of the surface</p>
<p>opacity: opacity of the surface</p>
<p>color: color of the surface</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>name: name of the surface</p>
<p>color: color of the surface</p>
<p>axis: if True draw the axis of the reference {o, v1, v2, v3}</p>
<p>o: origin of the reference R'</p>
<p>u1, u2: vectors to construct the basis {v1, v2, v3}</p>
<p>scale: scale coefficients</p>
<p>wrap_u: wrap the u coordinate</p>
<p>wrap_v: wrap the u coordinate</p>
<p>close_v: close the v coordinate</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_tetrahedron"><code class="name flex">
<span>def <span class="ident">draw_tetrahedron</span></span>(<span>self,<br>origin=[0, 0, 0],<br>u1=[2, 0, 0],<br>u2=[1.0000000000000002, 1.7320508075688772, 0],<br>u3=[1.0, 0.5773502691896257, 2],<br>scalelines=0.025,<br>color='AzureBlueDark',<br>linecolor='OrangeObscureDull',<br>name='Tetrahedron',<br>opacity=1.0,<br>thickness=0.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_tetrahedron(self,origin=[0,0,0],u1=[2,0,0],u2=[2*math.cos(math.pi/3),2*math.sin(math.pi/3),0],u3=[(2+2*math.cos(math.pi/3))/3,2*math.sin(math.pi/3)/3,2],scalelines=0.025,color=&#34;AzureBlueDark&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#39;Tetrahedron&#39;,opacity=1.0,thickness=0.0):
        &#34;&#34;&#34;
        Draws a tetrahedron
        Parameters:
           origin: base vertex of the tetrahedron

           u1, u2, u3: vectors that gives the edges

           scalelines: scale of the edges of the tetrahedron

           color: color of the tetrahedron

           linecolor: color of the edges

           name: name of the tetrahedron

           opacity: opacity of the tetrahedron

           thickness: thickness of the tetrahedron
        &#34;&#34;&#34;
        op = Vector(self.origin)
        if isinstance(origin,Vector):
                op = op + origin
        else:
                op = op + Vector(origin)
        if not isinstance(u1,Vector):
                u1 = Vector(u1)
        if not isinstance(u2,Vector):
                u2 = Vector(u2)
        if not isinstance(u3,Vector):
                u3 = Vector(u3)

        mat = Matrix(self.base)
        mat.transpose()
        u1 = mat @ u1
        u2 = mat @ u2
        u3 = mat @ u3

        bpy.ops.mesh.primitive_solid_add()
        bpy.context.object.name = name
        obj = bpy.data.objects.get(name)

        verts = obj.data.vertices
        verts[0].co = op + u3
        verts[1].co = op
        verts[2].co = op + u1
        verts[3].co = op + u2

        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 0.0

        lines = None
        s = 0.0
        edges =[[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]]
        if scalelines &gt; 0.0:
                objects = []
                for edge in edges:
                        l = self.draw_line(start=verts[edge[0]].co,end=verts[edge[1]].co,scale=scalelines,name=&#34;Lines&#34;,color=linecolor)
                        objects.append(l)
                lines = self.join(objects)

        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)

        if lines is not None:
                obj = self.join([obj,lines])

        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        bpy.ops.object.shade_smooth()
        bpy.context.view_layer.objects.active = None

        return obj</code></pre>
</details>
<div class="desc"><p>Draws a tetrahedron</p>
<h2 id="parameters">Parameters</h2>
<p>origin: base vertex of the tetrahedron</p>
<p>u1, u2, u3: vectors that gives the edges</p>
<p>scalelines: scale of the edges of the tetrahedron</p>
<p>color: color of the tetrahedron</p>
<p>linecolor: color of the edges</p>
<p>name: name of the tetrahedron</p>
<p>opacity: opacity of the tetrahedron</p>
<p>thickness: thickness of the tetrahedron</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_triangle"><code class="name flex">
<span>def <span class="ident">draw_triangle</span></span>(<span>self,<br>origin=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>points=[[0, 0], [1, 0], [0, 1]],<br>scalelines=0.075,<br>color='AzureBlueMedium',<br>linecolor='OrangeObscureDull',<br>name='Triangle',<br>opacity=1.0,<br>thickness=0.01)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_triangle(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],points=[[0,0],[1,0],[0,1]],scalelines=0.075,color=&#34;AzureBlueMedium&#34;,linecolor=&#34;OrangeObscureDull&#34;,name=&#34;Triangle&#34;,opacity=1.0,thickness=0.01):
        &#34;&#34;&#34;
        Draws a triangle. It&#39;s a polygon with three vertices
        Parameters:
           origin: base vertex of the triangle

           u1, u2: base vectors for the triangle

           points: list of coordinates of points. The coordinates are taken in the reference {origin; u1, u2}

           scalelines: scale of the edges of the triangle

           color: color of the triangle

           linecolor: color of the edges

           name: name of the triangle

           opacity: opacity of the triangle

           thickness: thickness of the triangle
        &#34;&#34;&#34;
        if len(points) != 3:
                return
        self.draw_polygon(origin=origin,u1=u1,u2=u2,points=points,scalelines=scalelines,color=color,linecolor=linecolor,name=name,opacity=opacity,thickness=thickness)</code></pre>
</details>
<div class="desc"><p>Draws a triangle. It's a polygon with three vertices</p>
<h2 id="parameters">Parameters</h2>
<p>origin: base vertex of the triangle</p>
<p>u1, u2: base vectors for the triangle</p>
<p>points: list of coordinates of points. The coordinates are taken in the reference {origin; u1, u2}</p>
<p>scalelines: scale of the edges of the triangle</p>
<p>color: color of the triangle</p>
<p>linecolor: color of the edges</p>
<p>name: name of the triangle</p>
<p>opacity: opacity of the triangle</p>
<p>thickness: thickness of the triangle</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_two_sheets_hyperboloid"><code class="name flex">
<span>def <span class="ident">draw_two_sheets_hyperboloid</span></span>(<span>self,<br>a=2.0,<br>b=1.0,<br>xmin=0.0,<br>xmax=5.0,<br>steps=50,<br>scale=[1, 1, 1],<br>color='AzureBlueDark',<br>name='HyperboloidTwoSheets',<br>opacity=1.0,<br>thickness=0.05)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_two_sheets_hyperboloid(self,a=2.0,b=1.0,xmin=0.0,xmax=5.0,steps=50,scale=[1,1,1],color=&#34;AzureBlueDark&#34;,name=&#34;HyperboloidTwoSheets&#34;,opacity=1.0,thickness=0.05):
        r&#34;&#34;&#34;
        Draws a two sheet hyperboloid from the hyperbole z = \pm a * math.sqrt(x**2+b) in the XZ plane
        Parameters:
           a, b: coefficients of the hyperbole

           xmin: minimum value of x

           xmax: maximum value of x

           steps: numbers of steps to draw the parabola

           scale: scaling factors in the X, Y and Z directions

           color: color of the surface

           name: name of the surface

           opacity: opacity of the surface

           thickness: thickness of the surface
        &#34;&#34;&#34;
        delta = (xmax - xmin) / steps
        x = xmax
        bm = bmesh.new()
        verts = []
        count = 2 * steps + 2
        sign = 1
        for k in range(count):
                if k == steps + 1:
                        sign = -1
                z = sign * a * math.sqrt(x**2+b)
                verts.append(bm.verts.new((x,0,z)))
                if k == steps and xmin &gt; 0:
                        x = xmin
                else:
                        x = x - sign * delta
                if k == 0 or k == steps + 1:
                        continue
                bm.edges.new([verts[k-1], verts[k]])

        me = self.meshes.new(&#39;placeholder_mesh&#39;)
        obj = self.objects.new(name,me)
        bm.to_mesh(me)
        bm.free()

        modifier = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
        modifier.angle = 2 * math.pi
        modifier.steps = 128
        modifier = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        modifier.levels = 4
        modifier.subdivision_type = &#39;SIMPLE&#39;
        if thickness &gt; 0.0:
                modifier = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
                modifier.thickness = thickness
                modifier.offset = 1.0
        c = Colors.color(color)
        if self.defaultcolor is not None:
                c = Colors.color(self.defaultcolor)
        o = Vector([0,0,0])
        op = Vector(self.origin)
        obj.location = o
        obj.scale = scale
        obj.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        self.add_material(obj,c.name,c.r,c.g,c.b,opacity)
        obj.location = op
        bpy.ops.object.shade_smooth()
        self.scene.collection.objects.link(obj)
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
<div class="desc"><p>Draws a two sheet hyperboloid from the hyperbole z = \pm a * math.sqrt(x**2+b) in the XZ plane</p>
<h2 id="parameters">Parameters</h2>
<p>a, b: coefficients of the hyperbole</p>
<p>xmin: minimum value of x</p>
<p>xmax: maximum value of x</p>
<p>steps: numbers of steps to draw the parabola</p>
<p>scale: scaling factors in the X, Y and Z directions</p>
<p>color: color of the surface</p>
<p>name: name of the surface</p>
<p>opacity: opacity of the surface</p>
<p>thickness: thickness of the surface</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_vector"><code class="name flex">
<span>def <span class="ident">draw_vector</span></span>(<span>self,<br>origin=Vector((0.0, 0.0, 0.0)),<br>vector=None,<br>canonica=False,<br>color='Black',<br>scale=0.05,<br>arrow=True,<br>head_height=None,<br>axis=0,<br>name='Vector',<br>positive=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_vector(self,origin=Vector([0,0,0]),vector=None,canonica=False,color=&#34;Black&#34;,scale=0.05,arrow=True,head_height=None,axis=0,name=&#34;Vector&#34;,positive=True):
        &#34;&#34;&#34;
        Draw the vector with components &#39;vector&#39; trough &#39;origin&#39;
        Parameters:

           origin: point of the line

           vector: components of the vector

           canonica: if True, the components are in the canonical basis, else they are in the basis self.base. Finally,
              self.rotation is applied

           color: color of the vector

           scale: scale of the cylinder

           arrow: if True draws the vector itself

           head_height: height of the head of the vector

           head_scale: scale of the head of the vector

           axis: if not zero, draw also the line generated by the vector

           positive: if axis is not zero and positive is True, draw only the positive part of the line
              generated by the vector
        &#34;&#34;&#34;
        if vector is None:
                return None
        if isinstance(vector,Vector):
                vec = vector
        else:
                vec = Vector(vector)
        if isinstance(origin,Vector):
                orig = origin
        else:
                orig = Vector(origin)
        if vec.length == 0:
                return None
        self.base_cilinder()
        self.base_cone()
        o = Vector([0,0,0])
        op = Vector(self.origin + orig)
        if color is not None:
                color = Colors.color(color)
        v = vec
        if not canonica:
                mat = Matrix(self.base)
                mat.transpose()
                v = mat @ vec

        lon =  (v - o).length
        if head_height is None:
                head_height = 0.03*lon
        if head_height &gt; 0.25:
                head_height = 0.25

        if arrow:
                t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                obj = t.copy()
                obj.name = name
                obj.data = obj.data.copy()
                obj.location = o
                obj.scale = (scale,scale,lon - 2 * head_height)
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                if color is not None:
                        self.add_material(obj,color.name,color.r,color.g,color.b)
                if self.rotation is not None:
                        obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location = op
                self.scene.collection.objects.link(obj)

                t = bpy.data.objects.get(&#34;Arrow_cone&#34;)
                obj2 = t.copy()
                obj2.data = obj2.data.copy()
                obj2.name = &#34;Arrow&#34;
                obj2.location =  v - 2 * head_height * v / v.length
                obj2.scale = (1.5*scale,1.5*scale,head_height)
                obj2.rotation_mode = &#39;QUATERNION&#39;
                obj2.rotation_quaternion = (v - o).to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                if color is not None:
                        self.add_material(obj2,color.name,color.r,color.g,color.b)
                if self.rotation is not None:
                        obj2.rotation_quaternion.rotate(self.rotation.quaternion)
                        obj2.location.rotate(self.rotation.quaternion)
                obj2.location = op + obj2.location
                self.scene.collection.objects.link(obj2)

        obj3 = None
        if axis != 0:
                v = axis * v / v.length
                t = bpy.data.objects.get(&#34;Arrow_stem&#34;)
                obj3 = t.copy()
                if not arrow:
                        obj3.name = name
                else:
                        obj3.name = &#34;Generated&#34;
                obj3.data = obj3.data.copy()
                obj3.scale = (scale / 2,scale / 2,(2 * v).length)
                obj3.rotation_mode = &#39;QUATERNION&#39;
                obj3.rotation_quaternion = v.to_track_quat(&#39;Z&#39;,&#39;Y&#39;)
                if color is not None:
                        self.add_material(obj3,color.name,color.r,color.g,color.b)
                if self.rotation is not None:
                        obj3.rotation_quaternion.rotate(self.rotation.quaternion)
                if positive:
                        obj3.location = op
                else:
                        obj3.location = op - v
                self.scene.collection.objects.link(obj3)

        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        if arrow:
                bpy.context.view_layer.objects.active = obj
        elif axis != 0:
                bpy.context.view_layer.objects.active = obj3
        if arrow:
                obj.select_set(True)
                obj2.select_set(True)
        if obj3 is not None:
                obj3.select_set(True)
        if arrow:
                bpy.ops.object.join()
        bpy.ops.object.shade_smooth()
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        self.delete_base_cilinder()
        self.delete_base_cone()
        bpy.context.view_layer.objects.active = None
        if arrow:
                return obj
        if axis != 0:
                return obj3
        self.set_origin()
        return None</code></pre>
</details>
<div class="desc"><p>Draw the vector with components 'vector' trough 'origin'</p>
<h2 id="parameters">Parameters</h2>
<p>origin: point of the line</p>
<p>vector: components of the vector</p>
<p>canonica: if True, the components are in the canonical basis, else they are in the basis self.base. Finally,
self.rotation is applied</p>
<p>color: color of the vector</p>
<p>scale: scale of the cylinder</p>
<p>arrow: if True draws the vector itself</p>
<p>head_height: height of the head of the vector</p>
<p>head_scale: scale of the head of the vector</p>
<p>axis: if not zero, draw also the line generated by the vector</p>
<p>positive: if axis is not zero and positive is True, draw only the positive part of the line
generated by the vector</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_vector_field"><code class="name flex">
<span>def <span class="ident">draw_vector_field</span></span>(<span>self,<br>f=None,<br>xmin=-3,<br>xmax=3,<br>xsteps=8,<br>ymin=-3,<br>ymax=3,<br>ysteps=8,<br>zmin=-3,<br>zmax=3,<br>zsteps=8,<br>name='Vector Field',<br>color='Red',<br>scale=0.02,<br>head_height=0.05)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_vector_field(self,f=None,xmin=-3,xmax=3,xsteps=8,ymin=-3,ymax=3,ysteps=8,zmin=-3,zmax=3,zsteps=8,name=&#34;Vector Field&#34;,color=&#34;Red&#34;,scale=0.02,head_height=0.05):
        &#34;&#34;&#34;
        Draws a vector field
        Parameters:
           f: the vector field

           xmin: minimum value of x

           xmax: maximum value of x

           xsteps: steps in the x direction

           ymin: minimum value of y

           ymax: maximum value of y

           ysteps: steps in the y direction

           zmin: minimum value of z

           zmax: maximum value of z

           zsteps: steps in the z direction

           name: name of the vector field

           color: color of the vector field

           scale: scale of the vectors

           head_height: head height of the vectors
        &#34;&#34;&#34;
        if f is None:
                return None
        xstep = (xmax - xmin)/xsteps
        ystep = (ymax - ymin)/ysteps
        zstep = (zmax - zmin)/zsteps
        if xstep == 0 or ystep == 0 or zstep == 0:
                return None
        vectors = []
        count = 1
        x = xmin
        while x &lt;= xmax:
                y = ymin
                while y &lt;= ymax:
                        z = zmin
                        while z &lt;= zmax:
                                o = Vector([x,y,z])
                                v = f(x,y,z)
                                if not isinstance(v,Vector):
                                        v = Vector(v)
                                self.set_origin(o)
                                vec = self.draw_vector(vector=v,color=color,name=f&#34;Vector{count}&#34;,scale=scale,head_height=head_height)
                                if vec is not None:
                                        vectors.append(vec)
                                z += zstep
                                count += 1
                        y += ystep
                x += xstep
        v = self.join(vectors)
        bpy.context.object.name = name
        return v</code></pre>
</details>
<div class="desc"><p>Draws a vector field</p>
<h2 id="parameters">Parameters</h2>
<p>f: the vector field</p>
<p>xmin: minimum value of x</p>
<p>xmax: maximum value of x</p>
<p>xsteps: steps in the x direction</p>
<p>ymin: minimum value of y</p>
<p>ymax: maximum value of y</p>
<p>ysteps: steps in the y direction</p>
<p>zmin: minimum value of z</p>
<p>zmax: maximum value of z</p>
<p>zsteps: steps in the z direction</p>
<p>name: name of the vector field</p>
<p>color: color of the vector field</p>
<p>scale: scale of the vectors</p>
<p>head_height: head height of the vectors</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.draw_vectors"><code class="name flex">
<span>def <span class="ident">draw_vectors</span></span>(<span>self,<br>vectors=[],<br>canonica=False,<br>color='Black',<br>scale=0.05,<br>head_height=0.2,<br>name='Vectors',<br>axis=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_vectors(self,vectors=[],canonica=False,color=&#34;Black&#34;,scale=0.05,head_height=0.2,name=&#34;Vectors&#34;,axis=0):
        &#34;&#34;&#34;
        Draws a list of vectors.
        Parameters:
           vectors: list of vectors

           canonica: if True, the the vectors are expressed in the canonical basis.

           color: color of the vectors

           scale: scale of the cylinder

           head_height: height of the head of the vector

           axis: if not zero, draw also the line generated by every vector
        &#34;&#34;&#34;
        if len(vectors) == 0:
                return
        count = 0
        for v in vectors:
                if count == 0:
                        this = name
                else:
                        this = f&#34;Vector{count}&#34;
                count += 1
                t = self.draw_vector(vector=v,canonica=canonica,color=color,scale=scale,head_height=head_height,axis=axis,name=this)
        t = bpy.data.objects.get(name)
        list = [t]
        for count in range(1,len(vectors)+1):
                obj = bpy.data.objects.get(f&#34;Vector{count}&#34;)
                if obj is not None:
                        list.append(obj)
        t = self.join(list)
        return t</code></pre>
</details>
<div class="desc"><p>Draws a list of vectors.</p>
<h2 id="parameters">Parameters</h2>
<p>vectors: list of vectors</p>
<p>canonica: if True, the the vectors are expressed in the canonical basis.</p>
<p>color: color of the vectors</p>
<p>scale: scale of the cylinder</p>
<p>head_height: height of the head of the vector</p>
<p>axis: if not zero, draw also the line generated by every vector</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.ellipse"><code class="name flex">
<span>def <span class="ident">ellipse</span></span>(<span>self, center=Vector((0.0, 0.0, 0.0)), a=8, b=5, canonica=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ellipse(self,center=Vector([0,0,0]),a=8,b=5,canonica=True):
        &#34;&#34;&#34;
        Draws the ellipse of equation (x-x0)^2/a^2 + (y-y0)^2/b^2 == 1
        Parameters:
                centre: center of the ellipse

                a, b: semiaxis of the ellipse

                canonica: if True, draws the x and y axis
        &#34;&#34;&#34;
        if len(center) == 2:
                center = (center[0],center[1],0)
        if not isinstance(center,Vector):
                center = Vector(center)
        if a &gt;= b:
                c = math.sqrt(a**2 - b**2)
                f1 = Vector([c,0,0])
                f2 = Vector([-c,0,0])
        else:
                c = math.sqrt(b**2 - a**2)
                f1 = Vector([0,c,0])
                f2 = Vector([0,-c,0])
        if canonica:
                self.referencia_canonica(zaxis=False)
        self.draw_ellipse(center=center,a=a,b=b,thickness=0.02,steps=128,axis=False)
        self.draw_point(radius=0.167,location=(0,0,0),name=&#34;Centre&#34;,color=&#34;White&#34;)
        self.draw_point(radius=0.167,location=f1,name=&#34;F1&#34;,color=&#34;Black&#34;)
        self.draw_point(radius=0.167,location=f2,name=&#34;F2&#34;,color=&#34;Black&#34;)
        self.set_origin()</code></pre>
</details>
<div class="desc"><p>Draws the ellipse of equation (x-x0)^2/a^2 + (y-y0)^2/b^2 == 1</p>
<h2 id="parameters">Parameters</h2>
<p>centre: center of the ellipse</p>
<p>a, b: semiaxis of the ellipse</p>
<p>canonica: if True, draws the x and y axis</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.ellipsoid"><code class="name flex">
<span>def <span class="ident">ellipsoid</span></span>(<span>self,<br>o=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>a2=1,<br>b2=1,<br>c2=1,<br>principal=True,<br>canonica=True,<br>color='AzureBlueDark',<br>name='Ellipsoid',<br>cmax=15,<br>pmax=15,<br>thickness=0.02,<br>opacity=1.0,<br>preserve=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ellipsoid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Ellipsoid&#34;,cmax=15,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
        &#34;&#34;&#34;
        Draws an ellipsoid
        Parameters:
           o: center of the ellipsoid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
               v1 = u1
                   v2 = u2 - u2.project(v1)
                   v1.normalize()
                   v2.normalize()
                   v3 = v1.cross(v2)

           a2, b2, c2: squares of semi-axes of the ellipsoid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 + z&#39;^2/c^2 = 1

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the ellipsoid

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -pmax and pmax

           thickness: thickness of the ellipsoid

           opacity: opaccity of the ellipsoid

           preserve: Keep self.origin and self.base as the principal reference
        &#34;&#34;&#34;
        axis1 = None
        axis2 = None
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                axis2 = self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        c = math.sqrt(c2)
        el = self.draw_ellipsoid(radius=1,scale=[a,b,c],color=color,name=name,thickness=thickness,opacity=opacity)
        if not preserve:
                self.set_origin()
                self.set_base()
                self.set_rotation()
        return axis1, axis2, el</code></pre>
</details>
<div class="desc"><p>Draws an ellipsoid</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the ellipsoid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
v1 = u1
v2 = u2 - u2.project(v1)
v1.normalize()
v2.normalize()
v3 = v1.cross(v2)</p>
<p>a2, b2, c2: squares of semi-axes of the ellipsoid. The equation is x'^2/a^2 + y'^2/b^2 + z'^2/c^2 = 1</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the ellipsoid</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -pmax and pmax</p>
<p>thickness: thickness of the ellipsoid</p>
<p>opacity: opaccity of the ellipsoid</p>
<p>preserve: Keep self.origin and self.base as the principal reference</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.ellipsoide"><code class="name flex">
<span>def <span class="ident">ellipsoide</span></span>(<span>self,<br>o=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>a2=1,<br>b2=1,<br>c2=1,<br>principal=True,<br>canonica=True,<br>color='AzureBlueDark',<br>name='Ellipsoid',<br>cmax=15,<br>pmax=15,<br>thickness=0.02,<br>opacity=1.0,<br>preserve=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ellipsoid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Ellipsoid&#34;,cmax=15,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
        &#34;&#34;&#34;
        Draws an ellipsoid
        Parameters:
           o: center of the ellipsoid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
               v1 = u1
                   v2 = u2 - u2.project(v1)
                   v1.normalize()
                   v2.normalize()
                   v3 = v1.cross(v2)

           a2, b2, c2: squares of semi-axes of the ellipsoid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 + z&#39;^2/c^2 = 1

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the ellipsoid

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -pmax and pmax

           thickness: thickness of the ellipsoid

           opacity: opaccity of the ellipsoid

           preserve: Keep self.origin and self.base as the principal reference
        &#34;&#34;&#34;
        axis1 = None
        axis2 = None
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                axis2 = self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        c = math.sqrt(c2)
        el = self.draw_ellipsoid(radius=1,scale=[a,b,c],color=color,name=name,thickness=thickness,opacity=opacity)
        if not preserve:
                self.set_origin()
                self.set_base()
                self.set_rotation()
        return axis1, axis2, el</code></pre>
</details>
<div class="desc"><p>Draws an ellipsoid</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the ellipsoid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
v1 = u1
v2 = u2 - u2.project(v1)
v1.normalize()
v2.normalize()
v3 = v1.cross(v2)</p>
<p>a2, b2, c2: squares of semi-axes of the ellipsoid. The equation is x'^2/a^2 + y'^2/b^2 + z'^2/c^2 = 1</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the ellipsoid</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -pmax and pmax</p>
<p>thickness: thickness of the ellipsoid</p>
<p>opacity: opaccity of the ellipsoid</p>
<p>preserve: Keep self.origin and self.base as the principal reference</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.ellipsoide_revolucio"><code class="name flex">
<span>def <span class="ident">ellipsoide_revolucio</span></span>(<span>self, a=12, b=8, direccio='Z', punt=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ellipsoide_revolucio(self,a=12,b=8,direccio=&#39;Z&#39;,punt=None):
        &#34;&#34;&#34;
        Draws an animation showing an ellipsoid of revolution
                a, b: semiaxis of the initial ellipse

                direccio: &#39;X&#39;, the initial ellipse is in the plane XZ and rotates around the X axis
                                  &#39;Y&#39;, the initial ellipse is in the plane YZ and rotates around the Y axis
                                  &#39;Z&#39;, the initial ellipse is in the plane ZX and rotates around the Z axis

                punt: if it&#39;s a value between 0 and pi, the animation shows a rotating point
        &#34;&#34;&#34;
        if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                F = lambda t: (a*math.cos(t),0,b*math.sin(t))
        elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                F = lambda t: (0,a*math.cos(t),b*math.sin(t))
        else:
                F = lambda t: (b*math.sin(t),0,a*math.cos(t))
        self.base_canonica()
        self.animate_revolution_surface(F,tmin=0,tmax=math.pi,steps=128,axis=direccio,point=punt)</code></pre>
</details>
<div class="desc"><p>Draws an animation showing an ellipsoid of revolution
a, b: semiaxis of the initial ellipse</p>
<pre><code>    direccio: 'X', the initial ellipse is in the plane XZ and rotates around the X axis
                      'Y', the initial ellipse is in the plane YZ and rotates around the Y axis
                      'Z', the initial ellipse is in the plane ZX and rotates around the Z axis

    punt: if it's a value between 0 and pi, the animation shows a rotating point
</code></pre></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.elliptic_cylinder"><code class="name flex">
<span>def <span class="ident">elliptic_cylinder</span></span>(<span>self,<br>o=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>a2=1,<br>b2=1,<br>principal=True,<br>canonica=True,<br>color='AzureBlueDark',<br>name='EllipticCylinder',<br>zmax=20,<br>cmax=20,<br>pmax=15,<br>thickness=0.02,<br>opacity=1.0,<br>preserve=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def elliptic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;EllipticCylinder&#34;,zmax=20,cmax=20,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
        &#34;&#34;&#34;
        Draws an elliptic cylinder
        Parameters:
           o: center of the elliptic cylinder

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2: squares of semi-axes of the elliptic cylinder. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 = 1

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the elliptic cylinder

           zmax: the elliptic cylinder is drawn between -zmax and zmax

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the elliptic cylinder

           opacity: opacity of the elliptic cylinder

           preserve: Keep self.origin and self.base as the principal reference
        &#34;&#34;&#34;
        axis1 = None
        axis2 = None
        if cmax &lt; zmax + 2:
                cmax = zmax + 2
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                axis2 = self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        el = self.draw_elliptic_cylinder(a=1.0,b=1.0,length=2*zmax,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)
        if not preserve:
                self.set_origin()
                self.set_base()
                self.set_rotation()
        return axis1, axis2, el</code></pre>
</details>
<div class="desc"><p>Draws an elliptic cylinder</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the elliptic cylinder</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2: squares of semi-axes of the elliptic cylinder. The equation is x'^2/a^2 + y'^2/b^2 = 1</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the elliptic cylinder</p>
<p>zmax: the elliptic cylinder is drawn between -zmax and zmax</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the elliptic cylinder</p>
<p>opacity: opacity of the elliptic cylinder</p>
<p>preserve: Keep self.origin and self.base as the principal reference</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.elliptic_paraboloid"><code class="name flex">
<span>def <span class="ident">elliptic_paraboloid</span></span>(<span>self,<br>o=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>a2=1,<br>b2=1,<br>principal=True,<br>canonica=True,<br>color='AzureBlueDark',<br>name='EllipticParaboloid',<br>xmax=None,<br>cmax=15,<br>pmax=15,<br>thickness=0.02,<br>opacity=1.0,<br>preserve=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def elliptic_paraboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;EllipticParaboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
        &#34;&#34;&#34;
        Draws an elliptic paraboloid
        Parameters:
           o: vertex of the elliptic paraboloid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2: squares of semi-axes of the elliptic paraboloid. The equation is z = x&#39;^2/a^2 + y&#39;^2/b^2

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the elliptic paraboloid

           xmax: maximum value of the coordinate x

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the elliptic paraboloid

           opacity: opacity of the elliptic paraboloid

           preserve: Keep self.origin and self.base as the principal reference
        &#34;&#34;&#34;
        axis1 = None
        axis2 = None
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                axis2 = self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        if xmax is None:
                xmax = 10.0/a
        xmax /= a
        el = self.draw_elliptic_paraboloid(a=1.0,xmin=0.0,xmax=xmax,steps=50,scale=[a,b,1],color=color,name=name,opacity=opacity,thickness=thickness)
        if not preserve:
                self.set_origin()
                self.set_base()
                self.set_rotation()
        return axis1, axis2, el</code></pre>
</details>
<div class="desc"><p>Draws an elliptic paraboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: vertex of the elliptic paraboloid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2: squares of semi-axes of the elliptic paraboloid. The equation is z = x'^2/a^2 + y'^2/b^2</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the elliptic paraboloid</p>
<p>xmax: maximum value of the coordinate x</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the elliptic paraboloid</p>
<p>opacity: opacity of the elliptic paraboloid</p>
<p>preserve: Keep self.origin and self.base as the principal reference</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.esfera"><code class="name flex">
<span>def <span class="ident">esfera</span></span>(<span>self, centre=Vector((0.0, 0.0, 0.0)), radi=10, cmax=20, name='Esfera')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esfera(self,centre=Vector([0,0,0]),radi=10,cmax=20,name=&#34;Esfera&#34;):
        &#34;&#34;&#34;
        Draws a sphere
        Parametre:
                centre: center of the sphere

                radi: radius of the sphere

                cmax: maximum values of the x, y and z coordinates
        &#34;&#34;&#34;
        return self.sphere(o=centre,r2=radi**2,canonica=True,principal=False,cmax=cmax,preserve=False,name=name,thickness=0.001)</code></pre>
</details>
<div class="desc"><p>Draws a sphere</p>
<h2 id="parametre">Parametre</h2>
<p>centre: center of the sphere</p>
<p>radi: radius of the sphere</p>
<p>cmax: maximum values of the x, y and z coordinates</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.esfera_cilindre_elliptic"><code class="name flex">
<span>def <span class="ident">esfera_cilindre_elliptic</span></span>(<span>self, radi=10, x0=5, a=5, b=5)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esfera_cilindre_elliptic(self,radi=10,x0=5,a=5,b=5):
        &#34;&#34;&#34;
        Draws an sphere centered at (0,0,0), an elliptic cylinder and their intersection
        Parameters:
                radi: radius of the sphere

                x0: (x0,0,0) is the center of the ellipse in the plain XY

                a, b: semiaxis of this ellipse
        &#34;&#34;&#34;
        if radi &lt;= 0:
                return
        def F(t):
                x = x0 + a*math.cos(t)
                y = b*math.sin(t)
                z = radi**2 - x**2 - y**2
                if z &lt; 0:
                        z  = 0
                z = math.sqrt(z)
                return (x,y,z)
        self.sphere(r2=radi**2,canonica=True,color=&#34;GrayLight&#34;,thickness=0.0001,pmax=3*radi+3,name=&#34;Esfera&#34;)
        self.elliptic_cylinder(o=[x0,0,0],a2=a**2,b2=b**2,principal=False,canonica=False,zmax=3*radi,thickness=0.01,name=&#34;Cilindre&#34;)
        x, y = symbols(&#39;x y&#39;,real=True)
        sol = solve([x**2 + y**2 - radi**2, (x-x0)**2/a**2 + y**2/b**2 - 1],[x,y],dict=True)
        #
        # 1. solve retorna una única solució
        # La solució és el punt (x0+a,0) o (x0-a,0,0)
        #
        if len(sol) == 1:
                #
                # L&#39;altre vèrtex està dins o fora de la circumferència x^2 + y^2 = radi^2
                #
                if (sol[0][x] == radi and abs(x0 - a) &lt; radi) or (sol[0][x] == - radi and abs(x0 + a) &lt; radi):
                        self.curve(F,tmin=0,tmax=2*math.pi,steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
                else:
                        self.draw_point(radius=0.2,location=(sol[0][x],sol[0][y],0),name=&#34;Punt intersecció&#34;,color=&#34;Black&#34;,opacity=1.0)
        #
        # 2. solve retorna dues solucions
        #
        if len(sol) == 2:
                try:
                        sol[0][x]
                        sol[0][y]
                        sol[1][x]
                        sol[1][y]
                        circ = False
                except:
                        circ = True
                if circ:
                        #
                        # El cilindre és de revolució i les circumferències al pla XY coincideixen
                        #
                        self.draw_circle(radius=radi,steps=64,thickness=0.05,name=&#34;Circumferència&#34;,color=&#34;Black&#34;)
                else:
                        #
                        # Tenim dues solucions diferents, que han de ser (radi,0) i (-radi,0)
                        #
                        if abs(b) &lt; radi:
                                theta = [math.atan2(sol[i][y]/b,(sol[i][x] - x0)/a) for i in range(2)]
                                theta.sort()
                                if x0 &gt; 0:
                                        self.curve(F,tmin=theta[1],tmax=2*math.pi-theta[1],steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
                                else:
                                        self.curve(F,tmin=theta[0],tmax=theta[1],steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
                        else:
                                self.draw_point(radius=0.2,location=(sol[0][x],sol[0][y],0),name=&#34;Punt intersecció 1&#34;,color=&#34;Black&#34;,opacity=1.0)
                                self.draw_point(radius=0.2,location=(sol[1][x],sol[1][y],0),name=&#34;Punt intersecció 2&#34;,color=&#34;Black&#34;,opacity=1.0)
        #
        # 2. solve retorna tres solucions
        #
        if len(sol) == 3:
                theta = [math.atan2(sol[i][y]/b,(sol[i][x] - x0)/a) for i in range(3)]
                theta.sort()
                if theta[1] == 0.0:
                        self.curve(F,tmin=theta[0],tmax=theta[2],steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
                if theta[2] == math.pi:
                        self.curve(F,tmin=theta[1],tmax=theta[0]+2*math.pi,steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=&#39;XY&#39;,name=&#34;Corba intersecció&#34;)
        #
        # 2. solve retorna quatre solucions
        #
        if len(sol) == 4:
                theta = [math.atan2(sol[i][y]/b,(sol[i][x] - x0)/a) for i in range(4)]
                theta.sort()
                self.curve(F,tmin=theta[2],tmax=theta[3],steps=512,thickness=0.05,color=&#34;Black&#34;,symmetry=(&#39;XY&#39;,&#39;XZ&#39;,&#39;X&#39;),name=&#34;Corba intersecció&#34;)</code></pre>
</details>
<div class="desc"><p>Draws an sphere centered at (0,0,0), an elliptic cylinder and their intersection</p>
<h2 id="parameters">Parameters</h2>
<p>radi: radius of the sphere</p>
<p>x0: (x0,0,0) is the center of the ellipse in the plain XY</p>
<p>a, b: semiaxis of this ellipse</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.gir_poligon"><code class="name flex">
<span>def <span class="ident">gir_poligon</span></span>(<span>self,<br>centre=Vector((0.0, 0.0, 0.0)),<br>costats=6,<br>origen=Vector((0.0, 0.0, 0.0)),<br>radi=8)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gir_poligon(self,centre=Vector([0,0,0]),costats=6,origen=Vector([0,0,0]),radi=8):
        &#34;&#34;&#34;
        Draws an animation of the rotation around a point of a polygon in the plane XY
        Parameters:
                centre: center of the polygon

                costats: sides of the polygon

                origen: center of the rotation

                radi: radius of the polygon
        &#34;&#34;&#34;
        if len(centre) == 2:
                centre = [centre[0],centre[1],0]
        if len(origen) == 2:
                origen = [origen[0],origen[1],0]
        if not isinstance(centre,Vector):
                centre = Vector(centre)
        if not isinstance(origen,Vector):
                origen = Vector(origen)
        self.base_canonica(zaxis=False)
        self.draw_point(radius=0.167,location=origen,name=&#34;Centre del gir&#34;,color=&#34;White&#34;)
        poligon = self.draw_regular_polygon(origin=centre,vertexs=costats,radius=radi,name=&#34;Polígon regular&#34;)
        self.rotate_object(poligon,axis=&#39;Z&#39;,origin=origen,draw=False)</code></pre>
</details>
<div class="desc"><p>Draws an animation of the rotation around a point of a polygon in the plane XY</p>
<h2 id="parameters">Parameters</h2>
<p>centre: center of the polygon</p>
<p>costats: sides of the polygon</p>
<p>origen: center of the rotation</p>
<p>radi: radius of the polygon</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.hiperbola"><code class="name flex">
<span>def <span class="ident">hiperbola</span></span>(<span>self, center=Vector((0.0, 0.0, 0.0)), a=8, b=5, negatiu=False, canonica=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hiperbola(self,center=Vector([0,0,0]),a=8,b=5,negatiu=False,canonica=True):
        &#34;&#34;&#34;
        Draws the hyperbole of equation (x-x0)^2/a^2 - (y-y0)^2/b^2 == 1 (or -1)
        Parameters:
                centre: center of the hyperbole

                a, b: semiaxis of the hyperbole

                canonica: if True, draws the x and y axis

                negatiu: if True, draws the hyperbole (x-x0)^2/a^2 - (y-y0)^2/b^2 == -1
        &#34;&#34;&#34;
        if len(center) == 2:
                center = (center[0],center[1],0)
        if not isinstance(center,Vector):
                center = Vector(center)
        u1 = Vector([a,b,0])
        u2 = Vector([a,-b,0])
        c = math.sqrt(a**2 + b**2)
        f1 = [c,0,0]
        f2 = [-c,0,0]
        if canonica:
                self.referencia_canonica(zaxis=False)
        v1 = Vector([1,0,0])
        v2 = Vector([0,1,0])
        if negatiu:
                self.set_base(base=[[0,1,0],[-1,0,0],[0,0,1]])
                v1 = Vector([0,1,0])
                v2 = Vector([-1,0,0])
                u1 = Vector([b,a,0])
                u2 = Vector([b,-a,0])
        self.draw_hyperbole(center=center,u1=v1,u2=v2,a=a,b=b,ymax=14,thickness=0.02,steps=128,axis=False)
        self.draw_point(radius=0.167,location=(0,0,0),name=&#34;Centre&#34;,color=&#34;White&#34;)
        self.draw_point(radius=0.167,location=f1,name=&#34;F1&#34;,color=&#34;Black&#34;)
        self.draw_point(radius=0.167,location=f2,name=&#34;F2&#34;,color=&#34;Black&#34;)
        self.draw_line(start=-5*u1,end=5*u1,color=&#34;Blue&#34;,scale=0.03,name=&#34;Asímptota 1&#34;)
        self.draw_line(start=-5*u2,end=5*u2,color=&#34;Blue&#34;,scale=0.03,name=&#34;Asímptota 2&#34;)
        self.set_origin()
        self.set_base()
        self.set_rotation()</code></pre>
</details>
<div class="desc"><p>Draws the hyperbole of equation (x-x0)^2/a^2 - (y-y0)^2/b^2 == 1 (or -1)</p>
<h2 id="parameters">Parameters</h2>
<p>centre: center of the hyperbole</p>
<p>a, b: semiaxis of the hyperbole</p>
<p>canonica: if True, draws the x and y axis</p>
<p>negatiu: if True, draws the hyperbole (x-x0)^2/a^2 - (y-y0)^2/b^2 == -1</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.hiperboloide_dues_fulles"><code class="name flex">
<span>def <span class="ident">hiperboloide_dues_fulles</span></span>(<span>self,<br>o=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>a2=1,<br>b2=1,<br>c2=1,<br>principal=True,<br>canonica=True,<br>color='AzureBlueDark',<br>name='TwoSheetParaboloid',<br>xmax=None,<br>cmax=15,<br>pmax=15,<br>thickness=0.02,<br>opacity=1.0,<br>preserve=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def two_sheets_hyperboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;TwoSheetParaboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
        &#34;&#34;&#34;
        Draws a two sheets hyperboloid
        Parameters:
           o: center of the hyperboloid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = -1

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the hyperboloid

           xmax: maximum value of the x coordinate

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the hyperboloid

           opacity: opacity of the hyperboloid

           preserve: Keep self.origin and self.base as the principal reference
        &#34;&#34;&#34;
        axis1 = None
        axis2 = None
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                axis2 = self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        c = math.sqrt(c2)
        if xmax is None:
                xmax = 5.0/a + 2
        xmax /= a
        hy = self.draw_two_sheets_hyperboloid(a=1.0,b=1.0,xmin=0.0,xmax=xmax,color=color,scale=[a,b,c],name=name,thickness=thickness,opacity=opacity)
        if not preserve:
                self.set_origin()
                self.set_base()
                self.set_rotation()
        return axis1, axis2, hy</code></pre>
</details>
<div class="desc"><p>Draws a two sheets hyperboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the hyperboloid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x'^2/a^2 + y'^2/b^2 - z'^2/c^2 = -1</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the hyperboloid</p>
<p>xmax: maximum value of the x coordinate</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the hyperboloid</p>
<p>opacity: opacity of the hyperboloid</p>
<p>preserve: Keep self.origin and self.base as the principal reference</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.hiperboloide_dues_fulles_revolucio"><code class="name flex">
<span>def <span class="ident">hiperboloide_dues_fulles_revolucio</span></span>(<span>self, a=3, b=2, pmax=8, direccio='Z', plane='XZ', punt=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hiperboloide_dues_fulles_revolucio(self,a=3,b=2,pmax=8,direccio=&#39;Z&#39;,plane=&#39;XZ&#39;,punt=None):
        &#34;&#34;&#34;
        Draws an animation showing a two sheet hyperboloid of revolution
                a, b: semiaxis of the initial hyperbole

                pmax: maximum value of the independent variable

                direccio: &#39;X&#39;, the initial hyperbole is in the plane YX and rotates around the X axis
                          &#39;Y&#39;, the initial hyperbole is in the plane ZY and rotates around the Y axis
                              &#39;Z&#39;, the initial hyperbole is in the plane XZ and rotates around the Z axis
                
                plane: plane containing the initial hyperbole. It can be &#39;XY&#39;, &#39;XZ&#39; or &#39;YZ&#39;

                punt: if it&#39;s a value between 0 and pi, the animation shows a rotating point
        &#34;&#34;&#34;
        plane = plane.upper()
        direccio = direccio.upper()
        if plane not in (&#39;XY&#39;,&#39;XZ&#39;,&#39;YZ&#39;):
                return None
        if direccio not in (&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;):
                return None
        if plane == &#39;XY&#39;:
                F = lambda t: (a*math.sqrt(1+t**2/b**2),t,0)
        elif plane == &#39;XZ&#39;:
                F = lambda t: (a*math.sqrt(1+t**2/b**2),0,t)
        else:
                F = lambda t: (0,a*math.sqrt(1+t**2/b**2),t)

        if direccio == &#39;X&#39;:
                if plane == &#39;YZ&#39;:
                        return None
                s = &#39;Z&#39;
        elif direccio == &#39;Y&#39;:
                if plane == &#39;XZ&#39;:
                        return None
                s = &#39;Y&#39;
        else:
                if plane == &#39;XY&#39;:
                        return None
                s = &#39;X&#39;

        self.base_canonica()
        self.animate_revolution_surface(F,tmin=0,tmax=pmax,steps=128,axis=direccio,symmetry=s,point=punt)</code></pre>
</details>
<div class="desc"><p>Draws an animation showing a two sheet hyperboloid of revolution
a, b: semiaxis of the initial hyperbole</p>
<pre><code>    pmax: maximum value of the independent variable

    direccio: 'X', the initial hyperbole is in the plane YX and rotates around the X axis
              'Y', the initial hyperbole is in the plane ZY and rotates around the Y axis
                  'Z', the initial hyperbole is in the plane XZ and rotates around the Z axis

    plane: plane containing the initial hyperbole. It can be 'XY', 'XZ' or 'YZ'

    punt: if it's a value between 0 and pi, the animation shows a rotating point
</code></pre></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.hiperboloide_una_fulla"><code class="name flex">
<span>def <span class="ident">hiperboloide_una_fulla</span></span>(<span>self,<br>o=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>a2=1,<br>b2=1,<br>c2=1,<br>principal=True,<br>canonica=True,<br>color='AzureBlueDark',<br>name='OneSheetHyperboloid',<br>xmax=None,<br>cmax=15,<br>pmax=15,<br>thickness=0.02,<br>opacity=1.0,<br>preserve=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def one_sheet_hyperboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;OneSheetHyperboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
        &#34;&#34;&#34;
        Draws an one sheet hyperboloid
        Parameters:
           o: center of the hyperboloid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = 1

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the hyperboloid

           xmax: maximum value of the x coordinate

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the hyperboloid

           opacity: opacity of the hyperboloid

           preserve: Keep self.origin and self.base as the principal reference
        &#34;&#34;&#34;
        axis1 = None
        axis2 = None
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                axis2 = self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        c = math.sqrt(c2)
        if xmax is None:
                xmax=10.0/a + 2
        xmax /= a
        hy = self.draw_one_sheet_hyperboloid(a=1.0,b=1.0,xmin=1.0,xmax=xmax,scale=[a,b,c],color=color,name=name,thickness=thickness,opacity=opacity)
        if not preserve:
                self.set_origin()
                self.set_base()
                self.set_rotation()
        return axis1, axis2, hy</code></pre>
</details>
<div class="desc"><p>Draws an one sheet hyperboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the hyperboloid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x'^2/a^2 + y'^2/b^2 - z'^2/c^2 = 1</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the hyperboloid</p>
<p>xmax: maximum value of the x coordinate</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the hyperboloid</p>
<p>opacity: opacity of the hyperboloid</p>
<p>preserve: Keep self.origin and self.base as the principal reference</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.hiperboloide_una_fulla_revolucio"><code class="name flex">
<span>def <span class="ident">hiperboloide_una_fulla_revolucio</span></span>(<span>self, a=3, b=2, pmax=8, direccio='Z', plane='XZ', punt=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hiperboloide_una_fulla_revolucio(self,a=3,b=2,pmax=8,direccio=&#39;Z&#39;,plane=&#39;XZ&#39;,punt=None):
        &#34;&#34;&#34;
        Draws an animation showing an one sheet hyperboloid of revolution
                a, b: semiaxis of the initial hyperbole

                pmax: maximum value of the independent variable

                direccio: &#39;X&#39;, the initial hyperbole is in the plane XZ and rotates around the X axis
                          &#39;Y&#39;, the initial hyperbole is in the plane YX and rotates around the Y axis
                              &#39;Z&#39;, the initial hyperbole is in the plane ZX and rotates around the Z axis

                plane: plane containing the initial hyperbole. It can be &#39;XY&#39;, &#39;XZ&#39; or &#39;YZ&#39;

                punt: if it&#39;s a value between 0 and pi, the animation shows a rotating point
        &#34;&#34;&#34;
        plane = plane.upper()
        direccio = direccio.upper()
        if plane not in (&#39;XY&#39;,&#39;XZ&#39;,&#39;YZ&#39;):
                return None
        if direccio not in (&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;):
                return None
        if plane == &#39;XY&#39;:
                F = lambda t: (a*math.sqrt(1+t**2/b**2),t,0)
        elif plane == &#39;XZ&#39;:
                F = lambda t: (a*math.sqrt(1+t**2/b**2),0,t)
        else:
                F = lambda t: (0,a*math.sqrt(1+t**2/b**2),t)
        self.base_canonica()
        self.animate_revolution_surface(F,tmin=-pmax,tmax=pmax,steps=128,axis=direccio,point=punt)</code></pre>
</details>
<div class="desc"><p>Draws an animation showing an one sheet hyperboloid of revolution
a, b: semiaxis of the initial hyperbole</p>
<pre><code>    pmax: maximum value of the independent variable

    direccio: 'X', the initial hyperbole is in the plane XZ and rotates around the X axis
              'Y', the initial hyperbole is in the plane YX and rotates around the Y axis
                  'Z', the initial hyperbole is in the plane ZX and rotates around the Z axis

    plane: plane containing the initial hyperbole. It can be 'XY', 'XZ' or 'YZ'

    punt: if it's a value between 0 and pi, the animation shows a rotating point
</code></pre></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.hyperbolic_cylinder"><code class="name flex">
<span>def <span class="ident">hyperbolic_cylinder</span></span>(<span>self,<br>o=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>a2=1,<br>b2=1,<br>principal=True,<br>canonica=True,<br>color='AzureBlueDark',<br>name='Hyperbolic Cylinder',<br>xmax=None,<br>zmax=15,<br>cmax=15,<br>pmax=15,<br>thickness=0.02,<br>opacity=1.0,<br>preserve=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hyperbolic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Hyperbolic Cylinder&#34;,xmax=None,zmax=15,cmax=15,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
        &#34;&#34;&#34;
        Draws an hyperbolic cylinder
        Parameters:
           o: center of the hyperbolic cylinder

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2: squares of semi-axes of the hyperbolic cylinder. The equation is x&#39;^2/a^2 - y&#39;^2/b^2 = 1

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the hyperbolic cylinder

           xmax: maximum value of the x coordinate

           zmax: the hyperbolic cylinder is drawn between -zmax and zmax

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the hyperbolic cylinder

           opacity: opacity of the hyperbolic cylinder

           preserve: Keep self.origin and self.base as the principal reference
        &#34;&#34;&#34;
        if cmax &lt; zmax + 2:
                cmax = zmax + 2
        axis1 = None
        axis2 = None
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                axis2 = self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        if xmax is None:
                xmax = 5.0/a + 2
        xmax /= a
        hy = self.draw_hyperbolic_cylinder(a=1.0,b=1.0,xmin=1.0,xmax=xmax,length=2*zmax,steps=128,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)
        if not preserve:
                self.set_origin()
                self.set_base()
                self.set_rotation()
        return axis1, axis2, hy</code></pre>
</details>
<div class="desc"><p>Draws an hyperbolic cylinder</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the hyperbolic cylinder</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2: squares of semi-axes of the hyperbolic cylinder. The equation is x'^2/a^2 - y'^2/b^2 = 1</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the hyperbolic cylinder</p>
<p>xmax: maximum value of the x coordinate</p>
<p>zmax: the hyperbolic cylinder is drawn between -zmax and zmax</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the hyperbolic cylinder</p>
<p>opacity: opacity of the hyperbolic cylinder</p>
<p>preserve: Keep self.origin and self.base as the principal reference</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.hyperbolic_paraboloid"><code class="name flex">
<span>def <span class="ident">hyperbolic_paraboloid</span></span>(<span>self,<br>o=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>a2=1,<br>b2=1,<br>principal=True,<br>canonica=True,<br>color='AzureBlueDark',<br>name='HyperbolicParaboloid',<br>xmax=None,<br>ymax=None,<br>cmax=15,<br>pmax=15,<br>thickness=0.02,<br>opacity=1.0,<br>preserve=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hyperbolic_paraboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicParaboloid&#34;,xmax=None,ymax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
        &#34;&#34;&#34;
        Draws an hyperbolic paraboloid
        Parameters:
           o: vertex of the hyperbolic paraboloid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2: squares of semi-axes of the hyperbolic paraboloid. The equation is z = x&#39;^2/a^2 - y&#39;^2/b^2

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the elliptic paraboloid

           xmax: maximum value of the coordinate x

           ymax: maximum value of the coordinate y

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the hyperbolic paraboloid

           opacity: opacity of the hyperbolic paraboloid

           preserve: Keep self.origin and self.base as the principal reference
        &#34;&#34;&#34;
        axis1 = None
        axis2 = None
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        if xmax is None:
                xmax = 10.0/a + 2
        if ymax is None:
                ymax = 10.0/b + 1
        xmax /= a
        ymax /= b
        hy = self.draw_hyperbolic_paraboloid(a=1.0,b=1.0,xmax=xmax,ymax=ymax,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)

        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        hy.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                hy.rotation_quaternion.rotate(self.rotation.quaternion)
                hy.location.rotate(self.rotation.quaternion)
        hy.location = o
        if not preserve:
                self.set_origin()
                self.set_base()
                self.set_rotation()
        return axis1, axis2, hy</code></pre>
</details>
<div class="desc"><p>Draws an hyperbolic paraboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: vertex of the hyperbolic paraboloid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2: squares of semi-axes of the hyperbolic paraboloid. The equation is z = x'^2/a^2 - y'^2/b^2</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the elliptic paraboloid</p>
<p>xmax: maximum value of the coordinate x</p>
<p>ymax: maximum value of the coordinate y</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the hyperbolic paraboloid</p>
<p>opacity: opacity of the hyperbolic paraboloid</p>
<p>preserve: Keep self.origin and self.base as the principal reference</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>self, llista)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join(self,llista):
        &#34;&#34;&#34;
        Joins a list of objects
        Parameters:
           llista: list of objects
        &#34;&#34;&#34;
        if len(llista) == 0:
                return
        if len(llista) == 1:
                return llista[0]
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        bpy.context.view_layer.objects.active = llista[0]
        for obj in llista:
                obj.select_set(True)
        bpy.ops.object.join()
        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)
        return llista[0]</code></pre>
</details>
<div class="desc"><p>Joins a list of objects</p>
<h2 id="parameters">Parameters</h2>
<p>llista: list of objects</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.moviment_helicoidal_cilindre"><code class="name flex">
<span>def <span class="ident">moviment_helicoidal_cilindre</span></span>(<span>self,<br>centre=Vector((0.0, 0.0, 0.0)),<br>radi=3,<br>altura=12,<br>opacity=1,<br>origen=Vector((4.0, 3.0, 0.0)),<br>eix='Z',<br>rounds=1,<br>translacio=0.0,<br>aligned=False,<br>reverse=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def moviment_helicoidal_cilindre(self,centre=Vector([0,0,0]),radi=3,altura=12,opacity=1,origen=Vector([4,3,0]),eix=&#39;Z&#39;,rounds=1,translacio=0.0,aligned=False,reverse=False):
        &#34;&#34;&#34;
        Draws an animation of the helical motion of an orthohedron around an affine line
        Parameters:
                centre: center of the cylinder

                radi: radius of the cylinder

                altura: height of the cylinder

                origen: point of the affine line

                eix: axis of rotation

                opacity: opacity of the orthohedron

                translation: translation of the helical motion (distance by round)
                             if translation = 0.0, it&#39;s a rotation motion

                aligned: if True, aligns the orthohedron with the axis of rotation
        &#34;&#34;&#34;
        if isinstance(eix,str):
                eix = eix.strip().upper()
        if eix == &#39;X&#39;:
                u = Vector([1,0,0])
        elif eix == &#39;Y&#39;:
                u = Vector([0,1,0])
        elif eix == &#39;Z&#39;:
                u = Vector([0,0,1])
        elif isinstance(eix,Vector):
                u = eix
        else:
                u = Vector(eix)

        w1 = u.normalized()
        w2 = u.orthogonal().normalized()
        w3 = w1.cross(w2)
        self.base_canonica()
        if not isinstance(centre,Vector):
                centre = Vector(centre)
        if not isinstance(origen,Vector):
                origen = Vector(origen)
        cil, cir = self.cilindre(centre=centre,radi=radi,height=altura,eix=&#39;Z&#39;,color=&#34;AzureBlueDark&#34;,circlecolor=&#34;Blue&#34;)
        if aligned:
                cil.rotation_mode = &#39;QUATERNION&#39;
                cir.rotation_mode = &#39;QUATERNION&#39;
                x = Vector([0,0,1])
                quaternion = x.rotation_difference(w1)
                cil.rotation_quaternion.rotate(quaternion)
                cir.rotation_quaternion.rotate(quaternion)
                cir.location = cil.location + altura/2 * w1
        if reverse:
                u *= -1
        self.rotate_objects([cil,cir],axis=u,origin=origen,translation=translacio,rounds=rounds,draw=True)</code></pre>
</details>
<div class="desc"><p>Draws an animation of the helical motion of an orthohedron around an affine line</p>
<h2 id="parameters">Parameters</h2>
<p>centre: center of the cylinder</p>
<p>radi: radius of the cylinder</p>
<p>altura: height of the cylinder</p>
<p>origen: point of the affine line</p>
<p>eix: axis of rotation</p>
<p>opacity: opacity of the orthohedron</p>
<p>translation: translation of the helical motion (distance by round)
if translation = 0.0, it's a rotation motion</p>
<p>aligned: if True, aligns the orthohedron with the axis of rotation</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.moviment_helicoidal_ortoedre"><code class="name flex">
<span>def <span class="ident">moviment_helicoidal_ortoedre</span></span>(<span>self,<br>centre=Vector((0.0, 0.0, 0.0)),<br>costats=Vector((3.0, 5.0, 2.0)),<br>opacity=1,<br>origen=Vector((4.0, 3.0, 0.0)),<br>eix='Z',<br>rounds=1,<br>translacio=0.0,<br>aligned=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def moviment_helicoidal_ortoedre(self,centre=Vector([0,0,0]),costats=Vector([3,5,2]),opacity=1,origen=Vector([4,3,0]),eix=&#39;Z&#39;,rounds=1,translacio=0.0,aligned=False):
        &#34;&#34;&#34;
        Draws an animation of the helical motion of an orthohedron around an affine line
        Parameters:
                centre: center of the orthohedron

                costats: half sides of the orthohedron

                origen: point of the affine line

                eix: axis of rotation

                opacity: opacity of the orthohedron

                translation: translation of the helical motion (distance by round)
                             if translation = 0.0, it&#39;s a rotation motion

                aligned: if True, aligns the orthohedron with the axis of rotation
        &#34;&#34;&#34;
        if isinstance(eix,str):
                eix = eix.strip().upper()
        if eix == &#39;X&#39;:
                u = Vector([1,0,0])
        elif eix == &#39;Y&#39;:
                u = Vector([0,1,0])
        elif eix == &#39;Z&#39;:
                u = Vector([0,0,1])
        elif isinstance(eix,Vector):
                u = eix
        else:
                u = Vector(eix)
        w1 = u.normalized()
        w2 = u.orthogonal().normalized()
        w3 = w1.cross(w2)
        self.base_canonica()
        if not isinstance(centre,Vector):
                centre = Vector(centre)
        if not isinstance(costats,Vector):
                costats = Vector(costats)
        if not isinstance(origen,Vector):
                origen = Vector(origen)
        ortoedre = self.draw_cube(origin=centre,scale=costats,color=&#34;AzureBlueDark&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Ortoedre&#34;)
        if aligned:
                ortoedre.rotation_mode = &#39;QUATERNION&#39;
                x = Vector([1,0,0])
                quaternion = x.rotation_difference(w1)
                ortoedre.rotation_quaternion.rotate(quaternion)
        self.rotate_object(ortoedre,axis=eix,origin=origen,translation=translacio,rounds=rounds)</code></pre>
</details>
<div class="desc"><p>Draws an animation of the helical motion of an orthohedron around an affine line</p>
<h2 id="parameters">Parameters</h2>
<p>centre: center of the orthohedron</p>
<p>costats: half sides of the orthohedron</p>
<p>origen: point of the affine line</p>
<p>eix: axis of rotation</p>
<p>opacity: opacity of the orthohedron</p>
<p>translation: translation of the helical motion (distance by round)
if translation = 0.0, it's a rotation motion</p>
<p>aligned: if True, aligns the orthohedron with the axis of rotation</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.moviment_helicoidal_punt"><code class="name flex">
<span>def <span class="ident">moviment_helicoidal_punt</span></span>(<span>self,<br>punt=Vector((0.0, 0.0, 0.0)),<br>origen=Vector((-3.0, -3.0, -4.0)),<br>eix='Z',<br>rounds=5,<br>angle=360,<br>stop=0,<br>translacio=2,<br>vectors=True,<br>length=15,<br>reverse=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def moviment_helicoidal_punt(self,punt=Vector([0,0,0]),origen=Vector([-3,-3,-4]),eix=&#39;Z&#39;,rounds=5,angle=360,stop=0,translacio=2,vectors=True,length=15,reverse=False):
        &#34;&#34;&#34;
        Draws an animation of the helical motion of an orthohedron around an affine line
        Parameters:
                punt: posició inicial del punt

                origen: point of the affine line

                eix: axis of rotation

                rounds: rounds of the point aroud the axis

                translation: translation of the helical motion (distance by frame)
                             if translation = 0.0, it&#39;s a rotation motion
        &#34;&#34;&#34;
        if isinstance(eix,str):
                eix = eix.strip().upper()
        if eix == &#39;X&#39;:
                u = Vector([1,0,0])
        elif eix == &#39;Y&#39;:
                u = Vector([0,1,0])
        elif eix == &#39;Z&#39;:
                u = Vector([0,0,1])
        elif isinstance(eix,Vector):
                u = eix
        else:
                u = Vector(eix)

        if angle &lt; 360:
                rounds = 1
        self.base_canonica()
        if not isinstance(punt,Vector):
                punt = Vector(punt)
        if not isinstance(origen,Vector):
                origen = Vector(origen)
        self.draw_point(radius=0.2,location=punt,name=&#34;Blue&#34;,color=&#34;Blue&#34;)
        obj = self.draw_point(radius=0.2,location=punt,name=&#34;Red&#34;,color=&#34;Red&#34;)
        obj2 = None
        if vectors:
                self.draw_vector(origin=origen,vector=punt-origen,name=&#34;VBlack&#34;,color=&#34;Black&#34;)
                obj2 = self.draw_vector(origin=origen,vector=punt-origen,name=&#34;VRed&#34;,color=&#34;Red&#34;)
        if obj2 is None:
                if reverse:
                        self.rotate_object(obj,axis=-u,origin=origen,translation=translacio,angle=angle,stop=stop,length=length,rounds=rounds,draw=True)
                else:
                        self.rotate_object(obj,axis=u,origin=origen,translation=translacio,angle=angle,stop=stop,length=length,rounds=rounds,draw=True)
        else:
                if reverse:
                        self.rotate_objects([obj,obj2],axis=-u,origin=origen,translation=translacio,angle=angle,stop=stop,length=length,rounds=rounds,draw=True)
                else:
                        self.rotate_objects([obj,obj2],axis=u,origin=origen,translation=translacio,angle=angle,stop=stop,length=length,rounds=rounds,draw=True)
        vec1 = (punt-origen).project(u)
        center = origen + vec1
        w1 = (punt-center).normalized()
        w3 = u.normalized()
        w2 = w3.cross(w1)
        radius = (center-punt).length
        if angle &lt; 360:
                self.curve(lambda t: (radius*math.cos(t),radius*math.sin(t),180*translacio*u.length/(angle*math.pi)*t),tmin=0,tmax=2*rounds*math.pi,steps=128,thickness=0.005,name=&#34;Hèlix&#34;,color=&#34;Yellow&#34;,o=center,u1=w1,u2=w2)
        else:
                self.curve(lambda t: (radius*math.cos(t),radius*math.sin(t),translacio*t/(2*math.pi)),tmin=-2*rounds*math.pi,tmax=2*rounds*math.pi,steps=128*rounds,thickness=0.005,name=&#34;Hèlix&#34;,color=&#34;Yellow&#34;,o=center,u1=w1,u2=w2)
        self.reset()</code></pre>
</details>
<div class="desc"><p>Draws an animation of the helical motion of an orthohedron around an affine line</p>
<h2 id="parameters">Parameters</h2>
<p>punt: posició inicial del punt</p>
<p>origen: point of the affine line</p>
<p>eix: axis of rotation</p>
<p>rounds: rounds of the point aroud the axis</p>
<p>translation: translation of the helical motion (distance by frame)
if translation = 0.0, it's a rotation motion</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.one_sheet_hyperboloid"><code class="name flex">
<span>def <span class="ident">one_sheet_hyperboloid</span></span>(<span>self,<br>o=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>a2=1,<br>b2=1,<br>c2=1,<br>principal=True,<br>canonica=True,<br>color='AzureBlueDark',<br>name='OneSheetHyperboloid',<br>xmax=None,<br>cmax=15,<br>pmax=15,<br>thickness=0.02,<br>opacity=1.0,<br>preserve=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def one_sheet_hyperboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;OneSheetHyperboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
        &#34;&#34;&#34;
        Draws an one sheet hyperboloid
        Parameters:
           o: center of the hyperboloid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = 1

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the hyperboloid

           xmax: maximum value of the x coordinate

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the hyperboloid

           opacity: opacity of the hyperboloid

           preserve: Keep self.origin and self.base as the principal reference
        &#34;&#34;&#34;
        axis1 = None
        axis2 = None
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                axis2 = self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        c = math.sqrt(c2)
        if xmax is None:
                xmax=10.0/a + 2
        xmax /= a
        hy = self.draw_one_sheet_hyperboloid(a=1.0,b=1.0,xmin=1.0,xmax=xmax,scale=[a,b,c],color=color,name=name,thickness=thickness,opacity=opacity)
        if not preserve:
                self.set_origin()
                self.set_base()
                self.set_rotation()
        return axis1, axis2, hy</code></pre>
</details>
<div class="desc"><p>Draws an one sheet hyperboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the hyperboloid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x'^2/a^2 + y'^2/b^2 - z'^2/c^2 = 1</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the hyperboloid</p>
<p>xmax: maximum value of the x coordinate</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the hyperboloid</p>
<p>opacity: opacity of the hyperboloid</p>
<p>preserve: Keep self.origin and self.base as the principal reference</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.ortoedre"><code class="name flex">
<span>def <span class="ident">ortoedre</span></span>(<span>self,<br>centre=Vector((0.0, 0.0, 0.0)),<br>costats=[6, 10, 8],<br>scalelines=0.05,<br>vectors=False,<br>color='Blue',<br>linecolor='Red',<br>vectorcolor='Black',<br>name='Ortoedre',<br>opacity=1.0,<br>thickness=0.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ortoedre(self,centre=Vector([0,0,0]),costats=[6,10,8],scalelines=0.05,vectors=False,color=&#34;Blue&#34;,linecolor=&#34;Red&#34;,vectorcolor=&#34;Black&#34;,name=&#39;Ortoedre&#39;,opacity=1.0,thickness=0.0):
        if not isinstance(centre,Vector):
                centre = Vector(centre)
        self.draw_cube(origin=centre,scale=costats,scalelines=scalelines,vectors=vectors,color=color,linecolor=linecolor,vectorcolor=vectorcolor,name=name,opacity=opacity,thickness=thickness)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.parabola"><code class="name flex">
<span>def <span class="ident">parabola</span></span>(<span>self, vertex=Vector((0.0, 0.0, 0.0)), p=5, xmax=15, eixos='XY', canonica=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parabola(self,vertex=Vector([0,0,0]),p=5,xmax=15,eixos=&#39;XY&#39;,canonica=True):
        &#34;&#34;&#34;
        Draws the parabola of equation y - y0 = (x-x0)^2/(2*p) or x - x0 = (y-y0)^2/(2*p)
        Parameters:
                vertex: vertex of the parabola

                p: parameter of the parabola

                pmax: maximum value of the independent variable

                eixos: &#39;XY&#39;, draws y - y0 = (x-x0)^2/(2*p)
                           &#39;YX&#39;, draws x - x0 = (y-y0)^2/(2*p)

                canonica: if True, draws the x and y axis
        &#34;&#34;&#34;
        if len(vertex) == 2:
                vertex = (vertex[0],vertex[1],0)
        if not isinstance(vertex,Vector):
                vertex = Vector(vertex)
        f = [0,p/2,0]
        if canonica:
                self.referencia_canonica(zaxis=False)
        u1 = Vector([1,0,0])
        u2 = Vector([0,1,0])
        if eixos == &#39;YX&#39; or eixos == &#39;yx&#39;:
                self.set_base(base=[[0,1,0],[1,0,0],[0,0,-1]])
                u1 = Vector([0,1,0])
                u2 = Vector([1,0,0])
        self.draw_parabola(vertex=vertex,a=1/(2*p),u1=u1,u2=u2,xmax=xmax,thickness=0.02,steps=128,axis=False)
        self.reset_rotation()
        self.draw_point(radius=0.167,location=f,name=&#34;Focus&#34;,color=&#34;Black&#34;)
        self.draw_point(radius=0.167,location=(0,0,0),name=&#34;Vèrtex&#34;,color=&#34;White&#34;)
        self.draw_line(start=[-xmax-3,-p/2,0],end=[xmax+3,-p/2,0],color=&#34;Blue&#34;,scale=0.04,name=&#34;Recta directriu&#34;)
        self.set_origin()
        self.set_base()
        self.set_rotation()</code></pre>
</details>
<div class="desc"><p>Draws the parabola of equation y - y0 = (x-x0)^2/(2<em>p) or x - x0 = (y-y0)^2/(2</em>p)</p>
<h2 id="parameters">Parameters</h2>
<p>vertex: vertex of the parabola</p>
<p>p: parameter of the parabola</p>
<p>pmax: maximum value of the independent variable</p>
<p>eixos: 'XY', draws y - y0 = (x-x0)^2/(2<em>p)
'YX', draws x - x0 = (y-y0)^2/(2</em>p)</p>
<p>canonica: if True, draws the x and y axis</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.parabolic_cylinder"><code class="name flex">
<span>def <span class="ident">parabolic_cylinder</span></span>(<span>self,<br>o=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>p=1,<br>principal=True,<br>canonica=True,<br>color='AzureBlueDark',<br>name='ParabolicCylinder',<br>xmax=12,<br>ymax=30,<br>cmax=20,<br>pmax=20,<br>thickness=0.02,<br>opacity=1.0,<br>preserve=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parabolic_cylinder(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],p=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;ParabolicCylinder&#34;,xmax=12,ymax=30,cmax=20,pmax=20,thickness=0.02,opacity=1.0,preserve=True):
        &#34;&#34;&#34;
        Draws an hyperbolic paraboloid
        Parameters:
           o: vertex of the hyperbolic paraboloid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           p: Parameter of the cylinder z&#39; = x&#39;^2/(2*p)

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the elliptic paraboloid

           xmax: maximum value of the coordinate x

           ymax: maximum value of the coordinate y

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the hyperbolic paraboloid

           opacity: opacity of the hyperbolic paraboloid

           preserve: Keep self.origin and self.base as the principal reference
        &#34;&#34;&#34;
        axis1 = None
        axis2 = None
        coef = 1.0
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                axis2 = self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        coef = 1.0
        if p &lt; 0:
                coef = -1
        xmax /= math.sqrt(2*coef*p)
        pa = self.draw_parabolic_cylinder(p=coef,xmin=0.0,xmax=xmax,length=ymax,color=color,name=name,scale=[math.sqrt(2*coef*p),1,1],thickness=thickness,opacity=opacity)
        if not preserve:
                self.set_origin()
                self.set_base()
                self.set_rotation()
        return axis1, axis2, pa</code></pre>
</details>
<div class="desc"><p>Draws an hyperbolic paraboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: vertex of the hyperbolic paraboloid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>p: Parameter of the cylinder z' = x'^2/(2*p)</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the elliptic paraboloid</p>
<p>xmax: maximum value of the coordinate x</p>
<p>ymax: maximum value of the coordinate y</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the hyperbolic paraboloid</p>
<p>opacity: opacity of the hyperbolic paraboloid</p>
<p>preserve: Keep self.origin and self.base as the principal reference</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.paraboloide_elliptic"><code class="name flex">
<span>def <span class="ident">paraboloide_elliptic</span></span>(<span>self,<br>o=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>a2=1,<br>b2=1,<br>principal=True,<br>canonica=True,<br>color='AzureBlueDark',<br>name='EllipticParaboloid',<br>xmax=None,<br>cmax=15,<br>pmax=15,<br>thickness=0.02,<br>opacity=1.0,<br>preserve=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def elliptic_paraboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;EllipticParaboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
        &#34;&#34;&#34;
        Draws an elliptic paraboloid
        Parameters:
           o: vertex of the elliptic paraboloid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2: squares of semi-axes of the elliptic paraboloid. The equation is z = x&#39;^2/a^2 + y&#39;^2/b^2

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the elliptic paraboloid

           xmax: maximum value of the coordinate x

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the elliptic paraboloid

           opacity: opacity of the elliptic paraboloid

           preserve: Keep self.origin and self.base as the principal reference
        &#34;&#34;&#34;
        axis1 = None
        axis2 = None
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                axis2 = self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        if xmax is None:
                xmax = 10.0/a
        xmax /= a
        el = self.draw_elliptic_paraboloid(a=1.0,xmin=0.0,xmax=xmax,steps=50,scale=[a,b,1],color=color,name=name,opacity=opacity,thickness=thickness)
        if not preserve:
                self.set_origin()
                self.set_base()
                self.set_rotation()
        return axis1, axis2, el</code></pre>
</details>
<div class="desc"><p>Draws an elliptic paraboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: vertex of the elliptic paraboloid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2: squares of semi-axes of the elliptic paraboloid. The equation is z = x'^2/a^2 + y'^2/b^2</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the elliptic paraboloid</p>
<p>xmax: maximum value of the coordinate x</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the elliptic paraboloid</p>
<p>opacity: opacity of the elliptic paraboloid</p>
<p>preserve: Keep self.origin and self.base as the principal reference</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.paraboloide_elliptic_revolucio"><code class="name flex">
<span>def <span class="ident">paraboloide_elliptic_revolucio</span></span>(<span>self, a=0.5, pmax=5, direccio='Z', punt=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paraboloide_elliptic_revolucio(self,a=0.5,pmax=5,direccio=&#39;Z&#39;,punt=None):
        &#34;&#34;&#34;
        Draws an animation showing an elliptic paraboloid of revolution
                a: The constant of the initial parabola

                pmax: maximum value of the independent variable

                direccio: &#39;X&#39;, the initial parabola is in the plane YX and rotates around the X axis
                          &#39;Y&#39;, the initial parabola is in the plane ZY and rotates around the Y axis
                              &#39;Z&#39;, the initial parabola is in the plane XZ and rotates around the Z axis

                punt: if it&#39;s a value between -pmax and pmax, the animation shows a rotating point
        &#34;&#34;&#34;
        if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                F = lambda t: (a*t**2,t,0)
        elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                F = lambda t: (0,a*t**2,t)
        else:
                F = lambda t: (t,0,a*t**2)
        self.base_canonica()
        self.animate_revolution_surface(F,tmin=0,tmax=pmax,steps=128,axis=direccio,point=punt)</code></pre>
</details>
<div class="desc"><p>Draws an animation showing an elliptic paraboloid of revolution
a: The constant of the initial parabola</p>
<pre><code>    pmax: maximum value of the independent variable

    direccio: 'X', the initial parabola is in the plane YX and rotates around the X axis
              'Y', the initial parabola is in the plane ZY and rotates around the Y axis
                  'Z', the initial parabola is in the plane XZ and rotates around the Z axis

    punt: if it's a value between -pmax and pmax, the animation shows a rotating point
</code></pre></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.paraboloide_elliptic_simple"><code class="name flex">
<span>def <span class="ident">paraboloide_elliptic_simple</span></span>(<span>self, a=3, b=4, direccio='Z', xmax=12)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paraboloide_elliptic_simple(self,a=3,b=4,direccio=&#39;Z&#39;,xmax=12):
        &#34;&#34;&#34;
        Draws the hyperbolic paraboloid of equation z = x^2/a^2 - y^2/b^2
        Parameters:
                a, b: constants the defines he hyperbolic paraboloid

                xmax, ymax: maximun values of the x and y coordinates
        &#34;&#34;&#34;
        if direccio == &#39;X&#39; or direccio == &#39;x&#39;:
                u1 = Vector([0,0,1])
                u2 = Vector([0,1,0])
        elif direccio == &#39;Y&#39; or direccio == &#39;y&#39;:
                u1 = Vector([1,0,0])
                u2 = Vector([0,0,-1])
        else:
                u1 = Vector([1,0,0])
                u2 = Vector([0,1,0])
        el = self.elliptic_paraboloid(a2=a**2,b2=b**2,u1=u1,u2=u2,xmax=xmax,cmax=xmax,canonica=True,principal=False)
        self.reset()
        return el</code></pre>
</details>
<div class="desc"><p>Draws the hyperbolic paraboloid of equation z = x^2/a^2 - y^2/b^2</p>
<h2 id="parameters">Parameters</h2>
<p>a, b: constants the defines he hyperbolic paraboloid</p>
<p>xmax, ymax: maximun values of the x and y coordinates</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.paraboloide_hiperbolic"><code class="name flex">
<span>def <span class="ident">paraboloide_hiperbolic</span></span>(<span>self,<br>o=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>a2=1,<br>b2=1,<br>principal=True,<br>canonica=True,<br>color='AzureBlueDark',<br>name='HyperbolicParaboloid',<br>xmax=None,<br>ymax=None,<br>cmax=15,<br>pmax=15,<br>thickness=0.02,<br>opacity=1.0,<br>preserve=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hyperbolic_paraboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;HyperbolicParaboloid&#34;,xmax=None,ymax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
        &#34;&#34;&#34;
        Draws an hyperbolic paraboloid
        Parameters:
           o: vertex of the hyperbolic paraboloid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2: squares of semi-axes of the hyperbolic paraboloid. The equation is z = x&#39;^2/a^2 - y&#39;^2/b^2

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the elliptic paraboloid

           xmax: maximum value of the coordinate x

           ymax: maximum value of the coordinate y

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the hyperbolic paraboloid

           opacity: opacity of the hyperbolic paraboloid

           preserve: Keep self.origin and self.base as the principal reference
        &#34;&#34;&#34;
        axis1 = None
        axis2 = None
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        if xmax is None:
                xmax = 10.0/a + 2
        if ymax is None:
                ymax = 10.0/b + 1
        xmax /= a
        ymax /= b
        hy = self.draw_hyperbolic_paraboloid(a=1.0,b=1.0,xmax=xmax,ymax=ymax,color=color,name=name,scale=[a,b,1],thickness=thickness,opacity=opacity)

        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        hy.rotation_mode = &#39;QUATERNION&#39;
        if self.rotation is not None:
                hy.rotation_quaternion.rotate(self.rotation.quaternion)
                hy.location.rotate(self.rotation.quaternion)
        hy.location = o
        if not preserve:
                self.set_origin()
                self.set_base()
                self.set_rotation()
        return axis1, axis2, hy</code></pre>
</details>
<div class="desc"><p>Draws an hyperbolic paraboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: vertex of the hyperbolic paraboloid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2: squares of semi-axes of the hyperbolic paraboloid. The equation is z = x'^2/a^2 - y'^2/b^2</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the elliptic paraboloid</p>
<p>xmax: maximum value of the coordinate x</p>
<p>ymax: maximum value of the coordinate y</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the hyperbolic paraboloid</p>
<p>opacity: opacity of the hyperbolic paraboloid</p>
<p>preserve: Keep self.origin and self.base as the principal reference</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.paraboloide_hiperbolic_simple"><code class="name flex">
<span>def <span class="ident">paraboloide_hiperbolic_simple</span></span>(<span>self, a=3, b=4, xmax=12, ymax=12)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paraboloide_hiperbolic_simple(self,a=3,b=4,xmax=12,ymax=12):
        &#34;&#34;&#34;
        Draws the hyperbolic paraboloid of equation z = x^2/a^2 - y^2/b^2
        Parameters:
                a, b: constants the defines he hyperbolic paraboloid

                xmax, ymax: maximun values of the x and y coordinates
        &#34;&#34;&#34;
        return self.hyperbolic_paraboloid(a2=a**2,b2=b**2,xmax=xmax,ymax=ymax,canonica=True,principal=False)</code></pre>
</details>
<div class="desc"><p>Draws the hyperbolic paraboloid of equation z = x^2/a^2 - y^2/b^2</p>
<h2 id="parameters">Parameters</h2>
<p>a, b: constants the defines he hyperbolic paraboloid</p>
<p>xmax, ymax: maximun values of the x and y coordinates</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.perpendicular_comuna_a_dues_rectes"><code class="name flex">
<span>def <span class="ident">perpendicular_comuna_a_dues_rectes</span></span>(<span>self,<br>p0=Vector((1.0, 1.0, 1.0)),<br>u=Vector((1.0, 0.0, 0.0)),<br>q0=Vector((-1.0, 2.0, -2.0)),<br>v=Vector((0.0, 0.0, 1.0)),<br>sizex=60,<br>sizey=80,<br>length=5,<br>t1=0,<br>t2=0,<br>head_height=0.1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def perpendicular_comuna_a_dues_rectes(self,p0=Vector([1,1,1]),u=Vector([1,0,0]),q0=Vector([-1,2,-2]),v=Vector([0,0,1]),sizex=60,sizey=80,length=5,t1=0,t2=0,head_height=0.1):
        &#34;&#34;&#34;
        Draws the straigth line perpendicular to a given two non parallel lines
        Parameters:
           p0: point of the first line

           u: director vector of the first line

           q0: point of the second line

           v: director vector of the second line

           sizex, sizey: sizes of the rectangle

           length: length og the vectors

           t1, t2: displacement of the points p0 and q0
        &#34;&#34;&#34;
        if not isinstance(p0,Vector):
                p0 = Vector(p0)
        if not isinstance(q0,Vector):
                q0 = Vector(q0)
        if not isinstance(u,Vector):
                u = Vector(u)
        if not isinstance(v,Vector):
                v = Vector(v)

        w = u.cross(v)
        if w.length == 0:
                return None
        pq = q0 - p0
        mat = Matrix([u,v,w])
        mat.transpose()
        mat.invert()
        pq1 = mat @ pq

        m0 = p0 + pq1.x * u
        m1 = m0 + pq1.z * w
        m = (m0 + m1)/2
        u.normalize()
        v.normalize()
        w.normalize()
        self.draw_vector(origin=p0+t1*u,vector=length*u,axis=30,scale=0.15,head_height=head_height,color=&#34;Blue&#34;,name=&#34;Recta  1&#34;,positive=False)
        self.draw_vector(origin=q0+t2*v,vector=length*v,axis=30,scale=0.15,head_height=head_height,color=&#34;Green&#34;,name=&#34;Recta  2&#34;,positive=False)
        self.draw_vector(origin=m,vector=length*w,axis=sizex/2+10,scale=0.15,head_height=head_height,color=&#34;Red&#34;,name=&#34;Recta perpendicular comuna&#34;,positive=False)
        self.rectangle(origin=m,u1=w,u2=u,sizex=sizex,sizey=sizey,name=&#34;Pla P&#34;,opacity=1)
        self.rectangle(origin=m,u1=w,u2=v,sizex=sizex,sizey=sizey,color=&#34;CyanAzureDark&#34;,name=&#34;Pla Q&#34;,opacity=1)
        self.draw_point(location=p0+t1*u,radius=0.5,name=&#34;Punt p0&#34;,color=&#34;Blue&#34;)
        self.draw_point(location=q0+t2*v,radius=0.5,name=&#34;Punt q0&#34;,color=&#34;Green&#34;)
        self.draw_point(location=m0,radius=0.5,name=&#34;Punt interseccio 1&#34;)
        self.draw_point(location=m1,radius=0.5,name=&#34;Punt interseccio 2&#34;)
        self.draw_point(location=m,radius=0.5,name=&#34;Punt recta perpendicular&#34;,color=&#34;Red&#34;)</code></pre>
</details>
<div class="desc"><p>Draws the straigth line perpendicular to a given two non parallel lines</p>
<h2 id="parameters">Parameters</h2>
<p>p0: point of the first line</p>
<p>u: director vector of the first line</p>
<p>q0: point of the second line</p>
<p>v: director vector of the second line</p>
<p>sizex, sizey: sizes of the rectangle</p>
<p>length: length og the vectors</p>
<p>t1, t2: displacement of the points p0 and q0</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.pla_afi"><code class="name flex">
<span>def <span class="ident">pla_afi</span></span>(<span>self,<br>punt=Vector((0.0, 0.0, 0.0)),<br>normal=None,<br>v1=Vector((3.0, 2.0, 1.0)),<br>v2=Vector((1.0, -2.0, 0.5)),<br>canonica=False,<br>name='Pla afí',<br>length=15,<br>color='Cyan',<br>sizex=25,<br>sizey=20,<br>opacity=0.9,<br>elements=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pla_afi(self,punt=Vector([0,0,0]),normal=None,v1=Vector([3,2,1]),v2=Vector([1,-2,0.5]),canonica=False,name=&#34;Pla afí&#34;,length=15,color=&#34;Cyan&#34;,sizex=25,sizey=20,opacity=0.9,elements=True):
        &#34;&#34;&#34;
        Draws the affine plane generated by two vectors passing through a point
        Parameters:
                punt: point of the plane

                normal: normal vector of the plane

                v1, v2: generators of the plane

                canonica: if True, draws the x, y and z axis

                name: name of the affine plane

                length: length of the axis x, y and z

                color: color of the plane

                sizex, sizey: size of the plane

                opacicity: opacity of the plane
        &#34;&#34;&#34;
        if not isinstance(punt,Vector):
                punt = Vector(punt)
        punt = self.components_en_canonica(punt)
        if canonica:
                if length &gt; 15:
                        self.base_canonica(length=length,scale=0.08)
                else:
                        self.base_canonica(length=length)
        if normal is not None:
                if not isinstance(normal,Vector):
                        normal = Vector(normal)
                self.draw_plane_surface(origin=punt,normal=normal,color=color,sizex=sizex,sizey=sizey,name=name,opacity=opacity)
        else:
                self.draw_plane_surface(origin=punt,base=[v1,v2],color=color,sizex=sizex,sizey=sizey,name=name,opacity=opacity)
        if elements:
                self.set_origin(punt)
                self.draw_point(color=&#34;Blue&#34;)
                if normal is not None:
                        self.draw_vector(vector=normal,color=&#34;Blue&#34;)
                else:
                        self.draw_vectors(vectors=[v1,v2],canonica=canonica,color=&#34;Blue&#34;)
                self.set_origin()</code></pre>
</details>
<div class="desc"><p>Draws the affine plane generated by two vectors passing through a point</p>
<h2 id="parameters">Parameters</h2>
<p>punt: point of the plane</p>
<p>normal: normal vector of the plane</p>
<p>v1, v2: generators of the plane</p>
<p>canonica: if True, draws the x, y and z axis</p>
<p>name: name of the affine plane</p>
<p>length: length of the axis x, y and z</p>
<p>color: color of the plane</p>
<p>sizex, sizey: size of the plane</p>
<p>opacicity: opacity of the plane</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.pla_vectorial"><code class="name flex">
<span>def <span class="ident">pla_vectorial</span></span>(<span>self,<br>v1=Vector((3.0, 2.0, 1.0)),<br>v2=Vector((1.0, -2.0, 0.5)),<br>canonica=False,<br>length=15,<br>color='Cyan',<br>sizex=25,<br>sizey=20,<br>opacity=0.8,<br>thickness=0.01)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pla_vectorial(self,v1=Vector([3,2,1]),v2=Vector([1,-2,0.5]),canonica=False,length=15,color=&#34;Cyan&#34;,sizex=25,sizey=20,opacity=0.8,thickness=0.01):
        &#34;&#34;&#34;
        Draws the plane generated by two vectors
        Parameters:
                v1, v2: generators of the plane

                canonica: if True, draws the x, y and z axis

                length: length of the axis x, y and z

                color: color of the plane

                sizex, sizey: size of the plane

                opacicity: opacity of the plane

                thickness: thickness of the plane
        &#34;&#34;&#34;
        if canonica:
                if length &gt; 15:
                        self.base_canonica(length=length,scale=0.01)
                else:
                        self.base_canonica(length=length)
        self.draw_vectors([v1,v2],color=&#34;Blue&#34;)
        self.draw_plane_surface(base=[v1,v2],color=color,sizex=sizex,sizey=sizey,opacity=opacity,thickness=thickness)</code></pre>
</details>
<div class="desc"><p>Draws the plane generated by two vectors</p>
<h2 id="parameters">Parameters</h2>
<p>v1, v2: generators of the plane</p>
<p>canonica: if True, draws the x, y and z axis</p>
<p>length: length of the axis x, y and z</p>
<p>color: color of the plane</p>
<p>sizex, sizey: size of the plane</p>
<p>opacicity: opacity of the plane</p>
<p>thickness: thickness of the plane</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.posicio_relativa_tres_plans"><code class="name flex">
<span>def <span class="ident">posicio_relativa_tres_plans</span></span>(<span>self,<br>punts=None,<br>normals=None,<br>colors=None,<br>canonica=True,<br>length=25,<br>sizex=45,<br>sizey=40,<br>opacity=1.0,<br>elements=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def posicio_relativa_tres_plans(self,punts=None,normals=None,colors=None,canonica=True,length=25,sizex=45,sizey=40,opacity=1.0,elements=False):
        &#34;&#34;&#34;
        Draws threee planes
        Parametres:
                punts: three points, one for each plane

                normals: three normal vectors, one for each plane

                colors: three colors, one for each plane

                canonica: if True, draws the x, y and z axis

                length: length of the axis x, y and z

                sizex, sizey: size of the planes

                opacicity: opacity of the planes

                elements: if True, draws the point and the normal vector for each plane
        &#34;&#34;&#34;
        punts = [p if isinstance(p,Vector) else Vector(p) for p in punts]
        normals = [n if isinstance(n,Vector) else Vector(n) for n in normals]
        n = (&#34;Primer pla&#34;,&#34;Segon pla&#34;,&#34;Tercer pla&#34;)
        if canonica:
                b = (True,False,False)
        else:
                b = (False,False,False)
        for i in range(3):
                self.pla_afi(punt=punts[i],normal=normals[i],canonica=b[i],name=n[i],length=length,color=colors[i],sizex=sizex,sizey=sizey,opacity=opacity,elements=elements)</code></pre>
</details>
<div class="desc"><p>Draws threee planes</p>
<h2 id="parametres">Parametres</h2>
<p>punts: three points, one for each plane</p>
<p>normals: three normal vectors, one for each plane</p>
<p>colors: three colors, one for each plane</p>
<p>canonica: if True, draws the x, y and z axis</p>
<p>length: length of the axis x, y and z</p>
<p>sizex, sizey: size of the planes</p>
<p>opacicity: opacity of the planes</p>
<p>elements: if True, draws the point and the normal vector for each plane</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.product_components"><code class="name flex">
<span>def <span class="ident">product_components</span></span>(<span>self, u, v)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def product_components(self,u,v):
        &#34;&#34;&#34;
        Computes the vectorial product u x v
        Parameters:
           u, v: two Vectors
        &#34;&#34;&#34;
        if not isinstance(u,Vector):
                u = Vector(u)
        if not isinstance(v,Vector):
                v = Vector(v)
        return Vector([u.x * v.x,u.y * v.y,u.z * v.z])</code></pre>
</details>
<div class="desc"><p>Computes the vectorial product u x v</p>
<h2 id="parameters">Parameters</h2>
<p>u, v: two Vectors</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_pla_afi"><code class="name flex">
<span>def <span class="ident">projeccio_ortogonal_simetric_pla_afi</span></span>(<span>self,<br>punt=Vector((6.0, -5.0, 8.0)),<br>p0=Vector((3.0, -2.0, -3.0)),<br>v1=Vector((3.0, -1.0, 1.0)),<br>v2=Vector((1.0, 0.5, 0.5)),<br>radi=0.15,<br>sizex=35,<br>sizey=30,<br>line=1.8,<br>canonica=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projeccio_ortogonal_simetric_pla_afi(self,punt=Vector([6,-5,8]),p0=Vector([3,-2,-3]),v1=Vector([3,-1,1]),v2=Vector([1,0.5,0.5]),radi=0.15,sizex=35,sizey=30,line=1.8,canonica=True):
        &#34;&#34;&#34;
        Draws the orthogonal projection and the symmetric of a point with respect an affine plane
        Parameters:
                punt: the initial point

                p0: point of the affine plane

                v1, v2: generators of the plane

                radi: radius of the points

                sizex, sizey: sizes of the affine plane

                factor: how to draw the perpendicular line

                canonica: if True, draws the x, y and z axis
        &#34;&#34;&#34;
        if not isinstance(punt,Vector):
                punt = Vector(punt)
        if not isinstance(p0,Vector):
                p0 = Vector(p0)
        if not isinstance(v1,Vector):
                v1 = Vector(v1)
        if not isinstance(v2,Vector):
                v2 = Vector(v2)
        self.draw_point(location=punt,color=&#34;Black&#34;,radius=radi,name=&#34;Punt&#34;)
        w = v1.cross(v2)
        self.pla_afi(punt=p0,v1=v1,v2=v2,sizex=sizex,sizey=sizey,color=&#34;AzureBlueMedium&#34;,canonica=canonica,elements=False)
        u = punt - p0
        up = punt - u.project(w)
        self.draw_point(location=up,color=&#34;Red&#34;,radius=radi,name=&#34;Projecció ortogonal&#34;)
        us = punt - 2*u.project(w)
        self.draw_point(location=us,color=&#34;Green&#34;,radius=radi,name=&#34;Simètric&#34;)
        u = punt - up
        self.draw_line(start=up-line*u,end=up+line*u,scale=0.04,color=&#34;White&#34;,name=&#34;Recta perpendicular al pla&#34;)</code></pre>
</details>
<div class="desc"><p>Draws the orthogonal projection and the symmetric of a point with respect an affine plane</p>
<h2 id="parameters">Parameters</h2>
<p>punt: the initial point</p>
<p>p0: point of the affine plane</p>
<p>v1, v2: generators of the plane</p>
<p>radi: radius of the points</p>
<p>sizex, sizey: sizes of the affine plane</p>
<p>factor: how to draw the perpendicular line</p>
<p>canonica: if True, draws the x, y and z axis</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_pla_vectorial"><code class="name flex">
<span>def <span class="ident">projeccio_ortogonal_simetric_pla_vectorial</span></span>(<span>self,<br>vector=Vector((7.0, -1.0, 12.0)),<br>v1=Vector((3.0, -1.0, 1.0)),<br>v2=Vector((1.0, 0.5, 0.5)),<br>sizex=None,<br>sizey=None,<br>color='AzureBlueDark',<br>canonica=True,<br>orthogonal=False,<br>orthonormal=False,<br>thickness=0.01)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projeccio_ortogonal_simetric_pla_vectorial(self,vector=Vector([7,-1,12]),v1=Vector([3,-1,1]),v2=Vector([1,0.5,0.5]),sizex=None,sizey=None,color=&#34;AzureBlueDark&#34;,canonica=True,orthogonal=False,orthonormal=False,thickness=0.01):
        &#34;&#34;&#34;
        Draws the otoghonal projection and the symmetric of a vector with respecte a plane
        Parameters:
                vector: the initial vector

                v1, v2: generators of the plane

                sizex, sizey: size of the plane

                canonica: if True, draws the x, y and z axis

                thickness:
        &#34;&#34;&#34;
        if not isinstance(vector,Vector):
                vector = Vector(vector)
        if not isinstance(v1,Vector):
                v1 = Vector(v1)
        if not isinstance(v2,Vector):
                v2 = Vector(v2)
        self.draw_vector(vector=vector)
        w = v1.cross(v2)
        vp = vector - vector.project(w)
        self.draw_vector(vector=vp,color=&#34;Red&#34;,name=&#34;Projecció ortogonal&#34;)
        if sizex is None:
                sizex = 4*vp.length
        if sizey is None:
                sizey = 4*vp.length
        self.pla_vectorial(v1,v2,sizex=sizex,sizey=sizey,canonica=canonica,color=color,thickness=thickness)
        if orthogonal:
                u1 = v1
                u2 = v2
                u2 = u1.dot(u1)*u2 - u2.dot(u1)*u1
                self.draw_vectors(vectors=(u1,u2),name=&#34;Base ortogonal&#34;,color=&#34;Green&#34;)
        if orthonormal:
                u1 = v1
                u2 = v2
                u2 = u1.dot(u1)*u2 - u2.dot(u1)*u1
                u1.normalize()
                u2.normalize()
                self.draw_vectors(vectors=(u1,u2),name=&#34;Base ortonormal&#34;,color=&#34;Orange&#34;)
                self.set_base([u1,u2,w])
                vb = self.components_in_base(vector)
                self.set_base()
                p1 = vb.x * u1
                p2 = vb.y * u2
                l1 = self.draw_line(start=[0,0,0],end=p1,scale=0.04,color=&#34;Orange&#34;,name=&#34;Lines 1&#34;)
                l2 = self.draw_line(start=[0,0,0],end=p2,scale=0.04,color=&#34;Orange&#34;)
                l3 = self.draw_line(start=vp,end=p1,scale=0.04,color=&#34;Orange&#34;)
                l4 = self.draw_line(start=vp,end=p2,scale=0.04,color=&#34;Orange&#34;)
                l11 = self.join([l1,l2,l3,l4])
        self.set_origin(vp)
        self.draw_vector(vector=vector.project(w),scale=0.025,color=&#34;White&#34;,name=&#34;Vector perpendicular&#34;)
        self.set_origin()
        self.set_base([v1,v2,w])
        vb = self.components_in_base(vector)
        self.set_base()
        p1 = vb.x * v1
        p2 = vb.y * v2
        l1 = self.draw_line(start=[0,0,0],end=p1,scale=0.04,color=&#34;Blue&#34;,name=&#34;Lines 2&#34;)
        l2 = self.draw_line(start=[0,0,0],end=p2,scale=0.04,color=&#34;Blue&#34;)
        l3 = self.draw_line(start=vp,end=p1,scale=0.04,color=&#34;Blue&#34;)
        l4 = self.draw_line(start=vp,end=p2,scale=0.04,color=&#34;Blue&#34;)
        l1 = self.join([l1,l2,l3,l4])
        self.draw_vector(vector=2 * vp - vector,color=&#34;Green&#34;,name=&#34;Simètric&#34;)
        self.draw_line(start=2 * vp - vector,end=vp,scale=0.04,color=&#34;White&#34;,name=&#34;Vector perpendicular&#34;)</code></pre>
</details>
<div class="desc"><p>Draws the otoghonal projection and the symmetric of a vector with respecte a plane</p>
<h2 id="parameters">Parameters</h2>
<p>vector: the initial vector</p>
<p>v1, v2: generators of the plane</p>
<p>sizex, sizey: size of the plane</p>
<p>canonica: if True, draws the x, y and z axis</p>
<p>thickness:</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_recta_afi"><code class="name flex">
<span>def <span class="ident">projeccio_ortogonal_simetric_recta_afi</span></span>(<span>self,<br>punt=Vector((6.0, -5.0, 8.0)),<br>p0=Vector((3.0, -2.0, -3.0)),<br>v1=Vector((3.0, -1.0, 1.0)),<br>scale=0.1,<br>radi=0.15,<br>sizex=10,<br>sizey=10,<br>canonica=True,<br>opacity=1.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projeccio_ortogonal_simetric_recta_afi(self,punt=Vector([6,-5,8]),p0=Vector([3,-2,-3]),v1=Vector([3,-1,1]),scale=0.1,radi=0.15,sizex=10,sizey=10,canonica=True,opacity=1.0):
        &#34;&#34;&#34;
        Draws the orthogonal projection and the symmetric of a point with respect an affine line
        Parameters:
                punt: the initial point

                p0: point of the affine line

                v1: generator of the line

                radi: radius of the points

                sizex, sizey: sizes of the affine plane

                canonica: if True, draws the x, y and z axis
        &#34;&#34;&#34;
        if not isinstance(punt,Vector):
                punt = Vector(punt)
        if not isinstance(p0,Vector):
                p0 = Vector(p0)
        if not isinstance(v1,Vector):
                v1 = Vector(v1)
        if canonica:
                self.base_canonica(length=0.75*sizex,name=&#34;Referència canònica&#34;)
        self.draw_point(location=p0,color=&#34;Blue&#34;,radius=radi,name=&#34;Punt de la recta&#34;)
        self.set_origin(p0)
        self.draw_vector(vector=v1,canonica=canonica,scale=scale,head_height=0.15,axis=20,name=&#34;Recta afí&#34;,color=&#34;Blue&#34;,positive=False)
        self.set_origin()
        self.draw_point(location=punt,color=&#34;Black&#34;,radius=radi,name=&#34;Punt inicial&#34;)
        u = punt - p0
        p1 = p0 + u.project(v1)
        self.draw_point(location=p1,color=&#34;Red&#34;,radius=radi,name=&#34;Projecció ortogonal&#34;)
        self.draw_plane_surface(origin=p1,normal=v1,name=&#34;Pla perpendicular a la recta&#34;,sizex=sizex,sizey=sizey,color=&#34;AzureBlueMedium&#34;,opacity=opacity)
        self.draw_point(location=2*p1-punt,color=&#34;Green&#34;,radius=radi,name=&#34;Simètric&#34;)
        self.draw_line(start=punt,end=2*p1-punt,scale=0.04,color=&#34;White&#34;)</code></pre>
</details>
<div class="desc"><p>Draws the orthogonal projection and the symmetric of a point with respect an affine line</p>
<h2 id="parameters">Parameters</h2>
<p>punt: the initial point</p>
<p>p0: point of the affine line</p>
<p>v1: generator of the line</p>
<p>radi: radius of the points</p>
<p>sizex, sizey: sizes of the affine plane</p>
<p>canonica: if True, draws the x, y and z axis</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_recta_vectorial"><code class="name flex">
<span>def <span class="ident">projeccio_ortogonal_simetric_recta_vectorial</span></span>(<span>self,<br>vector=Vector((7.0, -1.0, 12.0)),<br>v1=Vector((3.0, -1.0, 1.0)),<br>canonica=True,<br>length=15)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projeccio_ortogonal_simetric_recta_vectorial(self,vector=Vector([7,-1,12]),v1=Vector([3,-1,1]),canonica=True,length=15):
        &#34;&#34;&#34;
        Draws the otoghonal projection and the symmetric of a vector with respecte a line
        Parameters:
                vector: the initial vector

                v1: generator of the line

                canonica: if True, draws the x, y and z axis

                length: length for x, y and z axis and v1 axis
        &#34;&#34;&#34;
        if not isinstance(vector,Vector):
                vector = Vector(vector)
        if not isinstance(v1,Vector):
                v1 = Vector(v1)
        if canonica:
                self.base_canonica(length=length)
        self.draw_vector(vector=v1,axis=length,positive=False,color=&#34;Blue&#34;,scale=0.066)
        self.draw_vector(vector=vector)
        vp = vector.project(v1)
        self.draw_vector(vector=vp,color=&#34;Red&#34;)
        self.draw_vector(origin=vp,vector=vector - vp,scale=0.025,color=&#34;White&#34;)
        self.draw_vector(vector=2 * vp - vector,color=&#34;Green&#34;)
        self.draw_line(start=2 * vp - vector,end=vp,scale=0.04,color=&#34;White&#34;)</code></pre>
</details>
<div class="desc"><p>Draws the otoghonal projection and the symmetric of a vector with respecte a line</p>
<h2 id="parameters">Parameters</h2>
<p>vector: the initial vector</p>
<p>v1: generator of the line</p>
<p>canonica: if True, draws the x, y and z axis</p>
<p>length: length for x, y and z axis and v1 axis</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.punt_referencia_canonica"><code class="name flex">
<span>def <span class="ident">punt_referencia_canonica</span></span>(<span>self,<br>punt=Vector((-4.0, 7.0, 6.0)),<br>radius=0.1,<br>length=12,<br>scale=0.06,<br>name='Punt p',<br>color='Black',<br>coordenades=True,<br>vector=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def punt_referencia_canonica(self,punt=Vector([-4,7,6]),radius=0.1,length=12,scale=0.06,name=&#34;Punt p&#34;,color=&#34;Black&#34;,coordenades=True,vector=True):
        &#34;&#34;&#34;
        Draws a point expressed in the canonical reference
        Parameters:
           punt: the point to draw

           length: length of the axis

           name: name of the point

           coordenades: if True draws lines representing the coordinates

           vector: if True, it draws the position vector
        &#34;&#34;&#34;
        self.base_canonica(length=length,scale=scale,name=&#34;Referència canònica&#34;)
        if not isinstance(punt,Vector):
                punt = Vector(punt)
        self.draw_point(location=punt,color=&#34;Black&#34;,radius=radius,name=name)
        if coordenades:
                self.draw_components(punt,name=&#34;Coordenades en referència canònica&#34;)
        if vector:
                self.draw_vector(vector=punt,name=&#34;Vector de posició refereǹcia canònica&#34;,color=color)</code></pre>
</details>
<div class="desc"><p>Draws a point expressed in the canonical reference</p>
<h2 id="parameters">Parameters</h2>
<p>punt: the point to draw</p>
<p>length: length of the axis</p>
<p>name: name of the point</p>
<p>coordenades: if True draws lines representing the coordinates</p>
<p>vector: if True, it draws the position vector</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.punt_referencia_no_canonica"><code class="name flex">
<span>def <span class="ident">punt_referencia_no_canonica</span></span>(<span>self,<br>punt=Vector((5.0, 6.0, -5.0)),<br>origin=Vector((-2.0, 3.0, 3.0)),<br>u1=Vector((-0.3333333432674408, -0.6666666865348816, 0.6666666865348816)),<br>u2=Vector((0.6666666865348816, 0.3333333432674408, 0.6666666865348816)),<br>u3=Vector((-0.6666666865348816, 0.6666666865348816, 0.3333333432674408)),<br>color='Black',<br>length=12,<br>scale=0.04,<br>radius=0.1,<br>name='Punt p',<br>vector=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def punt_referencia_no_canonica(self,punt=Vector([5,6,-5]),origin=Vector([-2,3,3]),u1=1/3*Vector([-1,-2,2]),u2=1/3*Vector([2,1,2]),u3=1/3*Vector([-2,2,1]),color=&#34;Black&#34;,length=12,scale=0.04,radius=0.1,name=&#34;Punt p&#34;,vector=True):
        &#34;&#34;&#34;
        Draws a point expressed in the reference {o,u1,u2,u3} with origin in the point origin and sets the default
        origin and default base to them
        Parameters:
                punt: point to draw

                origin: origin of the reference

                u1, u2, u3: vectors of the base

                length: length of the axis

                scale: scale of the axis

                name: name of the reference

                vector: if True, it draws the position vector
        &#34;&#34;&#34;
        self.referencia_no_canonica(origin=origin,u1=u1,u2=u2,u3=u3,length=length,scale=scale,name=&#34;Referència R&#39;&#34;)
        if not isinstance(punt,Vector):
                punt = Vector(punt)
        self.draw_point(location=punt,color=&#34;Black&#34;,radius=radius,name=name)
        self.draw_components(punt,scale=0.015,name=&#34;Coordenades en referència R&#39;&#34;)
        if vector:
                self.draw_vector(vector=punt,name=&#34;Vector de posició referència R&#39;&#34;)</code></pre>
</details>
<div class="desc"><p>Draws a point expressed in the reference {o,u1,u2,u3} with origin in the point origin and sets the default
origin and default base to them</p>
<h2 id="parameters">Parameters</h2>
<p>punt: point to draw</p>
<p>origin: origin of the reference</p>
<p>u1, u2, u3: vectors of the base</p>
<p>length: length of the axis</p>
<p>scale: scale of the axis</p>
<p>name: name of the reference</p>
<p>vector: if True, it draws the position vector</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.recta_afi"><code class="name flex">
<span>def <span class="ident">recta_afi</span></span>(<span>self,<br>punt=Vector((3.0, 4.0, -2.0)),<br>v=Vector((1.0, 2.0, 1.0)),<br>color='Black',<br>size=15,<br>name='Recta afí',<br>canonica=True,<br>length=12,<br>scale=0.03,<br>elements=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recta_afi(self,punt=Vector([3,4,-2]),v=Vector([1,2,1]),color=&#34;Black&#34;,size=15,name=&#34;Recta afí&#34;,canonica=True,length=12,scale=0.03,elements=True):
        &#34;&#34;&#34;
        Draws the affine line generated by a vector passing through a point
        Parameters:
                punt: point of the line

                v: generator of the line

                canonica: if True, draws the x, y and z axis

                name: name of the affine plane

                length: length of the axis x, y and z

                color: color of the plane

                size: lenght of the line

                scale: scale of the line
        &#34;&#34;&#34;
        if canonica:
                if length &gt; 15:
                        self.base_canonica(length=length,scale=0.08)
                else:
                        self.base_canonica(length=length)
        if not isinstance(v,Vector):
                v = Vector(v)
        if not isinstance(punt,Vector):
                punt = Vector(punt)
        l = v.length
        p0 = punt + size/l * v
        p1 = punt - size/l * v
        self.draw_line(start=p0,end=p1,scale=0.04,color=color)
        if elements:
                self.set_origin(punt)
                self.draw_point(color=color,radius=2 * scale)
                self.draw_vector(vector=v,color=color)
                self.set_origin()</code></pre>
</details>
<div class="desc"><p>Draws the affine line generated by a vector passing through a point</p>
<h2 id="parameters">Parameters</h2>
<p>punt: point of the line</p>
<p>v: generator of the line</p>
<p>canonica: if True, draws the x, y and z axis</p>
<p>name: name of the affine plane</p>
<p>length: length of the axis x, y and z</p>
<p>color: color of the plane</p>
<p>size: lenght of the line</p>
<p>scale: scale of the line</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.recta_vectorial"><code class="name flex">
<span>def <span class="ident">recta_vectorial</span></span>(<span>self,<br>v=Vector((1.0, 2.0, 1.0)),<br>color='Black',<br>size=15,<br>name='Recta vectorial',<br>canonica=True,<br>length=12,<br>scale=0.03)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recta_vectorial(self,v=Vector([1,2,1]),color=&#34;Black&#34;,size=15,name=&#34;Recta vectorial&#34;,canonica=True,length=12,scale=0.03):
        &#34;&#34;&#34;
        Draws the affine line generated by a vector passing through a point
        Parameters:
                v: generator of the line

                canonica: if True, draws the x, y and z axis

                name: name of the affine plane

                length: length of the axis x, y and z

                color: color of the plane

                size: lenght of the line

                scale: scale of the line
        &#34;&#34;&#34;
        if canonica:
                if length &gt; 15:
                        self.base_canonica(length=length,scale=0.08)
                else:
                        self.base_canonica(length=length)
        if not isinstance(v,Vector):
                v = Vector(v)
        l = v.length
        p0 = size/l * v
        p1 = - size/l * v
        self.draw_line(start=p0,end=p1,scale=scale,color=color)
        self.draw_vector(vector=v,scale=1.2*scale,color=color)</code></pre>
</details>
<div class="desc"><p>Draws the affine line generated by a vector passing through a point</p>
<h2 id="parameters">Parameters</h2>
<p>v: generator of the line</p>
<p>canonica: if True, draws the x, y and z axis</p>
<p>name: name of the affine plane</p>
<p>length: length of the axis x, y and z</p>
<p>color: color of the plane</p>
<p>size: lenght of the line</p>
<p>scale: scale of the line</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rectangle"><code class="name flex">
<span>def <span class="ident">rectangle</span></span>(<span>self,<br>origin=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>scalelines=0.1,<br>color='AzureBlueMedium',<br>linecolor='AzureBlueDark',<br>name='Rectangle',<br>sizex=10,<br>sizey=10,<br>opacity=1.0,<br>thickness=0.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rectangle(self,origin=[0,0,0],u1=[1,0,0],u2=[0,1,0],scalelines=0.1,color=&#34;AzureBlueMedium&#34;,linecolor=&#34;AzureBlueDark&#34;,name=&#34;Rectangle&#34;,sizex=10,sizey=10,opacity=1.0,thickness=0.0):
        &#34;&#34;&#34;
        Draws a rectangle
        Parameters:
           origin: base vertex of the rectangle

           u1, u2: base vectors for the rectangle

           scalelines: scale of the edges of the rectangle

           color: color of the rectangle

           linecolor: color of the edges

           name: name of the rectangle

           sizex,  sizey: sizes of the rectangle

           opacity: opacity of the rectangle

           thickness: thickness of the rectangle
        &#34;&#34;&#34;
        if not isinstance(u1,Vector):
                u1 = Vector(u1)
        if not isinstance(u2,Vector):
                u2 = Vector(u2)
        if not isinstance(origin,Vector):
                origin = Vector(origin)
        u1.normalize()
        u2.normalize()
        points = [(0,0),(sizex,0),(sizex,sizey),(0,sizey)]
        self.draw_polygon(origin=origin-sizex/2*u1-sizex/2*u2,u1=u1,u2=u2,points=points,scalelines=scalelines,color=color,linecolor=linecolor,name=name,opacity=opacity,thickness=thickness)</code></pre>
</details>
<div class="desc"><p>Draws a rectangle</p>
<h2 id="parameters">Parameters</h2>
<p>origin: base vertex of the rectangle</p>
<p>u1, u2: base vectors for the rectangle</p>
<p>scalelines: scale of the edges of the rectangle</p>
<p>color: color of the rectangle</p>
<p>linecolor: color of the edges</p>
<p>name: name of the rectangle</p>
<p>sizex,
sizey: sizes of the rectangle</p>
<p>opacity: opacity of the rectangle</p>
<p>thickness: thickness of the rectangle</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.referencia_canonica"><code class="name flex">
<span>def <span class="ident">referencia_canonica</span></span>(<span>self,<br>origin=Vector((0.0, 0.0, 0.0)),<br>length=15,<br>scale=0.04,<br>zaxis=True,<br>name='Referència canònica')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def referencia_canonica(self,origin=Vector([0,0,0]),length=15,scale=0.04,zaxis=True,name=&#34;Referència canònica&#34;):
        &#34;&#34;&#34;
        Draws the canonical reference
        Parameters:
           origin: point where to represent the base

           length: length of the axis

           scale: scale of the cylinder

           zaxis: if False the z axis is not drawn

           name: name of the object
        &#34;&#34;&#34;
        if not isinstance(origin,Vector):
                origin = Vector(origin)
        self.set_origin(origin)
        self.draw_base_axis(axis=length,positive=False,scale=scale,zaxis=zaxis,name=name)</code></pre>
</details>
<div class="desc"><p>Draws the canonical reference</p>
<h2 id="parameters">Parameters</h2>
<p>origin: point where to represent the base</p>
<p>length: length of the axis</p>
<p>scale: scale of the cylinder</p>
<p>zaxis: if False the z axis is not drawn</p>
<p>name: name of the object</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.referencia_no_canonica"><code class="name flex">
<span>def <span class="ident">referencia_no_canonica</span></span>(<span>self,<br>origin=Vector((0.0, 0.0, 0.0)),<br>u1=Vector((1.0, -1.0, 0.0)),<br>u2=Vector((-0.5, 1.0, 0.5)),<br>u3=Vector((-1.0, 0.0, 1.0)),<br>length=12,<br>scale=0.04,<br>preserve=True,<br>name="Referència R'")</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def referencia_no_canonica(self,origin=Vector([0,0,0]),u1=Vector([1,-1,0]),u2=1/2*Vector([-1,2,1]),u3=Vector([-1,0,1]),length=12,scale=0.04,preserve=True,name=&#34;Referència R&#39;&#34;):
        &#34;&#34;&#34;
        Draws the reference {o;u1,u2,u3} with origin in the point origin and sets the default
        origin and default base to them
        Parameters:
                origin: origin of the reference

                u1, u2, u3: vectors of the base

                length: length of the axis

                scale: scale of the axis

                name: name of the reference
        &#34;&#34;&#34;
        if not isinstance(origin,Vector):
                origin = Vector(origin)
        if not isinstance(u1,Vector):
                u1 = Vector(u1)
        if not isinstance(u2,Vector):
                u2 = Vector(u2)
        if not isinstance(u3,Vector):
                u3 = Vector(u3)
        self.set_origin(origin)
        self.set_base([u1,u2,u3])
        self.draw_base_axis(axis=length,positive=False,scale=scale,name=name)
        if not preserve:
                self.set_origin()
                self.set_base()
                self.set_rotation()</code></pre>
</details>
<div class="desc"><p>Draws the reference {o;u1,u2,u3} with origin in the point origin and sets the default
origin and default base to them</p>
<h2 id="parameters">Parameters</h2>
<p>origin: origin of the reference</p>
<p>u1, u2, u3: vectors of the base</p>
<p>length: length of the axis</p>
<p>scale: scale of the axis</p>
<p>name: name of the reference</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
        &#34;&#34;&#34;
        Resets origin, base, rotation, frames and colors
        &#34;&#34;&#34;
        self.reset_origin()
        self.reset_base()
        self.reset_rotation()
        self.reset_frames()
        self.reset_colors()</code></pre>
</details>
<div class="desc"><p>Resets origin, base, rotation, frames and colors</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.reset_base"><code class="name flex">
<span>def <span class="ident">reset_base</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_base(self):
        &#34;&#34;&#34;
        Sets self.base to the canonical basis
        &#34;&#34;&#34;
        self.base = [[1,0,0],[0,1,0],[0,0,1]]</code></pre>
</details>
<div class="desc"><p>Sets self.base to the canonical basis</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.reset_colors"><code class="name flex">
<span>def <span class="ident">reset_colors</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_colors(self):
        &#34;&#34;&#34;
        Set self.colors to default colors
        &#34;&#34;&#34;
        self.colors = Colors.colors([&#34;Red&#34;,&#34;GreenDarkHard&#34;,&#34;Blue&#34;])</code></pre>
</details>
<div class="desc"><p>Set self.colors to default colors</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.reset_frames"><code class="name flex">
<span>def <span class="ident">reset_frames</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_frames(self):
        &#34;&#34;&#34;
        Set self.frame to 0
        Parameters:
           name: name of a color
        &#34;&#34;&#34;
        self.frame = 0</code></pre>
</details>
<div class="desc"><p>Set self.frame to 0</p>
<h2 id="parameters">Parameters</h2>
<p>name: name of a color</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.reset_origin"><code class="name flex">
<span>def <span class="ident">reset_origin</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_origin(self):
        &#34;&#34;&#34;
        Sets the origin to the point (0,0,0)
        &#34;&#34;&#34;
        self.origin = Vector([0,0,0])</code></pre>
</details>
<div class="desc"><p>Sets the origin to the point (0,0,0)</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.reset_rotation"><code class="name flex">
<span>def <span class="ident">reset_rotation</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_rotation(self):
        &#34;&#34;&#34;
        Sets the rotation to identity, i.e., rotation of 0 degrees around the
        vector (1,0,0)
        &#34;&#34;&#34;
        self.set_rotation()</code></pre>
</details>
<div class="desc"><p>Sets the rotation to identity, i.e., rotation of 0 degrees around the
vector (1,0,0)</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.revolution_surface"><code class="name flex">
<span>def <span class="ident">revolution_surface</span></span>(<span>self,<br>fun=None,<br>tmin=0.0,<br>tmax=1.0,<br>o=Vector((0.0, 0.0, 0.0)),<br>u1=Vector((1.0, 0.0, 0.0)),<br>u2=Vector((0.0, 1.0, 0.0)),<br>pmax=0,<br>steps=256,<br>thickness=0.025,<br>axis='Z',<br>name='Revolution surface',<br>color='AzureBlueDark')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def revolution_surface(self,fun=None,tmin=0.0,tmax=1.0,o=Vector([0,0,0]),u1=Vector([1,0,0]),u2=Vector([0,1,0]),pmax=0,steps=256,thickness=0.025,axis=&#39;Z&#39;,name=&#34;Revolution surface&#34;,color=&#34;AzureBlueDark&#34;):
        &#34;&#34;&#34;
        Draws a revolution surface from a curve in the reference R&#39;
        Parameters:
           fun: parametric equacion of the curve

           steps: number of steps

           axis: axis of revolution. It must be &#39;X&#39;, &#39;Y&#39; or &#39;Z&#39;

           o: origin of the reference R&#39;

           u1, u2: vectors to construct the basis {v1, v2, v3}

           pmax: the principal axis are drawn between -pmax and pmax

           color: color of the surface
        &#34;&#34;&#34;
        if fun is None:
                return None
        q = self.vectors_to_quaternion(u1,u2)
        obj = self.simple_curve(fun,tmin=tmin,tmax=tmax,steps=steps,name=name)
        m = obj.modifiers.new(name=&#34;SubSurf&#34;, type=&#39;SUBSURF&#39;)
        m.levels = 4
        m.subdivision_type = &#39;SIMPLE&#39;
        m = obj.modifiers.new(name=&#34;Solidify&#34;, type=&#39;SOLIDIFY&#39;)
        m.thickness = thickness
        m.offset = 1.0
        m = obj.modifiers.new(name=&#34;Screw&#34;, type=&#39;SCREW&#39;)
        m.angle = 2*math.pi
        m.steps = steps
        m.axis =  axis
        c = Colors.color(color)
        self.add_material(obj,c.name,c.r,c.g,c.b,1.0)
        bpy.context.scene.collection.objects.link(obj)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if self.rotation is not None:
                obj.rotation_mode = &#39;QUATERNION&#39;
                obj.rotation_quaternion.rotate(self.rotation.quaternion)
                obj.location.rotate(self.rotation.quaternion)
        if pmax &gt; 0.0:
                self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència R&#39;&#34;)
        bpy.ops.object.shade_smooth()
        obj.location = o
        obj.select_set(False)
        bpy.context.view_layer.objects.active = None</code></pre>
</details>
<div class="desc"><p>Draws a revolution surface from a curve in the reference R'</p>
<h2 id="parameters">Parameters</h2>
<p>fun: parametric equacion of the curve</p>
<p>steps: number of steps</p>
<p>axis: axis of revolution. It must be 'X', 'Y' or 'Z'</p>
<p>o: origin of the reference R'</p>
<p>u1, u2: vectors to construct the basis {v1, v2, v3}</p>
<p>pmax: the principal axis are drawn between -pmax and pmax</p>
<p>color: color of the surface</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rotacio_ortoedre"><code class="name flex">
<span>def <span class="ident">rotacio_ortoedre</span></span>(<span>self,<br>centre=Vector((0.0, 0.0, 0.0)),<br>costats=Vector((8.0, 5.0, 4.0)),<br>eix='Z',<br>angle=360,<br>stop=0,<br>opacity=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotacio_ortoedre(self,centre=Vector([0,0,0]),costats=Vector([8,5,4]),eix=&#39;Z&#39;,angle=360,stop=0,opacity=1):
        &#34;&#34;&#34;
        Draws an animation of an orthohedron rotating around a vectorial line
        Parameters:
                centre: center of the orthohedron

                costats: half sides of the orthohedron

                eix: axis of rotation

                opacity: opacity of the orthohedron
        &#34;&#34;&#34;
        self.base_canonica()
        if not isinstance(centre,Vector):
                centre = Vector(centre)
        if not isinstance(costats,Vector):
                costats = Vector(costats)
        ortoedre = self.draw_cube(origin=centre,scale=costats,color=&#34;AzureBlueDark&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Ortoedre&#34;)
        self.rotate_object(ortoedre,axis=eix,angle=angle,stop=stop,draw=False)</code></pre>
</details>
<div class="desc"><p>Draws an animation of an orthohedron rotating around a vectorial line</p>
<h2 id="parameters">Parameters</h2>
<p>centre: center of the orthohedron</p>
<p>costats: half sides of the orthohedron</p>
<p>eix: axis of rotation</p>
<p>opacity: opacity of the orthohedron</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rotacio_ortoedre_angles_euler"><code class="name flex">
<span>def <span class="ident">rotacio_ortoedre_angles_euler</span></span>(<span>self,<br>centre=Vector((0.0, 0.0, 0.0)),<br>costats=Vector((8.0, 5.0, 4.0)),<br>psi=90,<br>theta=60,<br>phi=45,<br>radians=False,<br>opacity=1,<br>eixos='zxz')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotacio_ortoedre_angles_euler(self,centre=Vector([0,0,0]),costats=Vector([8,5,4]),psi=90,theta=60,phi=45,radians=False,opacity=1,eixos=&#39;zxz&#39;):
        &#34;&#34;&#34;
        Draws an animation of an orthohedron rotating given the Euler&#39;s angles
        Parameters:
                centre: center of the orthohedron

                costats: half sides of the orthohedron

                psi, theta, phi: Euler&#39;s angles

                radians: if True the Euler&#39;s angles must in radians. If False in degrees

                opacity: opacity of the orthohedron

                eixos: axis of the three rotations
        &#34;&#34;&#34;
        if not isinstance(centre,Vector):
                centre = Vector(centre)
        if not isinstance(costats,Vector):
                costats = Vector(costats)
        ortoedre = self.draw_cube(origin=centre,scale=costats,color=&#34;AzureBlueDark&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Ortoedre&#34;)
        self.rotate_euler(ortoedre,psi,theta,phi,radians=radians,axis=eixos)</code></pre>
</details>
<div class="desc"><p>Draws an animation of an orthohedron rotating given the Euler's angles</p>
<h2 id="parameters">Parameters</h2>
<p>centre: center of the orthohedron</p>
<p>costats: half sides of the orthohedron</p>
<p>psi, theta, phi: Euler's angles</p>
<p>radians: if True the Euler's angles must in radians. If False in degrees</p>
<p>opacity: opacity of the orthohedron</p>
<p>eixos: axis of the three rotations</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rotacio_ortoedre_voltant_vector"><code class="name flex">
<span>def <span class="ident">rotacio_ortoedre_voltant_vector</span></span>(<span>self,<br>centre=Vector((0.0, 0.0, 0.0)),<br>costats=Vector((8.0, 5.0, 4.0)),<br>angle=80,<br>radians=False,<br>vector=Vector((1.0, -2.0, 1.0)),<br>opacity=0.7,<br>euler=None,<br>reverse=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotacio_ortoedre_voltant_vector(self,centre=Vector([0,0,0]),costats=Vector([8,5,4]),angle=80,radians=False,vector=Vector([1,-2,1]),opacity=0.7,euler=None,reverse=False):
        &#34;&#34;&#34;
        Draws an animation of a vector rotating around a vectorial line
        Parameters:
                centre: center of the orthohedron

                costats: half sides of the orthohedron

                angle: angle of rotation

                radians: if True the Euler&#39;s angles must in radians. If False in degrees

                vector: generator of the vectorial line

                opacity: opacity of the orthohedron

                euler: None or the value of the three Euler&#39;s axis

                reverse: if True, shows the rotation with Euler&#39;s angles in reverse order
        &#34;&#34;&#34;
        if not isinstance(centre,Vector):
                centre = Vector(centre)
        if not isinstance(costats,Vector):
                costats = Vector(costats)
        if not isinstance(vector,Vector):
                vector = Vector(vector)
        ortoedre = self.draw_cube(origin=centre,scale=costats,color=&#34;AzureBlueDark&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Primer ortoedre&#34;)
        if euler is not None:
                ortoedre2 = self.draw_cube(origin=centre,scale=costats,color=&#34;Green&#34;,opacity=opacity,thickness=0.015,scalelines=0.025,linecolor=&#34;Orange&#34;,name=&#34;Segon ortoedre&#34;)
        self.rotate_object_by_axis_angle(obj=ortoedre,axis=vector,angle=angle,frames=3)
        if euler is not None:
                R = Rotation(angle=angle,vector=vector)
                psi, theta, phi = R.to_euler_angles(axis=euler)
                self.rotate_euler(ortoedre2,psi=psi,theta=theta,phi=phi,axis=euler,canonica=False,reverse=reverse)</code></pre>
</details>
<div class="desc"><p>Draws an animation of a vector rotating around a vectorial line</p>
<h2 id="parameters">Parameters</h2>
<p>centre: center of the orthohedron</p>
<p>costats: half sides of the orthohedron</p>
<p>angle: angle of rotation</p>
<p>radians: if True the Euler's angles must in radians. If False in degrees</p>
<p>vector: generator of the vectorial line</p>
<p>opacity: opacity of the orthohedron</p>
<p>euler: None or the value of the three Euler's axis</p>
<p>reverse: if True, shows the rotation with Euler's angles in reverse order</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rotacio_punt"><code class="name flex">
<span>def <span class="ident">rotacio_punt</span></span>(<span>self,<br>punt=Vector((6.0, 8.0, 5.0)),<br>origen=Vector((4.0, 3.0, 0.0)),<br>angle=360,<br>eix=Vector((1.0, 1.0, 1.0)),<br>length=None,<br>stop=0,<br>vectors=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotacio_punt(self,punt=Vector([6,8,5]),origen=Vector([4,3,0]),angle=360,eix=Vector([1,1,1]),length=None,stop=0,vectors=True):
        &#34;&#34;&#34;
        Draws an animation of a point rotating around an afine line
        Parameters:
                punt: point to rotate

                origen: point of the affine line

                eix: axis of rotation, given by a vector or by X, Y or Z
        &#34;&#34;&#34;
        if not isinstance(punt,Vector):
                punt = Vector(punt)
        if eix == &#39;X&#39;:
                u = Vector([1,0,0])
        elif eix == &#39;Y&#39;:
                u = Vector([0,1,0])
        elif eix == &#39;Z&#39;:
                u = Vector([0,0,1])
        elif isinstance(eix,Vector):
                u = eix
        else:
                u = Vector(eix)

        if not isinstance(origen,Vector):
                origen = Vector(origen)
        e = (punt-origen).project(u)
        l = e.length
        if length is not None:
                l = length
        self.base_canonica(length=l)
        self.rotate_point(punt,origen,u,angle=angle,length=l,stop=stop,vectors=vectors)</code></pre>
</details>
<div class="desc"><p>Draws an animation of a point rotating around an afine line</p>
<h2 id="parameters">Parameters</h2>
<p>punt: point to rotate</p>
<p>origen: point of the affine line</p>
<p>eix: axis of rotation, given by a vector or by X, Y or Z</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rotacio_vector"><code class="name flex">
<span>def <span class="ident">rotacio_vector</span></span>(<span>self,<br>vector=Vector((6.0, 8.0, 5.0)),<br>eix=Vector((1.0, 1.0, 1.0)),<br>angle=360,<br>stop=0,<br>adaptada=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def rotacio_vector(self,vector=Vector([6,8,5]),eix=Vector([1,1,1]),angle=360,stop=0,adaptada=False):
            &#34;&#34;&#34;
            Draws an animation of a vector rotating around a vectorial line
            Parameters:
                    vector: vector to rotate

                    eix: axis of rotation, given by a vector or by X, Y or Z

                    adaptada: if True, draws a base adapted to the rotation
            &#34;&#34;&#34;
            if not isinstance(vector,Vector):
                    vector = Vector(vector)
            if eix == &#39;X&#39;:
                    u = Vector([1,0,0])
            elif eix == &#39;Y&#39;:
                    u = Vector([0,1,0])
            elif eix == &#39;Z&#39;:
                    u = Vector([0,0,1])
            elif isinstance(eix,Vector):
                    u = eix
            else:
                    u = Vector(eix)
            e = vector.project(eix)
            l = e.length
            if l &lt; 18:
                    l = 18
            if adaptada:
                    self.base_adaptada(axis=eix,length=l,scale=0.1)
            self.base_canonica(length=l)
            self.rotate_vector(vector,eix,length=l,angle=angle,stop=stop)
#</code></pre>
</details>
<div class="desc"><p>Draws an animation of a vector rotating around a vectorial line</p>
<h2 id="parameters">Parameters</h2>
<p>vector: vector to rotate</p>
<p>eix: axis of rotation, given by a vector or by X, Y or Z</p>
<p>adaptada: if True, draws a base adapted to the rotation</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rotate_euler"><code class="name flex">
<span>def <span class="ident">rotate_euler</span></span>(<span>self,<br>obj=None,<br>psi=0.0,<br>theta=0.0,<br>phi=0.0,<br>frames=3,<br>axis='ZXZ',<br>amax=15,<br>scaleaxis=0.075,<br>reverse=False,<br>local=False,<br>stop=0,<br>radians=False,<br>canonica=True,<br>positive=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_euler(self,obj=None,psi=0.0,theta=0.0,phi=0.0,frames=3,axis=&#39;ZXZ&#39;,amax=15,scaleaxis=0.075,reverse=False,local=False,stop=0,radians=False,canonica=True,positive=False):
        &#34;&#34;&#34;
        Rotates an object by the Euler angles psi, theta and phi
        Parameters:
           object: the object

           psi, theta, phi: the Euler angles expressed in degrees

           axis: it must be &#39;XYZ&#39;, &#39;XZY&#39;, &#39;YXZ&#39;, &#39;YZX&#39;, &#39;ZXY&#39;, &#39;ZYX&#39;, &#39;XYX&#39;, &#39;XZX&#39;, &#39;YXY&#39;, &#39;YZY&#39;, &#39;ZXZ&#39; or &#39;ZYZ&#39;

           amax: axis value for draw_base_axis

           scaleaxis: scale value for draw_base_axis

           local: if True the center of rotation is the location of the object

           radians: if True, psi, theta and phi must be in radians

           positive: if False and psi, theta or phi are greather than 180 degrees, they are converted
                     to negative angles
        &#34;&#34;&#34;
        def vector_from_axis(axis):
                if axis == &#39;X&#39;:
                        return Vector([1,0,0])
                if axis == &#39;Y&#39;:
                        return Vector([0,1,0])
                if axis == &#39;Z&#39;:
                        return Vector([0,0,1])
                return None

        if obj is None or axis is None:
                return None

        if not isinstance(axis,str):
                return None

        axis = axis.upper()
        if axis not in (&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,&#39;XYX&#39;,&#39;XZX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;):
                return None

        u1 = vector_from_axis(axis[0])
        u2 = vector_from_axis(axis[1])
        u3 = vector_from_axis(axis[2])

        if radians:
                psi *= 180/math.pi
                theta *= 180/math.pi
                phi *= 180/math.pi
        if positive:
                if psi &lt; 0.0:
                        psi += 360
                if theta &lt; 0.0:
                        theta += 360
                if phi &lt; 0.0:
                        phi += 360
        else:
                if psi &gt; 180.0:
                        psi -= 360
                if theta &gt; 180.0:
                        theta -= 360
                if phi &gt; 180.0:
                        phi -= 360

        if reverse:
                self.set_colors([&#34;OrangeRedDark&#34;,&#34;Yellow&#34;,&#34;Magenta&#34;])
                axis = self.draw_base_axis(axis=amax,scale=scaleaxis,positive=False,name=&#34;Eixos transformats&#34;)
                obj = self.join([obj,axis])
                u1, u2, u3 = u3, u2, u1
                psi, theta, phi = phi, theta, psi
                s = Rotation(psi,u1)
                u2 = s.apply(u2)
                u3 = s.apply(u3)
                s = Rotation(theta,u2)
                u3 = s.apply(u3)
        elif canonica:
                self.draw_base_axis(axis=amax,scale=scaleaxis,positive=False,name=&#34;Base canònica&#34;)

        bpy.context.scene.frame_set(self.frame)
        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        if not local:
                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
        fn = frames + self.frame
        if psi &gt; 0:
                num = int(psi)
        elif psi &lt; 0:
                num = int(-psi)
        alfa = psi / num
        r = Rotation(alfa,u1)
        for i in range(num):
                bpy.context.scene.frame_set(fn)
                obj.rotation_quaternion.rotate(r.quaternion)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if not local:
                        w = obj.location
                        w.rotate(r.quaternion)
                        obj.location = w
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn += frames

        if theta &gt; 0:
                num = int(theta)
        elif theta &lt; 0:
                num = int(-theta)
        alfa = theta / num
        r = Rotation(alfa,u2)
        for i in range(num):
                bpy.context.scene.frame_set(fn)
                obj.rotation_quaternion.rotate(r.quaternion)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if not local:
                        w = obj.location
                        w.rotate(r.quaternion)
                        obj.location = w
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn += frames

        if phi &gt; 0:
                num = int(phi)
        elif phi &lt; 0:
                num = int(-phi)
        alfa = phi / num
        r = Rotation(alfa,u3)
        for i in range(num):
                bpy.context.scene.frame_set(fn)
                obj.rotation_quaternion.rotate(r.quaternion)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if not local:
                        w = obj.location
                        w.rotate(r.quaternion)
                        obj.location = w
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn += frames

        self.frame = fn - frames
        bpy.context.scene.frame_end = self.frame + stop
        bpy.context.scene.frame_set(0)
        bpy.context.view_layer.update()</code></pre>
</details>
<div class="desc"><p>Rotates an object by the Euler angles psi, theta and phi</p>
<h2 id="parameters">Parameters</h2>
<p>object: the object</p>
<p>psi, theta, phi: the Euler angles expressed in degrees</p>
<p>axis: it must be 'XYZ', 'XZY', 'YXZ', 'YZX', 'ZXY', 'ZYX', 'XYX', 'XZX', 'YXY', 'YZY', 'ZXZ' or 'ZYZ'</p>
<p>amax: axis value for draw_base_axis</p>
<p>scaleaxis: scale value for draw_base_axis</p>
<p>local: if True the center of rotation is the location of the object</p>
<p>radians: if True, psi, theta and phi must be in radians</p>
<p>positive: if False and psi, theta or phi are greather than 180 degrees, they are converted
to negative angles</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rotate_object"><code class="name flex">
<span>def <span class="ident">rotate_object</span></span>(<span>self,<br>obj=None,<br>axis='Z',<br>frames=1,<br>origin=Vector((0.0, 0.0, 0.0)),<br>angle=360,<br>localaxis=None,<br>localangle=None,<br>translation=0.0,<br>rounds=1,<br>stop=0,<br>length=25,<br>draw=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_object(self,obj=None,axis=&#39;Z&#39;,frames=1,origin=Vector([0,0,0]),angle=360,localaxis=None,localangle=None,translation=0.0,rounds=1,stop=0,length=25,draw=True):
        &#34;&#34;&#34;
        Rotates an object around the axis
        Parameters:
           obj: the object

           axis: it must be &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39; or a Vector

           frames: increment of the frame set

           traslation: tranlation by round

           local: if True the center of rotation is the location of the object
        &#34;&#34;&#34;
        if obj is None:
                return None
        if not isinstance(origin,Vector):
                origin = Vector(origin)
        if isinstance(axis,str):
                axis = axis.strip().upper()
        if axis == &#39;X&#39;:
                u = Vector([1,0,0])
        elif axis == &#39;Y&#39;:
                u = Vector([0,1,0])
        elif axis == &#39;Z&#39;:
                u = Vector([0,0,1])
        elif isinstance(axis,Vector):
                u = axis
        else:
                u = Vector(axis)

        if angle != 360:
                rounds = 1

        line = None
        if localaxis is not None and localangle is not None:
                old = self.origin
                self.set_origin(obj.location)
                l = obj.dimensions.length / 2
                line = self.draw_vector(vector=localaxis,axis=l,scale=0.1,arrow=False,positive=False,color=&#34;Orange&#34;,name=&#34;Eix rotació local&#34;)
                line.select_set(True)
                bpy.ops.object.origin_set(type=&#39;ORIGIN_CENTER_OF_MASS&#39;, center=&#39;MEDIAN&#39;)
                line.select_set(False)
                self.set_origin(old)
                lr = Rotation(localangle,localaxis)
        if draw:
                self.set_origin(origin)
                self.draw_vector(vector=u,axis=length,positive=False,color=&#34;White&#34;)
                self.set_origin()
        r = Rotation(1/int(frames),u)
        axis, alpha = r.to_axis_angle()
        axis.normalize()
        t =  translation / (alpha * int(frames) * int(angle)) * axis
        bpy.context.scene.frame_set(self.frame)
        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
        fn = self.frame + 1
        for i in range(int(frames) * int(rounds) * int(angle)):
                bpy.context.scene.frame_set(fn)
                if line is None:
                        obj.rotation_quaternion.rotate(r.quaternion)
                else:
                        obj.rotation_quaternion.rotate(lr.quaternion)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                w = obj.location - origin
                w.rotate(r.quaternion)
                obj.location = origin + w + t
                if line is not None:
                        line.location = origin + w + t
                        line.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn += 1
        self.frame = fn - frames
        bpy.context.scene.frame_end = self.frame + stop
        bpy.context.scene.frame_set(0)
        bpy.context.view_layer.update()</code></pre>
</details>
<div class="desc"><p>Rotates an object around the axis</p>
<h2 id="parameters">Parameters</h2>
<p>obj: the object</p>
<p>axis: it must be 'X', 'Y', 'Z' or a Vector</p>
<p>frames: increment of the frame set</p>
<p>traslation: tranlation by round</p>
<p>local: if True the center of rotation is the location of the object</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rotate_object_by_axis_angle"><code class="name flex">
<span>def <span class="ident">rotate_object_by_axis_angle</span></span>(<span>self,<br>obj=None,<br>axis=Vector((1.0, 0.0, 0.0)),<br>angle=90,<br>amax=15,<br>frames=1,<br>scaleaxis=0.075,<br>local=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_object_by_axis_angle(self,obj=None,axis=Vector([1,0,0]),angle=90,amax=15,frames=1,scaleaxis=0.075,local=False):
        &#34;&#34;&#34;
        Rotates an object around an angle &#39;angle&#39; around the axis
        Parameters:
           obj: the object

           axis: any non nul Vector

           angle: the angle of rotation in degrees

           frames: increment of the frame set

           scaleaxis: scale value for draw_base_axis

           local: if True the center of rotation is the location of the object
        &#34;&#34;&#34;
        if obj is None:
                return None
        if isinstance(axis,Vector):
                u = axis
        else:
                u = Vector(axis)
        if u.length == 0.0 or angle &lt;= 1:
                return

        self.draw_base_axis(axis = amax,scale=scaleaxis,positive=False,name=&#34;Base canònica&#34;)
        self.draw_vector(vector=u,scale=0.1,axis=amax,positive=False,color=&#34;White&#34;,name=&#34;Eix rotació&#34;)

        num = int(angle)
        alfa = angle / num
        r = Rotation(alfa,u)
        bpy.context.scene.frame_set(self.frame)
        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
        if not local:
                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
        fn = frames + self.frame

        for i in range(num):
                bpy.context.scene.frame_set(fn)
                obj.rotation_quaternion.rotate(r.quaternion)
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                if not local:
                        w = obj.location
                        w.rotate(r.quaternion)
                        obj.location = w
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn += frames
        self.frame = fn - frames
        bpy.context.scene.frame_end = self.frame
        bpy.context.scene.frame_set(0)
        bpy.context.view_layer.update()</code></pre>
</details>
<div class="desc"><p>Rotates an object around an angle 'angle' around the axis</p>
<h2 id="parameters">Parameters</h2>
<p>obj: the object</p>
<p>axis: any non nul Vector</p>
<p>angle: the angle of rotation in degrees</p>
<p>frames: increment of the frame set</p>
<p>scaleaxis: scale value for draw_base_axis</p>
<p>local: if True the center of rotation is the location of the object</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rotate_objects"><code class="name flex">
<span>def <span class="ident">rotate_objects</span></span>(<span>self,<br>objs=[],<br>axis='Z',<br>angle=None,<br>frames=1,<br>origin=Vector((0.0, 0.0, 0.0)),<br>translation=0,<br>rounds=1,<br>length=25,<br>stop=0,<br>draw=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_objects(self,objs=[],axis=&#39;Z&#39;,angle=None,frames=1,origin=Vector([0,0,0]),translation=0,rounds=1,length=25,stop=0,draw=False):
        &#34;&#34;&#34;
        Rotates an object around the axis
        Parameters:
           objs: the list of objects

           axis: it must be &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39; or a Vector

           angle: angle of rotation

           frames: number of frames between

           origin: origin of rotation

           translation: translation betwwen intial and final positions
        &#34;&#34;&#34;
        if objs is None or (not isinstance(objs,list) and not isinstance(objs,tuple)):
                return None
        if not isinstance(origin,Vector):
                origin = Vector(origin)
        if isinstance(axis,str):
                axis = axis.strip().upper()
        if axis == &#39;X&#39;:
                u = Vector([1,0,0])
        elif axis == &#39;Y&#39;:
                u = Vector([0,1,0])
        elif axis == &#39;Z&#39;:
                u = Vector([0,0,1])
        elif isinstance(axis,Vector):
                u = axis
        else:
                u = Vector(axis)

        if angle is None:
                angle = 360
        else:
                rounds = 1

        if draw:
                self.draw_vector(origin=origin,vector=u,axis=length,positive=False,color=&#34;White&#34;)
        r = Rotation(1/int(frames),u)
        axis, alfa = r.to_axis_angle()
        axis.normalize()
        t =  translation / (alfa * int(frames) * angle) * u
        bpy.context.scene.frame_set(self.frame)
        for obj in objs:
                obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
        fn = self.frame + 1
        for i in range(int(frames) * int(rounds) * angle):
                for obj in objs:
                        bpy.context.scene.frame_set(fn)
                        obj.rotation_quaternion.rotate(r.quaternion)
                        obj.keyframe_insert(data_path=&#34;rotation_quaternion&#34;,index=-1)
                        w = obj.location - origin
                        w.rotate(r.quaternion)
                        obj.location = origin + w + t
                        obj.keyframe_insert(data_path=&#34;location&#34;,index=-1)
                fn += 1
        self.frame = fn - frames
        bpy.context.scene.frame_end = self.frame + stop
        bpy.context.scene.frame_set(0)
        bpy.context.view_layer.update()</code></pre>
</details>
<div class="desc"><p>Rotates an object around the axis</p>
<h2 id="parameters">Parameters</h2>
<p>objs: the list of objects</p>
<p>axis: it must be 'X', 'Y', 'Z' or a Vector</p>
<p>angle: angle of rotation</p>
<p>frames: number of frames between</p>
<p>origin: origin of rotation</p>
<p>translation: translation betwwen intial and final positions</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rotate_point"><code class="name flex">
<span>def <span class="ident">rotate_point</span></span>(<span>self,<br>punt=None,<br>origen=Vector((0.0, 0.0, 0.0)),<br>axis='Z',<br>angle=360,<br>length=20,<br>stop=0,<br>vectors=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_point(self,punt=None,origen=Vector([0,0,0]),axis=&#39;Z&#39;,angle=360,length=20,stop=0,vectors=True):
        &#34;&#34;&#34;
        Rotates a point around an affine line
        Parameters:
           point: the point

           origen: a point of the affine line

           axis: it must be &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39; or a vector

           length: length of the
        &#34;&#34;&#34;
        draw = False
        if punt is None:
                return None
        if axis == &#39;X&#39;:
                u = Vector([1,0,0])
        elif axis == &#39;Y&#39;:
                u = Vector([0,1,0])
        elif axis == &#39;Z&#39;:
                u = Vector([0,0,1])
        elif isinstance(axis,Vector):
                u = axis
        else:
                u = Vector(axis)

        if not isinstance(origen,Vector):
                origen = Vector(origen)

        self.draw_point(radius=0.2,location=punt,name=&#34;Blue&#34;,color=&#34;Blue&#34;)
        obj = self.draw_point(radius=0.2,location=punt,name=&#34;Red&#34;,color=&#34;Red&#34;)
        if vectors:
                self.set_origin(origen)
                self.draw_vector(vector=punt-origen,name=&#34;VBlack&#34;,color=&#34;Black&#34;)
                obj2 = self.draw_vector(vector=punt-origen,name=&#34;VRed&#34;,color=&#34;Red&#34;)
        w1 = u.orthogonal().normalized()
        vec1 = (punt-origen).project(u)
        center = origen + vec1
        radius = (center-punt).length
        w3 = vec1.normalized()
        w2 = w3.cross(w1)
        a = vec1.length
        b = (punt-origen-vec1).length
        p2 = b**2/a**2
        self.reset()
        if vectors:
                self.rotate_objects([obj,obj2],u,angle=angle,origin=origen,length=length,stop=stop,draw=True)
        else:
                self.rotate_object(obj,u,origin=origen,angle=angle,stop=stop,length=length)
        self.draw_circle(center=center,u1=w1,u2=w2,radius=radius,name=&#34;Circumferència&#34;,steps=128,color=&#34;Yellow&#34;)
        self.cone(o=origen,u1=w1,u2=w2,a2=p2,b2=p2,c2=1,half=True, principal=False,canonica=False,xmax=b,color=&#34;GrayLight&#34;,opacity=0.25,thickness=0.01)
        self.reset()</code></pre>
</details>
<div class="desc"><p>Rotates a point around an affine line</p>
<h2 id="parameters">Parameters</h2>
<p>point: the point</p>
<p>origen: a point of the affine line</p>
<p>axis: it must be 'X', 'Y', 'Z' or a vector</p>
<p>length: length of the</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.rotate_vector"><code class="name flex">
<span>def <span class="ident">rotate_vector</span></span>(<span>self, vector=None, axis='Z', length=25, angle=360, stop=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_vector(self,vector=None,axis=&#39;Z&#39;,length=25,angle=360,stop=0):
        &#34;&#34;&#34;
        Rotates a vector around the axis
        Parameters:
           vector: the vector

           axis: it must be &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39; or a vector
        &#34;&#34;&#34;
        draw = False
        if vector is None:
                return None
        if axis == &#39;X&#39;:
                u = Vector([1,0,0])
        elif axis == &#39;Y&#39;:
                u = Vector([0,1,0])
        elif axis == &#39;Z&#39;:
                u = Vector([0,0,1])
        elif isinstance(axis,Vector):
                u = axis
        else:
                u = Vector(axis)
        self.draw_vector(vector=vector,color=&#34;Black&#34;,scale=0.1,name=&#34;Vector inicial&#34;)
        obj = self.draw_vector(vector=vector,color=&#34;Red&#34;,scale=0.1,name=&#34;Vector que gira&#34;)
        w1 = u.orthogonal().normalized()
        vec1 = vector.project(u)
        w3 = vec1.normalized()
        w2 = w3.cross(w1)
        a = vec1.length
        b = (vector-vec1).length
        p2 = b**2/a**2
        self.rotate_object(obj,u,angle=angle,stop=stop,length=length)
        self.cone(u1=w1,u2=w2,a2=p2,b2=p2,c2=1,half=True, principal=False,canonica=False,xmax=b,color=&#34;GrayLight&#34;,opacity=0.7,thickness=0.04)</code></pre>
</details>
<div class="desc"><p>Rotates a vector around the axis</p>
<h2 id="parameters">Parameters</h2>
<p>vector: the vector</p>
<p>axis: it must be 'X', 'Y', 'Z' or a vector</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.segment_esferic"><code class="name flex">
<span>def <span class="ident">segment_esferic</span></span>(<span>self,<br>r=10,<br>p1=1.5707963267948966,<br>s1=0,<br>p2=1.5707963267948966,<br>s2=1.5707963267948966,<br>name='Segment')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def segment_esferic(self,r=10,p1=math.pi/2,s1=0,p2=math.pi/2,s2=math.pi/2,name=&#34;Segment&#34;):
        &#34;&#34;&#34;
        Draws an spheric segment in a sphere centered at origin with radius r from the point
        whith spherical coordinates (radi,p1,s1) to the point (radi,p2,s2).
        Parameters:
           r: radius of the sphere
           p1: polar angle of the first point
           s1: azimuthal angle of the first point
           p2: polar angle of the second point
           s2: azimuthal angle of the second point
        &#34;&#34;&#34;
        x = Vector([r*math.sin(p1)*math.cos(s1),r*math.sin(p1)*math.sin(s1),r*math.cos(p1)])
        y = Vector([r*math.sin(p2)*math.cos(s2),r*math.sin(p2)*math.sin(s2),r*math.cos(p2)])
        R = EuclideanReference(u1=x,u2=y)
        x1 = R.coordinates(x)
        y1 = R.coordinates(y)
        b = R.base()
        t0 = math.atan2(x1[1],x1[0])
        t1 = math.atan2(y1[1],y1[0])
        def F(t):
                x = r*math.cos(t)
                y = r*math.sin(t)
                z = 0
                return (x,y,z)
        c = self.draw_curve(F,tmin=t0,tmax=t1,steps=256,thickness=0.05,color=&#34;Red&#34;,name=name,u1=b[0],u2=b[1])
        return c</code></pre>
</details>
<div class="desc"><p>Draws an spheric segment in a sphere centered at origin with radius r from the point
whith spherical coordinates (radi,p1,s1) to the point (radi,p2,s2).</p>
<h2 id="parameters">Parameters</h2>
<p>r: radius of the sphere
p1: polar angle of the first point
s1: azimuthal angle of the first point
p2: polar angle of the second point
s2: azimuthal angle of the second point</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.set_base"><code class="name flex">
<span>def <span class="ident">set_base</span></span>(<span>self, base=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], orthonormal=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_base(self,base=[[1,0,0],[0,1,0],[0,0,1]],orthonormal=False):
        &#34;&#34;&#34;
        Sets the self.base, i.e., the basis of the reference coordinates used to display
        objects
        Parameters:
           base: list of three vectors

           orthonormal: if True, the Gram-Schmidt method is applied and the vectors
           are normalized.
        &#34;&#34;&#34;
        if orthonormal:
                u1 = base[0]
                u2 = base[1]
                if isinstance(u1,Vector):
                        v1 = u1
                else:
                        v1 = Vector(u1)
                if isinstance(u2,Vector):
                        v2 = u2
                else:
                        v2 = Vector(u2)
                v2 = v2 - v2.project(v1)
                v1.normalize()
                v2.normalize()
                v3 = v1.cross(v2)
                self.base=[v1,v2,v3]
        else:
                self.base = base</code></pre>
</details>
<div class="desc"><p>Sets the self.base, i.e., the basis of the reference coordinates used to display
objects</p>
<h2 id="parameters">Parameters</h2>
<p>base: list of three vectors</p>
<p>orthonormal: if True, the Gram-Schmidt method is applied and the vectors
are normalized.</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.set_colors"><code class="name flex">
<span>def <span class="ident">set_colors</span></span>(<span>self, names=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_colors(self,names=None):
        &#34;&#34;&#34;
        Set self.colors to the list of colors with names &#39;names&#39;
        Parameters:
           names: list of name colors
        &#34;&#34;&#34;
        if names is None:
                self.colors = Colors.colors([&#34;Red&#34;,&#34;GreenDarkHard&#34;,&#34;Blue&#34;])
        else:
                self.colors = Colors.colors(names)</code></pre>
</details>
<div class="desc"><p>Set self.colors to the list of colors with names 'names'</p>
<h2 id="parameters">Parameters</h2>
<p>names: list of name colors</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.set_cursor"><code class="name flex">
<span>def <span class="ident">set_cursor</span></span>(<span>self, origin=[0, 0, 0], direction=[1, 0, 0], axis='x')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cursor(self,origin=[0,0,0],direction=[1,0,0],axis=&#39;x&#39;):
        &#34;&#34;&#34;
        Sets the cursor position and direction
        Parameters:
          origin: position of the cursor

          direction: vector that indicates the direction of the axis &#39;axis&#39;

          axis: &#39;x&#39;, &#39;y&#39; or &#39;z&#39;
        &#34;&#34;&#34;
        axis = axis.lower()
        if axis not in [&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]:
                return
        eixos = {&#39;x&#39; : Vector([1,0,0]),
                         &#39;y&#39; : Vector([0,1,0]),
                         &#39;z&#39; : Vector([0,0,1])
        }
        if isinstance(direction,Vector):
                d = direction
        else:
                d = Vector(direction)
        x = eixos[axis]
        quaternion = x.rotation_difference(d)
        self.scene.cursor.location = origin
        self.scene.cursor.rotation_mode = &#39;QUATERNION&#39;
        self.scene.cursor.rotation_quaternion = quaternion</code></pre>
</details>
<div class="desc"><p>Sets the cursor position and direction</p>
<h2 id="parameters">Parameters</h2>
<p>origin: position of the cursor</p>
<p>direction: vector that indicates the direction of the axis 'axis'</p>
<p>axis: 'x', 'y' or 'z'</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.set_cursor_rotation"><code class="name flex">
<span>def <span class="ident">set_cursor_rotation</span></span>(<span>self,<br>origin=[0, 0, 0],<br>rotation=Matrix(((1.0, 0.0, 0.0),
(0.0, 1.0, 0.0),
(0.0, 0.0, 1.0))))</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cursor_rotation(self,origin=[0,0,0],rotation=Matrix.Identity(3)):
        &#34;&#34;&#34;
        Sets the rotation of the cursor
        Parameters:
           origin: position of the cursor

           rotation: matrix of a rotation
        &#34;&#34;&#34;
        m = rotation.copy()
        det = m.determinant()
        if abs(- det - 1.0) &lt; 0.1:
                m[2] = - m[2]
        quaternion = m.to_quaternion()
        self.scene.cursor.location = origin
        self.scene.cursor.rotation_mode = &#39;QUATERNION&#39;
        self.scene.cursor.rotation_quaternion = quaternion.conjugated()</code></pre>
</details>
<div class="desc"><p>Sets the rotation of the cursor</p>
<h2 id="parameters">Parameters</h2>
<p>origin: position of the cursor</p>
<p>rotation: matrix of a rotation</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.set_default_color"><code class="name flex">
<span>def <span class="ident">set_default_color</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_default_color(self,name):
        &#34;&#34;&#34;
        Set self.defaultcolor to the color with name &#39;name&#39;
        Parameters:
           name: name of a color
        &#34;&#34;&#34;
        self.defaultcolor = name</code></pre>
</details>
<div class="desc"><p>Set self.defaultcolor to the color with name 'name'</p>
<h2 id="parameters">Parameters</h2>
<p>name: name of a color</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.set_origin"><code class="name flex">
<span>def <span class="ident">set_origin</span></span>(<span>self, vector=[0, 0, 0])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_origin(self,vector=[0,0,0]):
        &#34;&#34;&#34;
        Sets the origin of the reference coordinates used to display objects.
        Parameters:
           vector: origin&#39;s position
        &#34;&#34;&#34;
        if isinstance(vector,Vector):
                v1 = vector.copy()
        else:
                v1 = Vector(vector)
        self.origin = v1</code></pre>
</details>
<div class="desc"><p>Sets the origin of the reference coordinates used to display objects.</p>
<h2 id="parameters">Parameters</h2>
<p>vector: origin's position</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.set_rotation"><code class="name flex">
<span>def <span class="ident">set_rotation</span></span>(<span>self, angle=None, vector=None, quaternion=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_rotation(self,angle=None,vector=None,quaternion=None):
        &#34;&#34;&#34;
        Sets self.rotation to the rotation defined by an angle and an axis or
        by a quaternion.
        Parameters:
           angle: angle of rotation in degrees

           vector: axis of rotation

           quaternion: quaternion that defines a rotation

        The angle and vector takes precedence over the quaternion
        &#34;&#34;&#34;
        if angle is not None:
                self.rotation = Rotation(angle,vector)
        elif quaternion is not None:
                self.rotation = Rotation(quaternion=quaternion)
        else:
                self.rotation = Rotation(0,[1,0,0])</code></pre>
</details>
<div class="desc"><p>Sets self.rotation to the rotation defined by an angle and an axis or
by a quaternion.</p>
<h2 id="parameters">Parameters</h2>
<p>angle: angle of rotation in degrees</p>
<p>vector: axis of rotation</p>
<p>quaternion: quaternion that defines a rotation</p>
<p>The angle and vector takes precedence over the quaternion</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.simple_curve"><code class="name flex">
<span>def <span class="ident">simple_curve</span></span>(<span>self,<br>f=None,<br>tmin=0.0,<br>tmax=1.0,<br>steps=25,<br>name='Simple curve',<br>symmetry=None,<br>draw=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simple_curve(self,f=None,tmin=0.0,tmax=1.0,steps=25,name=&#34;Simple curve&#34;,symmetry=None,draw=False):
        &#34;&#34;&#34;
        Return a curve defined by the parametrization f
        Parameters:
           f: Parametrization of the curve

           tmin: minimum value of the parameter

           tmax: maximum value of the parameter

           steps: number of steps

           name: name of the curve

           symmetry: None or a value in the list (&#39;XY&#39;,&#39;XZ&#39;,&#39;YZ&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;,&#39;O&#39;). Symmetry of the curve

           draw: if True, the curve is drawn
        &#34;&#34;&#34;
        if f is None:
                return None

        delta = (tmax - tmin)/steps
        t = tmin
        bm = bmesh.new()
        verts = []
        verts2 = []

        for k in range(steps + 1):
                p = f(t)
                q = None
                verts.append(bm.verts.new(p))
                if symmetry == &#39;XY&#39;:
                        q = (p[0],p[1],-p[2])
                elif symmetry == &#39;XZ&#39;:
                        q = (p[0],-p[1],p[2])
                elif symmetry == &#39;YZ&#39;:
                        q = (-p[0],p[1],p[2])
                elif symmetry == &#39;X&#39;:
                        q = (p[0],-p[1],-p[2])
                elif symmetry == &#39;Y&#39;:
                        q = (-p[0],p[1],-p[2])
                elif symmetry == &#39;Z&#39;:
                        q = (-p[0],-p[1],p[2])
                elif symmetry == &#39;O&#39;:
                        q = (-p[0],-p[1],-p[2])

                if q is not None:
                        verts2.append(bm.verts.new(q))
                t += delta
                if t &gt; tmax:
                        t = tmax

        for i in range(len(verts) - 1):
                bm.edges.new([verts[i], verts[i+1]])
                if len(verts2) &gt; 0:
                        bm.edges.new([verts2[i], verts2[i+1]])

        me = bpy.data.meshes.new(&#39;placeholder_mesh&#39;)
        obj = bpy.data.objects.new(name,me)
        bm.to_mesh(me)
        bm.free()

        if draw:
                self.scene.collection.objects.link(obj)
        bpy.context.view_layer.objects.active = None
        return obj</code></pre>
</details>
<div class="desc"><p>Return a curve defined by the parametrization f</p>
<h2 id="parameters">Parameters</h2>
<p>f: Parametrization of the curve</p>
<p>tmin: minimum value of the parameter</p>
<p>tmax: maximum value of the parameter</p>
<p>steps: number of steps</p>
<p>name: name of the curve</p>
<p>symmetry: None or a value in the list ('XY','XZ','YZ','X','Y','Z','O'). Symmetry of the curve</p>
<p>draw: if True, the curve is drawn</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.sphere"><code class="name flex">
<span>def <span class="ident">sphere</span></span>(<span>self,<br>o=[0, 0, 0],<br>r2=1,<br>principal=True,<br>canonica=True,<br>color='AzureBlueDark',<br>name='Sphere',<br>cmax=15,<br>pmax=15,<br>thickness=0.02,<br>opacity=1.0,<br>preserve=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sphere(self,o=[0,0,0],r2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;Sphere&#34;,cmax=15,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
        &#34;&#34;&#34;
        Draws a sphere of center &#39;o&#39; and radius squared equal to &#39;r2&#39;
        Parameters:
           o: center of the sphere

           r2: radius of the sphere squared

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the sphere

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the sphere

           opacity: opacity of the sphere

           preserve: Keep self.origin and self.base as the principal reference
        &#34;&#34;&#34;
        u1 = Vector([1,0,0])
        u2 = Vector([0,1,0])
        return self.ellipsoid(o=o,u1=u1,u2=u2,a2=r2,b2=r2,c2=r2,principal=principal,canonica=canonica,color=color,name=name,cmax=cmax,pmax=pmax,thickness=thickness,opacity=opacity,preserve=preserve)</code></pre>
</details>
<div class="desc"><p>Draws a sphere of center 'o' and radius squared equal to 'r2'</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the sphere</p>
<p>r2: radius of the sphere squared</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the sphere</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the sphere</p>
<p>opacity: opacity of the sphere</p>
<p>preserve: Keep self.origin and self.base as the principal reference</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.superficie_revolucio_parabola"><code class="name flex">
<span>def <span class="ident">superficie_revolucio_parabola</span></span>(<span>self, a=0.2, vertex=Vector((0.0, 0.0, 0.0)), pmax=8, pla='XZ', punt=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def superficie_revolucio_parabola(self,a=0.2,vertex=Vector([0,0,0]),pmax=8,pla=&#39;XZ&#39;,punt=None):
        &#34;&#34;&#34;
        Draws an animation of a revolution surface from a paràbola
        Parameters:
                a: the paràbola is of the form y = a*x^2

                vertex: vertex of the parabola

                pmax: maximum value of the independent variable

                pla: a value from the list (&#39;XY&#39;,&#39;YX&#39;,&#39;XZ&#39;,&#39;ZX&#39;,&#39;YZ&#39;,&#39;ZY&#39;) representing
                     the variables for the equation
                         &#39;XY&#39; y = a*x^2 and rotaqtion around the X axis
                         &#39;YX&#39; x = a*y^2 and rotaqtion around the Y axis
                         &#39;XZ&#39; z = a*x^2 and rotaqtion around the X axis
                         &#39;ZX&#39; x = a*x^2 and rotaqtion around the Z axis
                         &#39;YZ&#39; z = a*y^2 and rotaqtion around the Y axis
                         &#39;ZY&#39; y = a*z^2 and rotaqtion around the Z axis

                punt: punt: if it&#39;s a float value, draws a moving poing
        &#34;&#34;&#34;
        self.base_canonica()
        if not isinstance(vertex,Vector):
                vertex = Vector(vertex)
        def F(t):
                if pla.upper() == &#39;XZ&#39;:
                        return (vertex + Vector([t,0,a*t**2]))
                if pla.upper() == &#39;XY&#39;:
                        return (vertex + Vector([t,a*t**2,0]))
                if pla.upper() == &#39;ZX&#39;:
                        return (vertex + Vector([a*t**2,0,t]))
                if pla.upper() == &#39;ZY&#39;:
                        return (vertex + Vector([0,a*t**2,t]))
                if pla.upper() == &#39;YZ&#39;:
                        return (vertex + Vector([0,t,a*t**2]))
                if pla.upper() == &#39;YX&#39;:
                        return (vertex + Vector([a*t**2,t,0]))
        self.animate_revolution_surface(F,tmin=-pmax,tmax=pmax,steps=128,axis=pla[0],point=punt)</code></pre>
</details>
<div class="desc"><p>Draws an animation of a revolution surface from a paràbola</p>
<h2 id="parameters">Parameters</h2>
<p>a: the paràbola is of the form y = a*x^2</p>
<p>vertex: vertex of the parabola</p>
<p>pmax: maximum value of the independent variable</p>
<p>pla: a value from the list ('XY','YX','XZ','ZX','YZ','ZY') representing
the variables for the equation
'XY' y = a<em>x^2 and rotaqtion around the X axis
'YX' x = a</em>y^2 and rotaqtion around the Y axis
'XZ' z = a<em>x^2 and rotaqtion around the X axis
'ZX' x = a</em>x^2 and rotaqtion around the Z axis
'YZ' z = a<em>y^2 and rotaqtion around the Y axis
'ZY' y = a</em>z^2 and rotaqtion around the Z axis</p>
<p>punt: punt: if it's a float value, draws a moving poing</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.tor"><code class="name flex">
<span>def <span class="ident">tor</span></span>(<span>self, centre=Vector((8.0, 0.0, 3.0)), radi=3, cmax=15, punt=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tor(self,centre=Vector([8,0,3]),radi=3,cmax=15,punt=None):
        &#34;&#34;&#34;
        Draws a torus of revolution from a circumference
        Parameters:
                centre: center of the circumference

                radi: radius of the circumference

                cmax: maximum values of the x, y and z coordinates

                punt: if it&#39;s a float value, draws a moving poing
        &#34;&#34;&#34;
        self.base_canonica(length=cmax)
        if len(centre) == 2:
                centre = (centre[0],0,centre[1])
        if not isinstance(centre,Vector):
                centre = Vector(centre)
        def F(t):
                return (centre + Vector([radi*math.cos(t),0,radi*math.sin(t)]))
        self.animate_revolution_surface(F,tmin=0,tmax=2*math.pi,steps=128,axis=&#39;Z&#39;,point=punt)</code></pre>
</details>
<div class="desc"><p>Draws a torus of revolution from a circumference</p>
<h2 id="parameters">Parameters</h2>
<p>centre: center of the circumference</p>
<p>radi: radius of the circumference</p>
<p>cmax: maximum values of the x, y and z coordinates</p>
<p>punt: if it's a float value, draws a moving poing</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.triangle"><code class="name flex">
<span>def <span class="ident">triangle</span></span>(<span>self,<br>vertices=[[0, 0, 0], [1, 0, 0], [0, 1, 0]],<br>scalelines=0.075,<br>color='AzureBlueMedium',<br>linecolor='Blue',<br>name='Triangle',<br>baricentre=False,<br>factors=(2, 2, -2),<br>ortocentre=False,<br>circumcentre=False,<br>opacity=1.0,<br>radius=0.03)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangle(self,vertices=[[0,0,0],[1,0,0],[0,1,0]],scalelines=0.075,color=&#34;AzureBlueMedium&#34;,linecolor=&#34;Blue&#34;,name=&#34;Triangle&#34;,baricentre=False,factors=(2,2,-2),ortocentre=False,circumcentre=False,opacity=1.0,radius=0.03):
        &#34;&#34;&#34;
        Draws a triangle from the vertices
        Parameters:
           vertices: vertices of the triangle

           scalelines: scale of the edges of the triangle

           color: color of the triangle

           linecolor: color of the edges

           name: name of the triangle

           opacity: opacity of the triangle

           thickness: thickness of the triangle
        &#34;&#34;&#34;
        if len(vertices) != 3:
                return None
        if len(factors) != 3:
                return None
        v = [Vector(x) for x in vertices]
        if ortocentre:
                u1 = v[1]-v[0]
                u2 = v[2]-v[0]
                u3 = v[2] - v[1]
                p0 = v[1] - u1.project(u3)
                self.draw_line(start=v[0],end=v[0]+factors[0]*(p0-v[0]),scale=scalelines,name=&#34;Altura 1&#34;,color=&#34;White&#34;)
                p1 = v[2] - u3.project(u2)
                self.draw_line(start=v[1],end=v[1]+factors[1]*(p1-v[1]),scale=scalelines,name=&#34;Altura 2&#34;,color=&#34;White&#34;)
                p2 = v[0] + u2.project(u1)
                self.draw_line(start=v[2],end=v[2]+factors[2]*(p2-v[2]),scale=scalelines,name=&#34;Altura 3&#34;,color=&#34;White&#34;)

        if circumcentre:
                u1 = v[1] - v[0]
                u2 = v[2] - v[0]
                u3 = v[2] - v[1]
                w = u1.cross(u2)
                w.normalize()
                w01 = w.cross(u1)
                w02 = w.cross(u2)
                w12 = w.cross(u3)
                m12 = (v[2] + v[1])/2
                m01 = (v[0] + v[1])/2
                m02 = (v[2] + v[0])/2
                self.draw_line(start=m01,end=m01+factors[0]*w01,scale=scalelines,name=&#34;Mediatriu 1&#34;,color=&#34;White&#34;)
                self.draw_line(start=m02,end=m02+factors[1]*w02,scale=scalelines,name=&#34;Mediatriu 2&#34;,color=&#34;White&#34;)
                self.draw_line(start=m12,end=m12+factors[2]*w12,scale=scalelines,name=&#34;Mediatriu 3&#34;,color=&#34;White&#34;)
                p1 = self.draw_point(radius=radius,location=m01,name=&#34;Punt mitjà 1&#34;)
                p2 = self.draw_point(radius=radius,location=m02,name=&#34;Punt mitjà 2&#34;)
                p3 = self.draw_point(radius=radius,location=m12,name=&#34;Punt mitjà 3&#34;)

        if baricentre:
                m01 = (v[0]+v[1])/2
                m02 = (v[0]+v[2])/2
                m12 = (v[1]+v[2])/2
                m = (v[0]+v[1]+v[2])/3
                self.draw_line(start=v[0],end=m12,scale=scalelines,name=&#34;Mitjana 1&#34;,color=&#34;White&#34;)
                self.draw_line(start=v[1],end=m02,scale=scalelines,name=&#34;Mitjana 2&#34;,color=&#34;White&#34;)
                self.draw_line(start=v[2],end=m01,scale=scalelines,name=&#34;Mitjana 2&#34;,color=&#34;White&#34;)
        self.draw_triangle(origin=v[0],u1=v[1]-v[0],u2=v[2]-v[0],scalelines=scalelines,color=color,linecolor=linecolor,name=name,opacity=opacity,thickness=0.01)</code></pre>
</details>
<div class="desc"><p>Draws a triangle from the vertices</p>
<h2 id="parameters">Parameters</h2>
<p>vertices: vertices of the triangle</p>
<p>scalelines: scale of the edges of the triangle</p>
<p>color: color of the triangle</p>
<p>linecolor: color of the edges</p>
<p>name: name of the triangle</p>
<p>opacity: opacity of the triangle</p>
<p>thickness: thickness of the triangle</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.triangle_esferic"><code class="name flex">
<span>def <span class="ident">triangle_esferic</span></span>(<span>self,<br>r=10,<br>p1=1.5707963267948966,<br>s1=0,<br>p2=1.5707963267948966,<br>s2=1.5707963267948966,<br>p3=0,<br>s3=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangle_esferic(self,r=10,p1=math.pi/2,s1=0,p2=math.pi/2,s2=math.pi/2,p3=0,s3=0):
        &#34;&#34;&#34;
        Draws an spheric triangle in a sphere centered at origin with radius r  with vetices
        whith spherical coordinates (radi,p1,s1), (radi,p2,s2) and (radi,p2,s2).
        Parameters:
           r: radius of the sphere
           p1: polar angle of the first point
           s1: azimuthal angle of the first point
           p2: polar angle of the second point
           s2: azimuthal angle of the second point
           p3: polar angle of the third point
           s3: azimuthal angle of the third point
        &#34;&#34;&#34;
        es = self.esfera(r2=r**2,canonica=False,principal=False,thickness=0.001,name=&#34;Esfera&#34;)
        c1 = self.segment_esferic(r=r,p1=p1,s1=s1,p2=p2,s2=s2,name=&#34;Costat 1&#34;)
        c2 = self.segment_esferic(r=r,p1=p2,s1=s2,p2=p3,s2=s3,name=&#34;Costat 2&#34;)
        c3 = self.segment_esferic(r=r,p1=p3,s1=s3,p2=p1,s2=s1,name=&#34;Costat 3&#34;)</code></pre>
</details>
<div class="desc"><p>Draws an spheric triangle in a sphere centered at origin with radius r
with vetices
whith spherical coordinates (radi,p1,s1), (radi,p2,s2) and (radi,p2,s2).</p>
<h2 id="parameters">Parameters</h2>
<p>r: radius of the sphere
p1: polar angle of the first point
s1: azimuthal angle of the first point
p2: polar angle of the second point
s2: azimuthal angle of the second point
p3: polar angle of the third point
s3: azimuthal angle of the third point</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.triangle_esferic_aleatori"><code class="name flex">
<span>def <span class="ident">triangle_esferic_aleatori</span></span>(<span>self, r=10)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangle_esferic_aleatori(self,r=10):
        &#34;&#34;&#34;
        Draws a random spheric triangle in a sphere centered at origin with radius r
        Parameters:
           r: radius of the sphere
        &#34;&#34;&#34;
        std = math.pi/9
        mean = math.pi/2
        nums = np.random.normal(loc=mean, scale=std, size=20)
        nums = [x for x in nums if x &gt; 0 and x &lt; math.pi]
        p1, p2, p3 = nums[0:3]

        std = math.pi/6
        mean = 0
        nums = np.random.normal(loc=mean, scale=std, size=20)
        nums = [x for x in nums if x &lt; math.pi/2 and x &gt; -math.pi/2]
        s1, s2, s3 = nums[0:3]
        print(s1,s2,s3)
        self.triangle_esferic(r=r,p1=p1,s1=s1,p2=p2,s2=s2,p3=p3,s3=s3)</code></pre>
</details>
<div class="desc"><p>Draws a random spheric triangle in a sphere centered at origin with radius r</p>
<h2 id="parameters">Parameters</h2>
<p>r: radius of the sphere</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.two_sheets_hyperboloid"><code class="name flex">
<span>def <span class="ident">two_sheets_hyperboloid</span></span>(<span>self,<br>o=[0, 0, 0],<br>u1=[1, 0, 0],<br>u2=[0, 1, 0],<br>a2=1,<br>b2=1,<br>c2=1,<br>principal=True,<br>canonica=True,<br>color='AzureBlueDark',<br>name='TwoSheetParaboloid',<br>xmax=None,<br>cmax=15,<br>pmax=15,<br>thickness=0.02,<br>opacity=1.0,<br>preserve=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def two_sheets_hyperboloid(self,o=[0,0,0],u1=[1,0,0],u2=[0,1,0],a2=1,b2=1,c2=1,principal=True,canonica=True,color=&#34;AzureBlueDark&#34;,name=&#34;TwoSheetParaboloid&#34;,xmax=None,cmax=15,pmax=15,thickness=0.02,opacity=1.0,preserve=True):
        &#34;&#34;&#34;
        Draws a two sheets hyperboloid
        Parameters:
           o: center of the hyperboloid

           u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors

           a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x&#39;^2/a^2 + y&#39;^2/b^2 - z&#39;^2/c^2 = -1

           principal: if True, the principal axis are drawn

           canonica: if True, the canonical axis are drawn

           color: color of the surface

           name: name of the hyperboloid

           xmax: maximum value of the x coordinate

           cmax: the canonical axis are drawn between -cmax and cmax

           pmax: the principal axis are drawn between -cmax and cmax

           thickness: thickness of the hyperboloid

           opacity: opacity of the hyperboloid

           preserve: Keep self.origin and self.base as the principal reference
        &#34;&#34;&#34;
        axis1 = None
        axis2 = None
        q = self.vectors_to_quaternion(u1,u2)
        u = Quaternion([1,0,0,0])
        orig = [0,0,0]
        if q != u or o != orig:
                if canonica:
                        if principal:
                                self.colors = Colors.colors([&#34;White&#34;,&#34;White&#34;,&#34;White&#34;])
                        else:
                                self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
                        axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
                        self.colors = Colors.colors([&#34;Red&#34;,&#34;Green&#34;,&#34;Blue&#34;])
        elif canonica and not principal:
                axis1 = self.draw_base_axis(axis = cmax,positive=False,name=&#34;Referència canònica&#34;)
        self.set_origin(o)
        self.set_rotation(quaternion=q)
        if principal:
                axis2 = self.draw_base_axis(axis = pmax,positive=False,name=&#34;Referència principal&#34;)
        a = math.sqrt(a2)
        b = math.sqrt(b2)
        c = math.sqrt(c2)
        if xmax is None:
                xmax = 5.0/a + 2
        xmax /= a
        hy = self.draw_two_sheets_hyperboloid(a=1.0,b=1.0,xmin=0.0,xmax=xmax,color=color,scale=[a,b,c],name=name,thickness=thickness,opacity=opacity)
        if not preserve:
                self.set_origin()
                self.set_base()
                self.set_rotation()
        return axis1, axis2, hy</code></pre>
</details>
<div class="desc"><p>Draws a two sheets hyperboloid</p>
<h2 id="parameters">Parameters</h2>
<p>o: center of the hyperboloid</p>
<p>u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors</p>
<p>a2, b2, c2: squares of semi-axes of the hyperboloid. The equation is x'^2/a^2 + y'^2/b^2 - z'^2/c^2 = -1</p>
<p>principal: if True, the principal axis are drawn</p>
<p>canonica: if True, the canonical axis are drawn</p>
<p>color: color of the surface</p>
<p>name: name of the hyperboloid</p>
<p>xmax: maximum value of the x coordinate</p>
<p>cmax: the canonical axis are drawn between -cmax and cmax</p>
<p>pmax: the principal axis are drawn between -cmax and cmax</p>
<p>thickness: thickness of the hyperboloid</p>
<p>opacity: opacity of the hyperboloid</p>
<p>preserve: Keep self.origin and self.base as the principal reference</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.vector_base_canonica"><code class="name flex">
<span>def <span class="ident">vector_base_canonica</span></span>(<span>self, vector=Vector((-4.0, 7.0, 6.0)), length=12, name='Vector', components=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vector_base_canonica(self,vector=Vector([-4,7,6]),length=12,name=&#34;Vector&#34;,components=True):
        &#34;&#34;&#34;
        Draws a vector expressed in the canonical base
        Parameters:
           vector: the vector to draw

           length: length of the axis

           name: name of the vector

           components: if True draws lines representing the components
        &#34;&#34;&#34;
        self.base_canonica(length=length)
        if not isinstance(vector,Vector):
                vector = Vector(vector)
        self.draw_vector(vector=vector,name=name)
        if components:
                self.draw_components(vector,name=&#34;Components en base canònica&#34;)</code></pre>
</details>
<div class="desc"><p>Draws a vector expressed in the canonical base</p>
<h2 id="parameters">Parameters</h2>
<p>vector: the vector to draw</p>
<p>length: length of the axis</p>
<p>name: name of the vector</p>
<p>components: if True draws lines representing the components</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.vector_base_no_canonica"><code class="name flex">
<span>def <span class="ident">vector_base_no_canonica</span></span>(<span>self,<br>vector=Vector((5.0, 6.0, -5.0)),<br>origin=Vector((0.0, 0.0, 0.0)),<br>u1=Vector((-0.3333333432674408, -0.6666666865348816, 0.6666666865348816)),<br>u2=Vector((0.6666666865348816, 0.3333333432674408, 0.6666666865348816)),<br>u3=Vector((-0.6666666865348816, 0.6666666865348816, 0.3333333432674408)),<br>length=12,<br>scale=0.04,<br>name="Base B'",<br>canonica=True,<br>preserve=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vector_base_no_canonica(self,vector=Vector([5,6,-5]),origin=Vector([0,0,0]),u1=1/3*Vector([-1,-2,2]),u2=1/3*Vector([2,1,2]),u3=1/3*Vector([-2,2,1]),length=12,scale=0.04,name=&#34;Base B&#39;&#34;,canonica=True,preserve=False):
        &#34;&#34;&#34;
        Draws a vector expressed in the base {u1,u2,u3} with origin in the point origin and sets the default
        origin and default base to them
        Parameters:
                vector: vector to draw

                origin: origin of the vector and the base

                u1, u2, u3: vectors of the base

                length: length of the axis

                scale: scale of the base

                name: name of the base
        &#34;&#34;&#34;
        self.base_no_canonica(origin=origin,u1=u1,u2=u2,u3=u3,length=length,scale=scale,preserve=preserve,name=name)
        if not isinstance(vector,Vector):
                vector = Vector(vector)
        if canonica:
                vector = self.coordinates_en_referencia(vector)
        self.draw_vector(vector=vector,scale=0.06,head_height=0.25)
        self.draw_components(vector,scale=0.015,name=&#34;Components en base B&#39;&#34;)
        if not preserve:
                self.set_origin()
                self.set_base()
                self.set_rotation()</code></pre>
</details>
<div class="desc"><p>Draws a vector expressed in the base {u1,u2,u3} with origin in the point origin and sets the default
origin and default base to them</p>
<h2 id="parameters">Parameters</h2>
<p>vector: vector to draw</p>
<p>origin: origin of the vector and the base</p>
<p>u1, u2, u3: vectors of the base</p>
<p>length: length of the axis</p>
<p>scale: scale of the base</p>
<p>name: name of the base</p></div>
</dd>
<dt id="LinearAlgebra.LinearAlgebra.vectors_to_quaternion"><code class="name flex">
<span>def <span class="ident">vectors_to_quaternion</span></span>(<span>self, u1=Vector((1.0, 0.0, 0.0)), u2=Vector((0.0, 1.0, 0.0)))</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vectors_to_quaternion(self,u1=Vector([1,0,0]),u2=Vector([0,1,0])):
        &#34;&#34;&#34;
        Returns the quaternion correspondint to the base {v1,v2,v3}
        u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
               v1 = u1
                   v2 = u2 - u2.project(v1)
                   v1.normalize()
                   v2.normalize()
                   v3 = v1.cross(v2)
        &#34;&#34;&#34;
        if isinstance(u1,Vector):
                v1 = u1
        else:
                v1 = Vector(u1)
        if isinstance(u2,Vector):
                v2 = u2
        else:
                v2 = Vector(u2)
        v2 = v2 - v2.project(v1)
        v1.normalize()
        v2.normalize()
        v3 = v1.cross(v2)
        mat = Matrix([v1,v2,v3])
        mat.transpose()
        return mat.to_quaternion()</code></pre>
</details>
<div class="desc"><p>Returns the quaternion correspondint to the base {v1,v2,v3}
u1, u2: the principal basis {v1, v2, v3} is constructed from this vectors in the following way
v1 = u1
v2 = u2 - u2.project(v1)
v1.normalize()
v2.normalize()
v3 = v1.cross(v2)</p></div>
</dd>
</dl>
</dd>
<dt id="LinearAlgebra.Rotation"><code class="flex name class">
<span>class <span class="ident">Rotation</span></span>
<span>(</span><span>angle=None, vector=None, axis=None, quaternion=None, radians=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rotation():
        &#34;&#34;&#34;
    Class used for work with rotations. The stored value in the class is a quaternion
        &#34;&#34;&#34;
        def __init__(self,angle=None,vector=None,axis=None,quaternion=None,radians=False):
                &#34;&#34;&#34;
                Initializes the value for a rotation
                Parameters:
                   angle: angle of rotation

                   vector: axis of rotation

                   quaternion: The quaternion itself

                   radians: must be True if the angle is entered in radians and False if the
                            is entered in degrees.
                &#34;&#34;&#34;
                if vector is not None and axis is not None:
                        return
                if axis is not None:
                        if axis in (&#39;X&#39;,&#39;x&#39;):
                                vector = Vector([1,0,0])
                        elif axis in (&#39;Y&#39;,&#39;y&#39;):
                                vector = Vector([0,1,0])
                        elif axis in (&#39;Z&#39;,&#39;z&#39;):
                                vector = Vector([0,0,1])
                        else:
                                return

                if angle is not None:
                        if not radians:
                                angle = math.radians(angle)
                        if not isinstance(vector,Vector):
                                vector = Vector(vector)
                        self.quaternion = Quaternion(vector,angle)
                elif quaternion is not None:
                        self.quaternion = quaternion
                else:
                        self.quaternion = (1,0,0,0)
        #
        #
        #
        @classmethod
        def from_euler_angles(self,psi,theta,phi,axis=&#39;ZXZ&#39;,radians=False):
                &#34;&#34;&#34;
                Initializes a rotation from its Euler angles in the order ZXZ
                Parameters:
                   phi, theta, psi: Euler angles

                   axis: it must be &#39;XYZ&#39;, &#39;XZY&#39;, &#39;YXZ&#39;, &#39;YZX&#39;, &#39;ZXY&#39;, &#39;ZYX&#39;, &#39;XYX&#39;, &#39;XZX&#39;, &#39;YXY&#39;, &#39;YZY&#39;, &#39;ZXZ&#39; or &#39;ZYZ&#39;

                   radians: if radians, psi, theta and must be in radians
                &#34;&#34;&#34;
                if not radians:
                        phi = math.radians(phi)
                        theta = math.radians(theta)
                        psi = math.radians(psi)

                if axis is None:
                        return None
                if not isinstance(axis,str):
                        return None
                axis = axis.upper()
                if axis not in (&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,&#39;XYX&#39;,&#39;XZX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;):
                        return None

                r1 = Matrix.Rotation(psi,3,axis[0])
                r2 = Matrix.Rotation(theta,3,axis[1])
                r3 = Matrix.Rotation(phi,3,axis[2])
                m = r3 @ r2 @ r1
                q = m.to_quaternion()
                return self(quaternion=q)
        #
        #
        #
        def apply(self,v):
                &#34;&#34;&#34;
        Applies the rotation to an object v
                Parameters:
                   v: any object that can be transformed by a rotation
                &#34;&#34;&#34;
                return self.quaternion @ v
        #
        #
        #
        def to_axis_angle(self,radians=False):
                &#34;&#34;&#34;
                Returns the axis and angle of the rotation
                Parameters:
                   radians: if True, the angle returned is in radians, if not, is
                            returned in degrees
                &#34;&#34;&#34;
                v, alpha = self.quaternion.to_axis_angle()
                if radians:
                        return v, alpha
                return v, 180*alpha/math.pi
        #
        #
        #
        def to_euler_angles(self,axis=&#39;ZXZ&#39;,randomize=False,radians=False):
                &#34;&#34;&#34;
                Returns the Euler angles according to axis &#39;axis&#39;
                Parameters:
                   axis: it must be &#39;XYZ&#39;, &#39;XZY&#39;, &#39;YXZ&#39;, &#39;YZX&#39;, &#39;ZXY&#39;, &#39;ZYX&#39;, &#39;XYX&#39;, &#39;XZX&#39;, &#39;YXY&#39;, &#39;YZY&#39;, &#39;ZXZ&#39; or &#39;ZYZ&#39;

                   radians: if True, the angle returned is in radians, if not, is
                            returned in degrees
                &#34;&#34;&#34;
                def ACOS(x):
                        if x &gt; 1.0:
                                x = 1.0
                        if x &lt; -1.0:
                                x = -1.0
                        return math.acos(x)

                def ASIN(x):
                        if x &gt; 1.0:
                                x = 1.0
                        if x &lt; -1.0:
                                x = -1.0
                        return math.asin(x)

                axis = axis.upper()
                if axis not in (&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,&#39;XYX&#39;,&#39;XZX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;):
                        return None
                rndm = 0
                A = self.quaternion.to_matrix()
                if axis == &#39;ZXZ&#39;:
                        theta = ACOS(A[2][2])
                        if abs(A[2][2]) != 1:
                                psi = math.atan2(A[2][0],A[2][1])
                                phi = math.atan2(A[0][2],-A[1][2])
                        else:
                                rndm = A[2][2]
                                phi = 0
                                psi = math.atan2(A[1][0],A[0][0])
                if axis == &#39;XZX&#39;:
                        theta = ACOS(A[0][0])
                        if abs(A[0][0]) != 1:
                                psi = math.atan2(A[0][2],-A[0][1])
                                phi = math.atan2(A[2][0],A[1][0])
                        else:
                                rndm = A[0][0]
                                phi = 0
                                psi = math.atan2(-A[1][2],A[2][2])
                if axis == &#39;ZYZ&#39;:
                        theta = ACOS(A[2][2])
                        if abs(A[2][2]) != 1:
                                psi = math.atan2(A[2][1],-A[2][0])
                                phi = math.atan2(A[1][2],A[0][2])
                        else:
                                rndm = A[2][2]
                                phi = 0
                                psi = math.atan2(-A[0][1],A[1][1])
                if axis == &#39;YZY&#39;:
                        theta = ACOS(A[1][1])
                        if abs(A[1][1]) != 1:
                                psi = math.atan2(A[1][2],A[1][0])
                                phi = math.atan2(A[2][1],-A[0][1])
                        else:
                                rndm = A[1][1]
                                phi = 0
                                psi = math.atan2(A[0][2],A[2][2])
                if axis == &#39;XYX&#39;:
                        theta = ACOS(A[0][0])
                        if abs(A[0][0]) != 1:
                                psi = math.atan2(A[0][1],A[0][2])
                                phi = math.atan2(A[1][0],-A[2][0])
                        else:
                                rndm = A[0][0]
                                phi = 0
                                psi = math.atan2(A[2][1],A[1][1])
                if axis == &#39;YXY&#39;:
                        theta = ACOS(A[1][1])
                        if abs(A[1][1]) != 1:
                                psi = math.atan2(A[1][0],-A[1][2])
                                phi = math.atan2(A[0][1],A[2][1])
                        else:
                                rndm = A[1][1]
                                phi = 0
                                psi = math.atan2(-A[2][0],A[0][0])
                if axis == &#39;XYZ&#39;:
                        theta = ASIN(-A[2][0])
                        if abs(A[2][0]) != 1:
                                psi = math.atan2(A[2][1],A[2][2])
                                phi = math.atan2(A[1][0],A[0][0])
                        else:
                                rndm = A[2][0]
                                phi = 0
                                psi = math.atan2(-A[0][1],A[1][1])
                if axis == &#39;XZY&#39;:
                        theta = ASIN(A[1][0])
                        if abs(A[1][0]) != 1:
                                psi = math.atan2(-A[1][2],A[1][1])
                                phi = math.atan2(-A[2][0],A[0][0])
                        else:
                                rndm = A[1][0]
                                phi = 0
                                psi = math.atan2(A[0][2],A[2][2])
                if axis == &#39;YXZ&#39;:
                        theta = ASIN(A[2][1])
                        if abs(A[2][1]) != 1:
                                psi = math.atan2(-A[2][0],A[2][2])
                                phi = math.atan2(-A[0][1],A[1][1])
                        else:
                                rndm = A[2][1]
                                phi = 0
                                psi = math.atan2(A[1][0],A[0][0])
                if axis == &#39;YZX&#39;:
                        theta = ASIN(-A[0][1])
                        if abs(A[0][1]) != 1:
                                psi = math.atan2(A[0][2],A[0][0])
                                phi = math.atan2(A[2][1],A[1][1])
                        else:
                                rndm = A[0][1]
                                phi = 0
                                psi = math.atan2(-A[1][2],A[2][2])
                if axis == &#39;ZXY&#39;:
                        theta = ASIN(-A[1][2])
                        if abs(A[1][2]) != 1:
                                psi = math.atan2(A[1][0],A[1][1])
                                phi = math.atan2(A[0][2],A[2][2])
                        else:
                                rndm = A[1][2]
                                phi = 0
                                psi = math.atan2(-A[0][2],A[0][0])
                if axis == &#39;ZYX&#39;:
                        theta = ASIN(A[0][2])
                        if abs(A[0][2]) != 1:
                                psi = math.atan2(-A[0][1],A[0][0])
                                phi = math.atan2(-A[1][2],A[2][2])
                        else:
                                rndm = A[0][2]
                                phi = 0
                                psi = math.atan2(A[2][1],A[1][1])

                if psi &lt; 0:
                        psi += 2*math.pi
                if theta &lt; 0:
                        theta += 2*math.pi
                if phi &lt; 0:
                        phi += 2*math.pi

                if rndm != 0 and randomize:
                        phi = random.uniform(0.0,psi)
                        psi = rndm * (psi - phi)
                        if psi &lt; 0:
                                psi += 2*math.pi

                if not radians:
                        psi, theta, phi = 180.0/math.pi * psi, 180.0/math.pi * theta, 180.0/math.pi * phi
                        T = 359.9
                else:
                        T = 359.9 * math.pi / 180.0
                if psi &gt; T:
                        psi = 0.0
                if theta &gt; T:
                        theta = 0.0
                if phi &gt; T:
                        phi = 0.0
                return psi, theta, phi</code></pre>
</details>
<div class="desc"><p>Class used for work with rotations. The stored value in the class is a quaternion</p>
<p>Initializes the value for a rotation</p>
<h2 id="parameters">Parameters</h2>
<p>angle: angle of rotation</p>
<p>vector: axis of rotation</p>
<p>quaternion: The quaternion itself</p>
<p>radians: must be True if the angle is entered in radians and False if the
is entered in degrees.</p></div>
<h3>Static methods</h3>
<dl>
<dt id="LinearAlgebra.Rotation.from_euler_angles"><code class="name flex">
<span>def <span class="ident">from_euler_angles</span></span>(<span>psi, theta, phi, axis='ZXZ', radians=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a rotation from its Euler angles in the order ZXZ</p>
<h2 id="parameters">Parameters</h2>
<p>phi, theta, psi: Euler angles</p>
<p>axis: it must be 'XYZ', 'XZY', 'YXZ', 'YZX', 'ZXY', 'ZYX', 'XYX', 'XZX', 'YXY', 'YZY', 'ZXZ' or 'ZYZ'</p>
<p>radians: if radians, psi, theta and must be in radians</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="LinearAlgebra.Rotation.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, v)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self,v):
        &#34;&#34;&#34;
Applies the rotation to an object v
        Parameters:
           v: any object that can be transformed by a rotation
        &#34;&#34;&#34;
        return self.quaternion @ v</code></pre>
</details>
<div class="desc"><p>Applies the rotation to an object v
Parameters:
v: any object that can be transformed by a rotation</p></div>
</dd>
<dt id="LinearAlgebra.Rotation.to_axis_angle"><code class="name flex">
<span>def <span class="ident">to_axis_angle</span></span>(<span>self, radians=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_axis_angle(self,radians=False):
        &#34;&#34;&#34;
        Returns the axis and angle of the rotation
        Parameters:
           radians: if True, the angle returned is in radians, if not, is
                    returned in degrees
        &#34;&#34;&#34;
        v, alpha = self.quaternion.to_axis_angle()
        if radians:
                return v, alpha
        return v, 180*alpha/math.pi</code></pre>
</details>
<div class="desc"><p>Returns the axis and angle of the rotation</p>
<h2 id="parameters">Parameters</h2>
<p>radians: if True, the angle returned is in radians, if not, is
returned in degrees</p></div>
</dd>
<dt id="LinearAlgebra.Rotation.to_euler_angles"><code class="name flex">
<span>def <span class="ident">to_euler_angles</span></span>(<span>self, axis='ZXZ', randomize=False, radians=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_euler_angles(self,axis=&#39;ZXZ&#39;,randomize=False,radians=False):
        &#34;&#34;&#34;
        Returns the Euler angles according to axis &#39;axis&#39;
        Parameters:
           axis: it must be &#39;XYZ&#39;, &#39;XZY&#39;, &#39;YXZ&#39;, &#39;YZX&#39;, &#39;ZXY&#39;, &#39;ZYX&#39;, &#39;XYX&#39;, &#39;XZX&#39;, &#39;YXY&#39;, &#39;YZY&#39;, &#39;ZXZ&#39; or &#39;ZYZ&#39;

           radians: if True, the angle returned is in radians, if not, is
                    returned in degrees
        &#34;&#34;&#34;
        def ACOS(x):
                if x &gt; 1.0:
                        x = 1.0
                if x &lt; -1.0:
                        x = -1.0
                return math.acos(x)

        def ASIN(x):
                if x &gt; 1.0:
                        x = 1.0
                if x &lt; -1.0:
                        x = -1.0
                return math.asin(x)

        axis = axis.upper()
        if axis not in (&#39;XYZ&#39;,&#39;XZY&#39;,&#39;YXZ&#39;,&#39;YZX&#39;,&#39;ZXY&#39;,&#39;ZYX&#39;,&#39;XYX&#39;,&#39;XZX&#39;,&#39;YXY&#39;,&#39;YZY&#39;,&#39;ZXZ&#39;,&#39;ZYZ&#39;):
                return None
        rndm = 0
        A = self.quaternion.to_matrix()
        if axis == &#39;ZXZ&#39;:
                theta = ACOS(A[2][2])
                if abs(A[2][2]) != 1:
                        psi = math.atan2(A[2][0],A[2][1])
                        phi = math.atan2(A[0][2],-A[1][2])
                else:
                        rndm = A[2][2]
                        phi = 0
                        psi = math.atan2(A[1][0],A[0][0])
        if axis == &#39;XZX&#39;:
                theta = ACOS(A[0][0])
                if abs(A[0][0]) != 1:
                        psi = math.atan2(A[0][2],-A[0][1])
                        phi = math.atan2(A[2][0],A[1][0])
                else:
                        rndm = A[0][0]
                        phi = 0
                        psi = math.atan2(-A[1][2],A[2][2])
        if axis == &#39;ZYZ&#39;:
                theta = ACOS(A[2][2])
                if abs(A[2][2]) != 1:
                        psi = math.atan2(A[2][1],-A[2][0])
                        phi = math.atan2(A[1][2],A[0][2])
                else:
                        rndm = A[2][2]
                        phi = 0
                        psi = math.atan2(-A[0][1],A[1][1])
        if axis == &#39;YZY&#39;:
                theta = ACOS(A[1][1])
                if abs(A[1][1]) != 1:
                        psi = math.atan2(A[1][2],A[1][0])
                        phi = math.atan2(A[2][1],-A[0][1])
                else:
                        rndm = A[1][1]
                        phi = 0
                        psi = math.atan2(A[0][2],A[2][2])
        if axis == &#39;XYX&#39;:
                theta = ACOS(A[0][0])
                if abs(A[0][0]) != 1:
                        psi = math.atan2(A[0][1],A[0][2])
                        phi = math.atan2(A[1][0],-A[2][0])
                else:
                        rndm = A[0][0]
                        phi = 0
                        psi = math.atan2(A[2][1],A[1][1])
        if axis == &#39;YXY&#39;:
                theta = ACOS(A[1][1])
                if abs(A[1][1]) != 1:
                        psi = math.atan2(A[1][0],-A[1][2])
                        phi = math.atan2(A[0][1],A[2][1])
                else:
                        rndm = A[1][1]
                        phi = 0
                        psi = math.atan2(-A[2][0],A[0][0])
        if axis == &#39;XYZ&#39;:
                theta = ASIN(-A[2][0])
                if abs(A[2][0]) != 1:
                        psi = math.atan2(A[2][1],A[2][2])
                        phi = math.atan2(A[1][0],A[0][0])
                else:
                        rndm = A[2][0]
                        phi = 0
                        psi = math.atan2(-A[0][1],A[1][1])
        if axis == &#39;XZY&#39;:
                theta = ASIN(A[1][0])
                if abs(A[1][0]) != 1:
                        psi = math.atan2(-A[1][2],A[1][1])
                        phi = math.atan2(-A[2][0],A[0][0])
                else:
                        rndm = A[1][0]
                        phi = 0
                        psi = math.atan2(A[0][2],A[2][2])
        if axis == &#39;YXZ&#39;:
                theta = ASIN(A[2][1])
                if abs(A[2][1]) != 1:
                        psi = math.atan2(-A[2][0],A[2][2])
                        phi = math.atan2(-A[0][1],A[1][1])
                else:
                        rndm = A[2][1]
                        phi = 0
                        psi = math.atan2(A[1][0],A[0][0])
        if axis == &#39;YZX&#39;:
                theta = ASIN(-A[0][1])
                if abs(A[0][1]) != 1:
                        psi = math.atan2(A[0][2],A[0][0])
                        phi = math.atan2(A[2][1],A[1][1])
                else:
                        rndm = A[0][1]
                        phi = 0
                        psi = math.atan2(-A[1][2],A[2][2])
        if axis == &#39;ZXY&#39;:
                theta = ASIN(-A[1][2])
                if abs(A[1][2]) != 1:
                        psi = math.atan2(A[1][0],A[1][1])
                        phi = math.atan2(A[0][2],A[2][2])
                else:
                        rndm = A[1][2]
                        phi = 0
                        psi = math.atan2(-A[0][2],A[0][0])
        if axis == &#39;ZYX&#39;:
                theta = ASIN(A[0][2])
                if abs(A[0][2]) != 1:
                        psi = math.atan2(-A[0][1],A[0][0])
                        phi = math.atan2(-A[1][2],A[2][2])
                else:
                        rndm = A[0][2]
                        phi = 0
                        psi = math.atan2(A[2][1],A[1][1])

        if psi &lt; 0:
                psi += 2*math.pi
        if theta &lt; 0:
                theta += 2*math.pi
        if phi &lt; 0:
                phi += 2*math.pi

        if rndm != 0 and randomize:
                phi = random.uniform(0.0,psi)
                psi = rndm * (psi - phi)
                if psi &lt; 0:
                        psi += 2*math.pi

        if not radians:
                psi, theta, phi = 180.0/math.pi * psi, 180.0/math.pi * theta, 180.0/math.pi * phi
                T = 359.9
        else:
                T = 359.9 * math.pi / 180.0
        if psi &gt; T:
                psi = 0.0
        if theta &gt; T:
                theta = 0.0
        if phi &gt; T:
                phi = 0.0
        return psi, theta, phi</code></pre>
</details>
<div class="desc"><p>Returns the Euler angles according to axis 'axis'</p>
<h2 id="parameters">Parameters</h2>
<p>axis: it must be 'XYZ', 'XZY', 'YXZ', 'YZX', 'ZXY', 'ZYX', 'XYX', 'XZX', 'YXY', 'YZY', 'ZXZ' or 'ZYZ'</p>
<p>radians: if True, the angle returned is in radians, if not, is
returned in degrees</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="LinearAlgebra.add_object_align_init" href="#LinearAlgebra.add_object_align_init">add_object_align_init</a></code></li>
<li><code><a title="LinearAlgebra.createFaces" href="#LinearAlgebra.createFaces">createFaces</a></code></li>
<li><code><a title="LinearAlgebra.create_mesh_object" href="#LinearAlgebra.create_mesh_object">create_mesh_object</a></code></li>
<li><code><a title="LinearAlgebra.draw_parametric_surface" href="#LinearAlgebra.draw_parametric_surface">draw_parametric_surface</a></code></li>
<li><code><a title="LinearAlgebra.object_data_add" href="#LinearAlgebra.object_data_add">object_data_add</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="LinearAlgebra.Color" href="#LinearAlgebra.Color">Color</a></code></h4>
</li>
<li>
<h4><code><a title="LinearAlgebra.Colors" href="#LinearAlgebra.Colors">Colors</a></code></h4>
<ul class="">
<li><code><a title="LinearAlgebra.Colors.color" href="#LinearAlgebra.Colors.color">color</a></code></li>
<li><code><a title="LinearAlgebra.Colors.colors" href="#LinearAlgebra.Colors.colors">colors</a></code></li>
<li><code><a title="LinearAlgebra.Colors.colorsbyname" href="#LinearAlgebra.Colors.colorsbyname">colorsbyname</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="LinearAlgebra.EuclideanReference" href="#LinearAlgebra.EuclideanReference">EuclideanReference</a></code></h4>
<ul class="">
<li><code><a title="LinearAlgebra.EuclideanReference.base" href="#LinearAlgebra.EuclideanReference.base">base</a></code></li>
<li><code><a title="LinearAlgebra.EuclideanReference.coordinates" href="#LinearAlgebra.EuclideanReference.coordinates">coordinates</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="LinearAlgebra.LinearAlgebra" href="#LinearAlgebra.LinearAlgebra">LinearAlgebra</a></code></h4>
<ul class="">
<li><code><a title="LinearAlgebra.LinearAlgebra.add_ligth" href="#LinearAlgebra.LinearAlgebra.add_ligth">add_ligth</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.add_ligths" href="#LinearAlgebra.LinearAlgebra.add_ligths">add_ligths</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.add_material" href="#LinearAlgebra.LinearAlgebra.add_material">add_material</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.animate_revolution_surface" href="#LinearAlgebra.LinearAlgebra.animate_revolution_surface">animate_revolution_surface</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.base_adaptada" href="#LinearAlgebra.LinearAlgebra.base_adaptada">base_adaptada</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.base_canonica" href="#LinearAlgebra.LinearAlgebra.base_canonica">base_canonica</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.base_canonica_white" href="#LinearAlgebra.LinearAlgebra.base_canonica_white">base_canonica_white</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.base_cilinder" href="#LinearAlgebra.LinearAlgebra.base_cilinder">base_cilinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.base_cone" href="#LinearAlgebra.LinearAlgebra.base_cone">base_cone</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.base_disk" href="#LinearAlgebra.LinearAlgebra.base_disk">base_disk</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.base_is_canonica" href="#LinearAlgebra.LinearAlgebra.base_is_canonica">base_is_canonica</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.base_no_canonica" href="#LinearAlgebra.LinearAlgebra.base_no_canonica">base_no_canonica</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.canvi_base" href="#LinearAlgebra.LinearAlgebra.canvi_base">canvi_base</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.canvi_coordenades" href="#LinearAlgebra.LinearAlgebra.canvi_coordenades">canvi_coordenades</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.cilindre" href="#LinearAlgebra.LinearAlgebra.cilindre">cilindre</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.cilindre_elliptic" href="#LinearAlgebra.LinearAlgebra.cilindre_elliptic">cilindre_elliptic</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.cilindre_elliptic_simple" href="#LinearAlgebra.LinearAlgebra.cilindre_elliptic_simple">cilindre_elliptic_simple</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.cilindre_hiperbolic" href="#LinearAlgebra.LinearAlgebra.cilindre_hiperbolic">cilindre_hiperbolic</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.cilindre_hiperbolic_simple" href="#LinearAlgebra.LinearAlgebra.cilindre_hiperbolic_simple">cilindre_hiperbolic_simple</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.cilindre_parabolic" href="#LinearAlgebra.LinearAlgebra.cilindre_parabolic">cilindre_parabolic</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.cilindre_parabolic_simple" href="#LinearAlgebra.LinearAlgebra.cilindre_parabolic_simple">cilindre_parabolic_simple</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.circumferencia" href="#LinearAlgebra.LinearAlgebra.circumferencia">circumferencia</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.clear" href="#LinearAlgebra.LinearAlgebra.clear">clear</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.components_en_canonica" href="#LinearAlgebra.LinearAlgebra.components_en_canonica">components_en_canonica</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.components_in_base" href="#LinearAlgebra.LinearAlgebra.components_in_base">components_in_base</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.con" href="#LinearAlgebra.LinearAlgebra.con">con</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.con_cilindre_elliptic" href="#LinearAlgebra.LinearAlgebra.con_cilindre_elliptic">con_cilindre_elliptic</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.con_revolucio" href="#LinearAlgebra.LinearAlgebra.con_revolucio">con_revolucio</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.con_simple" href="#LinearAlgebra.LinearAlgebra.con_simple">con_simple</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.cone" href="#LinearAlgebra.LinearAlgebra.cone">cone</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.coordinates_en_canonica" href="#LinearAlgebra.LinearAlgebra.coordinates_en_canonica">coordinates_en_canonica</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.coordinates_en_referencia" href="#LinearAlgebra.LinearAlgebra.coordinates_en_referencia">coordinates_en_referencia</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.curve" href="#LinearAlgebra.LinearAlgebra.curve">curve</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.delete_base_cilinder" href="#LinearAlgebra.LinearAlgebra.delete_base_cilinder">delete_base_cilinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.delete_base_cone" href="#LinearAlgebra.LinearAlgebra.delete_base_cone">delete_base_cone</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.delete_base_disk" href="#LinearAlgebra.LinearAlgebra.delete_base_disk">delete_base_disk</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.distancia_rectes_encreuen" href="#LinearAlgebra.LinearAlgebra.distancia_rectes_encreuen">distancia_rectes_encreuen</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_base_axis" href="#LinearAlgebra.LinearAlgebra.draw_base_axis">draw_base_axis</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_circle" href="#LinearAlgebra.LinearAlgebra.draw_circle">draw_circle</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_components" href="#LinearAlgebra.LinearAlgebra.draw_components">draw_components</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_cone" href="#LinearAlgebra.LinearAlgebra.draw_cone">draw_cone</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_cube" href="#LinearAlgebra.LinearAlgebra.draw_cube">draw_cube</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_curve" href="#LinearAlgebra.LinearAlgebra.draw_curve">draw_curve</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_disk" href="#LinearAlgebra.LinearAlgebra.draw_disk">draw_disk</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_ellipse" href="#LinearAlgebra.LinearAlgebra.draw_ellipse">draw_ellipse</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_ellipsoid" href="#LinearAlgebra.LinearAlgebra.draw_ellipsoid">draw_ellipsoid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_elliptic_cylinder" href="#LinearAlgebra.LinearAlgebra.draw_elliptic_cylinder">draw_elliptic_cylinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_elliptic_paraboloid" href="#LinearAlgebra.LinearAlgebra.draw_elliptic_paraboloid">draw_elliptic_paraboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_frenet_curve" href="#LinearAlgebra.LinearAlgebra.draw_frenet_curve">draw_frenet_curve</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_function" href="#LinearAlgebra.LinearAlgebra.draw_function">draw_function</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_hyperbole" href="#LinearAlgebra.LinearAlgebra.draw_hyperbole">draw_hyperbole</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_hyperbolic_cylinder" href="#LinearAlgebra.LinearAlgebra.draw_hyperbolic_cylinder">draw_hyperbolic_cylinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_hyperbolic_paraboloid" href="#LinearAlgebra.LinearAlgebra.draw_hyperbolic_paraboloid">draw_hyperbolic_paraboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_line" href="#LinearAlgebra.LinearAlgebra.draw_line">draw_line</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_mesh" href="#LinearAlgebra.LinearAlgebra.draw_mesh">draw_mesh</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_one_sheet_hyperboloid" href="#LinearAlgebra.LinearAlgebra.draw_one_sheet_hyperboloid">draw_one_sheet_hyperboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_parabola" href="#LinearAlgebra.LinearAlgebra.draw_parabola">draw_parabola</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_parabolic_cylinder" href="#LinearAlgebra.LinearAlgebra.draw_parabolic_cylinder">draw_parabolic_cylinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_parallelepiped" href="#LinearAlgebra.LinearAlgebra.draw_parallelepiped">draw_parallelepiped</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_parallelogram" href="#LinearAlgebra.LinearAlgebra.draw_parallelogram">draw_parallelogram</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_plane" href="#LinearAlgebra.LinearAlgebra.draw_plane">draw_plane</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_plane_surface" href="#LinearAlgebra.LinearAlgebra.draw_plane_surface">draw_plane_surface</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_point" href="#LinearAlgebra.LinearAlgebra.draw_point">draw_point</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_points" href="#LinearAlgebra.LinearAlgebra.draw_points">draw_points</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_polygon" href="#LinearAlgebra.LinearAlgebra.draw_polygon">draw_polygon</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_pyramid" href="#LinearAlgebra.LinearAlgebra.draw_pyramid">draw_pyramid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_regular_polygon" href="#LinearAlgebra.LinearAlgebra.draw_regular_polygon">draw_regular_polygon</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_simple_curve" href="#LinearAlgebra.LinearAlgebra.draw_simple_curve">draw_simple_curve</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_surface" href="#LinearAlgebra.LinearAlgebra.draw_surface">draw_surface</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_tetrahedron" href="#LinearAlgebra.LinearAlgebra.draw_tetrahedron">draw_tetrahedron</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_triangle" href="#LinearAlgebra.LinearAlgebra.draw_triangle">draw_triangle</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_two_sheets_hyperboloid" href="#LinearAlgebra.LinearAlgebra.draw_two_sheets_hyperboloid">draw_two_sheets_hyperboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_vector" href="#LinearAlgebra.LinearAlgebra.draw_vector">draw_vector</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_vector_field" href="#LinearAlgebra.LinearAlgebra.draw_vector_field">draw_vector_field</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.draw_vectors" href="#LinearAlgebra.LinearAlgebra.draw_vectors">draw_vectors</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.ellipse" href="#LinearAlgebra.LinearAlgebra.ellipse">ellipse</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.ellipsoid" href="#LinearAlgebra.LinearAlgebra.ellipsoid">ellipsoid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.ellipsoide" href="#LinearAlgebra.LinearAlgebra.ellipsoide">ellipsoide</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.ellipsoide_revolucio" href="#LinearAlgebra.LinearAlgebra.ellipsoide_revolucio">ellipsoide_revolucio</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.elliptic_cylinder" href="#LinearAlgebra.LinearAlgebra.elliptic_cylinder">elliptic_cylinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.elliptic_paraboloid" href="#LinearAlgebra.LinearAlgebra.elliptic_paraboloid">elliptic_paraboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.esfera" href="#LinearAlgebra.LinearAlgebra.esfera">esfera</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.esfera_cilindre_elliptic" href="#LinearAlgebra.LinearAlgebra.esfera_cilindre_elliptic">esfera_cilindre_elliptic</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.gir_poligon" href="#LinearAlgebra.LinearAlgebra.gir_poligon">gir_poligon</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.hiperbola" href="#LinearAlgebra.LinearAlgebra.hiperbola">hiperbola</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.hiperboloide_dues_fulles" href="#LinearAlgebra.LinearAlgebra.hiperboloide_dues_fulles">hiperboloide_dues_fulles</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.hiperboloide_dues_fulles_revolucio" href="#LinearAlgebra.LinearAlgebra.hiperboloide_dues_fulles_revolucio">hiperboloide_dues_fulles_revolucio</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.hiperboloide_una_fulla" href="#LinearAlgebra.LinearAlgebra.hiperboloide_una_fulla">hiperboloide_una_fulla</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.hiperboloide_una_fulla_revolucio" href="#LinearAlgebra.LinearAlgebra.hiperboloide_una_fulla_revolucio">hiperboloide_una_fulla_revolucio</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.hyperbolic_cylinder" href="#LinearAlgebra.LinearAlgebra.hyperbolic_cylinder">hyperbolic_cylinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.hyperbolic_paraboloid" href="#LinearAlgebra.LinearAlgebra.hyperbolic_paraboloid">hyperbolic_paraboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.join" href="#LinearAlgebra.LinearAlgebra.join">join</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.moviment_helicoidal_cilindre" href="#LinearAlgebra.LinearAlgebra.moviment_helicoidal_cilindre">moviment_helicoidal_cilindre</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.moviment_helicoidal_ortoedre" href="#LinearAlgebra.LinearAlgebra.moviment_helicoidal_ortoedre">moviment_helicoidal_ortoedre</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.moviment_helicoidal_punt" href="#LinearAlgebra.LinearAlgebra.moviment_helicoidal_punt">moviment_helicoidal_punt</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.one_sheet_hyperboloid" href="#LinearAlgebra.LinearAlgebra.one_sheet_hyperboloid">one_sheet_hyperboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.ortoedre" href="#LinearAlgebra.LinearAlgebra.ortoedre">ortoedre</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.parabola" href="#LinearAlgebra.LinearAlgebra.parabola">parabola</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.parabolic_cylinder" href="#LinearAlgebra.LinearAlgebra.parabolic_cylinder">parabolic_cylinder</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.paraboloide_elliptic" href="#LinearAlgebra.LinearAlgebra.paraboloide_elliptic">paraboloide_elliptic</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.paraboloide_elliptic_revolucio" href="#LinearAlgebra.LinearAlgebra.paraboloide_elliptic_revolucio">paraboloide_elliptic_revolucio</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.paraboloide_elliptic_simple" href="#LinearAlgebra.LinearAlgebra.paraboloide_elliptic_simple">paraboloide_elliptic_simple</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.paraboloide_hiperbolic" href="#LinearAlgebra.LinearAlgebra.paraboloide_hiperbolic">paraboloide_hiperbolic</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.paraboloide_hiperbolic_simple" href="#LinearAlgebra.LinearAlgebra.paraboloide_hiperbolic_simple">paraboloide_hiperbolic_simple</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.perpendicular_comuna_a_dues_rectes" href="#LinearAlgebra.LinearAlgebra.perpendicular_comuna_a_dues_rectes">perpendicular_comuna_a_dues_rectes</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.pla_afi" href="#LinearAlgebra.LinearAlgebra.pla_afi">pla_afi</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.pla_vectorial" href="#LinearAlgebra.LinearAlgebra.pla_vectorial">pla_vectorial</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.posicio_relativa_tres_plans" href="#LinearAlgebra.LinearAlgebra.posicio_relativa_tres_plans">posicio_relativa_tres_plans</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.product_components" href="#LinearAlgebra.LinearAlgebra.product_components">product_components</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_pla_afi" href="#LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_pla_afi">projeccio_ortogonal_simetric_pla_afi</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_pla_vectorial" href="#LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_pla_vectorial">projeccio_ortogonal_simetric_pla_vectorial</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_recta_afi" href="#LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_recta_afi">projeccio_ortogonal_simetric_recta_afi</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_recta_vectorial" href="#LinearAlgebra.LinearAlgebra.projeccio_ortogonal_simetric_recta_vectorial">projeccio_ortogonal_simetric_recta_vectorial</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.punt_referencia_canonica" href="#LinearAlgebra.LinearAlgebra.punt_referencia_canonica">punt_referencia_canonica</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.punt_referencia_no_canonica" href="#LinearAlgebra.LinearAlgebra.punt_referencia_no_canonica">punt_referencia_no_canonica</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.recta_afi" href="#LinearAlgebra.LinearAlgebra.recta_afi">recta_afi</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.recta_vectorial" href="#LinearAlgebra.LinearAlgebra.recta_vectorial">recta_vectorial</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rectangle" href="#LinearAlgebra.LinearAlgebra.rectangle">rectangle</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.referencia_canonica" href="#LinearAlgebra.LinearAlgebra.referencia_canonica">referencia_canonica</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.referencia_no_canonica" href="#LinearAlgebra.LinearAlgebra.referencia_no_canonica">referencia_no_canonica</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.reset" href="#LinearAlgebra.LinearAlgebra.reset">reset</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.reset_base" href="#LinearAlgebra.LinearAlgebra.reset_base">reset_base</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.reset_colors" href="#LinearAlgebra.LinearAlgebra.reset_colors">reset_colors</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.reset_frames" href="#LinearAlgebra.LinearAlgebra.reset_frames">reset_frames</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.reset_origin" href="#LinearAlgebra.LinearAlgebra.reset_origin">reset_origin</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.reset_rotation" href="#LinearAlgebra.LinearAlgebra.reset_rotation">reset_rotation</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.revolution_surface" href="#LinearAlgebra.LinearAlgebra.revolution_surface">revolution_surface</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rotacio_ortoedre" href="#LinearAlgebra.LinearAlgebra.rotacio_ortoedre">rotacio_ortoedre</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rotacio_ortoedre_angles_euler" href="#LinearAlgebra.LinearAlgebra.rotacio_ortoedre_angles_euler">rotacio_ortoedre_angles_euler</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rotacio_ortoedre_voltant_vector" href="#LinearAlgebra.LinearAlgebra.rotacio_ortoedre_voltant_vector">rotacio_ortoedre_voltant_vector</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rotacio_punt" href="#LinearAlgebra.LinearAlgebra.rotacio_punt">rotacio_punt</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rotacio_vector" href="#LinearAlgebra.LinearAlgebra.rotacio_vector">rotacio_vector</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rotate_euler" href="#LinearAlgebra.LinearAlgebra.rotate_euler">rotate_euler</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rotate_object" href="#LinearAlgebra.LinearAlgebra.rotate_object">rotate_object</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rotate_object_by_axis_angle" href="#LinearAlgebra.LinearAlgebra.rotate_object_by_axis_angle">rotate_object_by_axis_angle</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rotate_objects" href="#LinearAlgebra.LinearAlgebra.rotate_objects">rotate_objects</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rotate_point" href="#LinearAlgebra.LinearAlgebra.rotate_point">rotate_point</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.rotate_vector" href="#LinearAlgebra.LinearAlgebra.rotate_vector">rotate_vector</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.segment_esferic" href="#LinearAlgebra.LinearAlgebra.segment_esferic">segment_esferic</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.set_base" href="#LinearAlgebra.LinearAlgebra.set_base">set_base</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.set_colors" href="#LinearAlgebra.LinearAlgebra.set_colors">set_colors</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.set_cursor" href="#LinearAlgebra.LinearAlgebra.set_cursor">set_cursor</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.set_cursor_rotation" href="#LinearAlgebra.LinearAlgebra.set_cursor_rotation">set_cursor_rotation</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.set_default_color" href="#LinearAlgebra.LinearAlgebra.set_default_color">set_default_color</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.set_origin" href="#LinearAlgebra.LinearAlgebra.set_origin">set_origin</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.set_rotation" href="#LinearAlgebra.LinearAlgebra.set_rotation">set_rotation</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.simple_curve" href="#LinearAlgebra.LinearAlgebra.simple_curve">simple_curve</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.sphere" href="#LinearAlgebra.LinearAlgebra.sphere">sphere</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.superficie_revolucio_parabola" href="#LinearAlgebra.LinearAlgebra.superficie_revolucio_parabola">superficie_revolucio_parabola</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.tor" href="#LinearAlgebra.LinearAlgebra.tor">tor</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.triangle" href="#LinearAlgebra.LinearAlgebra.triangle">triangle</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.triangle_esferic" href="#LinearAlgebra.LinearAlgebra.triangle_esferic">triangle_esferic</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.triangle_esferic_aleatori" href="#LinearAlgebra.LinearAlgebra.triangle_esferic_aleatori">triangle_esferic_aleatori</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.two_sheets_hyperboloid" href="#LinearAlgebra.LinearAlgebra.two_sheets_hyperboloid">two_sheets_hyperboloid</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.vector_base_canonica" href="#LinearAlgebra.LinearAlgebra.vector_base_canonica">vector_base_canonica</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.vector_base_no_canonica" href="#LinearAlgebra.LinearAlgebra.vector_base_no_canonica">vector_base_no_canonica</a></code></li>
<li><code><a title="LinearAlgebra.LinearAlgebra.vectors_to_quaternion" href="#LinearAlgebra.LinearAlgebra.vectors_to_quaternion">vectors_to_quaternion</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="LinearAlgebra.Rotation" href="#LinearAlgebra.Rotation">Rotation</a></code></h4>
<ul class="">
<li><code><a title="LinearAlgebra.Rotation.apply" href="#LinearAlgebra.Rotation.apply">apply</a></code></li>
<li><code><a title="LinearAlgebra.Rotation.from_euler_angles" href="#LinearAlgebra.Rotation.from_euler_angles">from_euler_angles</a></code></li>
<li><code><a title="LinearAlgebra.Rotation.to_axis_angle" href="#LinearAlgebra.Rotation.to_axis_angle">to_axis_angle</a></code></li>
<li><code><a title="LinearAlgebra.Rotation.to_euler_angles" href="#LinearAlgebra.Rotation.to_euler_angles">to_euler_angles</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
